
Home_Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006436  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000005a  00800060  00006436  000064ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000065e  008000ba  008000ba  00006524  2**0
                  ALLOC
  3 .stab         0000ae9c  00000000  00000000  00006524  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004dc6  00000000  00000000  000113c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00016186  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00016198  2**2
                  CONTENTS, READONLY
  7 .debug_info   000004e6  00000000  00000000  000161d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004a3  00000000  00000000  000166ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00016b5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000196  00000000  00000000  00016b77  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d2 17 	jmp	0x2fa4	; 0x2fa4 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e3       	ldi	r30, 0x36	; 54
      68:	f4 e6       	ldi	r31, 0x64	; 100
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 3b       	cpi	r26, 0xBA	; 186
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	aa eb       	ldi	r26, 0xBA	; 186
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 31       	cpi	r26, 0x18	; 24
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7e 14 	call	0x28fc	; 0x28fc <main>
      8a:	0c 94 19 32 	jmp	0x6432	; 0x6432 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Clock_Print_Default_Interface>:
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	80 e0       	ldi	r24, 0x00	; 0
      9c:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
      a0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <Hours>
      a4:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <LCD_Void_Write_Number_2>
      a8:	82 e0       	ldi	r24, 0x02	; 2
      aa:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
      ae:	8a e3       	ldi	r24, 0x3A	; 58
      b0:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
      b4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <Minutes>
      b8:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <LCD_Void_Write_Number_2>
      bc:	85 e0       	ldi	r24, 0x05	; 5
      be:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
      c2:	8a e3       	ldi	r24, 0x3A	; 58
      c4:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
      c8:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <__data_end>
      cc:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <LCD_Void_Write_Number_2>
      d0:	00 00       	nop
      d2:	df 91       	pop	r29
      d4:	cf 91       	pop	r28
      d6:	08 95       	ret

000000d8 <Clock_Second>:
	LCD_Void_Write_Number_2(Seconds);

}

void Clock_Second(void *pvParameters)
{
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	00 d0       	rcall	.+0      	; 0xde <Clock_Second+0x6>
      de:	00 d0       	rcall	.+0      	; 0xe0 <Clock_Second+0x8>
      e0:	cd b7       	in	r28, 0x3d	; 61
      e2:	de b7       	in	r29, 0x3e	; 62
      e4:	9c 83       	std	Y+4, r25	; 0x04
      e6:	8b 83       	std	Y+3, r24	; 0x03
	LCD = xSemaphoreCreateMutex();
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	0e 94 21 19 	call	0x3242	; 0x3242 <xQueueCreateMutex>
      ee:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <LCD+0x1>
      f2:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <LCD>
	TickType_t MyLastUnblockS;
	MyLastUnblockS = xTaskGetTickCount();
      f6:	0e 94 50 25 	call	0x4aa0	; 0x4aa0 <xTaskGetTickCount>
      fa:	9a 83       	std	Y+2, r25	; 0x02
      fc:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(seconds_position-1);
      fe:	85 e0       	ldi	r24, 0x05	; 5
     100:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     104:	8a e3       	ldi	r24, 0x3A	; 58
     106:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     10a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     10e:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     112:	6a e0       	ldi	r22, 0x0A	; 10
     114:	70 e0       	ldi	r23, 0x00	; 0
     116:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <xQueueSemaphoreTake>
     11a:	88 23       	and	r24, r24
     11c:	91 f0       	breq	.+36     	; 0x142 <Clock_Second+0x6a>
		{
			LCD_Set_Block(seconds_position);
     11e:	86 e0       	ldi	r24, 0x06	; 6
     120:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
			LCD_Void_Write_Number_2(Seconds);
     124:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <__data_end>
     128:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     12c:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     130:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     134:	20 e0       	ldi	r18, 0x00	; 0
     136:	40 e0       	ldi	r20, 0x00	; 0
     138:	50 e0       	ldi	r21, 0x00	; 0
     13a:	60 e0       	ldi	r22, 0x00	; 0
     13c:	70 e0       	ldi	r23, 0x00	; 0
     13e:	0e 94 41 19 	call	0x3282	; 0x3282 <xQueueGenericSend>
		}
		vTaskDelayUntil(&MyLastUnblockS,seconds_frequency);
     142:	6a e0       	ldi	r22, 0x0A	; 10
     144:	70 e0       	ldi	r23, 0x00	; 0
     146:	ce 01       	movw	r24, r28
     148:	01 96       	adiw	r24, 0x01	; 1
     14a:	0e 94 61 22 	call	0x44c2	; 0x44c2 <vTaskDelayUntil>
		Seconds++;
     14e:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <__data_end>
     152:	8f 5f       	subi	r24, 0xFF	; 255
     154:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__data_end>
		Seconds %= 60;
     158:	90 91 ba 00 	lds	r25, 0x00BA	; 0x8000ba <__data_end>
     15c:	89 e8       	ldi	r24, 0x89	; 137
     15e:	98 9f       	mul	r25, r24
     160:	81 2d       	mov	r24, r1
     162:	11 24       	eor	r1, r1
     164:	82 95       	swap	r24
     166:	86 95       	lsr	r24
     168:	87 70       	andi	r24, 0x07	; 7
     16a:	2c e3       	ldi	r18, 0x3C	; 60
     16c:	82 9f       	mul	r24, r18
     16e:	80 2d       	mov	r24, r0
     170:	11 24       	eor	r1, r1
     172:	29 2f       	mov	r18, r25
     174:	28 1b       	sub	r18, r24
     176:	82 2f       	mov	r24, r18
     178:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__data_end>
	}
     17c:	c6 cf       	rjmp	.-116    	; 0x10a <Clock_Second+0x32>

0000017e <Clock_Minute>:
}

void Clock_Minute(void *pvParameters)
{
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
     182:	00 d0       	rcall	.+0      	; 0x184 <Clock_Minute+0x6>
     184:	00 d0       	rcall	.+0      	; 0x186 <Clock_Minute+0x8>
     186:	cd b7       	in	r28, 0x3d	; 61
     188:	de b7       	in	r29, 0x3e	; 62
     18a:	9c 83       	std	Y+4, r25	; 0x04
     18c:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockM;
	MyLastUnblockM = xTaskGetTickCount();
     18e:	0e 94 50 25 	call	0x4aa0	; 0x4aa0 <xTaskGetTickCount>
     192:	9a 83       	std	Y+2, r25	; 0x02
     194:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     196:	82 e0       	ldi	r24, 0x02	; 2
     198:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     19c:	8a e3       	ldi	r24, 0x3A	; 58
     19e:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     1a2:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     1a6:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     1aa:	6a e0       	ldi	r22, 0x0A	; 10
     1ac:	70 e0       	ldi	r23, 0x00	; 0
     1ae:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <xQueueSemaphoreTake>
     1b2:	88 23       	and	r24, r24
     1b4:	91 f0       	breq	.+36     	; 0x1da <Clock_Minute+0x5c>
		{
			LCD_Set_Block(minutes_position);
     1b6:	83 e0       	ldi	r24, 0x03	; 3
     1b8:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
			LCD_Void_Write_Number_2(Minutes);
     1bc:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <Minutes>
     1c0:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     1c4:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     1c8:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     1cc:	20 e0       	ldi	r18, 0x00	; 0
     1ce:	40 e0       	ldi	r20, 0x00	; 0
     1d0:	50 e0       	ldi	r21, 0x00	; 0
     1d2:	60 e0       	ldi	r22, 0x00	; 0
     1d4:	70 e0       	ldi	r23, 0x00	; 0
     1d6:	0e 94 41 19 	call	0x3282	; 0x3282 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockM,minutes_frequency);
     1da:	68 e5       	ldi	r22, 0x58	; 88
     1dc:	72 e0       	ldi	r23, 0x02	; 2
     1de:	ce 01       	movw	r24, r28
     1e0:	01 96       	adiw	r24, 0x01	; 1
     1e2:	0e 94 61 22 	call	0x44c2	; 0x44c2 <vTaskDelayUntil>
		Minutes++;
     1e6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <Minutes>
     1ea:	8f 5f       	subi	r24, 0xFF	; 255
     1ec:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <Minutes>
		Minutes %= 60;
     1f0:	90 91 bb 00 	lds	r25, 0x00BB	; 0x8000bb <Minutes>
     1f4:	89 e8       	ldi	r24, 0x89	; 137
     1f6:	98 9f       	mul	r25, r24
     1f8:	81 2d       	mov	r24, r1
     1fa:	11 24       	eor	r1, r1
     1fc:	82 95       	swap	r24
     1fe:	86 95       	lsr	r24
     200:	87 70       	andi	r24, 0x07	; 7
     202:	2c e3       	ldi	r18, 0x3C	; 60
     204:	82 9f       	mul	r24, r18
     206:	80 2d       	mov	r24, r0
     208:	11 24       	eor	r1, r1
     20a:	29 2f       	mov	r18, r25
     20c:	28 1b       	sub	r18, r24
     20e:	82 2f       	mov	r24, r18
     210:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <Minutes>
	}
     214:	c6 cf       	rjmp	.-116    	; 0x1a2 <Clock_Minute+0x24>

00000216 <Clock_Hours>:
}
void Clock_Hours(void *pvParameters)
{
     216:	cf 93       	push	r28
     218:	df 93       	push	r29
     21a:	00 d0       	rcall	.+0      	; 0x21c <Clock_Hours+0x6>
     21c:	00 d0       	rcall	.+0      	; 0x21e <Clock_Hours+0x8>
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
     222:	9c 83       	std	Y+4, r25	; 0x04
     224:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockH;
	MyLastUnblockH = xTaskGetTickCount();
     226:	0e 94 50 25 	call	0x4aa0	; 0x4aa0 <xTaskGetTickCount>
     22a:	9a 83       	std	Y+2, r25	; 0x02
     22c:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     22e:	82 e0       	ldi	r24, 0x02	; 2
     230:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     234:	8a e3       	ldi	r24, 0x3A	; 58
     236:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     23a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     23e:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     242:	6a e0       	ldi	r22, 0x0A	; 10
     244:	70 e0       	ldi	r23, 0x00	; 0
     246:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <xQueueSemaphoreTake>
     24a:	88 23       	and	r24, r24
     24c:	19 f1       	breq	.+70     	; 0x294 <Clock_Hours+0x7e>
		{
			LCD_Set_Block(hours_position);
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
			LCD_Void_Write_Number_2((Hours%12)+1);
     254:	20 91 bc 00 	lds	r18, 0x00BC	; 0x8000bc <Hours>
     258:	8b ea       	ldi	r24, 0xAB	; 171
     25a:	28 9f       	mul	r18, r24
     25c:	81 2d       	mov	r24, r1
     25e:	11 24       	eor	r1, r1
     260:	98 2f       	mov	r25, r24
     262:	96 95       	lsr	r25
     264:	96 95       	lsr	r25
     266:	96 95       	lsr	r25
     268:	89 2f       	mov	r24, r25
     26a:	88 0f       	add	r24, r24
     26c:	89 0f       	add	r24, r25
     26e:	88 0f       	add	r24, r24
     270:	88 0f       	add	r24, r24
     272:	92 2f       	mov	r25, r18
     274:	98 1b       	sub	r25, r24
     276:	81 e0       	ldi	r24, 0x01	; 1
     278:	89 0f       	add	r24, r25
     27a:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     27e:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     282:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     286:	20 e0       	ldi	r18, 0x00	; 0
     288:	40 e0       	ldi	r20, 0x00	; 0
     28a:	50 e0       	ldi	r21, 0x00	; 0
     28c:	60 e0       	ldi	r22, 0x00	; 0
     28e:	70 e0       	ldi	r23, 0x00	; 0
     290:	0e 94 41 19 	call	0x3282	; 0x3282 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockH,hours_frequency);
     294:	60 ea       	ldi	r22, 0xA0	; 160
     296:	7c e8       	ldi	r23, 0x8C	; 140
     298:	ce 01       	movw	r24, r28
     29a:	01 96       	adiw	r24, 0x01	; 1
     29c:	0e 94 61 22 	call	0x44c2	; 0x44c2 <vTaskDelayUntil>
		Hours++;
     2a0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <Hours>
     2a4:	8f 5f       	subi	r24, 0xFF	; 255
     2a6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <Hours>
		Hours %= 24;
     2aa:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <Hours>
     2ae:	8b ea       	ldi	r24, 0xAB	; 171
     2b0:	98 9f       	mul	r25, r24
     2b2:	81 2d       	mov	r24, r1
     2b4:	11 24       	eor	r1, r1
     2b6:	82 95       	swap	r24
     2b8:	8f 70       	andi	r24, 0x0F	; 15
     2ba:	28 e1       	ldi	r18, 0x18	; 24
     2bc:	82 9f       	mul	r24, r18
     2be:	80 2d       	mov	r24, r0
     2c0:	11 24       	eor	r1, r1
     2c2:	29 2f       	mov	r18, r25
     2c4:	28 1b       	sub	r18, r24
     2c6:	82 2f       	mov	r24, r18
     2c8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <Hours>
	}
     2cc:	b6 cf       	rjmp	.-148    	; 0x23a <Clock_Hours+0x24>

000002ce <Clock_Check_KPD>:
}

void Clock_Check_KPD(void *pvParameters)
{
     2ce:	cf 93       	push	r28
     2d0:	df 93       	push	r29
     2d2:	cd b7       	in	r28, 0x3d	; 61
     2d4:	de b7       	in	r29, 0x3e	; 62
     2d6:	65 97       	sbiw	r28, 0x15	; 21
     2d8:	0f b6       	in	r0, 0x3f	; 63
     2da:	f8 94       	cli
     2dc:	de bf       	out	0x3e, r29	; 62
     2de:	0f be       	out	0x3f, r0	; 63
     2e0:	cd bf       	out	0x3d, r28	; 61
     2e2:	9d 8b       	std	Y+21, r25	; 0x15
     2e4:	8c 8b       	std	Y+20, r24	; 0x14
	KPD_input = xQueueCreate(1,sizeof(u8));
     2e6:	40 e0       	ldi	r20, 0x00	; 0
     2e8:	61 e0       	ldi	r22, 0x01	; 1
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	0e 94 69 18 	call	0x30d2	; 0x30d2 <xQueueGenericCreate>
     2f0:	90 93 be 00 	sts	0x00BE, r25	; 0x8000be <KPD_input+0x1>
     2f4:	80 93 bd 00 	sts	0x00BD, r24	; 0x8000bd <KPD_input>
	TickType_t MyLastUnblockKPD;
	MyLastUnblockKPD = xTaskGetTickCount();
     2f8:	0e 94 50 25 	call	0x4aa0	; 0x4aa0 <xTaskGetTickCount>
     2fc:	9a 83       	std	Y+2, r25	; 0x02
     2fe:	89 83       	std	Y+1, r24	; 0x01
	u8 keys[16];
	u8 pressed;
	while(1)
	{	pressed = KBD_u8GetKeyPadState(keys);
     300:	ce 01       	movw	r24, r28
     302:	03 96       	adiw	r24, 0x03	; 3
     304:	0e 94 64 05 	call	0xac8	; 0xac8 <KBD_u8GetKeyPadState>
     308:	8b 8b       	std	Y+19, r24	; 0x13
		if(pressed != 0xff)
     30a:	8b 89       	ldd	r24, Y+19	; 0x13
     30c:	8f 3f       	cpi	r24, 0xFF	; 255
     30e:	61 f0       	breq	.+24     	; 0x328 <Clock_Check_KPD+0x5a>
		{
			xQueueSend(KPD_input,&pressed,10);
     310:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <KPD_input>
     314:	90 91 be 00 	lds	r25, 0x00BE	; 0x8000be <KPD_input+0x1>
     318:	be 01       	movw	r22, r28
     31a:	6d 5e       	subi	r22, 0xED	; 237
     31c:	7f 4f       	sbci	r23, 0xFF	; 255
     31e:	20 e0       	ldi	r18, 0x00	; 0
     320:	4a e0       	ldi	r20, 0x0A	; 10
     322:	50 e0       	ldi	r21, 0x00	; 0
     324:	0e 94 41 19 	call	0x3282	; 0x3282 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockKPD,KPD_Check_frequency);
     328:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <KPD_Check_frequency>
     32c:	88 2f       	mov	r24, r24
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	bc 01       	movw	r22, r24
     332:	ce 01       	movw	r24, r28
     334:	01 96       	adiw	r24, 0x01	; 1
     336:	0e 94 61 22 	call	0x44c2	; 0x44c2 <vTaskDelayUntil>
	}
     33a:	e2 cf       	rjmp	.-60     	; 0x300 <Clock_Check_KPD+0x32>

0000033c <Clock_Enter_Typing_Mode>:
}

void Clock_Enter_Typing_Mode(void *pvParameters)
{
     33c:	cf 93       	push	r28
     33e:	df 93       	push	r29
     340:	00 d0       	rcall	.+0      	; 0x342 <Clock_Enter_Typing_Mode+0x6>
     342:	00 d0       	rcall	.+0      	; 0x344 <Clock_Enter_Typing_Mode+0x8>
     344:	00 d0       	rcall	.+0      	; 0x346 <Clock_Enter_Typing_Mode+0xa>
     346:	cd b7       	in	r28, 0x3d	; 61
     348:	de b7       	in	r29, 0x3e	; 62
     34a:	9e 83       	std	Y+6, r25	; 0x06
     34c:	8d 83       	std	Y+5, r24	; 0x05
	u8 pressed  = 0xff;
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	8c 83       	std	Y+4, r24	; 0x04
	u8 take_lach = 0;
     352:	19 82       	std	Y+1, r1	; 0x01
	u8 current_block = 26;
     354:	8a e1       	ldi	r24, 0x1A	; 26
     356:	8b 83       	std	Y+3, r24	; 0x03
	u8 take_lcd = 0;
     358:	1a 82       	std	Y+2, r1	; 0x02
	while(1)
	{
		if(xQueueReceive(KPD_input,&pressed,10))
     35a:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <KPD_input>
     35e:	90 91 be 00 	lds	r25, 0x00BE	; 0x8000be <KPD_input+0x1>
     362:	9e 01       	movw	r18, r28
     364:	2c 5f       	subi	r18, 0xFC	; 252
     366:	3f 4f       	sbci	r19, 0xFF	; 255
     368:	4a e0       	ldi	r20, 0x0A	; 10
     36a:	50 e0       	ldi	r21, 0x00	; 0
     36c:	b9 01       	movw	r22, r18
     36e:	0e 94 ab 1a 	call	0x3556	; 0x3556 <xQueueReceive>
     372:	88 23       	and	r24, r24
     374:	91 f3       	breq	.-28     	; 0x35a <Clock_Enter_Typing_Mode+0x1e>
		{
			if((take_lach)&&(pressed != '*'))
     376:	89 81       	ldd	r24, Y+1	; 0x01
     378:	88 23       	and	r24, r24
     37a:	51 f0       	breq	.+20     	; 0x390 <Clock_Enter_Typing_Mode+0x54>
     37c:	8c 81       	ldd	r24, Y+4	; 0x04
     37e:	8a 32       	cpi	r24, 0x2A	; 42
     380:	39 f0       	breq	.+14     	; 0x390 <Clock_Enter_Typing_Mode+0x54>
			{
				LCD_Set_Block(current_block);
     382:	8b 81       	ldd	r24, Y+3	; 0x03
     384:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
				LCD_Void_Write_Data(pressed);
     388:	8c 81       	ldd	r24, Y+4	; 0x04
     38a:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
				continue;
     38e:	3f c0       	rjmp	.+126    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
			}
			switch (pressed)
     390:	8c 81       	ldd	r24, Y+4	; 0x04
     392:	88 2f       	mov	r24, r24
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	8a 97       	sbiw	r24, 0x2a	; 42
     398:	d1 f5       	brne	.+116    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
			{
			case '*':
				if(take_lcd%2)
     39a:	8a 81       	ldd	r24, Y+2	; 0x02
     39c:	81 70       	andi	r24, 0x01	; 1
     39e:	88 23       	and	r24, r24
     3a0:	d1 f0       	breq	.+52     	; 0x3d6 <Clock_Enter_Typing_Mode+0x9a>
				{
					if(xSemaphoreTake(LCD,10))
     3a2:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     3a6:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     3aa:	6a e0       	ldi	r22, 0x0A	; 10
     3ac:	70 e0       	ldi	r23, 0x00	; 0
     3ae:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <xQueueSemaphoreTake>
     3b2:	88 23       	and	r24, r24
     3b4:	59 f1       	breq	.+86     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
					{
						LCD_Set_Block(16);
     3b6:	80 e1       	ldi	r24, 0x10	; 16
     3b8:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
						LCD_Void_Write_String("taken  ");
     3bc:	81 e7       	ldi	r24, 0x71	; 113
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	0e 94 8c 0c 	call	0x1918	; 0x1918 <LCD_Void_Write_String>
						KPD_Check_frequency = 1;
     3c4:	81 e0       	ldi	r24, 0x01	; 1
     3c6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
						take_lach = 1;
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	89 83       	std	Y+1, r24	; 0x01
						take_lcd++;
     3ce:	8a 81       	ldd	r24, Y+2	; 0x02
     3d0:	8f 5f       	subi	r24, 0xFF	; 255
     3d2:	8a 83       	std	Y+2, r24	; 0x02
					take_lach = 0;
					Clock_Print_Default_Interface();
					KPD_Check_frequency = configTICK_RATE_HZ*2;
					take_lcd++;
				}
				break;
     3d4:	1b c0       	rjmp	.+54     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
						take_lcd++;
					}
				}
				else
				{
					xSemaphoreGive(LCD);
     3d6:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     3da:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     3de:	20 e0       	ldi	r18, 0x00	; 0
     3e0:	40 e0       	ldi	r20, 0x00	; 0
     3e2:	50 e0       	ldi	r21, 0x00	; 0
     3e4:	60 e0       	ldi	r22, 0x00	; 0
     3e6:	70 e0       	ldi	r23, 0x00	; 0
     3e8:	0e 94 41 19 	call	0x3282	; 0x3282 <xQueueGenericSend>
					LCD_Set_Block(16);
     3ec:	80 e1       	ldi	r24, 0x10	; 16
     3ee:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
					LCD_Void_Write_String("released");
     3f2:	89 e7       	ldi	r24, 0x79	; 121
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	0e 94 8c 0c 	call	0x1918	; 0x1918 <LCD_Void_Write_String>
					take_lach = 0;
     3fa:	19 82       	std	Y+1, r1	; 0x01
					Clock_Print_Default_Interface();
     3fc:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
					KPD_Check_frequency = configTICK_RATE_HZ*2;
     400:	84 e1       	ldi	r24, 0x14	; 20
     402:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
					take_lcd++;
     406:	8a 81       	ldd	r24, Y+2	; 0x02
     408:	8f 5f       	subi	r24, 0xFF	; 255
     40a:	8a 83       	std	Y+2, r24	; 0x02
				}
				break;
     40c:	00 00       	nop
			}

		}

	}
     40e:	a5 cf       	rjmp	.-182    	; 0x35a <Clock_Enter_Typing_Mode+0x1e>

00000410 <DIO_voidInitialize>:

/* Description: This function shall initialize the     */
/*              direction and initial value for DIO    */
/*              pins                                   */
void DIO_voidInitialize(void)
{
     410:	cf 93       	push	r28
     412:	df 93       	push	r29
     414:	cd b7       	in	r28, 0x3d	; 61
     416:	de b7       	in	r29, 0x3e	; 62
	DIO_u8_DDRA->ByteAccess = CONC_8BIT(DIO_u8_PIN0_DIR,
     418:	8a e3       	ldi	r24, 0x3A	; 58
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	fc 01       	movw	r30, r24
     41e:	10 82       	st	Z, r1
										DIO_u8_PIN4_DIR,
										DIO_u8_PIN5_DIR,
										DIO_u8_PIN6_DIR,
										DIO_u8_PIN7_DIR);

	DIO_u8_DDRB->ByteAccess = CONC_8BIT(DIO_u8_PIN8_DIR,
     420:	87 e3       	ldi	r24, 0x37	; 55
     422:	90 e0       	ldi	r25, 0x00	; 0
     424:	fc 01       	movw	r30, r24
     426:	10 82       	st	Z, r1
										DIO_u8_PIN12_DIR,
										DIO_u8_PIN13_DIR,
										DIO_u8_PIN14_DIR,
										DIO_u8_PIN15_DIR);

	DIO_u8_DDRC->ByteAccess = CONC_8BIT(DIO_u8_PIN16_DIR,
     428:	84 e3       	ldi	r24, 0x34	; 52
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	fc 01       	movw	r30, r24
     42e:	10 82       	st	Z, r1
										DIO_u8_PIN20_DIR,
										DIO_u8_PIN21_DIR,
										DIO_u8_PIN22_DIR,
										DIO_u8_PIN23_DIR);

	DIO_u8_DDRD->ByteAccess = CONC_8BIT(DIO_u8_PIN24_DIR,
     430:	81 e3       	ldi	r24, 0x31	; 49
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	fc 01       	movw	r30, r24
     436:	10 82       	st	Z, r1
										DIO_u8_PIN27_DIR,
										DIO_u8_PIN28_DIR,
										DIO_u8_PIN29_DIR,
										DIO_u8_PIN30_DIR,
										DIO_u8_PIN31_DIR);
}
     438:	00 00       	nop
     43a:	df 91       	pop	r29
     43c:	cf 91       	pop	r28
     43e:	08 95       	ret

00000440 <DIO_u8SetPinDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_pin           */
u8 DIO_u8SetPinDirection(u8 Copy_u8PinNB, u8 Copy_u8PinDirection)
{
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
     444:	00 d0       	rcall	.+0      	; 0x446 <DIO_u8SetPinDirection+0x6>
     446:	00 d0       	rcall	.+0      	; 0x448 <DIO_u8SetPinDirection+0x8>
     448:	1f 92       	push	r1
     44a:	cd b7       	in	r28, 0x3d	; 61
     44c:	de b7       	in	r29, 0x3e	; 62
     44e:	8c 83       	std	Y+4, r24	; 0x04
     450:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     452:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     454:	8c 81       	ldd	r24, Y+4	; 0x04
     456:	80 32       	cpi	r24, 0x20	; 32
     458:	18 f0       	brcs	.+6      	; 0x460 <DIO_u8SetPinDirection+0x20>
	{
		u8ErrorState = 1;
     45a:	81 e0       	ldi	r24, 0x01	; 1
     45c:	89 83       	std	Y+1, r24	; 0x01
     45e:	dd c0       	rjmp	.+442    	; 0x61a <DIO_u8SetPinDirection+0x1da>
	}else if ((Copy_u8PinDirection != DIO_u8_INPUT) && (Copy_u8PinDirection != DIO_u8_OUTPUT))
     460:	8d 81       	ldd	r24, Y+5	; 0x05
     462:	88 23       	and	r24, r24
     464:	31 f0       	breq	.+12     	; 0x472 <DIO_u8SetPinDirection+0x32>
     466:	8d 81       	ldd	r24, Y+5	; 0x05
     468:	81 30       	cpi	r24, 0x01	; 1
     46a:	19 f0       	breq	.+6      	; 0x472 <DIO_u8SetPinDirection+0x32>
	{
		u8ErrorState = 1;
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	89 83       	std	Y+1, r24	; 0x01
     470:	d4 c0       	rjmp	.+424    	; 0x61a <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     472:	8c 81       	ldd	r24, Y+4	; 0x04
     474:	86 95       	lsr	r24
     476:	86 95       	lsr	r24
     478:	86 95       	lsr	r24
     47a:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     47c:	8c 81       	ldd	r24, Y+4	; 0x04
     47e:	87 70       	andi	r24, 0x07	; 7
     480:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     482:	8a 81       	ldd	r24, Y+2	; 0x02
     484:	88 2f       	mov	r24, r24
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	81 30       	cpi	r24, 0x01	; 1
     48a:	91 05       	cpc	r25, r1
     48c:	e1 f1       	breq	.+120    	; 0x506 <DIO_u8SetPinDirection+0xc6>
     48e:	82 30       	cpi	r24, 0x02	; 2
     490:	91 05       	cpc	r25, r1
     492:	1c f4       	brge	.+6      	; 0x49a <DIO_u8SetPinDirection+0x5a>
     494:	89 2b       	or	r24, r25
     496:	49 f0       	breq	.+18     	; 0x4aa <DIO_u8SetPinDirection+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     498:	c0 c0       	rjmp	.+384    	; 0x61a <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     49a:	82 30       	cpi	r24, 0x02	; 2
     49c:	91 05       	cpc	r25, r1
     49e:	09 f4       	brne	.+2      	; 0x4a2 <DIO_u8SetPinDirection+0x62>
     4a0:	60 c0       	rjmp	.+192    	; 0x562 <DIO_u8SetPinDirection+0x122>
     4a2:	03 97       	sbiw	r24, 0x03	; 3
     4a4:	09 f4       	brne	.+2      	; 0x4a8 <DIO_u8SetPinDirection+0x68>
     4a6:	8b c0       	rjmp	.+278    	; 0x5be <DIO_u8SetPinDirection+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     4a8:	b8 c0       	rjmp	.+368    	; 0x61a <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     4aa:	8d 81       	ldd	r24, Y+5	; 0x05
     4ac:	81 30       	cpi	r24, 0x01	; 1
     4ae:	a9 f4       	brne	.+42     	; 0x4da <DIO_u8SetPinDirection+0x9a>
     4b0:	8a e3       	ldi	r24, 0x3A	; 58
     4b2:	90 e0       	ldi	r25, 0x00	; 0
     4b4:	2a e3       	ldi	r18, 0x3A	; 58
     4b6:	30 e0       	ldi	r19, 0x00	; 0
     4b8:	f9 01       	movw	r30, r18
     4ba:	20 81       	ld	r18, Z
     4bc:	62 2f       	mov	r22, r18
     4be:	2b 81       	ldd	r18, Y+3	; 0x03
     4c0:	42 2f       	mov	r20, r18
     4c2:	50 e0       	ldi	r21, 0x00	; 0
     4c4:	21 e0       	ldi	r18, 0x01	; 1
     4c6:	30 e0       	ldi	r19, 0x00	; 0
     4c8:	02 c0       	rjmp	.+4      	; 0x4ce <DIO_u8SetPinDirection+0x8e>
     4ca:	22 0f       	add	r18, r18
     4cc:	33 1f       	adc	r19, r19
     4ce:	4a 95       	dec	r20
     4d0:	e2 f7       	brpl	.-8      	; 0x4ca <DIO_u8SetPinDirection+0x8a>
     4d2:	26 2b       	or	r18, r22
     4d4:	fc 01       	movw	r30, r24
     4d6:	20 83       	st	Z, r18
			break;
     4d8:	a0 c0       	rjmp	.+320    	; 0x61a <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     4da:	8a e3       	ldi	r24, 0x3A	; 58
     4dc:	90 e0       	ldi	r25, 0x00	; 0
     4de:	2a e3       	ldi	r18, 0x3A	; 58
     4e0:	30 e0       	ldi	r19, 0x00	; 0
     4e2:	f9 01       	movw	r30, r18
     4e4:	20 81       	ld	r18, Z
     4e6:	62 2f       	mov	r22, r18
     4e8:	2b 81       	ldd	r18, Y+3	; 0x03
     4ea:	42 2f       	mov	r20, r18
     4ec:	50 e0       	ldi	r21, 0x00	; 0
     4ee:	21 e0       	ldi	r18, 0x01	; 1
     4f0:	30 e0       	ldi	r19, 0x00	; 0
     4f2:	02 c0       	rjmp	.+4      	; 0x4f8 <DIO_u8SetPinDirection+0xb8>
     4f4:	22 0f       	add	r18, r18
     4f6:	33 1f       	adc	r19, r19
     4f8:	4a 95       	dec	r20
     4fa:	e2 f7       	brpl	.-8      	; 0x4f4 <DIO_u8SetPinDirection+0xb4>
     4fc:	20 95       	com	r18
     4fe:	26 23       	and	r18, r22
     500:	fc 01       	movw	r30, r24
     502:	20 83       	st	Z, r18
			break;
     504:	8a c0       	rjmp	.+276    	; 0x61a <DIO_u8SetPinDirection+0x1da>
		case GROUP_B :
			if(Copy_u8PinDirection == DIO_u8_INPUT)
     506:	8d 81       	ldd	r24, Y+5	; 0x05
     508:	88 23       	and	r24, r24
     50a:	b1 f4       	brne	.+44     	; 0x538 <DIO_u8SetPinDirection+0xf8>
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     50c:	87 e3       	ldi	r24, 0x37	; 55
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	27 e3       	ldi	r18, 0x37	; 55
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	f9 01       	movw	r30, r18
     516:	20 81       	ld	r18, Z
     518:	62 2f       	mov	r22, r18
     51a:	2b 81       	ldd	r18, Y+3	; 0x03
     51c:	42 2f       	mov	r20, r18
     51e:	50 e0       	ldi	r21, 0x00	; 0
     520:	21 e0       	ldi	r18, 0x01	; 1
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	02 c0       	rjmp	.+4      	; 0x52a <DIO_u8SetPinDirection+0xea>
     526:	22 0f       	add	r18, r18
     528:	33 1f       	adc	r19, r19
     52a:	4a 95       	dec	r20
     52c:	e2 f7       	brpl	.-8      	; 0x526 <DIO_u8SetPinDirection+0xe6>
     52e:	20 95       	com	r18
     530:	26 23       	and	r18, r22
     532:	fc 01       	movw	r30, r24
     534:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
     536:	71 c0       	rjmp	.+226    	; 0x61a <DIO_u8SetPinDirection+0x1da>
			if(Copy_u8PinDirection == DIO_u8_INPUT)
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     538:	87 e3       	ldi	r24, 0x37	; 55
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	27 e3       	ldi	r18, 0x37	; 55
     53e:	30 e0       	ldi	r19, 0x00	; 0
     540:	f9 01       	movw	r30, r18
     542:	20 81       	ld	r18, Z
     544:	62 2f       	mov	r22, r18
     546:	2b 81       	ldd	r18, Y+3	; 0x03
     548:	42 2f       	mov	r20, r18
     54a:	50 e0       	ldi	r21, 0x00	; 0
     54c:	21 e0       	ldi	r18, 0x01	; 1
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	02 c0       	rjmp	.+4      	; 0x556 <DIO_u8SetPinDirection+0x116>
     552:	22 0f       	add	r18, r18
     554:	33 1f       	adc	r19, r19
     556:	4a 95       	dec	r20
     558:	e2 f7       	brpl	.-8      	; 0x552 <DIO_u8SetPinDirection+0x112>
     55a:	26 2b       	or	r18, r22
     55c:	fc 01       	movw	r30, r24
     55e:	20 83       	st	Z, r18
			}
			break;
     560:	5c c0       	rjmp	.+184    	; 0x61a <DIO_u8SetPinDirection+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     562:	8d 81       	ldd	r24, Y+5	; 0x05
     564:	81 30       	cpi	r24, 0x01	; 1
     566:	a9 f4       	brne	.+42     	; 0x592 <DIO_u8SetPinDirection+0x152>
     568:	84 e3       	ldi	r24, 0x34	; 52
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	24 e3       	ldi	r18, 0x34	; 52
     56e:	30 e0       	ldi	r19, 0x00	; 0
     570:	f9 01       	movw	r30, r18
     572:	20 81       	ld	r18, Z
     574:	62 2f       	mov	r22, r18
     576:	2b 81       	ldd	r18, Y+3	; 0x03
     578:	42 2f       	mov	r20, r18
     57a:	50 e0       	ldi	r21, 0x00	; 0
     57c:	21 e0       	ldi	r18, 0x01	; 1
     57e:	30 e0       	ldi	r19, 0x00	; 0
     580:	02 c0       	rjmp	.+4      	; 0x586 <DIO_u8SetPinDirection+0x146>
     582:	22 0f       	add	r18, r18
     584:	33 1f       	adc	r19, r19
     586:	4a 95       	dec	r20
     588:	e2 f7       	brpl	.-8      	; 0x582 <DIO_u8SetPinDirection+0x142>
     58a:	26 2b       	or	r18, r22
     58c:	fc 01       	movw	r30, r24
     58e:	20 83       	st	Z, r18
			break;
     590:	44 c0       	rjmp	.+136    	; 0x61a <DIO_u8SetPinDirection+0x1da>
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     592:	84 e3       	ldi	r24, 0x34	; 52
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	24 e3       	ldi	r18, 0x34	; 52
     598:	30 e0       	ldi	r19, 0x00	; 0
     59a:	f9 01       	movw	r30, r18
     59c:	20 81       	ld	r18, Z
     59e:	62 2f       	mov	r22, r18
     5a0:	2b 81       	ldd	r18, Y+3	; 0x03
     5a2:	42 2f       	mov	r20, r18
     5a4:	50 e0       	ldi	r21, 0x00	; 0
     5a6:	21 e0       	ldi	r18, 0x01	; 1
     5a8:	30 e0       	ldi	r19, 0x00	; 0
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <DIO_u8SetPinDirection+0x170>
     5ac:	22 0f       	add	r18, r18
     5ae:	33 1f       	adc	r19, r19
     5b0:	4a 95       	dec	r20
     5b2:	e2 f7       	brpl	.-8      	; 0x5ac <DIO_u8SetPinDirection+0x16c>
     5b4:	20 95       	com	r18
     5b6:	26 23       	and	r18, r22
     5b8:	fc 01       	movw	r30, r24
     5ba:	20 83       	st	Z, r18
			break;
     5bc:	2e c0       	rjmp	.+92     	; 0x61a <DIO_u8SetPinDirection+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     5be:	8d 81       	ldd	r24, Y+5	; 0x05
     5c0:	81 30       	cpi	r24, 0x01	; 1
     5c2:	a9 f4       	brne	.+42     	; 0x5ee <DIO_u8SetPinDirection+0x1ae>
     5c4:	81 e3       	ldi	r24, 0x31	; 49
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	21 e3       	ldi	r18, 0x31	; 49
     5ca:	30 e0       	ldi	r19, 0x00	; 0
     5cc:	f9 01       	movw	r30, r18
     5ce:	20 81       	ld	r18, Z
     5d0:	62 2f       	mov	r22, r18
     5d2:	2b 81       	ldd	r18, Y+3	; 0x03
     5d4:	42 2f       	mov	r20, r18
     5d6:	50 e0       	ldi	r21, 0x00	; 0
     5d8:	21 e0       	ldi	r18, 0x01	; 1
     5da:	30 e0       	ldi	r19, 0x00	; 0
     5dc:	02 c0       	rjmp	.+4      	; 0x5e2 <DIO_u8SetPinDirection+0x1a2>
     5de:	22 0f       	add	r18, r18
     5e0:	33 1f       	adc	r19, r19
     5e2:	4a 95       	dec	r20
     5e4:	e2 f7       	brpl	.-8      	; 0x5de <DIO_u8SetPinDirection+0x19e>
     5e6:	26 2b       	or	r18, r22
     5e8:	fc 01       	movw	r30, r24
     5ea:	20 83       	st	Z, r18
			break;
     5ec:	15 c0       	rjmp	.+42     	; 0x618 <DIO_u8SetPinDirection+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     5ee:	81 e3       	ldi	r24, 0x31	; 49
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	21 e3       	ldi	r18, 0x31	; 49
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	f9 01       	movw	r30, r18
     5f8:	20 81       	ld	r18, Z
     5fa:	62 2f       	mov	r22, r18
     5fc:	2b 81       	ldd	r18, Y+3	; 0x03
     5fe:	42 2f       	mov	r20, r18
     600:	50 e0       	ldi	r21, 0x00	; 0
     602:	21 e0       	ldi	r18, 0x01	; 1
     604:	30 e0       	ldi	r19, 0x00	; 0
     606:	02 c0       	rjmp	.+4      	; 0x60c <DIO_u8SetPinDirection+0x1cc>
     608:	22 0f       	add	r18, r18
     60a:	33 1f       	adc	r19, r19
     60c:	4a 95       	dec	r20
     60e:	e2 f7       	brpl	.-8      	; 0x608 <DIO_u8SetPinDirection+0x1c8>
     610:	20 95       	com	r18
     612:	26 23       	and	r18, r22
     614:	fc 01       	movw	r30, r24
     616:	20 83       	st	Z, r18
			break;
     618:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     61a:	89 81       	ldd	r24, Y+1	; 0x01
}
     61c:	0f 90       	pop	r0
     61e:	0f 90       	pop	r0
     620:	0f 90       	pop	r0
     622:	0f 90       	pop	r0
     624:	0f 90       	pop	r0
     626:	df 91       	pop	r29
     628:	cf 91       	pop	r28
     62a:	08 95       	ret

0000062c <DIO_u8SetPinValue>:
/* Description: This function shall set certain value  */
/*              to certain DIO pin                     */
u8 DIO_u8SetPinValue(u8 Copy_u8PinNB, u8 Copy_u8PinValue)
{
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
     630:	00 d0       	rcall	.+0      	; 0x632 <DIO_u8SetPinValue+0x6>
     632:	00 d0       	rcall	.+0      	; 0x634 <DIO_u8SetPinValue+0x8>
     634:	1f 92       	push	r1
     636:	cd b7       	in	r28, 0x3d	; 61
     638:	de b7       	in	r29, 0x3e	; 62
     63a:	8c 83       	std	Y+4, r24	; 0x04
     63c:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     63e:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     640:	8c 81       	ldd	r24, Y+4	; 0x04
     642:	80 32       	cpi	r24, 0x20	; 32
     644:	18 f0       	brcs	.+6      	; 0x64c <DIO_u8SetPinValue+0x20>
	{
		u8ErrorState = 1;
     646:	81 e0       	ldi	r24, 0x01	; 1
     648:	89 83       	std	Y+1, r24	; 0x01
     64a:	dd c0       	rjmp	.+442    	; 0x806 <DIO_u8SetPinValue+0x1da>
	}else if ((Copy_u8PinValue != DIO_u8_HIGH) && (Copy_u8PinValue != DIO_u8_LOW))
     64c:	8d 81       	ldd	r24, Y+5	; 0x05
     64e:	81 30       	cpi	r24, 0x01	; 1
     650:	31 f0       	breq	.+12     	; 0x65e <DIO_u8SetPinValue+0x32>
     652:	8d 81       	ldd	r24, Y+5	; 0x05
     654:	88 23       	and	r24, r24
     656:	19 f0       	breq	.+6      	; 0x65e <DIO_u8SetPinValue+0x32>
	{
		u8ErrorState = 1;
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	89 83       	std	Y+1, r24	; 0x01
     65c:	d4 c0       	rjmp	.+424    	; 0x806 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     65e:	8c 81       	ldd	r24, Y+4	; 0x04
     660:	86 95       	lsr	r24
     662:	86 95       	lsr	r24
     664:	86 95       	lsr	r24
     666:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     668:	8c 81       	ldd	r24, Y+4	; 0x04
     66a:	87 70       	andi	r24, 0x07	; 7
     66c:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     66e:	8a 81       	ldd	r24, Y+2	; 0x02
     670:	88 2f       	mov	r24, r24
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	81 30       	cpi	r24, 0x01	; 1
     676:	91 05       	cpc	r25, r1
     678:	e1 f1       	breq	.+120    	; 0x6f2 <DIO_u8SetPinValue+0xc6>
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	91 05       	cpc	r25, r1
     67e:	1c f4       	brge	.+6      	; 0x686 <DIO_u8SetPinValue+0x5a>
     680:	89 2b       	or	r24, r25
     682:	49 f0       	breq	.+18     	; 0x696 <DIO_u8SetPinValue+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     684:	c0 c0       	rjmp	.+384    	; 0x806 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     686:	82 30       	cpi	r24, 0x02	; 2
     688:	91 05       	cpc	r25, r1
     68a:	09 f4       	brne	.+2      	; 0x68e <DIO_u8SetPinValue+0x62>
     68c:	60 c0       	rjmp	.+192    	; 0x74e <DIO_u8SetPinValue+0x122>
     68e:	03 97       	sbiw	r24, 0x03	; 3
     690:	09 f4       	brne	.+2      	; 0x694 <DIO_u8SetPinValue+0x68>
     692:	8b c0       	rjmp	.+278    	; 0x7aa <DIO_u8SetPinValue+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     694:	b8 c0       	rjmp	.+368    	; 0x806 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     696:	8d 81       	ldd	r24, Y+5	; 0x05
     698:	81 30       	cpi	r24, 0x01	; 1
     69a:	a9 f4       	brne	.+42     	; 0x6c6 <DIO_u8SetPinValue+0x9a>
     69c:	8b e3       	ldi	r24, 0x3B	; 59
     69e:	90 e0       	ldi	r25, 0x00	; 0
     6a0:	2b e3       	ldi	r18, 0x3B	; 59
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	f9 01       	movw	r30, r18
     6a6:	20 81       	ld	r18, Z
     6a8:	62 2f       	mov	r22, r18
     6aa:	2b 81       	ldd	r18, Y+3	; 0x03
     6ac:	42 2f       	mov	r20, r18
     6ae:	50 e0       	ldi	r21, 0x00	; 0
     6b0:	21 e0       	ldi	r18, 0x01	; 1
     6b2:	30 e0       	ldi	r19, 0x00	; 0
     6b4:	02 c0       	rjmp	.+4      	; 0x6ba <DIO_u8SetPinValue+0x8e>
     6b6:	22 0f       	add	r18, r18
     6b8:	33 1f       	adc	r19, r19
     6ba:	4a 95       	dec	r20
     6bc:	e2 f7       	brpl	.-8      	; 0x6b6 <DIO_u8SetPinValue+0x8a>
     6be:	26 2b       	or	r18, r22
     6c0:	fc 01       	movw	r30, r24
     6c2:	20 83       	st	Z, r18
			break;
     6c4:	a0 c0       	rjmp	.+320    	; 0x806 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     6c6:	8b e3       	ldi	r24, 0x3B	; 59
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	2b e3       	ldi	r18, 0x3B	; 59
     6cc:	30 e0       	ldi	r19, 0x00	; 0
     6ce:	f9 01       	movw	r30, r18
     6d0:	20 81       	ld	r18, Z
     6d2:	62 2f       	mov	r22, r18
     6d4:	2b 81       	ldd	r18, Y+3	; 0x03
     6d6:	42 2f       	mov	r20, r18
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	21 e0       	ldi	r18, 0x01	; 1
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	02 c0       	rjmp	.+4      	; 0x6e4 <DIO_u8SetPinValue+0xb8>
     6e0:	22 0f       	add	r18, r18
     6e2:	33 1f       	adc	r19, r19
     6e4:	4a 95       	dec	r20
     6e6:	e2 f7       	brpl	.-8      	; 0x6e0 <DIO_u8SetPinValue+0xb4>
     6e8:	20 95       	com	r18
     6ea:	26 23       	and	r18, r22
     6ec:	fc 01       	movw	r30, r24
     6ee:	20 83       	st	Z, r18
			break;
     6f0:	8a c0       	rjmp	.+276    	; 0x806 <DIO_u8SetPinValue+0x1da>
		case GROUP_B :
			if(Copy_u8PinValue == DIO_u8_LOW)
     6f2:	8d 81       	ldd	r24, Y+5	; 0x05
     6f4:	88 23       	and	r24, r24
     6f6:	b1 f4       	brne	.+44     	; 0x724 <DIO_u8SetPinValue+0xf8>
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     6f8:	88 e3       	ldi	r24, 0x38	; 56
     6fa:	90 e0       	ldi	r25, 0x00	; 0
     6fc:	28 e3       	ldi	r18, 0x38	; 56
     6fe:	30 e0       	ldi	r19, 0x00	; 0
     700:	f9 01       	movw	r30, r18
     702:	20 81       	ld	r18, Z
     704:	62 2f       	mov	r22, r18
     706:	2b 81       	ldd	r18, Y+3	; 0x03
     708:	42 2f       	mov	r20, r18
     70a:	50 e0       	ldi	r21, 0x00	; 0
     70c:	21 e0       	ldi	r18, 0x01	; 1
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	02 c0       	rjmp	.+4      	; 0x716 <DIO_u8SetPinValue+0xea>
     712:	22 0f       	add	r18, r18
     714:	33 1f       	adc	r19, r19
     716:	4a 95       	dec	r20
     718:	e2 f7       	brpl	.-8      	; 0x712 <DIO_u8SetPinValue+0xe6>
     71a:	20 95       	com	r18
     71c:	26 23       	and	r18, r22
     71e:	fc 01       	movw	r30, r24
     720:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
     722:	71 c0       	rjmp	.+226    	; 0x806 <DIO_u8SetPinValue+0x1da>
			if(Copy_u8PinValue == DIO_u8_LOW)
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     724:	88 e3       	ldi	r24, 0x38	; 56
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	28 e3       	ldi	r18, 0x38	; 56
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	f9 01       	movw	r30, r18
     72e:	20 81       	ld	r18, Z
     730:	62 2f       	mov	r22, r18
     732:	2b 81       	ldd	r18, Y+3	; 0x03
     734:	42 2f       	mov	r20, r18
     736:	50 e0       	ldi	r21, 0x00	; 0
     738:	21 e0       	ldi	r18, 0x01	; 1
     73a:	30 e0       	ldi	r19, 0x00	; 0
     73c:	02 c0       	rjmp	.+4      	; 0x742 <DIO_u8SetPinValue+0x116>
     73e:	22 0f       	add	r18, r18
     740:	33 1f       	adc	r19, r19
     742:	4a 95       	dec	r20
     744:	e2 f7       	brpl	.-8      	; 0x73e <DIO_u8SetPinValue+0x112>
     746:	26 2b       	or	r18, r22
     748:	fc 01       	movw	r30, r24
     74a:	20 83       	st	Z, r18
			}
			break;
     74c:	5c c0       	rjmp	.+184    	; 0x806 <DIO_u8SetPinValue+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     74e:	8d 81       	ldd	r24, Y+5	; 0x05
     750:	81 30       	cpi	r24, 0x01	; 1
     752:	a9 f4       	brne	.+42     	; 0x77e <DIO_u8SetPinValue+0x152>
     754:	85 e3       	ldi	r24, 0x35	; 53
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	25 e3       	ldi	r18, 0x35	; 53
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	f9 01       	movw	r30, r18
     75e:	20 81       	ld	r18, Z
     760:	62 2f       	mov	r22, r18
     762:	2b 81       	ldd	r18, Y+3	; 0x03
     764:	42 2f       	mov	r20, r18
     766:	50 e0       	ldi	r21, 0x00	; 0
     768:	21 e0       	ldi	r18, 0x01	; 1
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	02 c0       	rjmp	.+4      	; 0x772 <DIO_u8SetPinValue+0x146>
     76e:	22 0f       	add	r18, r18
     770:	33 1f       	adc	r19, r19
     772:	4a 95       	dec	r20
     774:	e2 f7       	brpl	.-8      	; 0x76e <DIO_u8SetPinValue+0x142>
     776:	26 2b       	or	r18, r22
     778:	fc 01       	movw	r30, r24
     77a:	20 83       	st	Z, r18
			break;
     77c:	44 c0       	rjmp	.+136    	; 0x806 <DIO_u8SetPinValue+0x1da>
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     77e:	85 e3       	ldi	r24, 0x35	; 53
     780:	90 e0       	ldi	r25, 0x00	; 0
     782:	25 e3       	ldi	r18, 0x35	; 53
     784:	30 e0       	ldi	r19, 0x00	; 0
     786:	f9 01       	movw	r30, r18
     788:	20 81       	ld	r18, Z
     78a:	62 2f       	mov	r22, r18
     78c:	2b 81       	ldd	r18, Y+3	; 0x03
     78e:	42 2f       	mov	r20, r18
     790:	50 e0       	ldi	r21, 0x00	; 0
     792:	21 e0       	ldi	r18, 0x01	; 1
     794:	30 e0       	ldi	r19, 0x00	; 0
     796:	02 c0       	rjmp	.+4      	; 0x79c <DIO_u8SetPinValue+0x170>
     798:	22 0f       	add	r18, r18
     79a:	33 1f       	adc	r19, r19
     79c:	4a 95       	dec	r20
     79e:	e2 f7       	brpl	.-8      	; 0x798 <DIO_u8SetPinValue+0x16c>
     7a0:	20 95       	com	r18
     7a2:	26 23       	and	r18, r22
     7a4:	fc 01       	movw	r30, r24
     7a6:	20 83       	st	Z, r18
			break;
     7a8:	2e c0       	rjmp	.+92     	; 0x806 <DIO_u8SetPinValue+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     7aa:	8d 81       	ldd	r24, Y+5	; 0x05
     7ac:	81 30       	cpi	r24, 0x01	; 1
     7ae:	a9 f4       	brne	.+42     	; 0x7da <DIO_u8SetPinValue+0x1ae>
     7b0:	82 e3       	ldi	r24, 0x32	; 50
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	22 e3       	ldi	r18, 0x32	; 50
     7b6:	30 e0       	ldi	r19, 0x00	; 0
     7b8:	f9 01       	movw	r30, r18
     7ba:	20 81       	ld	r18, Z
     7bc:	62 2f       	mov	r22, r18
     7be:	2b 81       	ldd	r18, Y+3	; 0x03
     7c0:	42 2f       	mov	r20, r18
     7c2:	50 e0       	ldi	r21, 0x00	; 0
     7c4:	21 e0       	ldi	r18, 0x01	; 1
     7c6:	30 e0       	ldi	r19, 0x00	; 0
     7c8:	02 c0       	rjmp	.+4      	; 0x7ce <DIO_u8SetPinValue+0x1a2>
     7ca:	22 0f       	add	r18, r18
     7cc:	33 1f       	adc	r19, r19
     7ce:	4a 95       	dec	r20
     7d0:	e2 f7       	brpl	.-8      	; 0x7ca <DIO_u8SetPinValue+0x19e>
     7d2:	26 2b       	or	r18, r22
     7d4:	fc 01       	movw	r30, r24
     7d6:	20 83       	st	Z, r18
			break;
     7d8:	15 c0       	rjmp	.+42     	; 0x804 <DIO_u8SetPinValue+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     7da:	82 e3       	ldi	r24, 0x32	; 50
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	22 e3       	ldi	r18, 0x32	; 50
     7e0:	30 e0       	ldi	r19, 0x00	; 0
     7e2:	f9 01       	movw	r30, r18
     7e4:	20 81       	ld	r18, Z
     7e6:	62 2f       	mov	r22, r18
     7e8:	2b 81       	ldd	r18, Y+3	; 0x03
     7ea:	42 2f       	mov	r20, r18
     7ec:	50 e0       	ldi	r21, 0x00	; 0
     7ee:	21 e0       	ldi	r18, 0x01	; 1
     7f0:	30 e0       	ldi	r19, 0x00	; 0
     7f2:	02 c0       	rjmp	.+4      	; 0x7f8 <DIO_u8SetPinValue+0x1cc>
     7f4:	22 0f       	add	r18, r18
     7f6:	33 1f       	adc	r19, r19
     7f8:	4a 95       	dec	r20
     7fa:	e2 f7       	brpl	.-8      	; 0x7f4 <DIO_u8SetPinValue+0x1c8>
     7fc:	20 95       	com	r18
     7fe:	26 23       	and	r18, r22
     800:	fc 01       	movw	r30, r24
     802:	20 83       	st	Z, r18
			break;
     804:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     806:	89 81       	ldd	r24, Y+1	; 0x01
}
     808:	0f 90       	pop	r0
     80a:	0f 90       	pop	r0
     80c:	0f 90       	pop	r0
     80e:	0f 90       	pop	r0
     810:	0f 90       	pop	r0
     812:	df 91       	pop	r29
     814:	cf 91       	pop	r28
     816:	08 95       	ret

00000818 <DIO_u8SetPortDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_port          */
u8 DIO_u8SetPortDirection(u8 Copy_u8PortNB, u8 Copy_u8PortDirection)
{
     818:	cf 93       	push	r28
     81a:	df 93       	push	r29
     81c:	00 d0       	rcall	.+0      	; 0x81e <DIO_u8SetPortDirection+0x6>
     81e:	1f 92       	push	r1
     820:	cd b7       	in	r28, 0x3d	; 61
     822:	de b7       	in	r29, 0x3e	; 62
     824:	8a 83       	std	Y+2, r24	; 0x02
     826:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     828:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
		if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     82a:	8a 81       	ldd	r24, Y+2	; 0x02
     82c:	84 30       	cpi	r24, 0x04	; 4
     82e:	18 f0       	brcs	.+6      	; 0x836 <DIO_u8SetPortDirection+0x1e>
		{
			u8ErrorState = 1;
     830:	81 e0       	ldi	r24, 0x01	; 1
     832:	89 83       	std	Y+1, r24	; 0x01
     834:	2a c0       	rjmp	.+84     	; 0x88a <__stack+0x2b>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     836:	8a 81       	ldd	r24, Y+2	; 0x02
     838:	88 2f       	mov	r24, r24
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	81 30       	cpi	r24, 0x01	; 1
     83e:	91 05       	cpc	r25, r1
     840:	91 f0       	breq	.+36     	; 0x866 <__stack+0x7>
     842:	82 30       	cpi	r24, 0x02	; 2
     844:	91 05       	cpc	r25, r1
     846:	1c f4       	brge	.+6      	; 0x84e <DIO_u8SetPortDirection+0x36>
     848:	89 2b       	or	r24, r25
     84a:	39 f0       	breq	.+14     	; 0x85a <DIO_u8SetPortDirection+0x42>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     84c:	1e c0       	rjmp	.+60     	; 0x88a <__stack+0x2b>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     84e:	82 30       	cpi	r24, 0x02	; 2
     850:	91 05       	cpc	r25, r1
     852:	79 f0       	breq	.+30     	; 0x872 <__stack+0x13>
     854:	03 97       	sbiw	r24, 0x03	; 3
     856:	99 f0       	breq	.+38     	; 0x87e <__stack+0x1f>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     858:	18 c0       	rjmp	.+48     	; 0x88a <__stack+0x2b>
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
			{
			case GROUP_A :
				DIO_u8_DDRA->ByteAccess = Copy_u8PortDirection;
     85a:	8a e3       	ldi	r24, 0x3A	; 58
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	2b 81       	ldd	r18, Y+3	; 0x03
     860:	fc 01       	movw	r30, r24
     862:	20 83       	st	Z, r18
				break;
     864:	12 c0       	rjmp	.+36     	; 0x88a <__stack+0x2b>
			case GROUP_B :
				DIO_u8_DDRB->ByteAccess = Copy_u8PortDirection;
     866:	87 e3       	ldi	r24, 0x37	; 55
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	2b 81       	ldd	r18, Y+3	; 0x03
     86c:	fc 01       	movw	r30, r24
     86e:	20 83       	st	Z, r18
				break;
     870:	0c c0       	rjmp	.+24     	; 0x88a <__stack+0x2b>
			case GROUP_C :
				DIO_u8_DDRC->ByteAccess = Copy_u8PortDirection;
     872:	84 e3       	ldi	r24, 0x34	; 52
     874:	90 e0       	ldi	r25, 0x00	; 0
     876:	2b 81       	ldd	r18, Y+3	; 0x03
     878:	fc 01       	movw	r30, r24
     87a:	20 83       	st	Z, r18
				break;
     87c:	06 c0       	rjmp	.+12     	; 0x88a <__stack+0x2b>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
     87e:	81 e3       	ldi	r24, 0x31	; 49
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	2b 81       	ldd	r18, Y+3	; 0x03
     884:	fc 01       	movw	r30, r24
     886:	20 83       	st	Z, r18
				break;
     888:	00 00       	nop

				break;
			}
		}
	/*Function return*/
	return u8ErrorState;
     88a:	89 81       	ldd	r24, Y+1	; 0x01
}
     88c:	0f 90       	pop	r0
     88e:	0f 90       	pop	r0
     890:	0f 90       	pop	r0
     892:	df 91       	pop	r29
     894:	cf 91       	pop	r28
     896:	08 95       	ret

00000898 <DIO_u8SetPortValue>:

/* Description: This function shall set certain        */
/*              value to certain DIO_port              */
u8 DIO_u8SetPortValue(u8 Copy_u8PortNB, u8 Copy_u8PortValue)
{
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
     89c:	00 d0       	rcall	.+0      	; 0x89e <DIO_u8SetPortValue+0x6>
     89e:	1f 92       	push	r1
     8a0:	cd b7       	in	r28, 0x3d	; 61
     8a2:	de b7       	in	r29, 0x3e	; 62
     8a4:	8a 83       	std	Y+2, r24	; 0x02
     8a6:	6b 83       	std	Y+3, r22	; 0x03
		/*Local variables*/
		u8 u8ErrorState = 0;
     8a8:	19 82       	std	Y+1, r1	; 0x01

		/*validate inputs*/
			if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     8aa:	8a 81       	ldd	r24, Y+2	; 0x02
     8ac:	84 30       	cpi	r24, 0x04	; 4
     8ae:	18 f0       	brcs	.+6      	; 0x8b6 <DIO_u8SetPortValue+0x1e>
			{
				u8ErrorState = 1;
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	89 83       	std	Y+1, r24	; 0x01
     8b4:	2a c0       	rjmp	.+84     	; 0x90a <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     8b6:	8a 81       	ldd	r24, Y+2	; 0x02
     8b8:	88 2f       	mov	r24, r24
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	81 30       	cpi	r24, 0x01	; 1
     8be:	91 05       	cpc	r25, r1
     8c0:	91 f0       	breq	.+36     	; 0x8e6 <DIO_u8SetPortValue+0x4e>
     8c2:	82 30       	cpi	r24, 0x02	; 2
     8c4:	91 05       	cpc	r25, r1
     8c6:	1c f4       	brge	.+6      	; 0x8ce <DIO_u8SetPortValue+0x36>
     8c8:	89 2b       	or	r24, r25
     8ca:	39 f0       	breq	.+14     	; 0x8da <DIO_u8SetPortValue+0x42>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     8cc:	1e c0       	rjmp	.+60     	; 0x90a <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	91 05       	cpc	r25, r1
     8d2:	79 f0       	breq	.+30     	; 0x8f2 <DIO_u8SetPortValue+0x5a>
     8d4:	03 97       	sbiw	r24, 0x03	; 3
     8d6:	99 f0       	breq	.+38     	; 0x8fe <DIO_u8SetPortValue+0x66>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     8d8:	18 c0       	rjmp	.+48     	; 0x90a <DIO_u8SetPortValue+0x72>
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
				{
				case GROUP_A :
					DIO_u8_PORTA->ByteAccess = Copy_u8PortValue;
     8da:	8b e3       	ldi	r24, 0x3B	; 59
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	2b 81       	ldd	r18, Y+3	; 0x03
     8e0:	fc 01       	movw	r30, r24
     8e2:	20 83       	st	Z, r18
					break;
     8e4:	12 c0       	rjmp	.+36     	; 0x90a <DIO_u8SetPortValue+0x72>
				case GROUP_B :
					DIO_u8_PORTB->ByteAccess = Copy_u8PortValue;
     8e6:	88 e3       	ldi	r24, 0x38	; 56
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	2b 81       	ldd	r18, Y+3	; 0x03
     8ec:	fc 01       	movw	r30, r24
     8ee:	20 83       	st	Z, r18
					break;
     8f0:	0c c0       	rjmp	.+24     	; 0x90a <DIO_u8SetPortValue+0x72>
				case GROUP_C :
					DIO_u8_PORTC->ByteAccess = Copy_u8PortValue;
     8f2:	85 e3       	ldi	r24, 0x35	; 53
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	2b 81       	ldd	r18, Y+3	; 0x03
     8f8:	fc 01       	movw	r30, r24
     8fa:	20 83       	st	Z, r18
					break;
     8fc:	06 c0       	rjmp	.+12     	; 0x90a <DIO_u8SetPortValue+0x72>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
     8fe:	82 e3       	ldi	r24, 0x32	; 50
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	2b 81       	ldd	r18, Y+3	; 0x03
     904:	fc 01       	movw	r30, r24
     906:	20 83       	st	Z, r18
					break;
     908:	00 00       	nop

					break;
				}
			}
		/*Function return*/
		return u8ErrorState;
     90a:	89 81       	ldd	r24, Y+1	; 0x01
}
     90c:	0f 90       	pop	r0
     90e:	0f 90       	pop	r0
     910:	0f 90       	pop	r0
     912:	df 91       	pop	r29
     914:	cf 91       	pop	r28
     916:	08 95       	ret

00000918 <DIO_u8GetPinValue>:

/* */
/* */
u8 DIO_u8GetPinValue(u8 Copy_u8PinNB, u8 *Copy_u8PinValue)
{
     918:	cf 93       	push	r28
     91a:	df 93       	push	r29
     91c:	00 d0       	rcall	.+0      	; 0x91e <DIO_u8GetPinValue+0x6>
     91e:	00 d0       	rcall	.+0      	; 0x920 <DIO_u8GetPinValue+0x8>
     920:	00 d0       	rcall	.+0      	; 0x922 <DIO_u8GetPinValue+0xa>
     922:	cd b7       	in	r28, 0x3d	; 61
     924:	de b7       	in	r29, 0x3e	; 62
     926:	8c 83       	std	Y+4, r24	; 0x04
     928:	7e 83       	std	Y+6, r23	; 0x06
     92a:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     92c:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     92e:	8c 81       	ldd	r24, Y+4	; 0x04
     930:	80 32       	cpi	r24, 0x20	; 32
     932:	18 f0       	brcs	.+6      	; 0x93a <DIO_u8GetPinValue+0x22>
	{
		u8ErrorState = 1;
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	89 83       	std	Y+1, r24	; 0x01
     938:	6f c0       	rjmp	.+222    	; 0xa18 <DIO_u8GetPinValue+0x100>
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     93a:	8c 81       	ldd	r24, Y+4	; 0x04
     93c:	86 95       	lsr	r24
     93e:	86 95       	lsr	r24
     940:	86 95       	lsr	r24
     942:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     944:	8c 81       	ldd	r24, Y+4	; 0x04
     946:	87 70       	andi	r24, 0x07	; 7
     948:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     94a:	8a 81       	ldd	r24, Y+2	; 0x02
     94c:	88 2f       	mov	r24, r24
     94e:	90 e0       	ldi	r25, 0x00	; 0
     950:	81 30       	cpi	r24, 0x01	; 1
     952:	91 05       	cpc	r25, r1
     954:	11 f1       	breq	.+68     	; 0x99a <DIO_u8GetPinValue+0x82>
     956:	82 30       	cpi	r24, 0x02	; 2
     958:	91 05       	cpc	r25, r1
     95a:	1c f4       	brge	.+6      	; 0x962 <DIO_u8GetPinValue+0x4a>
     95c:	89 2b       	or	r24, r25
     95e:	41 f0       	breq	.+16     	; 0x970 <DIO_u8GetPinValue+0x58>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     960:	5b c0       	rjmp	.+182    	; 0xa18 <DIO_u8GetPinValue+0x100>
		u8ErrorState = 1;
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     962:	82 30       	cpi	r24, 0x02	; 2
     964:	91 05       	cpc	r25, r1
     966:	71 f1       	breq	.+92     	; 0x9c4 <DIO_u8GetPinValue+0xac>
     968:	03 97       	sbiw	r24, 0x03	; 3
     96a:	09 f4       	brne	.+2      	; 0x96e <DIO_u8GetPinValue+0x56>
     96c:	40 c0       	rjmp	.+128    	; 0x9ee <DIO_u8GetPinValue+0xd6>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     96e:	54 c0       	rjmp	.+168    	; 0xa18 <DIO_u8GetPinValue+0x100>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINA -> ByteAccess, u8PIN_ID);
     970:	89 e3       	ldi	r24, 0x39	; 57
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	fc 01       	movw	r30, r24
     976:	80 81       	ld	r24, Z
     978:	88 2f       	mov	r24, r24
     97a:	90 e0       	ldi	r25, 0x00	; 0
     97c:	2b 81       	ldd	r18, Y+3	; 0x03
     97e:	22 2f       	mov	r18, r18
     980:	30 e0       	ldi	r19, 0x00	; 0
     982:	02 c0       	rjmp	.+4      	; 0x988 <DIO_u8GetPinValue+0x70>
     984:	95 95       	asr	r25
     986:	87 95       	ror	r24
     988:	2a 95       	dec	r18
     98a:	e2 f7       	brpl	.-8      	; 0x984 <DIO_u8GetPinValue+0x6c>
     98c:	28 2f       	mov	r18, r24
     98e:	21 70       	andi	r18, 0x01	; 1
     990:	8d 81       	ldd	r24, Y+5	; 0x05
     992:	9e 81       	ldd	r25, Y+6	; 0x06
     994:	fc 01       	movw	r30, r24
     996:	20 83       	st	Z, r18
			break;
     998:	3f c0       	rjmp	.+126    	; 0xa18 <DIO_u8GetPinValue+0x100>
		case GROUP_B :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINB -> ByteAccess, u8PIN_ID);
     99a:	86 e3       	ldi	r24, 0x36	; 54
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	fc 01       	movw	r30, r24
     9a0:	80 81       	ld	r24, Z
     9a2:	88 2f       	mov	r24, r24
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	2b 81       	ldd	r18, Y+3	; 0x03
     9a8:	22 2f       	mov	r18, r18
     9aa:	30 e0       	ldi	r19, 0x00	; 0
     9ac:	02 c0       	rjmp	.+4      	; 0x9b2 <DIO_u8GetPinValue+0x9a>
     9ae:	95 95       	asr	r25
     9b0:	87 95       	ror	r24
     9b2:	2a 95       	dec	r18
     9b4:	e2 f7       	brpl	.-8      	; 0x9ae <DIO_u8GetPinValue+0x96>
     9b6:	28 2f       	mov	r18, r24
     9b8:	21 70       	andi	r18, 0x01	; 1
     9ba:	8d 81       	ldd	r24, Y+5	; 0x05
     9bc:	9e 81       	ldd	r25, Y+6	; 0x06
     9be:	fc 01       	movw	r30, r24
     9c0:	20 83       	st	Z, r18
			break;
     9c2:	2a c0       	rjmp	.+84     	; 0xa18 <DIO_u8GetPinValue+0x100>
		case GROUP_C :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINC -> ByteAccess, u8PIN_ID);
     9c4:	83 e3       	ldi	r24, 0x33	; 51
     9c6:	90 e0       	ldi	r25, 0x00	; 0
     9c8:	fc 01       	movw	r30, r24
     9ca:	80 81       	ld	r24, Z
     9cc:	88 2f       	mov	r24, r24
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	2b 81       	ldd	r18, Y+3	; 0x03
     9d2:	22 2f       	mov	r18, r18
     9d4:	30 e0       	ldi	r19, 0x00	; 0
     9d6:	02 c0       	rjmp	.+4      	; 0x9dc <DIO_u8GetPinValue+0xc4>
     9d8:	95 95       	asr	r25
     9da:	87 95       	ror	r24
     9dc:	2a 95       	dec	r18
     9de:	e2 f7       	brpl	.-8      	; 0x9d8 <DIO_u8GetPinValue+0xc0>
     9e0:	28 2f       	mov	r18, r24
     9e2:	21 70       	andi	r18, 0x01	; 1
     9e4:	8d 81       	ldd	r24, Y+5	; 0x05
     9e6:	9e 81       	ldd	r25, Y+6	; 0x06
     9e8:	fc 01       	movw	r30, r24
     9ea:	20 83       	st	Z, r18
			break;
     9ec:	15 c0       	rjmp	.+42     	; 0xa18 <DIO_u8GetPinValue+0x100>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
     9ee:	80 e3       	ldi	r24, 0x30	; 48
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	fc 01       	movw	r30, r24
     9f4:	80 81       	ld	r24, Z
     9f6:	88 2f       	mov	r24, r24
     9f8:	90 e0       	ldi	r25, 0x00	; 0
     9fa:	2b 81       	ldd	r18, Y+3	; 0x03
     9fc:	22 2f       	mov	r18, r18
     9fe:	30 e0       	ldi	r19, 0x00	; 0
     a00:	02 c0       	rjmp	.+4      	; 0xa06 <DIO_u8GetPinValue+0xee>
     a02:	95 95       	asr	r25
     a04:	87 95       	ror	r24
     a06:	2a 95       	dec	r18
     a08:	e2 f7       	brpl	.-8      	; 0xa02 <DIO_u8GetPinValue+0xea>
     a0a:	28 2f       	mov	r18, r24
     a0c:	21 70       	andi	r18, 0x01	; 1
     a0e:	8d 81       	ldd	r24, Y+5	; 0x05
     a10:	9e 81       	ldd	r25, Y+6	; 0x06
     a12:	fc 01       	movw	r30, r24
     a14:	20 83       	st	Z, r18
			break;
     a16:	00 00       	nop

			break;
		}
	}
	/*Function return*/
	return u8ErrorState;
     a18:	89 81       	ldd	r24, Y+1	; 0x01
}
     a1a:	26 96       	adiw	r28, 0x06	; 6
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	f8 94       	cli
     a20:	de bf       	out	0x3e, r29	; 62
     a22:	0f be       	out	0x3f, r0	; 63
     a24:	cd bf       	out	0x3d, r28	; 61
     a26:	df 91       	pop	r29
     a28:	cf 91       	pop	r28
     a2a:	08 95       	ret

00000a2c <DIO_u8GetPortValue>:

/* */
/* */
u8 DIO_u8GetPortValue(u8 Copy_u8PortNB, u8 *Copy_u8PortValue)
{
     a2c:	cf 93       	push	r28
     a2e:	df 93       	push	r29
     a30:	00 d0       	rcall	.+0      	; 0xa32 <DIO_u8GetPortValue+0x6>
     a32:	00 d0       	rcall	.+0      	; 0xa34 <DIO_u8GetPortValue+0x8>
     a34:	cd b7       	in	r28, 0x3d	; 61
     a36:	de b7       	in	r29, 0x3e	; 62
     a38:	8a 83       	std	Y+2, r24	; 0x02
     a3a:	7c 83       	std	Y+4, r23	; 0x04
     a3c:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     a3e:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
	if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     a40:	8a 81       	ldd	r24, Y+2	; 0x02
     a42:	84 30       	cpi	r24, 0x04	; 4
     a44:	18 f0       	brcs	.+6      	; 0xa4c <DIO_u8GetPortValue+0x20>
	{
		u8ErrorState = 1;
     a46:	81 e0       	ldi	r24, 0x01	; 1
     a48:	89 83       	std	Y+1, r24	; 0x01
     a4a:	36 c0       	rjmp	.+108    	; 0xab8 <DIO_u8GetPortValue+0x8c>
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a4c:	8a 81       	ldd	r24, Y+2	; 0x02
     a4e:	88 2f       	mov	r24, r24
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	81 30       	cpi	r24, 0x01	; 1
     a54:	91 05       	cpc	r25, r1
     a56:	a9 f0       	breq	.+42     	; 0xa82 <DIO_u8GetPortValue+0x56>
     a58:	82 30       	cpi	r24, 0x02	; 2
     a5a:	91 05       	cpc	r25, r1
     a5c:	1c f4       	brge	.+6      	; 0xa64 <DIO_u8GetPortValue+0x38>
     a5e:	89 2b       	or	r24, r25
     a60:	39 f0       	breq	.+14     	; 0xa70 <DIO_u8GetPortValue+0x44>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     a62:	2a c0       	rjmp	.+84     	; 0xab8 <DIO_u8GetPortValue+0x8c>
		u8ErrorState = 1;
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a64:	82 30       	cpi	r24, 0x02	; 2
     a66:	91 05       	cpc	r25, r1
     a68:	a9 f0       	breq	.+42     	; 0xa94 <DIO_u8GetPortValue+0x68>
     a6a:	03 97       	sbiw	r24, 0x03	; 3
     a6c:	e1 f0       	breq	.+56     	; 0xaa6 <DIO_u8GetPortValue+0x7a>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     a6e:	24 c0       	rjmp	.+72     	; 0xab8 <DIO_u8GetPortValue+0x8c>
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
		{
			case GROUP_A :
				*Copy_u8PortValue = DIO_u8_PINA->ByteAccess;
     a70:	89 e3       	ldi	r24, 0x39	; 57
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	fc 01       	movw	r30, r24
     a76:	20 81       	ld	r18, Z
     a78:	8b 81       	ldd	r24, Y+3	; 0x03
     a7a:	9c 81       	ldd	r25, Y+4	; 0x04
     a7c:	fc 01       	movw	r30, r24
     a7e:	20 83       	st	Z, r18
				break;
     a80:	1b c0       	rjmp	.+54     	; 0xab8 <DIO_u8GetPortValue+0x8c>
			case GROUP_B :
				*Copy_u8PortValue = DIO_u8_PINB->ByteAccess;
     a82:	86 e3       	ldi	r24, 0x36	; 54
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	fc 01       	movw	r30, r24
     a88:	20 81       	ld	r18, Z
     a8a:	8b 81       	ldd	r24, Y+3	; 0x03
     a8c:	9c 81       	ldd	r25, Y+4	; 0x04
     a8e:	fc 01       	movw	r30, r24
     a90:	20 83       	st	Z, r18
				break;
     a92:	12 c0       	rjmp	.+36     	; 0xab8 <DIO_u8GetPortValue+0x8c>
			case GROUP_C :
				*Copy_u8PortValue = DIO_u8_PINC->ByteAccess;
     a94:	83 e3       	ldi	r24, 0x33	; 51
     a96:	90 e0       	ldi	r25, 0x00	; 0
     a98:	fc 01       	movw	r30, r24
     a9a:	20 81       	ld	r18, Z
     a9c:	8b 81       	ldd	r24, Y+3	; 0x03
     a9e:	9c 81       	ldd	r25, Y+4	; 0x04
     aa0:	fc 01       	movw	r30, r24
     aa2:	20 83       	st	Z, r18
				break;
     aa4:	09 c0       	rjmp	.+18     	; 0xab8 <DIO_u8GetPortValue+0x8c>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
     aa6:	80 e3       	ldi	r24, 0x30	; 48
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	fc 01       	movw	r30, r24
     aac:	20 81       	ld	r18, Z
     aae:	8b 81       	ldd	r24, Y+3	; 0x03
     ab0:	9c 81       	ldd	r25, Y+4	; 0x04
     ab2:	fc 01       	movw	r30, r24
     ab4:	20 83       	st	Z, r18
				break;
     ab6:	00 00       	nop
				break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     ab8:	89 81       	ldd	r24, Y+1	; 0x01
}
     aba:	0f 90       	pop	r0
     abc:	0f 90       	pop	r0
     abe:	0f 90       	pop	r0
     ac0:	0f 90       	pop	r0
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	08 95       	ret

00000ac8 <KBD_u8GetKeyPadState>:
#include "KBD_interface.h"
#include "KBD_private.h"


u8 KBD_u8GetKeyPadState(u8* Copy_Au8KeysState/*[KBD_u8_KEYS_NB]*/)
{
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	cd b7       	in	r28, 0x3d	; 61
     ace:	de b7       	in	r29, 0x3e	; 62
     ad0:	27 97       	sbiw	r28, 0x07	; 7
     ad2:	0f b6       	in	r0, 0x3f	; 63
     ad4:	f8 94       	cli
     ad6:	de bf       	out	0x3e, r29	; 62
     ad8:	0f be       	out	0x3f, r0	; 63
     ada:	cd bf       	out	0x3d, r28	; 61
     adc:	9f 83       	std	Y+7, r25	; 0x07
     ade:	8e 83       	std	Y+6, r24	; 0x06
	u8 LOCAL_u8ColIndex = 0;
     ae0:	19 82       	std	Y+1, r1	; 0x01
	u8 LOCAL_u8RowIndex = 0;
     ae2:	1a 82       	std	Y+2, r1	; 0x02
	
	u8 Local_u8CurrentPinValue=0;
     ae4:	1d 82       	std	Y+5, r1	; 0x05
	u8 Local_u8KeyIndex=0;
     ae6:	1c 82       	std	Y+4, r1	; 0x04
	u8 pressed = 0xff;
     ae8:	8f ef       	ldi	r24, 0xFF	; 255
     aea:	8b 83       	std	Y+3, r24	; 0x03
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     aec:	19 82       	std	Y+1, r1	; 0x01
     aee:	52 c0       	rjmp	.+164    	; 0xb94 <KBD_u8GetKeyPadState+0xcc>
		{
			//activate current col
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	88 2f       	mov	r24, r24
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	80 5f       	subi	r24, 0xF0	; 240
     af8:	98 4f       	sbci	r25, 0xF8	; 248
     afa:	fc 01       	movw	r30, r24
     afc:	80 81       	ld	r24, Z
     afe:	60 e0       	ldi	r22, 0x00	; 0
     b00:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     b04:	1a 82       	std	Y+2, r1	; 0x02
     b06:	36 c0       	rjmp	.+108    	; 0xb74 <KBD_u8GetKeyPadState+0xac>
			{
				DIO_u8GetPinValue(KBD_Au8RowsPins[LOCAL_u8RowIndex], &Local_u8CurrentPinValue);
     b08:	8a 81       	ldd	r24, Y+2	; 0x02
     b0a:	88 2f       	mov	r24, r24
     b0c:	90 e0       	ldi	r25, 0x00	; 0
     b0e:	8c 5e       	subi	r24, 0xEC	; 236
     b10:	98 4f       	sbci	r25, 0xF8	; 248
     b12:	fc 01       	movw	r30, r24
     b14:	20 81       	ld	r18, Z
     b16:	ce 01       	movw	r24, r28
     b18:	05 96       	adiw	r24, 0x05	; 5
     b1a:	bc 01       	movw	r22, r24
     b1c:	82 2f       	mov	r24, r18
     b1e:	0e 94 8c 04 	call	0x918	; 0x918 <DIO_u8GetPinValue>
				
				Local_u8KeyIndex = LOCAL_u8ColIndex + (LOCAL_u8RowIndex*KBD_u8_COL);
     b22:	8a 81       	ldd	r24, Y+2	; 0x02
     b24:	98 2f       	mov	r25, r24
     b26:	99 0f       	add	r25, r25
     b28:	99 0f       	add	r25, r25
     b2a:	89 81       	ldd	r24, Y+1	; 0x01
     b2c:	89 0f       	add	r24, r25
     b2e:	8c 83       	std	Y+4, r24	; 0x04
				
				if(Local_u8CurrentPinValue == DIO_u8_HIGH)
     b30:	8d 81       	ldd	r24, Y+5	; 0x05
     b32:	81 30       	cpi	r24, 0x01	; 1
     b34:	51 f4       	brne	.+20     	; 0xb4a <KBD_u8GetKeyPadState+0x82>
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Not Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
     b36:	8c 81       	ldd	r24, Y+4	; 0x04
     b38:	88 2f       	mov	r24, r24
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	2e 81       	ldd	r18, Y+6	; 0x06
     b3e:	3f 81       	ldd	r19, Y+7	; 0x07
     b40:	82 0f       	add	r24, r18
     b42:	93 1f       	adc	r25, r19
     b44:	fc 01       	movw	r30, r24
     b46:	10 82       	st	Z, r1
     b48:	12 c0       	rjmp	.+36     	; 0xb6e <KBD_u8GetKeyPadState+0xa6>
					#endif
				}else
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_PRESSED;
     b4a:	8c 81       	ldd	r24, Y+4	; 0x04
     b4c:	88 2f       	mov	r24, r24
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	2e 81       	ldd	r18, Y+6	; 0x06
     b52:	3f 81       	ldd	r19, Y+7	; 0x07
     b54:	82 0f       	add	r24, r18
     b56:	93 1f       	adc	r25, r19
     b58:	21 e0       	ldi	r18, 0x01	; 1
     b5a:	fc 01       	movw	r30, r24
     b5c:	20 83       	st	Z, r18
						pressed = key_map[Local_u8KeyIndex];
     b5e:	8c 81       	ldd	r24, Y+4	; 0x04
     b60:	88 2f       	mov	r24, r24
     b62:	90 e0       	ldi	r25, 0x00	; 0
     b64:	8f 59       	subi	r24, 0x9F	; 159
     b66:	9f 4f       	sbci	r25, 0xFF	; 255
     b68:	fc 01       	movw	r30, r24
     b6a:	80 81       	ld	r24, Z
     b6c:	8b 83       	std	Y+3, r24	; 0x03
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     b6e:	8a 81       	ldd	r24, Y+2	; 0x02
     b70:	8f 5f       	subi	r24, 0xFF	; 255
     b72:	8a 83       	std	Y+2, r24	; 0x02
     b74:	8a 81       	ldd	r24, Y+2	; 0x02
     b76:	84 30       	cpi	r24, 0x04	; 4
     b78:	38 f2       	brcs	.-114    	; 0xb08 <KBD_u8GetKeyPadState+0x40>
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
					#endif
				}
			}
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
     b7a:	89 81       	ldd	r24, Y+1	; 0x01
     b7c:	88 2f       	mov	r24, r24
     b7e:	90 e0       	ldi	r25, 0x00	; 0
     b80:	80 5f       	subi	r24, 0xF0	; 240
     b82:	98 4f       	sbci	r25, 0xF8	; 248
     b84:	fc 01       	movw	r30, r24
     b86:	80 81       	ld	r24, Z
     b88:	61 e0       	ldi	r22, 0x01	; 1
     b8a:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	u8 Local_u8CurrentPinValue=0;
	u8 Local_u8KeyIndex=0;
	u8 pressed = 0xff;
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     b8e:	89 81       	ldd	r24, Y+1	; 0x01
     b90:	8f 5f       	subi	r24, 0xFF	; 255
     b92:	89 83       	std	Y+1, r24	; 0x01
     b94:	89 81       	ldd	r24, Y+1	; 0x01
     b96:	84 30       	cpi	r24, 0x04	; 4
     b98:	08 f4       	brcc	.+2      	; 0xb9c <KBD_u8GetKeyPadState+0xd4>
     b9a:	aa cf       	rjmp	.-172    	; 0xaf0 <KBD_u8GetKeyPadState+0x28>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#else
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
			#endif
		}
		return pressed;
     b9c:	8b 81       	ldd	r24, Y+3	; 0x03
			#endif
		}

	#endif

}
     b9e:	27 96       	adiw	r28, 0x07	; 7
     ba0:	0f b6       	in	r0, 0x3f	; 63
     ba2:	f8 94       	cli
     ba4:	de bf       	out	0x3e, r29	; 62
     ba6:	0f be       	out	0x3f, r0	; 63
     ba8:	cd bf       	out	0x3d, r28	; 61
     baa:	df 91       	pop	r29
     bac:	cf 91       	pop	r28
     bae:	08 95       	ret

00000bb0 <KBD_u8Initialize>:
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	cd b7       	in	r28, 0x3d	; 61
     bb6:	de b7       	in	r29, 0x3e	; 62
     bb8:	29 97       	sbiw	r28, 0x09	; 9
     bba:	0f b6       	in	r0, 0x3f	; 63
     bbc:	f8 94       	cli
     bbe:	de bf       	out	0x3e, r29	; 62
     bc0:	0f be       	out	0x3f, r0	; 63
     bc2:	cd bf       	out	0x3d, r28	; 61
     bc4:	89 87       	std	Y+9, r24	; 0x09
		switch (group_nb)
     bc6:	89 85       	ldd	r24, Y+9	; 0x09
     bc8:	88 2f       	mov	r24, r24
     bca:	90 e0       	ldi	r25, 0x00	; 0
     bcc:	81 30       	cpi	r24, 0x01	; 1
     bce:	91 05       	cpc	r25, r1
     bd0:	09 f4       	brne	.+2      	; 0xbd4 <KBD_u8Initialize+0x24>
     bd2:	42 c0       	rjmp	.+132    	; 0xc58 <KBD_u8Initialize+0xa8>
     bd4:	82 30       	cpi	r24, 0x02	; 2
     bd6:	91 05       	cpc	r25, r1
     bd8:	1c f4       	brge	.+6      	; 0xbe0 <KBD_u8Initialize+0x30>
     bda:	89 2b       	or	r24, r25
     bdc:	49 f0       	breq	.+18     	; 0xbf0 <KBD_u8Initialize+0x40>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     bde:	d8 c0       	rjmp	.+432    	; 0xd90 <KBD_u8Initialize+0x1e0>
	#endif

}
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
     be0:	82 30       	cpi	r24, 0x02	; 2
     be2:	91 05       	cpc	r25, r1
     be4:	09 f4       	brne	.+2      	; 0xbe8 <KBD_u8Initialize+0x38>
     be6:	6c c0       	rjmp	.+216    	; 0xcc0 <KBD_u8Initialize+0x110>
     be8:	03 97       	sbiw	r24, 0x03	; 3
     bea:	09 f4       	brne	.+2      	; 0xbee <KBD_u8Initialize+0x3e>
     bec:	9d c0       	rjmp	.+314    	; 0xd28 <KBD_u8Initialize+0x178>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     bee:	d0 c0       	rjmp	.+416    	; 0xd90 <KBD_u8Initialize+0x1e0>
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
		{
		case 0:
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
     bf0:	6f e0       	ldi	r22, 0x0F	; 15
     bf2:	80 e0       	ldi	r24, 0x00	; 0
     bf4:	0e 94 0c 04 	call	0x818	; 0x818 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(A4,1);
     bf8:	61 e0       	ldi	r22, 0x01	; 1
     bfa:	84 e0       	ldi	r24, 0x04	; 4
     bfc:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A5,1);
     c00:	61 e0       	ldi	r22, 0x01	; 1
     c02:	85 e0       	ldi	r24, 0x05	; 5
     c04:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A6,1);
     c08:	61 e0       	ldi	r22, 0x01	; 1
     c0a:	86 e0       	ldi	r24, 0x06	; 6
     c0c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A7,1);
     c10:	61 e0       	ldi	r22, 0x01	; 1
     c12:	87 e0       	ldi	r24, 0x07	; 7
     c14:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c18:	1a 82       	std	Y+2, r1	; 0x02
     c1a:	19 82       	std	Y+1, r1	; 0x01
     c1c:	18 c0       	rjmp	.+48     	; 0xc4e <KBD_u8Initialize+0x9e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
     c1e:	89 81       	ldd	r24, Y+1	; 0x01
     c20:	24 e0       	ldi	r18, 0x04	; 4
     c22:	28 0f       	add	r18, r24
     c24:	89 81       	ldd	r24, Y+1	; 0x01
     c26:	9a 81       	ldd	r25, Y+2	; 0x02
     c28:	8c 5e       	subi	r24, 0xEC	; 236
     c2a:	98 4f       	sbci	r25, 0xF8	; 248
     c2c:	fc 01       	movw	r30, r24
     c2e:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = A3 - i;
     c30:	89 81       	ldd	r24, Y+1	; 0x01
     c32:	93 e0       	ldi	r25, 0x03	; 3
     c34:	29 2f       	mov	r18, r25
     c36:	28 1b       	sub	r18, r24
     c38:	89 81       	ldd	r24, Y+1	; 0x01
     c3a:	9a 81       	ldd	r25, Y+2	; 0x02
     c3c:	80 5f       	subi	r24, 0xF0	; 240
     c3e:	98 4f       	sbci	r25, 0xF8	; 248
     c40:	fc 01       	movw	r30, r24
     c42:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
			DIO_u8SetPinValue(A4,1);
			DIO_u8SetPinValue(A5,1);
			DIO_u8SetPinValue(A6,1);
			DIO_u8SetPinValue(A7,1);
			for (int i=0;i<4;i++)
     c44:	89 81       	ldd	r24, Y+1	; 0x01
     c46:	9a 81       	ldd	r25, Y+2	; 0x02
     c48:	01 96       	adiw	r24, 0x01	; 1
     c4a:	9a 83       	std	Y+2, r25	; 0x02
     c4c:	89 83       	std	Y+1, r24	; 0x01
     c4e:	89 81       	ldd	r24, Y+1	; 0x01
     c50:	9a 81       	ldd	r25, Y+2	; 0x02
     c52:	04 97       	sbiw	r24, 0x04	; 4
     c54:	24 f3       	brlt	.-56     	; 0xc1e <KBD_u8Initialize+0x6e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
				KBD_Au8ColsPins[i] = A3 - i;
			}
			break;
     c56:	9c c0       	rjmp	.+312    	; 0xd90 <KBD_u8Initialize+0x1e0>
		case 1:
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
     c58:	6f e0       	ldi	r22, 0x0F	; 15
     c5a:	81 e0       	ldi	r24, 0x01	; 1
     c5c:	0e 94 0c 04 	call	0x818	; 0x818 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(B4,1);
     c60:	61 e0       	ldi	r22, 0x01	; 1
     c62:	8c e0       	ldi	r24, 0x0C	; 12
     c64:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B5,1);
     c68:	61 e0       	ldi	r22, 0x01	; 1
     c6a:	8d e0       	ldi	r24, 0x0D	; 13
     c6c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B6,1);
     c70:	61 e0       	ldi	r22, 0x01	; 1
     c72:	8e e0       	ldi	r24, 0x0E	; 14
     c74:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B7,1);
     c78:	61 e0       	ldi	r22, 0x01	; 1
     c7a:	8f e0       	ldi	r24, 0x0F	; 15
     c7c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c80:	1c 82       	std	Y+4, r1	; 0x04
     c82:	1b 82       	std	Y+3, r1	; 0x03
     c84:	18 c0       	rjmp	.+48     	; 0xcb6 <KBD_u8Initialize+0x106>
			{
				KBD_Au8RowsPins[i] = B4 + i;
     c86:	8b 81       	ldd	r24, Y+3	; 0x03
     c88:	2c e0       	ldi	r18, 0x0C	; 12
     c8a:	28 0f       	add	r18, r24
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	8c 5e       	subi	r24, 0xEC	; 236
     c92:	98 4f       	sbci	r25, 0xF8	; 248
     c94:	fc 01       	movw	r30, r24
     c96:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = B3 - i;
     c98:	8b 81       	ldd	r24, Y+3	; 0x03
     c9a:	9b e0       	ldi	r25, 0x0B	; 11
     c9c:	29 2f       	mov	r18, r25
     c9e:	28 1b       	sub	r18, r24
     ca0:	8b 81       	ldd	r24, Y+3	; 0x03
     ca2:	9c 81       	ldd	r25, Y+4	; 0x04
     ca4:	80 5f       	subi	r24, 0xF0	; 240
     ca6:	98 4f       	sbci	r25, 0xF8	; 248
     ca8:	fc 01       	movw	r30, r24
     caa:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
			DIO_u8SetPinValue(B4,1);
			DIO_u8SetPinValue(B5,1);
			DIO_u8SetPinValue(B6,1);
			DIO_u8SetPinValue(B7,1);
			for (int i=0;i<4;i++)
     cac:	8b 81       	ldd	r24, Y+3	; 0x03
     cae:	9c 81       	ldd	r25, Y+4	; 0x04
     cb0:	01 96       	adiw	r24, 0x01	; 1
     cb2:	9c 83       	std	Y+4, r25	; 0x04
     cb4:	8b 83       	std	Y+3, r24	; 0x03
     cb6:	8b 81       	ldd	r24, Y+3	; 0x03
     cb8:	9c 81       	ldd	r25, Y+4	; 0x04
     cba:	04 97       	sbiw	r24, 0x04	; 4
     cbc:	24 f3       	brlt	.-56     	; 0xc86 <KBD_u8Initialize+0xd6>
			{
				KBD_Au8RowsPins[i] = B4 + i;
				KBD_Au8ColsPins[i] = B3 - i;
			}
			break;
     cbe:	68 c0       	rjmp	.+208    	; 0xd90 <KBD_u8Initialize+0x1e0>
		case 2:
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
     cc0:	6f e0       	ldi	r22, 0x0F	; 15
     cc2:	82 e0       	ldi	r24, 0x02	; 2
     cc4:	0e 94 0c 04 	call	0x818	; 0x818 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(C4,1);
     cc8:	61 e0       	ldi	r22, 0x01	; 1
     cca:	84 e1       	ldi	r24, 0x14	; 20
     ccc:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C5,1);
     cd0:	61 e0       	ldi	r22, 0x01	; 1
     cd2:	85 e1       	ldi	r24, 0x15	; 21
     cd4:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C6,1);
     cd8:	61 e0       	ldi	r22, 0x01	; 1
     cda:	86 e1       	ldi	r24, 0x16	; 22
     cdc:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C7,1);
     ce0:	61 e0       	ldi	r22, 0x01	; 1
     ce2:	87 e1       	ldi	r24, 0x17	; 23
     ce4:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     ce8:	1e 82       	std	Y+6, r1	; 0x06
     cea:	1d 82       	std	Y+5, r1	; 0x05
     cec:	18 c0       	rjmp	.+48     	; 0xd1e <KBD_u8Initialize+0x16e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
     cee:	8d 81       	ldd	r24, Y+5	; 0x05
     cf0:	24 e1       	ldi	r18, 0x14	; 20
     cf2:	28 0f       	add	r18, r24
     cf4:	8d 81       	ldd	r24, Y+5	; 0x05
     cf6:	9e 81       	ldd	r25, Y+6	; 0x06
     cf8:	8c 5e       	subi	r24, 0xEC	; 236
     cfa:	98 4f       	sbci	r25, 0xF8	; 248
     cfc:	fc 01       	movw	r30, r24
     cfe:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = C3 - i;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	93 e1       	ldi	r25, 0x13	; 19
     d04:	29 2f       	mov	r18, r25
     d06:	28 1b       	sub	r18, r24
     d08:	8d 81       	ldd	r24, Y+5	; 0x05
     d0a:	9e 81       	ldd	r25, Y+6	; 0x06
     d0c:	80 5f       	subi	r24, 0xF0	; 240
     d0e:	98 4f       	sbci	r25, 0xF8	; 248
     d10:	fc 01       	movw	r30, r24
     d12:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
			DIO_u8SetPinValue(C4,1);
			DIO_u8SetPinValue(C5,1);
			DIO_u8SetPinValue(C6,1);
			DIO_u8SetPinValue(C7,1);
			for (int i=0;i<4;i++)
     d14:	8d 81       	ldd	r24, Y+5	; 0x05
     d16:	9e 81       	ldd	r25, Y+6	; 0x06
     d18:	01 96       	adiw	r24, 0x01	; 1
     d1a:	9e 83       	std	Y+6, r25	; 0x06
     d1c:	8d 83       	std	Y+5, r24	; 0x05
     d1e:	8d 81       	ldd	r24, Y+5	; 0x05
     d20:	9e 81       	ldd	r25, Y+6	; 0x06
     d22:	04 97       	sbiw	r24, 0x04	; 4
     d24:	24 f3       	brlt	.-56     	; 0xcee <KBD_u8Initialize+0x13e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
				KBD_Au8ColsPins[i] = C3 - i;
			}
			break;
     d26:	34 c0       	rjmp	.+104    	; 0xd90 <KBD_u8Initialize+0x1e0>
		case 3:
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
     d28:	6f e0       	ldi	r22, 0x0F	; 15
     d2a:	83 e0       	ldi	r24, 0x03	; 3
     d2c:	0e 94 0c 04 	call	0x818	; 0x818 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(D4,1);
     d30:	61 e0       	ldi	r22, 0x01	; 1
     d32:	8c e1       	ldi	r24, 0x1C	; 28
     d34:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D5,1);
     d38:	61 e0       	ldi	r22, 0x01	; 1
     d3a:	8d e1       	ldi	r24, 0x1D	; 29
     d3c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D6,1);
     d40:	61 e0       	ldi	r22, 0x01	; 1
     d42:	8e e1       	ldi	r24, 0x1E	; 30
     d44:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D7,1);
     d48:	61 e0       	ldi	r22, 0x01	; 1
     d4a:	8f e1       	ldi	r24, 0x1F	; 31
     d4c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     d50:	18 86       	std	Y+8, r1	; 0x08
     d52:	1f 82       	std	Y+7, r1	; 0x07
     d54:	18 c0       	rjmp	.+48     	; 0xd86 <KBD_u8Initialize+0x1d6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
     d56:	8f 81       	ldd	r24, Y+7	; 0x07
     d58:	2c e1       	ldi	r18, 0x1C	; 28
     d5a:	28 0f       	add	r18, r24
     d5c:	8f 81       	ldd	r24, Y+7	; 0x07
     d5e:	98 85       	ldd	r25, Y+8	; 0x08
     d60:	8c 5e       	subi	r24, 0xEC	; 236
     d62:	98 4f       	sbci	r25, 0xF8	; 248
     d64:	fc 01       	movw	r30, r24
     d66:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = D3 - i;
     d68:	8f 81       	ldd	r24, Y+7	; 0x07
     d6a:	9b e1       	ldi	r25, 0x1B	; 27
     d6c:	29 2f       	mov	r18, r25
     d6e:	28 1b       	sub	r18, r24
     d70:	8f 81       	ldd	r24, Y+7	; 0x07
     d72:	98 85       	ldd	r25, Y+8	; 0x08
     d74:	80 5f       	subi	r24, 0xF0	; 240
     d76:	98 4f       	sbci	r25, 0xF8	; 248
     d78:	fc 01       	movw	r30, r24
     d7a:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
			DIO_u8SetPinValue(D4,1);
			DIO_u8SetPinValue(D5,1);
			DIO_u8SetPinValue(D6,1);
			DIO_u8SetPinValue(D7,1);
			for (int i=0;i<4;i++)
     d7c:	8f 81       	ldd	r24, Y+7	; 0x07
     d7e:	98 85       	ldd	r25, Y+8	; 0x08
     d80:	01 96       	adiw	r24, 0x01	; 1
     d82:	98 87       	std	Y+8, r25	; 0x08
     d84:	8f 83       	std	Y+7, r24	; 0x07
     d86:	8f 81       	ldd	r24, Y+7	; 0x07
     d88:	98 85       	ldd	r25, Y+8	; 0x08
     d8a:	04 97       	sbiw	r24, 0x04	; 4
     d8c:	24 f3       	brlt	.-56     	; 0xd56 <KBD_u8Initialize+0x1a6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
     d8e:	00 00       	nop
		}
	}
     d90:	00 00       	nop
     d92:	29 96       	adiw	r28, 0x09	; 9
     d94:	0f b6       	in	r0, 0x3f	; 63
     d96:	f8 94       	cli
     d98:	de bf       	out	0x3e, r29	; 62
     d9a:	0f be       	out	0x3f, r0	; 63
     d9c:	cd bf       	out	0x3d, r28	; 61
     d9e:	df 91       	pop	r29
     da0:	cf 91       	pop	r28
     da2:	08 95       	ret

00000da4 <KBD_keys_map>:
u8 KBD_keys_map(u8* keys)
{
     da4:	cf 93       	push	r28
     da6:	df 93       	push	r29
     da8:	00 d0       	rcall	.+0      	; 0xdaa <KBD_keys_map+0x6>
     daa:	1f 92       	push	r1
     dac:	cd b7       	in	r28, 0x3d	; 61
     dae:	de b7       	in	r29, 0x3e	; 62
     db0:	9b 83       	std	Y+3, r25	; 0x03
     db2:	8a 83       	std	Y+2, r24	; 0x02
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     db4:	19 82       	std	Y+1, r1	; 0x01
     db6:	16 c0       	rjmp	.+44     	; 0xde4 <KBD_keys_map+0x40>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
     db8:	89 81       	ldd	r24, Y+1	; 0x01
     dba:	88 2f       	mov	r24, r24
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	2a 81       	ldd	r18, Y+2	; 0x02
     dc0:	3b 81       	ldd	r19, Y+3	; 0x03
     dc2:	82 0f       	add	r24, r18
     dc4:	93 1f       	adc	r25, r19
     dc6:	fc 01       	movw	r30, r24
     dc8:	80 81       	ld	r24, Z
     dca:	81 30       	cpi	r24, 0x01	; 1
     dcc:	41 f4       	brne	.+16     	; 0xdde <KBD_keys_map+0x3a>
     dce:	89 81       	ldd	r24, Y+1	; 0x01
     dd0:	88 2f       	mov	r24, r24
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	8f 59       	subi	r24, 0x9F	; 159
     dd6:	9f 4f       	sbci	r25, 0xFF	; 255
     dd8:	fc 01       	movw	r30, r24
     dda:	80 81       	ld	r24, Z
     ddc:	07 c0       	rjmp	.+14     	; 0xdec <KBD_keys_map+0x48>
		}
	}
u8 KBD_keys_map(u8* keys)
{
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     dde:	89 81       	ldd	r24, Y+1	; 0x01
     de0:	8f 5f       	subi	r24, 0xFF	; 255
     de2:	89 83       	std	Y+1, r24	; 0x01
     de4:	89 81       	ldd	r24, Y+1	; 0x01
     de6:	80 31       	cpi	r24, 0x10	; 16
     de8:	38 f3       	brcs	.-50     	; 0xdb8 <KBD_keys_map+0x14>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
    }
    return 0xff;
     dea:	8f ef       	ldi	r24, 0xFF	; 255
}
     dec:	0f 90       	pop	r0
     dee:	0f 90       	pop	r0
     df0:	0f 90       	pop	r0
     df2:	df 91       	pop	r29
     df4:	cf 91       	pop	r28
     df6:	08 95       	ret

00000df8 <LCD_Void_Write>:
#define F_CPU 8000000
#include "avr/delay.h"

static void LCD_Void_Write(u8 copy_u8_value) // the user wont use this func because only other functions will use it so the prototype will be in private.h
//and to make this func visible only in this file not on the whole project we will put static in front of it
{
     df8:	cf 93       	push	r28
     dfa:	df 93       	push	r29
     dfc:	cd b7       	in	r28, 0x3d	; 61
     dfe:	de b7       	in	r29, 0x3e	; 62
     e00:	2f 97       	sbiw	r28, 0x0f	; 15
     e02:	0f b6       	in	r0, 0x3f	; 63
     e04:	f8 94       	cli
     e06:	de bf       	out	0x3e, r29	; 62
     e08:	0f be       	out	0x3f, r0	; 63
     e0a:	cd bf       	out	0x3d, r28	; 61
     e0c:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_u8SetPinValue(LCD_u8_RW_Pin,DIO_u8_LOW);
     e0e:	60 e0       	ldi	r22, 0x00	; 0
     e10:	81 e1       	ldi	r24, 0x11	; 17
     e12:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D0_Pin,Get_Bit(copy_u8_value,0));
     e16:	8f 85       	ldd	r24, Y+15	; 0x0f
     e18:	81 70       	andi	r24, 0x01	; 1
     e1a:	68 2f       	mov	r22, r24
     e1c:	87 e0       	ldi	r24, 0x07	; 7
     e1e:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D1_Pin,Get_Bit(copy_u8_value,1));
     e22:	8f 85       	ldd	r24, Y+15	; 0x0f
     e24:	86 95       	lsr	r24
     e26:	81 70       	andi	r24, 0x01	; 1
     e28:	68 2f       	mov	r22, r24
     e2a:	86 e0       	ldi	r24, 0x06	; 6
     e2c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D2_Pin,Get_Bit(copy_u8_value,2));
     e30:	8f 85       	ldd	r24, Y+15	; 0x0f
     e32:	86 95       	lsr	r24
     e34:	86 95       	lsr	r24
     e36:	81 70       	andi	r24, 0x01	; 1
     e38:	68 2f       	mov	r22, r24
     e3a:	85 e0       	ldi	r24, 0x05	; 5
     e3c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D3_Pin,Get_Bit(copy_u8_value,3));
     e40:	8f 85       	ldd	r24, Y+15	; 0x0f
     e42:	86 95       	lsr	r24
     e44:	86 95       	lsr	r24
     e46:	86 95       	lsr	r24
     e48:	81 70       	andi	r24, 0x01	; 1
     e4a:	68 2f       	mov	r22, r24
     e4c:	84 e0       	ldi	r24, 0x04	; 4
     e4e:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D4_Pin,Get_Bit(copy_u8_value,4));
     e52:	8f 85       	ldd	r24, Y+15	; 0x0f
     e54:	82 95       	swap	r24
     e56:	8f 70       	andi	r24, 0x0F	; 15
     e58:	81 70       	andi	r24, 0x01	; 1
     e5a:	68 2f       	mov	r22, r24
     e5c:	83 e0       	ldi	r24, 0x03	; 3
     e5e:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D5_Pin,Get_Bit(copy_u8_value,5));
     e62:	8f 85       	ldd	r24, Y+15	; 0x0f
     e64:	82 95       	swap	r24
     e66:	86 95       	lsr	r24
     e68:	87 70       	andi	r24, 0x07	; 7
     e6a:	81 70       	andi	r24, 0x01	; 1
     e6c:	68 2f       	mov	r22, r24
     e6e:	82 e0       	ldi	r24, 0x02	; 2
     e70:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D6_Pin,Get_Bit(copy_u8_value,6));
     e74:	8f 85       	ldd	r24, Y+15	; 0x0f
     e76:	82 95       	swap	r24
     e78:	86 95       	lsr	r24
     e7a:	86 95       	lsr	r24
     e7c:	83 70       	andi	r24, 0x03	; 3
     e7e:	81 70       	andi	r24, 0x01	; 1
     e80:	68 2f       	mov	r22, r24
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D7_Pin,Get_Bit(copy_u8_value,7));
     e88:	8f 85       	ldd	r24, Y+15	; 0x0f
     e8a:	88 1f       	adc	r24, r24
     e8c:	88 27       	eor	r24, r24
     e8e:	88 1f       	adc	r24, r24
     e90:	68 2f       	mov	r22, r24
     e92:	80 e0       	ldi	r24, 0x00	; 0
     e94:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_HIGH);
     e98:	61 e0       	ldi	r22, 0x01	; 1
     e9a:	82 e1       	ldi	r24, 0x12	; 18
     e9c:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
     ea0:	80 e0       	ldi	r24, 0x00	; 0
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	a0 e8       	ldi	r26, 0x80	; 128
     ea6:	bf e3       	ldi	r27, 0x3F	; 63
     ea8:	89 83       	std	Y+1, r24	; 0x01
     eaa:	9a 83       	std	Y+2, r25	; 0x02
     eac:	ab 83       	std	Y+3, r26	; 0x03
     eae:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     eb0:	20 e0       	ldi	r18, 0x00	; 0
     eb2:	30 e0       	ldi	r19, 0x00	; 0
     eb4:	4a ef       	ldi	r20, 0xFA	; 250
     eb6:	54 e4       	ldi	r21, 0x44	; 68
     eb8:	69 81       	ldd	r22, Y+1	; 0x01
     eba:	7a 81       	ldd	r23, Y+2	; 0x02
     ebc:	8b 81       	ldd	r24, Y+3	; 0x03
     ebe:	9c 81       	ldd	r25, Y+4	; 0x04
     ec0:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
     ec4:	dc 01       	movw	r26, r24
     ec6:	cb 01       	movw	r24, r22
     ec8:	8d 83       	std	Y+5, r24	; 0x05
     eca:	9e 83       	std	Y+6, r25	; 0x06
     ecc:	af 83       	std	Y+7, r26	; 0x07
     ece:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     ed0:	20 e0       	ldi	r18, 0x00	; 0
     ed2:	30 e0       	ldi	r19, 0x00	; 0
     ed4:	40 e8       	ldi	r20, 0x80	; 128
     ed6:	5f e3       	ldi	r21, 0x3F	; 63
     ed8:	6d 81       	ldd	r22, Y+5	; 0x05
     eda:	7e 81       	ldd	r23, Y+6	; 0x06
     edc:	8f 81       	ldd	r24, Y+7	; 0x07
     ede:	98 85       	ldd	r25, Y+8	; 0x08
     ee0:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
     ee4:	88 23       	and	r24, r24
     ee6:	2c f4       	brge	.+10     	; 0xef2 <LCD_Void_Write+0xfa>
		__ticks = 1;
     ee8:	81 e0       	ldi	r24, 0x01	; 1
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	9a 87       	std	Y+10, r25	; 0x0a
     eee:	89 87       	std	Y+9, r24	; 0x09
     ef0:	3f c0       	rjmp	.+126    	; 0xf70 <LCD_Void_Write+0x178>
	else if (__tmp > 65535)
     ef2:	20 e0       	ldi	r18, 0x00	; 0
     ef4:	3f ef       	ldi	r19, 0xFF	; 255
     ef6:	4f e7       	ldi	r20, 0x7F	; 127
     ef8:	57 e4       	ldi	r21, 0x47	; 71
     efa:	6d 81       	ldd	r22, Y+5	; 0x05
     efc:	7e 81       	ldd	r23, Y+6	; 0x06
     efe:	8f 81       	ldd	r24, Y+7	; 0x07
     f00:	98 85       	ldd	r25, Y+8	; 0x08
     f02:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
     f06:	18 16       	cp	r1, r24
     f08:	4c f5       	brge	.+82     	; 0xf5c <LCD_Void_Write+0x164>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f0a:	20 e0       	ldi	r18, 0x00	; 0
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	40 e2       	ldi	r20, 0x20	; 32
     f10:	51 e4       	ldi	r21, 0x41	; 65
     f12:	69 81       	ldd	r22, Y+1	; 0x01
     f14:	7a 81       	ldd	r23, Y+2	; 0x02
     f16:	8b 81       	ldd	r24, Y+3	; 0x03
     f18:	9c 81       	ldd	r25, Y+4	; 0x04
     f1a:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
     f1e:	dc 01       	movw	r26, r24
     f20:	cb 01       	movw	r24, r22
     f22:	bc 01       	movw	r22, r24
     f24:	cd 01       	movw	r24, r26
     f26:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
     f2a:	dc 01       	movw	r26, r24
     f2c:	cb 01       	movw	r24, r22
     f2e:	9a 87       	std	Y+10, r25	; 0x0a
     f30:	89 87       	std	Y+9, r24	; 0x09
     f32:	0f c0       	rjmp	.+30     	; 0xf52 <LCD_Void_Write+0x15a>
     f34:	88 ec       	ldi	r24, 0xC8	; 200
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	9c 87       	std	Y+12, r25	; 0x0c
     f3a:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     f3c:	8b 85       	ldd	r24, Y+11	; 0x0b
     f3e:	9c 85       	ldd	r25, Y+12	; 0x0c
     f40:	01 97       	sbiw	r24, 0x01	; 1
     f42:	f1 f7       	brne	.-4      	; 0xf40 <LCD_Void_Write+0x148>
     f44:	9c 87       	std	Y+12, r25	; 0x0c
     f46:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f48:	89 85       	ldd	r24, Y+9	; 0x09
     f4a:	9a 85       	ldd	r25, Y+10	; 0x0a
     f4c:	01 97       	sbiw	r24, 0x01	; 1
     f4e:	9a 87       	std	Y+10, r25	; 0x0a
     f50:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f52:	89 85       	ldd	r24, Y+9	; 0x09
     f54:	9a 85       	ldd	r25, Y+10	; 0x0a
     f56:	89 2b       	or	r24, r25
     f58:	69 f7       	brne	.-38     	; 0xf34 <LCD_Void_Write+0x13c>
     f5a:	14 c0       	rjmp	.+40     	; 0xf84 <LCD_Void_Write+0x18c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f5c:	6d 81       	ldd	r22, Y+5	; 0x05
     f5e:	7e 81       	ldd	r23, Y+6	; 0x06
     f60:	8f 81       	ldd	r24, Y+7	; 0x07
     f62:	98 85       	ldd	r25, Y+8	; 0x08
     f64:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
     f68:	dc 01       	movw	r26, r24
     f6a:	cb 01       	movw	r24, r22
     f6c:	9a 87       	std	Y+10, r25	; 0x0a
     f6e:	89 87       	std	Y+9, r24	; 0x09
     f70:	89 85       	ldd	r24, Y+9	; 0x09
     f72:	9a 85       	ldd	r25, Y+10	; 0x0a
     f74:	9e 87       	std	Y+14, r25	; 0x0e
     f76:	8d 87       	std	Y+13, r24	; 0x0d
     f78:	8d 85       	ldd	r24, Y+13	; 0x0d
     f7a:	9e 85       	ldd	r25, Y+14	; 0x0e
     f7c:	01 97       	sbiw	r24, 0x01	; 1
     f7e:	f1 f7       	brne	.-4      	; 0xf7c <LCD_Void_Write+0x184>
     f80:	9e 87       	std	Y+14, r25	; 0x0e
     f82:	8d 87       	std	Y+13, r24	; 0x0d
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_LOW);
     f84:	60 e0       	ldi	r22, 0x00	; 0
     f86:	82 e1       	ldi	r24, 0x12	; 18
     f88:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
}
     f8c:	00 00       	nop
     f8e:	2f 96       	adiw	r28, 0x0f	; 15
     f90:	0f b6       	in	r0, 0x3f	; 63
     f92:	f8 94       	cli
     f94:	de bf       	out	0x3e, r29	; 62
     f96:	0f be       	out	0x3f, r0	; 63
     f98:	cd bf       	out	0x3d, r28	; 61
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	08 95       	ret

00000fa0 <LCD_Void_Write_Cmd>:

void LCD_Void_Write_Cmd(u8 copy_u8_cmd)
{
     fa0:	cf 93       	push	r28
     fa2:	df 93       	push	r29
     fa4:	1f 92       	push	r1
     fa6:	cd b7       	in	r28, 0x3d	; 61
     fa8:	de b7       	in	r29, 0x3e	; 62
     faa:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue (LCD_u8_RS_Pin,DIO_u8_LOW);
     fac:	60 e0       	ldi	r22, 0x00	; 0
     fae:	80 e1       	ldi	r24, 0x10	; 16
     fb0:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_cmd);
     fb4:	89 81       	ldd	r24, Y+1	; 0x01
     fb6:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <LCD_Void_Write>
}
     fba:	00 00       	nop
     fbc:	0f 90       	pop	r0
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	08 95       	ret

00000fc4 <LCD_Void_Write_Data>:

void LCD_Void_Write_Data(u8 copy_u8_data)
{
     fc4:	cf 93       	push	r28
     fc6:	df 93       	push	r29
     fc8:	1f 92       	push	r1
     fca:	cd b7       	in	r28, 0x3d	; 61
     fcc:	de b7       	in	r29, 0x3e	; 62
     fce:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue(LCD_u8_RS_Pin,DIO_u8_HIGH);
     fd0:	61 e0       	ldi	r22, 0x01	; 1
     fd2:	80 e1       	ldi	r24, 0x10	; 16
     fd4:	0e 94 16 03 	call	0x62c	; 0x62c <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_data);
     fd8:	89 81       	ldd	r24, Y+1	; 0x01
     fda:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <LCD_Void_Write>
}
     fde:	00 00       	nop
     fe0:	0f 90       	pop	r0
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	08 95       	ret

00000fe8 <LCD_initialize>:


void LCD_initialize(void)
{
     fe8:	0f 93       	push	r16
     fea:	1f 93       	push	r17
     fec:	cf 93       	push	r28
     fee:	df 93       	push	r29
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	ca 56       	subi	r28, 0x6A	; 106
     ff6:	d1 09       	sbc	r29, r1
     ff8:	0f b6       	in	r0, 0x3f	; 63
     ffa:	f8 94       	cli
     ffc:	de bf       	out	0x3e, r29	; 62
     ffe:	0f be       	out	0x3f, r0	; 63
    1000:	cd bf       	out	0x3d, r28	; 61
	DIO_u8SetPinDirection(LCD_u8_RS_Pin,1);
    1002:	61 e0       	ldi	r22, 0x01	; 1
    1004:	80 e1       	ldi	r24, 0x10	; 16
    1006:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_RW_Pin,1);
    100a:	61 e0       	ldi	r22, 0x01	; 1
    100c:	81 e1       	ldi	r24, 0x11	; 17
    100e:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_E_Pin,1);
    1012:	61 e0       	ldi	r22, 0x01	; 1
    1014:	82 e1       	ldi	r24, 0x12	; 18
    1016:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D0_Pin,1);
    101a:	61 e0       	ldi	r22, 0x01	; 1
    101c:	87 e0       	ldi	r24, 0x07	; 7
    101e:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D1_Pin,1);
    1022:	61 e0       	ldi	r22, 0x01	; 1
    1024:	86 e0       	ldi	r24, 0x06	; 6
    1026:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D2_Pin,1);
    102a:	61 e0       	ldi	r22, 0x01	; 1
    102c:	85 e0       	ldi	r24, 0x05	; 5
    102e:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D3_Pin,1);
    1032:	61 e0       	ldi	r22, 0x01	; 1
    1034:	84 e0       	ldi	r24, 0x04	; 4
    1036:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D4_Pin,1);
    103a:	61 e0       	ldi	r22, 0x01	; 1
    103c:	83 e0       	ldi	r24, 0x03	; 3
    103e:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D5_Pin,1);
    1042:	61 e0       	ldi	r22, 0x01	; 1
    1044:	82 e0       	ldi	r24, 0x02	; 2
    1046:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D6_Pin,1);
    104a:	61 e0       	ldi	r22, 0x01	; 1
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D7_Pin,1);
    1052:	61 e0       	ldi	r22, 0x01	; 1
    1054:	80 e0       	ldi	r24, 0x00	; 0
    1056:	0e 94 20 02 	call	0x440	; 0x440 <DIO_u8SetPinDirection>
    105a:	80 e0       	ldi	r24, 0x00	; 0
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	a8 e4       	ldi	r26, 0x48	; 72
    1060:	b2 e4       	ldi	r27, 0x42	; 66
    1062:	89 83       	std	Y+1, r24	; 0x01
    1064:	9a 83       	std	Y+2, r25	; 0x02
    1066:	ab 83       	std	Y+3, r26	; 0x03
    1068:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    106a:	8e 01       	movw	r16, r28
    106c:	0f 59       	subi	r16, 0x9F	; 159
    106e:	1f 4f       	sbci	r17, 0xFF	; 255
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	4a ef       	ldi	r20, 0xFA	; 250
    1076:	54 e4       	ldi	r21, 0x44	; 68
    1078:	69 81       	ldd	r22, Y+1	; 0x01
    107a:	7a 81       	ldd	r23, Y+2	; 0x02
    107c:	8b 81       	ldd	r24, Y+3	; 0x03
    107e:	9c 81       	ldd	r25, Y+4	; 0x04
    1080:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    1084:	dc 01       	movw	r26, r24
    1086:	cb 01       	movw	r24, r22
    1088:	f8 01       	movw	r30, r16
    108a:	80 83       	st	Z, r24
    108c:	91 83       	std	Z+1, r25	; 0x01
    108e:	a2 83       	std	Z+2, r26	; 0x02
    1090:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1092:	ce 01       	movw	r24, r28
    1094:	8f 59       	subi	r24, 0x9F	; 159
    1096:	9f 4f       	sbci	r25, 0xFF	; 255
    1098:	20 e0       	ldi	r18, 0x00	; 0
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	40 e8       	ldi	r20, 0x80	; 128
    109e:	5f e3       	ldi	r21, 0x3F	; 63
    10a0:	fc 01       	movw	r30, r24
    10a2:	60 81       	ld	r22, Z
    10a4:	71 81       	ldd	r23, Z+1	; 0x01
    10a6:	82 81       	ldd	r24, Z+2	; 0x02
    10a8:	93 81       	ldd	r25, Z+3	; 0x03
    10aa:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    10ae:	88 23       	and	r24, r24
    10b0:	4c f4       	brge	.+18     	; 0x10c4 <LCD_initialize+0xdc>
		__ticks = 1;
    10b2:	ce 01       	movw	r24, r28
    10b4:	8b 59       	subi	r24, 0x9B	; 155
    10b6:	9f 4f       	sbci	r25, 0xFF	; 255
    10b8:	21 e0       	ldi	r18, 0x01	; 1
    10ba:	30 e0       	ldi	r19, 0x00	; 0
    10bc:	fc 01       	movw	r30, r24
    10be:	31 83       	std	Z+1, r19	; 0x01
    10c0:	20 83       	st	Z, r18
    10c2:	69 c0       	rjmp	.+210    	; 0x1196 <LCD_initialize+0x1ae>
	else if (__tmp > 65535)
    10c4:	ce 01       	movw	r24, r28
    10c6:	8f 59       	subi	r24, 0x9F	; 159
    10c8:	9f 4f       	sbci	r25, 0xFF	; 255
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	3f ef       	ldi	r19, 0xFF	; 255
    10ce:	4f e7       	ldi	r20, 0x7F	; 127
    10d0:	57 e4       	ldi	r21, 0x47	; 71
    10d2:	fc 01       	movw	r30, r24
    10d4:	60 81       	ld	r22, Z
    10d6:	71 81       	ldd	r23, Z+1	; 0x01
    10d8:	82 81       	ldd	r24, Z+2	; 0x02
    10da:	93 81       	ldd	r25, Z+3	; 0x03
    10dc:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    10e0:	18 16       	cp	r1, r24
    10e2:	0c f0       	brlt	.+2      	; 0x10e6 <LCD_initialize+0xfe>
    10e4:	46 c0       	rjmp	.+140    	; 0x1172 <LCD_initialize+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10e6:	20 e0       	ldi	r18, 0x00	; 0
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	40 e2       	ldi	r20, 0x20	; 32
    10ec:	51 e4       	ldi	r21, 0x41	; 65
    10ee:	69 81       	ldd	r22, Y+1	; 0x01
    10f0:	7a 81       	ldd	r23, Y+2	; 0x02
    10f2:	8b 81       	ldd	r24, Y+3	; 0x03
    10f4:	9c 81       	ldd	r25, Y+4	; 0x04
    10f6:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    10fa:	dc 01       	movw	r26, r24
    10fc:	cb 01       	movw	r24, r22
    10fe:	8e 01       	movw	r16, r28
    1100:	0b 59       	subi	r16, 0x9B	; 155
    1102:	1f 4f       	sbci	r17, 0xFF	; 255
    1104:	bc 01       	movw	r22, r24
    1106:	cd 01       	movw	r24, r26
    1108:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    110c:	dc 01       	movw	r26, r24
    110e:	cb 01       	movw	r24, r22
    1110:	f8 01       	movw	r30, r16
    1112:	91 83       	std	Z+1, r25	; 0x01
    1114:	80 83       	st	Z, r24
    1116:	24 c0       	rjmp	.+72     	; 0x1160 <LCD_initialize+0x178>
    1118:	ce 01       	movw	r24, r28
    111a:	89 59       	subi	r24, 0x99	; 153
    111c:	9f 4f       	sbci	r25, 0xFF	; 255
    111e:	28 ec       	ldi	r18, 0xC8	; 200
    1120:	30 e0       	ldi	r19, 0x00	; 0
    1122:	fc 01       	movw	r30, r24
    1124:	31 83       	std	Z+1, r19	; 0x01
    1126:	20 83       	st	Z, r18
    1128:	ce 01       	movw	r24, r28
    112a:	89 59       	subi	r24, 0x99	; 153
    112c:	9f 4f       	sbci	r25, 0xFF	; 255
    112e:	fc 01       	movw	r30, r24
    1130:	80 81       	ld	r24, Z
    1132:	91 81       	ldd	r25, Z+1	; 0x01
    1134:	01 97       	sbiw	r24, 0x01	; 1
    1136:	f1 f7       	brne	.-4      	; 0x1134 <LCD_initialize+0x14c>
    1138:	9e 01       	movw	r18, r28
    113a:	29 59       	subi	r18, 0x99	; 153
    113c:	3f 4f       	sbci	r19, 0xFF	; 255
    113e:	f9 01       	movw	r30, r18
    1140:	91 83       	std	Z+1, r25	; 0x01
    1142:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1144:	ce 01       	movw	r24, r28
    1146:	8b 59       	subi	r24, 0x9B	; 155
    1148:	9f 4f       	sbci	r25, 0xFF	; 255
    114a:	9e 01       	movw	r18, r28
    114c:	2b 59       	subi	r18, 0x9B	; 155
    114e:	3f 4f       	sbci	r19, 0xFF	; 255
    1150:	f9 01       	movw	r30, r18
    1152:	20 81       	ld	r18, Z
    1154:	31 81       	ldd	r19, Z+1	; 0x01
    1156:	21 50       	subi	r18, 0x01	; 1
    1158:	31 09       	sbc	r19, r1
    115a:	fc 01       	movw	r30, r24
    115c:	31 83       	std	Z+1, r19	; 0x01
    115e:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1160:	ce 01       	movw	r24, r28
    1162:	8b 59       	subi	r24, 0x9B	; 155
    1164:	9f 4f       	sbci	r25, 0xFF	; 255
    1166:	fc 01       	movw	r30, r24
    1168:	80 81       	ld	r24, Z
    116a:	91 81       	ldd	r25, Z+1	; 0x01
    116c:	89 2b       	or	r24, r25
    116e:	a1 f6       	brne	.-88     	; 0x1118 <LCD_initialize+0x130>
    1170:	2c c0       	rjmp	.+88     	; 0x11ca <LCD_initialize+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1172:	8e 01       	movw	r16, r28
    1174:	0b 59       	subi	r16, 0x9B	; 155
    1176:	1f 4f       	sbci	r17, 0xFF	; 255
    1178:	ce 01       	movw	r24, r28
    117a:	8f 59       	subi	r24, 0x9F	; 159
    117c:	9f 4f       	sbci	r25, 0xFF	; 255
    117e:	fc 01       	movw	r30, r24
    1180:	60 81       	ld	r22, Z
    1182:	71 81       	ldd	r23, Z+1	; 0x01
    1184:	82 81       	ldd	r24, Z+2	; 0x02
    1186:	93 81       	ldd	r25, Z+3	; 0x03
    1188:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    118c:	dc 01       	movw	r26, r24
    118e:	cb 01       	movw	r24, r22
    1190:	f8 01       	movw	r30, r16
    1192:	91 83       	std	Z+1, r25	; 0x01
    1194:	80 83       	st	Z, r24
    1196:	ce 01       	movw	r24, r28
    1198:	87 59       	subi	r24, 0x97	; 151
    119a:	9f 4f       	sbci	r25, 0xFF	; 255
    119c:	9e 01       	movw	r18, r28
    119e:	2b 59       	subi	r18, 0x9B	; 155
    11a0:	3f 4f       	sbci	r19, 0xFF	; 255
    11a2:	f9 01       	movw	r30, r18
    11a4:	20 81       	ld	r18, Z
    11a6:	31 81       	ldd	r19, Z+1	; 0x01
    11a8:	fc 01       	movw	r30, r24
    11aa:	31 83       	std	Z+1, r19	; 0x01
    11ac:	20 83       	st	Z, r18
    11ae:	ce 01       	movw	r24, r28
    11b0:	87 59       	subi	r24, 0x97	; 151
    11b2:	9f 4f       	sbci	r25, 0xFF	; 255
    11b4:	fc 01       	movw	r30, r24
    11b6:	80 81       	ld	r24, Z
    11b8:	91 81       	ldd	r25, Z+1	; 0x01
    11ba:	01 97       	sbiw	r24, 0x01	; 1
    11bc:	f1 f7       	brne	.-4      	; 0x11ba <LCD_initialize+0x1d2>
    11be:	9e 01       	movw	r18, r28
    11c0:	27 59       	subi	r18, 0x97	; 151
    11c2:	3f 4f       	sbci	r19, 0xFF	; 255
    11c4:	f9 01       	movw	r30, r18
    11c6:	91 83       	std	Z+1, r25	; 0x01
    11c8:	80 83       	st	Z, r24
    11ca:	80 e0       	ldi	r24, 0x00	; 0
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	a0 e2       	ldi	r26, 0x20	; 32
    11d0:	b2 e4       	ldi	r27, 0x42	; 66
    11d2:	8d 83       	std	Y+5, r24	; 0x05
    11d4:	9e 83       	std	Y+6, r25	; 0x06
    11d6:	af 83       	std	Y+7, r26	; 0x07
    11d8:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    11da:	8e 01       	movw	r16, r28
    11dc:	09 5a       	subi	r16, 0xA9	; 169
    11de:	1f 4f       	sbci	r17, 0xFF	; 255
    11e0:	20 e0       	ldi	r18, 0x00	; 0
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	4a ef       	ldi	r20, 0xFA	; 250
    11e6:	54 e4       	ldi	r21, 0x44	; 68
    11e8:	6d 81       	ldd	r22, Y+5	; 0x05
    11ea:	7e 81       	ldd	r23, Y+6	; 0x06
    11ec:	8f 81       	ldd	r24, Y+7	; 0x07
    11ee:	98 85       	ldd	r25, Y+8	; 0x08
    11f0:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    11f4:	dc 01       	movw	r26, r24
    11f6:	cb 01       	movw	r24, r22
    11f8:	f8 01       	movw	r30, r16
    11fa:	80 83       	st	Z, r24
    11fc:	91 83       	std	Z+1, r25	; 0x01
    11fe:	a2 83       	std	Z+2, r26	; 0x02
    1200:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1202:	ce 01       	movw	r24, r28
    1204:	89 5a       	subi	r24, 0xA9	; 169
    1206:	9f 4f       	sbci	r25, 0xFF	; 255
    1208:	20 e0       	ldi	r18, 0x00	; 0
    120a:	30 e0       	ldi	r19, 0x00	; 0
    120c:	40 e8       	ldi	r20, 0x80	; 128
    120e:	5f e3       	ldi	r21, 0x3F	; 63
    1210:	fc 01       	movw	r30, r24
    1212:	60 81       	ld	r22, Z
    1214:	71 81       	ldd	r23, Z+1	; 0x01
    1216:	82 81       	ldd	r24, Z+2	; 0x02
    1218:	93 81       	ldd	r25, Z+3	; 0x03
    121a:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    121e:	88 23       	and	r24, r24
    1220:	4c f4       	brge	.+18     	; 0x1234 <LCD_initialize+0x24c>
		__ticks = 1;
    1222:	ce 01       	movw	r24, r28
    1224:	85 5a       	subi	r24, 0xA5	; 165
    1226:	9f 4f       	sbci	r25, 0xFF	; 255
    1228:	21 e0       	ldi	r18, 0x01	; 1
    122a:	30 e0       	ldi	r19, 0x00	; 0
    122c:	fc 01       	movw	r30, r24
    122e:	31 83       	std	Z+1, r19	; 0x01
    1230:	20 83       	st	Z, r18
    1232:	69 c0       	rjmp	.+210    	; 0x1306 <LCD_initialize+0x31e>
	else if (__tmp > 65535)
    1234:	ce 01       	movw	r24, r28
    1236:	89 5a       	subi	r24, 0xA9	; 169
    1238:	9f 4f       	sbci	r25, 0xFF	; 255
    123a:	20 e0       	ldi	r18, 0x00	; 0
    123c:	3f ef       	ldi	r19, 0xFF	; 255
    123e:	4f e7       	ldi	r20, 0x7F	; 127
    1240:	57 e4       	ldi	r21, 0x47	; 71
    1242:	fc 01       	movw	r30, r24
    1244:	60 81       	ld	r22, Z
    1246:	71 81       	ldd	r23, Z+1	; 0x01
    1248:	82 81       	ldd	r24, Z+2	; 0x02
    124a:	93 81       	ldd	r25, Z+3	; 0x03
    124c:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    1250:	18 16       	cp	r1, r24
    1252:	0c f0       	brlt	.+2      	; 0x1256 <LCD_initialize+0x26e>
    1254:	46 c0       	rjmp	.+140    	; 0x12e2 <LCD_initialize+0x2fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1256:	20 e0       	ldi	r18, 0x00	; 0
    1258:	30 e0       	ldi	r19, 0x00	; 0
    125a:	40 e2       	ldi	r20, 0x20	; 32
    125c:	51 e4       	ldi	r21, 0x41	; 65
    125e:	6d 81       	ldd	r22, Y+5	; 0x05
    1260:	7e 81       	ldd	r23, Y+6	; 0x06
    1262:	8f 81       	ldd	r24, Y+7	; 0x07
    1264:	98 85       	ldd	r25, Y+8	; 0x08
    1266:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    126a:	dc 01       	movw	r26, r24
    126c:	cb 01       	movw	r24, r22
    126e:	8e 01       	movw	r16, r28
    1270:	05 5a       	subi	r16, 0xA5	; 165
    1272:	1f 4f       	sbci	r17, 0xFF	; 255
    1274:	bc 01       	movw	r22, r24
    1276:	cd 01       	movw	r24, r26
    1278:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    127c:	dc 01       	movw	r26, r24
    127e:	cb 01       	movw	r24, r22
    1280:	f8 01       	movw	r30, r16
    1282:	91 83       	std	Z+1, r25	; 0x01
    1284:	80 83       	st	Z, r24
    1286:	24 c0       	rjmp	.+72     	; 0x12d0 <LCD_initialize+0x2e8>
    1288:	ce 01       	movw	r24, r28
    128a:	83 5a       	subi	r24, 0xA3	; 163
    128c:	9f 4f       	sbci	r25, 0xFF	; 255
    128e:	28 ec       	ldi	r18, 0xC8	; 200
    1290:	30 e0       	ldi	r19, 0x00	; 0
    1292:	fc 01       	movw	r30, r24
    1294:	31 83       	std	Z+1, r19	; 0x01
    1296:	20 83       	st	Z, r18
    1298:	ce 01       	movw	r24, r28
    129a:	83 5a       	subi	r24, 0xA3	; 163
    129c:	9f 4f       	sbci	r25, 0xFF	; 255
    129e:	fc 01       	movw	r30, r24
    12a0:	80 81       	ld	r24, Z
    12a2:	91 81       	ldd	r25, Z+1	; 0x01
    12a4:	01 97       	sbiw	r24, 0x01	; 1
    12a6:	f1 f7       	brne	.-4      	; 0x12a4 <LCD_initialize+0x2bc>
    12a8:	9e 01       	movw	r18, r28
    12aa:	23 5a       	subi	r18, 0xA3	; 163
    12ac:	3f 4f       	sbci	r19, 0xFF	; 255
    12ae:	f9 01       	movw	r30, r18
    12b0:	91 83       	std	Z+1, r25	; 0x01
    12b2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12b4:	ce 01       	movw	r24, r28
    12b6:	85 5a       	subi	r24, 0xA5	; 165
    12b8:	9f 4f       	sbci	r25, 0xFF	; 255
    12ba:	9e 01       	movw	r18, r28
    12bc:	25 5a       	subi	r18, 0xA5	; 165
    12be:	3f 4f       	sbci	r19, 0xFF	; 255
    12c0:	f9 01       	movw	r30, r18
    12c2:	20 81       	ld	r18, Z
    12c4:	31 81       	ldd	r19, Z+1	; 0x01
    12c6:	21 50       	subi	r18, 0x01	; 1
    12c8:	31 09       	sbc	r19, r1
    12ca:	fc 01       	movw	r30, r24
    12cc:	31 83       	std	Z+1, r19	; 0x01
    12ce:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12d0:	ce 01       	movw	r24, r28
    12d2:	85 5a       	subi	r24, 0xA5	; 165
    12d4:	9f 4f       	sbci	r25, 0xFF	; 255
    12d6:	fc 01       	movw	r30, r24
    12d8:	80 81       	ld	r24, Z
    12da:	91 81       	ldd	r25, Z+1	; 0x01
    12dc:	89 2b       	or	r24, r25
    12de:	a1 f6       	brne	.-88     	; 0x1288 <LCD_initialize+0x2a0>
    12e0:	2c c0       	rjmp	.+88     	; 0x133a <LCD_initialize+0x352>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    12e2:	8e 01       	movw	r16, r28
    12e4:	05 5a       	subi	r16, 0xA5	; 165
    12e6:	1f 4f       	sbci	r17, 0xFF	; 255
    12e8:	ce 01       	movw	r24, r28
    12ea:	89 5a       	subi	r24, 0xA9	; 169
    12ec:	9f 4f       	sbci	r25, 0xFF	; 255
    12ee:	fc 01       	movw	r30, r24
    12f0:	60 81       	ld	r22, Z
    12f2:	71 81       	ldd	r23, Z+1	; 0x01
    12f4:	82 81       	ldd	r24, Z+2	; 0x02
    12f6:	93 81       	ldd	r25, Z+3	; 0x03
    12f8:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    12fc:	dc 01       	movw	r26, r24
    12fe:	cb 01       	movw	r24, r22
    1300:	f8 01       	movw	r30, r16
    1302:	91 83       	std	Z+1, r25	; 0x01
    1304:	80 83       	st	Z, r24
    1306:	ce 01       	movw	r24, r28
    1308:	81 5a       	subi	r24, 0xA1	; 161
    130a:	9f 4f       	sbci	r25, 0xFF	; 255
    130c:	9e 01       	movw	r18, r28
    130e:	25 5a       	subi	r18, 0xA5	; 165
    1310:	3f 4f       	sbci	r19, 0xFF	; 255
    1312:	f9 01       	movw	r30, r18
    1314:	20 81       	ld	r18, Z
    1316:	31 81       	ldd	r19, Z+1	; 0x01
    1318:	fc 01       	movw	r30, r24
    131a:	31 83       	std	Z+1, r19	; 0x01
    131c:	20 83       	st	Z, r18
    131e:	ce 01       	movw	r24, r28
    1320:	81 5a       	subi	r24, 0xA1	; 161
    1322:	9f 4f       	sbci	r25, 0xFF	; 255
    1324:	fc 01       	movw	r30, r24
    1326:	80 81       	ld	r24, Z
    1328:	91 81       	ldd	r25, Z+1	; 0x01
    132a:	01 97       	sbiw	r24, 0x01	; 1
    132c:	f1 f7       	brne	.-4      	; 0x132a <LCD_initialize+0x342>
    132e:	9e 01       	movw	r18, r28
    1330:	21 5a       	subi	r18, 0xA1	; 161
    1332:	3f 4f       	sbci	r19, 0xFF	; 255
    1334:	f9 01       	movw	r30, r18
    1336:	91 83       	std	Z+1, r25	; 0x01
    1338:	80 83       	st	Z, r24
	_delay_ms(50);
	_delay_ms(40);
	LCD_Void_Write_Cmd(0b00111000);
    133a:	88 e3       	ldi	r24, 0x38	; 56
    133c:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
    1340:	80 e0       	ldi	r24, 0x00	; 0
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	a8 e4       	ldi	r26, 0x48	; 72
    1346:	b2 e4       	ldi	r27, 0x42	; 66
    1348:	89 87       	std	Y+9, r24	; 0x09
    134a:	9a 87       	std	Y+10, r25	; 0x0a
    134c:	ab 87       	std	Y+11, r26	; 0x0b
    134e:	bc 87       	std	Y+12, r27	; 0x0c
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    1350:	2b ea       	ldi	r18, 0xAB	; 171
    1352:	3a ea       	ldi	r19, 0xAA	; 170
    1354:	4a e2       	ldi	r20, 0x2A	; 42
    1356:	50 e4       	ldi	r21, 0x40	; 64
    1358:	69 85       	ldd	r22, Y+9	; 0x09
    135a:	7a 85       	ldd	r23, Y+10	; 0x0a
    135c:	8b 85       	ldd	r24, Y+11	; 0x0b
    135e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1360:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    1364:	dc 01       	movw	r26, r24
    1366:	cb 01       	movw	r24, r22
    1368:	8b af       	std	Y+59, r24	; 0x3b
    136a:	9c af       	std	Y+60, r25	; 0x3c
    136c:	ad af       	std	Y+61, r26	; 0x3d
    136e:	be af       	std	Y+62, r27	; 0x3e
	__tmp2 = ((F_CPU) / 4e6) * __us;
    1370:	8e 01       	movw	r16, r28
    1372:	01 5c       	subi	r16, 0xC1	; 193
    1374:	1f 4f       	sbci	r17, 0xFF	; 255
    1376:	89 85       	ldd	r24, Y+9	; 0x09
    1378:	9a 85       	ldd	r25, Y+10	; 0x0a
    137a:	ab 85       	ldd	r26, Y+11	; 0x0b
    137c:	bc 85       	ldd	r27, Y+12	; 0x0c
    137e:	9c 01       	movw	r18, r24
    1380:	ad 01       	movw	r20, r26
    1382:	bc 01       	movw	r22, r24
    1384:	cd 01       	movw	r24, r26
    1386:	0e 94 17 30 	call	0x602e	; 0x602e <__addsf3>
    138a:	dc 01       	movw	r26, r24
    138c:	cb 01       	movw	r24, r22
    138e:	f8 01       	movw	r30, r16
    1390:	80 83       	st	Z, r24
    1392:	91 83       	std	Z+1, r25	; 0x01
    1394:	a2 83       	std	Z+2, r26	; 0x02
    1396:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1398:	20 e0       	ldi	r18, 0x00	; 0
    139a:	30 e0       	ldi	r19, 0x00	; 0
    139c:	40 e8       	ldi	r20, 0x80	; 128
    139e:	5f e3       	ldi	r21, 0x3F	; 63
    13a0:	6b ad       	ldd	r22, Y+59	; 0x3b
    13a2:	7c ad       	ldd	r23, Y+60	; 0x3c
    13a4:	8d ad       	ldd	r24, Y+61	; 0x3d
    13a6:	9e ad       	ldd	r25, Y+62	; 0x3e
    13a8:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    13ac:	88 23       	and	r24, r24
    13ae:	3c f4       	brge	.+14     	; 0x13be <LCD_initialize+0x3d6>
		__ticks = 1;
    13b0:	ce 01       	movw	r24, r28
    13b2:	8d 5b       	subi	r24, 0xBD	; 189
    13b4:	9f 4f       	sbci	r25, 0xFF	; 255
    13b6:	21 e0       	ldi	r18, 0x01	; 1
    13b8:	fc 01       	movw	r30, r24
    13ba:	20 83       	st	Z, r18
    13bc:	22 c1       	rjmp	.+580    	; 0x1602 <LCD_initialize+0x61a>
	else if (__tmp2 > 65535)
    13be:	ce 01       	movw	r24, r28
    13c0:	cf 96       	adiw	r24, 0x3f	; 63
    13c2:	20 e0       	ldi	r18, 0x00	; 0
    13c4:	3f ef       	ldi	r19, 0xFF	; 255
    13c6:	4f e7       	ldi	r20, 0x7F	; 127
    13c8:	57 e4       	ldi	r21, 0x47	; 71
    13ca:	fc 01       	movw	r30, r24
    13cc:	60 81       	ld	r22, Z
    13ce:	71 81       	ldd	r23, Z+1	; 0x01
    13d0:	82 81       	ldd	r24, Z+2	; 0x02
    13d2:	93 81       	ldd	r25, Z+3	; 0x03
    13d4:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    13d8:	18 16       	cp	r1, r24
    13da:	0c f0       	brlt	.+2      	; 0x13de <LCD_initialize+0x3f6>
    13dc:	cd c0       	rjmp	.+410    	; 0x1578 <LCD_initialize+0x590>
	{
		_delay_ms(__us / 1000.0);
    13de:	20 e0       	ldi	r18, 0x00	; 0
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	4a e7       	ldi	r20, 0x7A	; 122
    13e4:	54 e4       	ldi	r21, 0x44	; 68
    13e6:	69 85       	ldd	r22, Y+9	; 0x09
    13e8:	7a 85       	ldd	r23, Y+10	; 0x0a
    13ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    13ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    13ee:	0e 94 88 30 	call	0x6110	; 0x6110 <__divsf3>
    13f2:	dc 01       	movw	r26, r24
    13f4:	cb 01       	movw	r24, r22
    13f6:	9e 01       	movw	r18, r28
    13f8:	2c 5b       	subi	r18, 0xBC	; 188
    13fa:	3f 4f       	sbci	r19, 0xFF	; 255
    13fc:	f9 01       	movw	r30, r18
    13fe:	80 83       	st	Z, r24
    1400:	91 83       	std	Z+1, r25	; 0x01
    1402:	a2 83       	std	Z+2, r26	; 0x02
    1404:	b3 83       	std	Z+3, r27	; 0x03

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1406:	8e 01       	movw	r16, r28
    1408:	08 5b       	subi	r16, 0xB8	; 184
    140a:	1f 4f       	sbci	r17, 0xFF	; 255
    140c:	ce 01       	movw	r24, r28
    140e:	8c 5b       	subi	r24, 0xBC	; 188
    1410:	9f 4f       	sbci	r25, 0xFF	; 255
    1412:	20 e0       	ldi	r18, 0x00	; 0
    1414:	30 e0       	ldi	r19, 0x00	; 0
    1416:	4a ef       	ldi	r20, 0xFA	; 250
    1418:	54 e4       	ldi	r21, 0x44	; 68
    141a:	fc 01       	movw	r30, r24
    141c:	60 81       	ld	r22, Z
    141e:	71 81       	ldd	r23, Z+1	; 0x01
    1420:	82 81       	ldd	r24, Z+2	; 0x02
    1422:	93 81       	ldd	r25, Z+3	; 0x03
    1424:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    1428:	dc 01       	movw	r26, r24
    142a:	cb 01       	movw	r24, r22
    142c:	f8 01       	movw	r30, r16
    142e:	80 83       	st	Z, r24
    1430:	91 83       	std	Z+1, r25	; 0x01
    1432:	a2 83       	std	Z+2, r26	; 0x02
    1434:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1436:	ce 01       	movw	r24, r28
    1438:	88 5b       	subi	r24, 0xB8	; 184
    143a:	9f 4f       	sbci	r25, 0xFF	; 255
    143c:	20 e0       	ldi	r18, 0x00	; 0
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	40 e8       	ldi	r20, 0x80	; 128
    1442:	5f e3       	ldi	r21, 0x3F	; 63
    1444:	fc 01       	movw	r30, r24
    1446:	60 81       	ld	r22, Z
    1448:	71 81       	ldd	r23, Z+1	; 0x01
    144a:	82 81       	ldd	r24, Z+2	; 0x02
    144c:	93 81       	ldd	r25, Z+3	; 0x03
    144e:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    1452:	88 23       	and	r24, r24
    1454:	4c f4       	brge	.+18     	; 0x1468 <LCD_initialize+0x480>
		__ticks = 1;
    1456:	ce 01       	movw	r24, r28
    1458:	84 5b       	subi	r24, 0xB4	; 180
    145a:	9f 4f       	sbci	r25, 0xFF	; 255
    145c:	21 e0       	ldi	r18, 0x01	; 1
    145e:	30 e0       	ldi	r19, 0x00	; 0
    1460:	fc 01       	movw	r30, r24
    1462:	31 83       	std	Z+1, r19	; 0x01
    1464:	20 83       	st	Z, r18
    1466:	6d c0       	rjmp	.+218    	; 0x1542 <LCD_initialize+0x55a>
	else if (__tmp > 65535)
    1468:	ce 01       	movw	r24, r28
    146a:	88 5b       	subi	r24, 0xB8	; 184
    146c:	9f 4f       	sbci	r25, 0xFF	; 255
    146e:	20 e0       	ldi	r18, 0x00	; 0
    1470:	3f ef       	ldi	r19, 0xFF	; 255
    1472:	4f e7       	ldi	r20, 0x7F	; 127
    1474:	57 e4       	ldi	r21, 0x47	; 71
    1476:	fc 01       	movw	r30, r24
    1478:	60 81       	ld	r22, Z
    147a:	71 81       	ldd	r23, Z+1	; 0x01
    147c:	82 81       	ldd	r24, Z+2	; 0x02
    147e:	93 81       	ldd	r25, Z+3	; 0x03
    1480:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    1484:	18 16       	cp	r1, r24
    1486:	0c f0       	brlt	.+2      	; 0x148a <LCD_initialize+0x4a2>
    1488:	4a c0       	rjmp	.+148    	; 0x151e <LCD_initialize+0x536>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    148a:	ce 01       	movw	r24, r28
    148c:	8c 5b       	subi	r24, 0xBC	; 188
    148e:	9f 4f       	sbci	r25, 0xFF	; 255
    1490:	20 e0       	ldi	r18, 0x00	; 0
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	40 e2       	ldi	r20, 0x20	; 32
    1496:	51 e4       	ldi	r21, 0x41	; 65
    1498:	fc 01       	movw	r30, r24
    149a:	60 81       	ld	r22, Z
    149c:	71 81       	ldd	r23, Z+1	; 0x01
    149e:	82 81       	ldd	r24, Z+2	; 0x02
    14a0:	93 81       	ldd	r25, Z+3	; 0x03
    14a2:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    14a6:	dc 01       	movw	r26, r24
    14a8:	cb 01       	movw	r24, r22
    14aa:	8e 01       	movw	r16, r28
    14ac:	04 5b       	subi	r16, 0xB4	; 180
    14ae:	1f 4f       	sbci	r17, 0xFF	; 255
    14b0:	bc 01       	movw	r22, r24
    14b2:	cd 01       	movw	r24, r26
    14b4:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    14b8:	dc 01       	movw	r26, r24
    14ba:	cb 01       	movw	r24, r22
    14bc:	f8 01       	movw	r30, r16
    14be:	91 83       	std	Z+1, r25	; 0x01
    14c0:	80 83       	st	Z, r24
    14c2:	24 c0       	rjmp	.+72     	; 0x150c <LCD_initialize+0x524>
    14c4:	ce 01       	movw	r24, r28
    14c6:	82 5b       	subi	r24, 0xB2	; 178
    14c8:	9f 4f       	sbci	r25, 0xFF	; 255
    14ca:	28 ec       	ldi	r18, 0xC8	; 200
    14cc:	30 e0       	ldi	r19, 0x00	; 0
    14ce:	fc 01       	movw	r30, r24
    14d0:	31 83       	std	Z+1, r19	; 0x01
    14d2:	20 83       	st	Z, r18
    14d4:	ce 01       	movw	r24, r28
    14d6:	82 5b       	subi	r24, 0xB2	; 178
    14d8:	9f 4f       	sbci	r25, 0xFF	; 255
    14da:	fc 01       	movw	r30, r24
    14dc:	80 81       	ld	r24, Z
    14de:	91 81       	ldd	r25, Z+1	; 0x01
    14e0:	01 97       	sbiw	r24, 0x01	; 1
    14e2:	f1 f7       	brne	.-4      	; 0x14e0 <LCD_initialize+0x4f8>
    14e4:	9e 01       	movw	r18, r28
    14e6:	22 5b       	subi	r18, 0xB2	; 178
    14e8:	3f 4f       	sbci	r19, 0xFF	; 255
    14ea:	f9 01       	movw	r30, r18
    14ec:	91 83       	std	Z+1, r25	; 0x01
    14ee:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14f0:	ce 01       	movw	r24, r28
    14f2:	84 5b       	subi	r24, 0xB4	; 180
    14f4:	9f 4f       	sbci	r25, 0xFF	; 255
    14f6:	9e 01       	movw	r18, r28
    14f8:	24 5b       	subi	r18, 0xB4	; 180
    14fa:	3f 4f       	sbci	r19, 0xFF	; 255
    14fc:	f9 01       	movw	r30, r18
    14fe:	20 81       	ld	r18, Z
    1500:	31 81       	ldd	r19, Z+1	; 0x01
    1502:	21 50       	subi	r18, 0x01	; 1
    1504:	31 09       	sbc	r19, r1
    1506:	fc 01       	movw	r30, r24
    1508:	31 83       	std	Z+1, r19	; 0x01
    150a:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    150c:	ce 01       	movw	r24, r28
    150e:	84 5b       	subi	r24, 0xB4	; 180
    1510:	9f 4f       	sbci	r25, 0xFF	; 255
    1512:	fc 01       	movw	r30, r24
    1514:	80 81       	ld	r24, Z
    1516:	91 81       	ldd	r25, Z+1	; 0x01
    1518:	89 2b       	or	r24, r25
    151a:	a1 f6       	brne	.-88     	; 0x14c4 <LCD_initialize+0x4dc>
    151c:	72 c0       	rjmp	.+228    	; 0x1602 <LCD_initialize+0x61a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    151e:	8e 01       	movw	r16, r28
    1520:	04 5b       	subi	r16, 0xB4	; 180
    1522:	1f 4f       	sbci	r17, 0xFF	; 255
    1524:	ce 01       	movw	r24, r28
    1526:	88 5b       	subi	r24, 0xB8	; 184
    1528:	9f 4f       	sbci	r25, 0xFF	; 255
    152a:	fc 01       	movw	r30, r24
    152c:	60 81       	ld	r22, Z
    152e:	71 81       	ldd	r23, Z+1	; 0x01
    1530:	82 81       	ldd	r24, Z+2	; 0x02
    1532:	93 81       	ldd	r25, Z+3	; 0x03
    1534:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1538:	dc 01       	movw	r26, r24
    153a:	cb 01       	movw	r24, r22
    153c:	f8 01       	movw	r30, r16
    153e:	91 83       	std	Z+1, r25	; 0x01
    1540:	80 83       	st	Z, r24
    1542:	ce 01       	movw	r24, r28
    1544:	80 5b       	subi	r24, 0xB0	; 176
    1546:	9f 4f       	sbci	r25, 0xFF	; 255
    1548:	9e 01       	movw	r18, r28
    154a:	24 5b       	subi	r18, 0xB4	; 180
    154c:	3f 4f       	sbci	r19, 0xFF	; 255
    154e:	f9 01       	movw	r30, r18
    1550:	20 81       	ld	r18, Z
    1552:	31 81       	ldd	r19, Z+1	; 0x01
    1554:	fc 01       	movw	r30, r24
    1556:	31 83       	std	Z+1, r19	; 0x01
    1558:	20 83       	st	Z, r18
    155a:	ce 01       	movw	r24, r28
    155c:	80 5b       	subi	r24, 0xB0	; 176
    155e:	9f 4f       	sbci	r25, 0xFF	; 255
    1560:	fc 01       	movw	r30, r24
    1562:	80 81       	ld	r24, Z
    1564:	91 81       	ldd	r25, Z+1	; 0x01
    1566:	01 97       	sbiw	r24, 0x01	; 1
    1568:	f1 f7       	brne	.-4      	; 0x1566 <LCD_initialize+0x57e>
    156a:	9e 01       	movw	r18, r28
    156c:	20 5b       	subi	r18, 0xB0	; 176
    156e:	3f 4f       	sbci	r19, 0xFF	; 255
    1570:	f9 01       	movw	r30, r18
    1572:	91 83       	std	Z+1, r25	; 0x01
    1574:	80 83       	st	Z, r24
    1576:	45 c0       	rjmp	.+138    	; 0x1602 <LCD_initialize+0x61a>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    1578:	20 e0       	ldi	r18, 0x00	; 0
    157a:	30 e0       	ldi	r19, 0x00	; 0
    157c:	4f e7       	ldi	r20, 0x7F	; 127
    157e:	53 e4       	ldi	r21, 0x43	; 67
    1580:	6b ad       	ldd	r22, Y+59	; 0x3b
    1582:	7c ad       	ldd	r23, Y+60	; 0x3c
    1584:	8d ad       	ldd	r24, Y+61	; 0x3d
    1586:	9e ad       	ldd	r25, Y+62	; 0x3e
    1588:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    158c:	18 16       	cp	r1, r24
    158e:	64 f5       	brge	.+88     	; 0x15e8 <LCD_initialize+0x600>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    1590:	8e 01       	movw	r16, r28
    1592:	0e 5a       	subi	r16, 0xAE	; 174
    1594:	1f 4f       	sbci	r17, 0xFF	; 255
    1596:	ce 01       	movw	r24, r28
    1598:	cf 96       	adiw	r24, 0x3f	; 63
    159a:	fc 01       	movw	r30, r24
    159c:	60 81       	ld	r22, Z
    159e:	71 81       	ldd	r23, Z+1	; 0x01
    15a0:	82 81       	ldd	r24, Z+2	; 0x02
    15a2:	93 81       	ldd	r25, Z+3	; 0x03
    15a4:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    15a8:	dc 01       	movw	r26, r24
    15aa:	cb 01       	movw	r24, r22
    15ac:	f8 01       	movw	r30, r16
    15ae:	91 83       	std	Z+1, r25	; 0x01
    15b0:	80 83       	st	Z, r24
    15b2:	ce 01       	movw	r24, r28
    15b4:	8c 5a       	subi	r24, 0xAC	; 172
    15b6:	9f 4f       	sbci	r25, 0xFF	; 255
    15b8:	9e 01       	movw	r18, r28
    15ba:	2e 5a       	subi	r18, 0xAE	; 174
    15bc:	3f 4f       	sbci	r19, 0xFF	; 255
    15be:	f9 01       	movw	r30, r18
    15c0:	20 81       	ld	r18, Z
    15c2:	31 81       	ldd	r19, Z+1	; 0x01
    15c4:	fc 01       	movw	r30, r24
    15c6:	31 83       	std	Z+1, r19	; 0x01
    15c8:	20 83       	st	Z, r18
    15ca:	ce 01       	movw	r24, r28
    15cc:	8c 5a       	subi	r24, 0xAC	; 172
    15ce:	9f 4f       	sbci	r25, 0xFF	; 255
    15d0:	fc 01       	movw	r30, r24
    15d2:	80 81       	ld	r24, Z
    15d4:	91 81       	ldd	r25, Z+1	; 0x01
    15d6:	01 97       	sbiw	r24, 0x01	; 1
    15d8:	f1 f7       	brne	.-4      	; 0x15d6 <LCD_initialize+0x5ee>
    15da:	9e 01       	movw	r18, r28
    15dc:	2c 5a       	subi	r18, 0xAC	; 172
    15de:	3f 4f       	sbci	r19, 0xFF	; 255
    15e0:	f9 01       	movw	r30, r18
    15e2:	91 83       	std	Z+1, r25	; 0x01
    15e4:	80 83       	st	Z, r24
    15e6:	24 c0       	rjmp	.+72     	; 0x1630 <LCD_initialize+0x648>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    15e8:	8e 01       	movw	r16, r28
    15ea:	0d 5b       	subi	r16, 0xBD	; 189
    15ec:	1f 4f       	sbci	r17, 0xFF	; 255
    15ee:	6b ad       	ldd	r22, Y+59	; 0x3b
    15f0:	7c ad       	ldd	r23, Y+60	; 0x3c
    15f2:	8d ad       	ldd	r24, Y+61	; 0x3d
    15f4:	9e ad       	ldd	r25, Y+62	; 0x3e
    15f6:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    15fa:	dc 01       	movw	r26, r24
    15fc:	cb 01       	movw	r24, r22
    15fe:	f8 01       	movw	r30, r16
    1600:	80 83       	st	Z, r24
    1602:	ce 01       	movw	r24, r28
    1604:	8a 5a       	subi	r24, 0xAA	; 170
    1606:	9f 4f       	sbci	r25, 0xFF	; 255
    1608:	9e 01       	movw	r18, r28
    160a:	2d 5b       	subi	r18, 0xBD	; 189
    160c:	3f 4f       	sbci	r19, 0xFF	; 255
    160e:	f9 01       	movw	r30, r18
    1610:	20 81       	ld	r18, Z
    1612:	fc 01       	movw	r30, r24
    1614:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1616:	ce 01       	movw	r24, r28
    1618:	8a 5a       	subi	r24, 0xAA	; 170
    161a:	9f 4f       	sbci	r25, 0xFF	; 255
    161c:	fc 01       	movw	r30, r24
    161e:	80 81       	ld	r24, Z
    1620:	28 2f       	mov	r18, r24
    1622:	2a 95       	dec	r18
    1624:	f1 f7       	brne	.-4      	; 0x1622 <LCD_initialize+0x63a>
    1626:	ce 01       	movw	r24, r28
    1628:	8a 5a       	subi	r24, 0xAA	; 170
    162a:	9f 4f       	sbci	r25, 0xFF	; 255
    162c:	fc 01       	movw	r30, r24
    162e:	20 83       	st	Z, r18
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00001100);
    1630:	8c e0       	ldi	r24, 0x0C	; 12
    1632:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
    1636:	80 e0       	ldi	r24, 0x00	; 0
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	a8 e4       	ldi	r26, 0x48	; 72
    163c:	b2 e4       	ldi	r27, 0x42	; 66
    163e:	8d 87       	std	Y+13, r24	; 0x0d
    1640:	9e 87       	std	Y+14, r25	; 0x0e
    1642:	af 87       	std	Y+15, r26	; 0x0f
    1644:	b8 8b       	std	Y+16, r27	; 0x10
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    1646:	2b ea       	ldi	r18, 0xAB	; 171
    1648:	3a ea       	ldi	r19, 0xAA	; 170
    164a:	4a e2       	ldi	r20, 0x2A	; 42
    164c:	50 e4       	ldi	r21, 0x40	; 64
    164e:	6d 85       	ldd	r22, Y+13	; 0x0d
    1650:	7e 85       	ldd	r23, Y+14	; 0x0e
    1652:	8f 85       	ldd	r24, Y+15	; 0x0f
    1654:	98 89       	ldd	r25, Y+16	; 0x10
    1656:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    165a:	dc 01       	movw	r26, r24
    165c:	cb 01       	movw	r24, r22
    165e:	8f 8f       	std	Y+31, r24	; 0x1f
    1660:	98 a3       	std	Y+32, r25	; 0x20
    1662:	a9 a3       	std	Y+33, r26	; 0x21
    1664:	ba a3       	std	Y+34, r27	; 0x22
	__tmp2 = ((F_CPU) / 4e6) * __us;
    1666:	8d 85       	ldd	r24, Y+13	; 0x0d
    1668:	9e 85       	ldd	r25, Y+14	; 0x0e
    166a:	af 85       	ldd	r26, Y+15	; 0x0f
    166c:	b8 89       	ldd	r27, Y+16	; 0x10
    166e:	9c 01       	movw	r18, r24
    1670:	ad 01       	movw	r20, r26
    1672:	bc 01       	movw	r22, r24
    1674:	cd 01       	movw	r24, r26
    1676:	0e 94 17 30 	call	0x602e	; 0x602e <__addsf3>
    167a:	dc 01       	movw	r26, r24
    167c:	cb 01       	movw	r24, r22
    167e:	8b a3       	std	Y+35, r24	; 0x23
    1680:	9c a3       	std	Y+36, r25	; 0x24
    1682:	ad a3       	std	Y+37, r26	; 0x25
    1684:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1686:	20 e0       	ldi	r18, 0x00	; 0
    1688:	30 e0       	ldi	r19, 0x00	; 0
    168a:	40 e8       	ldi	r20, 0x80	; 128
    168c:	5f e3       	ldi	r21, 0x3F	; 63
    168e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1690:	78 a1       	ldd	r23, Y+32	; 0x20
    1692:	89 a1       	ldd	r24, Y+33	; 0x21
    1694:	9a a1       	ldd	r25, Y+34	; 0x22
    1696:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    169a:	88 23       	and	r24, r24
    169c:	1c f4       	brge	.+6      	; 0x16a4 <LCD_initialize+0x6bc>
		__ticks = 1;
    169e:	81 e0       	ldi	r24, 0x01	; 1
    16a0:	8f a3       	std	Y+39, r24	; 0x27
    16a2:	b2 c0       	rjmp	.+356    	; 0x1808 <LCD_initialize+0x820>
	else if (__tmp2 > 65535)
    16a4:	20 e0       	ldi	r18, 0x00	; 0
    16a6:	3f ef       	ldi	r19, 0xFF	; 255
    16a8:	4f e7       	ldi	r20, 0x7F	; 127
    16aa:	57 e4       	ldi	r21, 0x47	; 71
    16ac:	6b a1       	ldd	r22, Y+35	; 0x23
    16ae:	7c a1       	ldd	r23, Y+36	; 0x24
    16b0:	8d a1       	ldd	r24, Y+37	; 0x25
    16b2:	9e a1       	ldd	r25, Y+38	; 0x26
    16b4:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    16b8:	18 16       	cp	r1, r24
    16ba:	0c f0       	brlt	.+2      	; 0x16be <LCD_initialize+0x6d6>
    16bc:	7b c0       	rjmp	.+246    	; 0x17b4 <LCD_initialize+0x7cc>
	{
		_delay_ms(__us / 1000.0);
    16be:	20 e0       	ldi	r18, 0x00	; 0
    16c0:	30 e0       	ldi	r19, 0x00	; 0
    16c2:	4a e7       	ldi	r20, 0x7A	; 122
    16c4:	54 e4       	ldi	r21, 0x44	; 68
    16c6:	6d 85       	ldd	r22, Y+13	; 0x0d
    16c8:	7e 85       	ldd	r23, Y+14	; 0x0e
    16ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    16cc:	98 89       	ldd	r25, Y+16	; 0x10
    16ce:	0e 94 88 30 	call	0x6110	; 0x6110 <__divsf3>
    16d2:	dc 01       	movw	r26, r24
    16d4:	cb 01       	movw	r24, r22
    16d6:	88 a7       	std	Y+40, r24	; 0x28
    16d8:	99 a7       	std	Y+41, r25	; 0x29
    16da:	aa a7       	std	Y+42, r26	; 0x2a
    16dc:	bb a7       	std	Y+43, r27	; 0x2b

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    16de:	20 e0       	ldi	r18, 0x00	; 0
    16e0:	30 e0       	ldi	r19, 0x00	; 0
    16e2:	4a ef       	ldi	r20, 0xFA	; 250
    16e4:	54 e4       	ldi	r21, 0x44	; 68
    16e6:	68 a5       	ldd	r22, Y+40	; 0x28
    16e8:	79 a5       	ldd	r23, Y+41	; 0x29
    16ea:	8a a5       	ldd	r24, Y+42	; 0x2a
    16ec:	9b a5       	ldd	r25, Y+43	; 0x2b
    16ee:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    16f2:	dc 01       	movw	r26, r24
    16f4:	cb 01       	movw	r24, r22
    16f6:	8c a7       	std	Y+44, r24	; 0x2c
    16f8:	9d a7       	std	Y+45, r25	; 0x2d
    16fa:	ae a7       	std	Y+46, r26	; 0x2e
    16fc:	bf a7       	std	Y+47, r27	; 0x2f
	if (__tmp < 1.0)
    16fe:	20 e0       	ldi	r18, 0x00	; 0
    1700:	30 e0       	ldi	r19, 0x00	; 0
    1702:	40 e8       	ldi	r20, 0x80	; 128
    1704:	5f e3       	ldi	r21, 0x3F	; 63
    1706:	6c a5       	ldd	r22, Y+44	; 0x2c
    1708:	7d a5       	ldd	r23, Y+45	; 0x2d
    170a:	8e a5       	ldd	r24, Y+46	; 0x2e
    170c:	9f a5       	ldd	r25, Y+47	; 0x2f
    170e:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    1712:	88 23       	and	r24, r24
    1714:	2c f4       	brge	.+10     	; 0x1720 <LCD_initialize+0x738>
		__ticks = 1;
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	99 ab       	std	Y+49, r25	; 0x31
    171c:	88 ab       	std	Y+48, r24	; 0x30
    171e:	3f c0       	rjmp	.+126    	; 0x179e <LCD_initialize+0x7b6>
	else if (__tmp > 65535)
    1720:	20 e0       	ldi	r18, 0x00	; 0
    1722:	3f ef       	ldi	r19, 0xFF	; 255
    1724:	4f e7       	ldi	r20, 0x7F	; 127
    1726:	57 e4       	ldi	r21, 0x47	; 71
    1728:	6c a5       	ldd	r22, Y+44	; 0x2c
    172a:	7d a5       	ldd	r23, Y+45	; 0x2d
    172c:	8e a5       	ldd	r24, Y+46	; 0x2e
    172e:	9f a5       	ldd	r25, Y+47	; 0x2f
    1730:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    1734:	18 16       	cp	r1, r24
    1736:	4c f5       	brge	.+82     	; 0x178a <LCD_initialize+0x7a2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1738:	20 e0       	ldi	r18, 0x00	; 0
    173a:	30 e0       	ldi	r19, 0x00	; 0
    173c:	40 e2       	ldi	r20, 0x20	; 32
    173e:	51 e4       	ldi	r21, 0x41	; 65
    1740:	68 a5       	ldd	r22, Y+40	; 0x28
    1742:	79 a5       	ldd	r23, Y+41	; 0x29
    1744:	8a a5       	ldd	r24, Y+42	; 0x2a
    1746:	9b a5       	ldd	r25, Y+43	; 0x2b
    1748:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    174c:	dc 01       	movw	r26, r24
    174e:	cb 01       	movw	r24, r22
    1750:	bc 01       	movw	r22, r24
    1752:	cd 01       	movw	r24, r26
    1754:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1758:	dc 01       	movw	r26, r24
    175a:	cb 01       	movw	r24, r22
    175c:	99 ab       	std	Y+49, r25	; 0x31
    175e:	88 ab       	std	Y+48, r24	; 0x30
    1760:	0f c0       	rjmp	.+30     	; 0x1780 <LCD_initialize+0x798>
    1762:	88 ec       	ldi	r24, 0xC8	; 200
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	9b ab       	std	Y+51, r25	; 0x33
    1768:	8a ab       	std	Y+50, r24	; 0x32
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    176a:	8a a9       	ldd	r24, Y+50	; 0x32
    176c:	9b a9       	ldd	r25, Y+51	; 0x33
    176e:	01 97       	sbiw	r24, 0x01	; 1
    1770:	f1 f7       	brne	.-4      	; 0x176e <LCD_initialize+0x786>
    1772:	9b ab       	std	Y+51, r25	; 0x33
    1774:	8a ab       	std	Y+50, r24	; 0x32
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1776:	88 a9       	ldd	r24, Y+48	; 0x30
    1778:	99 a9       	ldd	r25, Y+49	; 0x31
    177a:	01 97       	sbiw	r24, 0x01	; 1
    177c:	99 ab       	std	Y+49, r25	; 0x31
    177e:	88 ab       	std	Y+48, r24	; 0x30
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1780:	88 a9       	ldd	r24, Y+48	; 0x30
    1782:	99 a9       	ldd	r25, Y+49	; 0x31
    1784:	89 2b       	or	r24, r25
    1786:	69 f7       	brne	.-38     	; 0x1762 <LCD_initialize+0x77a>
    1788:	3f c0       	rjmp	.+126    	; 0x1808 <LCD_initialize+0x820>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    178a:	6c a5       	ldd	r22, Y+44	; 0x2c
    178c:	7d a5       	ldd	r23, Y+45	; 0x2d
    178e:	8e a5       	ldd	r24, Y+46	; 0x2e
    1790:	9f a5       	ldd	r25, Y+47	; 0x2f
    1792:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1796:	dc 01       	movw	r26, r24
    1798:	cb 01       	movw	r24, r22
    179a:	99 ab       	std	Y+49, r25	; 0x31
    179c:	88 ab       	std	Y+48, r24	; 0x30
    179e:	88 a9       	ldd	r24, Y+48	; 0x30
    17a0:	99 a9       	ldd	r25, Y+49	; 0x31
    17a2:	9d ab       	std	Y+53, r25	; 0x35
    17a4:	8c ab       	std	Y+52, r24	; 0x34
    17a6:	8c a9       	ldd	r24, Y+52	; 0x34
    17a8:	9d a9       	ldd	r25, Y+53	; 0x35
    17aa:	01 97       	sbiw	r24, 0x01	; 1
    17ac:	f1 f7       	brne	.-4      	; 0x17aa <LCD_initialize+0x7c2>
    17ae:	9d ab       	std	Y+53, r25	; 0x35
    17b0:	8c ab       	std	Y+52, r24	; 0x34
    17b2:	2a c0       	rjmp	.+84     	; 0x1808 <LCD_initialize+0x820>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    17b4:	20 e0       	ldi	r18, 0x00	; 0
    17b6:	30 e0       	ldi	r19, 0x00	; 0
    17b8:	4f e7       	ldi	r20, 0x7F	; 127
    17ba:	53 e4       	ldi	r21, 0x43	; 67
    17bc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17be:	78 a1       	ldd	r23, Y+32	; 0x20
    17c0:	89 a1       	ldd	r24, Y+33	; 0x21
    17c2:	9a a1       	ldd	r25, Y+34	; 0x22
    17c4:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    17c8:	18 16       	cp	r1, r24
    17ca:	ac f4       	brge	.+42     	; 0x17f6 <LCD_initialize+0x80e>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    17cc:	6b a1       	ldd	r22, Y+35	; 0x23
    17ce:	7c a1       	ldd	r23, Y+36	; 0x24
    17d0:	8d a1       	ldd	r24, Y+37	; 0x25
    17d2:	9e a1       	ldd	r25, Y+38	; 0x26
    17d4:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    17d8:	dc 01       	movw	r26, r24
    17da:	cb 01       	movw	r24, r22
    17dc:	9f ab       	std	Y+55, r25	; 0x37
    17de:	8e ab       	std	Y+54, r24	; 0x36
    17e0:	8e a9       	ldd	r24, Y+54	; 0x36
    17e2:	9f a9       	ldd	r25, Y+55	; 0x37
    17e4:	99 af       	std	Y+57, r25	; 0x39
    17e6:	88 af       	std	Y+56, r24	; 0x38
    17e8:	88 ad       	ldd	r24, Y+56	; 0x38
    17ea:	99 ad       	ldd	r25, Y+57	; 0x39
    17ec:	01 97       	sbiw	r24, 0x01	; 1
    17ee:	f1 f7       	brne	.-4      	; 0x17ec <LCD_initialize+0x804>
    17f0:	99 af       	std	Y+57, r25	; 0x39
    17f2:	88 af       	std	Y+56, r24	; 0x38
    17f4:	0f c0       	rjmp	.+30     	; 0x1814 <LCD_initialize+0x82c>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    17f6:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17f8:	78 a1       	ldd	r23, Y+32	; 0x20
    17fa:	89 a1       	ldd	r24, Y+33	; 0x21
    17fc:	9a a1       	ldd	r25, Y+34	; 0x22
    17fe:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1802:	dc 01       	movw	r26, r24
    1804:	cb 01       	movw	r24, r22
    1806:	8f a3       	std	Y+39, r24	; 0x27
    1808:	8f a1       	ldd	r24, Y+39	; 0x27
    180a:	8a af       	std	Y+58, r24	; 0x3a
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    180c:	8a ad       	ldd	r24, Y+58	; 0x3a
    180e:	8a 95       	dec	r24
    1810:	f1 f7       	brne	.-4      	; 0x180e <LCD_initialize+0x826>
    1812:	8a af       	std	Y+58, r24	; 0x3a
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00000001);
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
    181a:	80 e0       	ldi	r24, 0x00	; 0
    181c:	90 e0       	ldi	r25, 0x00	; 0
    181e:	a0 e0       	ldi	r26, 0x00	; 0
    1820:	b0 e4       	ldi	r27, 0x40	; 64
    1822:	89 8b       	std	Y+17, r24	; 0x11
    1824:	9a 8b       	std	Y+18, r25	; 0x12
    1826:	ab 8b       	std	Y+19, r26	; 0x13
    1828:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    182a:	20 e0       	ldi	r18, 0x00	; 0
    182c:	30 e0       	ldi	r19, 0x00	; 0
    182e:	4a ef       	ldi	r20, 0xFA	; 250
    1830:	54 e4       	ldi	r21, 0x44	; 68
    1832:	69 89       	ldd	r22, Y+17	; 0x11
    1834:	7a 89       	ldd	r23, Y+18	; 0x12
    1836:	8b 89       	ldd	r24, Y+19	; 0x13
    1838:	9c 89       	ldd	r25, Y+20	; 0x14
    183a:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    183e:	dc 01       	movw	r26, r24
    1840:	cb 01       	movw	r24, r22
    1842:	8d 8b       	std	Y+21, r24	; 0x15
    1844:	9e 8b       	std	Y+22, r25	; 0x16
    1846:	af 8b       	std	Y+23, r26	; 0x17
    1848:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    184a:	20 e0       	ldi	r18, 0x00	; 0
    184c:	30 e0       	ldi	r19, 0x00	; 0
    184e:	40 e8       	ldi	r20, 0x80	; 128
    1850:	5f e3       	ldi	r21, 0x3F	; 63
    1852:	6d 89       	ldd	r22, Y+21	; 0x15
    1854:	7e 89       	ldd	r23, Y+22	; 0x16
    1856:	8f 89       	ldd	r24, Y+23	; 0x17
    1858:	98 8d       	ldd	r25, Y+24	; 0x18
    185a:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    185e:	88 23       	and	r24, r24
    1860:	2c f4       	brge	.+10     	; 0x186c <LCD_initialize+0x884>
		__ticks = 1;
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	9a 8f       	std	Y+26, r25	; 0x1a
    1868:	89 8f       	std	Y+25, r24	; 0x19
    186a:	3f c0       	rjmp	.+126    	; 0x18ea <LCD_initialize+0x902>
	else if (__tmp > 65535)
    186c:	20 e0       	ldi	r18, 0x00	; 0
    186e:	3f ef       	ldi	r19, 0xFF	; 255
    1870:	4f e7       	ldi	r20, 0x7F	; 127
    1872:	57 e4       	ldi	r21, 0x47	; 71
    1874:	6d 89       	ldd	r22, Y+21	; 0x15
    1876:	7e 89       	ldd	r23, Y+22	; 0x16
    1878:	8f 89       	ldd	r24, Y+23	; 0x17
    187a:	98 8d       	ldd	r25, Y+24	; 0x18
    187c:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    1880:	18 16       	cp	r1, r24
    1882:	4c f5       	brge	.+82     	; 0x18d6 <LCD_initialize+0x8ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1884:	20 e0       	ldi	r18, 0x00	; 0
    1886:	30 e0       	ldi	r19, 0x00	; 0
    1888:	40 e2       	ldi	r20, 0x20	; 32
    188a:	51 e4       	ldi	r21, 0x41	; 65
    188c:	69 89       	ldd	r22, Y+17	; 0x11
    188e:	7a 89       	ldd	r23, Y+18	; 0x12
    1890:	8b 89       	ldd	r24, Y+19	; 0x13
    1892:	9c 89       	ldd	r25, Y+20	; 0x14
    1894:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    1898:	dc 01       	movw	r26, r24
    189a:	cb 01       	movw	r24, r22
    189c:	bc 01       	movw	r22, r24
    189e:	cd 01       	movw	r24, r26
    18a0:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    18a4:	dc 01       	movw	r26, r24
    18a6:	cb 01       	movw	r24, r22
    18a8:	9a 8f       	std	Y+26, r25	; 0x1a
    18aa:	89 8f       	std	Y+25, r24	; 0x19
    18ac:	0f c0       	rjmp	.+30     	; 0x18cc <LCD_initialize+0x8e4>
    18ae:	88 ec       	ldi	r24, 0xC8	; 200
    18b0:	90 e0       	ldi	r25, 0x00	; 0
    18b2:	9c 8f       	std	Y+28, r25	; 0x1c
    18b4:	8b 8f       	std	Y+27, r24	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    18b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18ba:	01 97       	sbiw	r24, 0x01	; 1
    18bc:	f1 f7       	brne	.-4      	; 0x18ba <LCD_initialize+0x8d2>
    18be:	9c 8f       	std	Y+28, r25	; 0x1c
    18c0:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18c2:	89 8d       	ldd	r24, Y+25	; 0x19
    18c4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18c6:	01 97       	sbiw	r24, 0x01	; 1
    18c8:	9a 8f       	std	Y+26, r25	; 0x1a
    18ca:	89 8f       	std	Y+25, r24	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18cc:	89 8d       	ldd	r24, Y+25	; 0x19
    18ce:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18d0:	89 2b       	or	r24, r25
    18d2:	69 f7       	brne	.-38     	; 0x18ae <LCD_initialize+0x8c6>
	_delay_ms(2);

}
    18d4:	14 c0       	rjmp	.+40     	; 0x18fe <LCD_initialize+0x916>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18d6:	6d 89       	ldd	r22, Y+21	; 0x15
    18d8:	7e 89       	ldd	r23, Y+22	; 0x16
    18da:	8f 89       	ldd	r24, Y+23	; 0x17
    18dc:	98 8d       	ldd	r25, Y+24	; 0x18
    18de:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    18e2:	dc 01       	movw	r26, r24
    18e4:	cb 01       	movw	r24, r22
    18e6:	9a 8f       	std	Y+26, r25	; 0x1a
    18e8:	89 8f       	std	Y+25, r24	; 0x19
    18ea:	89 8d       	ldd	r24, Y+25	; 0x19
    18ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18ee:	9e 8f       	std	Y+30, r25	; 0x1e
    18f0:	8d 8f       	std	Y+29, r24	; 0x1d
    18f2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18f4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18f6:	01 97       	sbiw	r24, 0x01	; 1
    18f8:	f1 f7       	brne	.-4      	; 0x18f6 <LCD_initialize+0x90e>
    18fa:	9e 8f       	std	Y+30, r25	; 0x1e
    18fc:	8d 8f       	std	Y+29, r24	; 0x1d
    18fe:	00 00       	nop
    1900:	c6 59       	subi	r28, 0x96	; 150
    1902:	df 4f       	sbci	r29, 0xFF	; 255
    1904:	0f b6       	in	r0, 0x3f	; 63
    1906:	f8 94       	cli
    1908:	de bf       	out	0x3e, r29	; 62
    190a:	0f be       	out	0x3f, r0	; 63
    190c:	cd bf       	out	0x3d, r28	; 61
    190e:	df 91       	pop	r29
    1910:	cf 91       	pop	r28
    1912:	1f 91       	pop	r17
    1914:	0f 91       	pop	r16
    1916:	08 95       	ret

00001918 <LCD_Void_Write_String>:

void LCD_Void_Write_String(u8* copy_string)
{
    1918:	cf 93       	push	r28
    191a:	df 93       	push	r29
    191c:	00 d0       	rcall	.+0      	; 0x191e <LCD_Void_Write_String+0x6>
    191e:	1f 92       	push	r1
    1920:	cd b7       	in	r28, 0x3d	; 61
    1922:	de b7       	in	r29, 0x3e	; 62
    1924:	9b 83       	std	Y+3, r25	; 0x03
    1926:	8a 83       	std	Y+2, r24	; 0x02
	u8 i = 0;
    1928:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    192a:	14 c0       	rjmp	.+40     	; 0x1954 <LCD_Void_Write_String+0x3c>
	{	if(i==16)
    192c:	89 81       	ldd	r24, Y+1	; 0x01
    192e:	80 31       	cpi	r24, 0x10	; 16
    1930:	19 f4       	brne	.+6      	; 0x1938 <LCD_Void_Write_String+0x20>
		{
			LCD_Set_Block(16);
    1932:	80 e1       	ldi	r24, 0x10	; 16
    1934:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
		}
		LCD_Void_Write_Data(copy_string[i]);
    1938:	89 81       	ldd	r24, Y+1	; 0x01
    193a:	88 2f       	mov	r24, r24
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	2a 81       	ldd	r18, Y+2	; 0x02
    1940:	3b 81       	ldd	r19, Y+3	; 0x03
    1942:	82 0f       	add	r24, r18
    1944:	93 1f       	adc	r25, r19
    1946:	fc 01       	movw	r30, r24
    1948:	80 81       	ld	r24, Z
    194a:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
		i++;
    194e:	89 81       	ldd	r24, Y+1	; 0x01
    1950:	8f 5f       	subi	r24, 0xFF	; 255
    1952:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	88 2f       	mov	r24, r24
    1958:	90 e0       	ldi	r25, 0x00	; 0
    195a:	2a 81       	ldd	r18, Y+2	; 0x02
    195c:	3b 81       	ldd	r19, Y+3	; 0x03
    195e:	82 0f       	add	r24, r18
    1960:	93 1f       	adc	r25, r19
    1962:	fc 01       	movw	r30, r24
    1964:	80 81       	ld	r24, Z
    1966:	88 23       	and	r24, r24
    1968:	09 f7       	brne	.-62     	; 0x192c <LCD_Void_Write_String+0x14>
			LCD_Set_Block(16);
		}
		LCD_Void_Write_Data(copy_string[i]);
		i++;
	}
}
    196a:	00 00       	nop
    196c:	0f 90       	pop	r0
    196e:	0f 90       	pop	r0
    1970:	0f 90       	pop	r0
    1972:	df 91       	pop	r29
    1974:	cf 91       	pop	r28
    1976:	08 95       	ret

00001978 <LCD_Void_Clear>:

void LCD_Void_Clear(void)
{
    1978:	cf 93       	push	r28
    197a:	df 93       	push	r29
    197c:	cd b7       	in	r28, 0x3d	; 61
    197e:	de b7       	in	r29, 0x3e	; 62
	LCD_Void_Write_Cmd(0b00000001);
    1980:	81 e0       	ldi	r24, 0x01	; 1
    1982:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
}
    1986:	00 00       	nop
    1988:	df 91       	pop	r29
    198a:	cf 91       	pop	r28
    198c:	08 95       	ret

0000198e <LCD_Void_Write_Blinking_String>:

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
    198e:	cf 93       	push	r28
    1990:	df 93       	push	r29
    1992:	cd b7       	in	r28, 0x3d	; 61
    1994:	de b7       	in	r29, 0x3e	; 62
    1996:	61 97       	sbiw	r28, 0x11	; 17
    1998:	0f b6       	in	r0, 0x3f	; 63
    199a:	f8 94       	cli
    199c:	de bf       	out	0x3e, r29	; 62
    199e:	0f be       	out	0x3f, r0	; 63
    19a0:	cd bf       	out	0x3d, r28	; 61
    19a2:	99 8b       	std	Y+17, r25	; 0x11
    19a4:	88 8b       	std	Y+16, r24	; 0x10
	u8 i = 0;
    19a6:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    19a8:	80 c0       	rjmp	.+256    	; 0x1aaa <LCD_Void_Write_Blinking_String+0x11c>
	{
		LCD_Void_Write_Data(copy_string[i]);
    19aa:	89 81       	ldd	r24, Y+1	; 0x01
    19ac:	88 2f       	mov	r24, r24
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	28 89       	ldd	r18, Y+16	; 0x10
    19b2:	39 89       	ldd	r19, Y+17	; 0x11
    19b4:	82 0f       	add	r24, r18
    19b6:	93 1f       	adc	r25, r19
    19b8:	fc 01       	movw	r30, r24
    19ba:	80 81       	ld	r24, Z
    19bc:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
    19c0:	80 e0       	ldi	r24, 0x00	; 0
    19c2:	90 e0       	ldi	r25, 0x00	; 0
    19c4:	aa ef       	ldi	r26, 0xFA	; 250
    19c6:	b3 e4       	ldi	r27, 0x43	; 67
    19c8:	8a 83       	std	Y+2, r24	; 0x02
    19ca:	9b 83       	std	Y+3, r25	; 0x03
    19cc:	ac 83       	std	Y+4, r26	; 0x04
    19ce:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    19d0:	20 e0       	ldi	r18, 0x00	; 0
    19d2:	30 e0       	ldi	r19, 0x00	; 0
    19d4:	4a ef       	ldi	r20, 0xFA	; 250
    19d6:	54 e4       	ldi	r21, 0x44	; 68
    19d8:	6a 81       	ldd	r22, Y+2	; 0x02
    19da:	7b 81       	ldd	r23, Y+3	; 0x03
    19dc:	8c 81       	ldd	r24, Y+4	; 0x04
    19de:	9d 81       	ldd	r25, Y+5	; 0x05
    19e0:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    19e4:	dc 01       	movw	r26, r24
    19e6:	cb 01       	movw	r24, r22
    19e8:	8e 83       	std	Y+6, r24	; 0x06
    19ea:	9f 83       	std	Y+7, r25	; 0x07
    19ec:	a8 87       	std	Y+8, r26	; 0x08
    19ee:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    19f0:	20 e0       	ldi	r18, 0x00	; 0
    19f2:	30 e0       	ldi	r19, 0x00	; 0
    19f4:	40 e8       	ldi	r20, 0x80	; 128
    19f6:	5f e3       	ldi	r21, 0x3F	; 63
    19f8:	6e 81       	ldd	r22, Y+6	; 0x06
    19fa:	7f 81       	ldd	r23, Y+7	; 0x07
    19fc:	88 85       	ldd	r24, Y+8	; 0x08
    19fe:	99 85       	ldd	r25, Y+9	; 0x09
    1a00:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    1a04:	88 23       	and	r24, r24
    1a06:	2c f4       	brge	.+10     	; 0x1a12 <LCD_Void_Write_Blinking_String+0x84>
		__ticks = 1;
    1a08:	81 e0       	ldi	r24, 0x01	; 1
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	9b 87       	std	Y+11, r25	; 0x0b
    1a0e:	8a 87       	std	Y+10, r24	; 0x0a
    1a10:	3f c0       	rjmp	.+126    	; 0x1a90 <LCD_Void_Write_Blinking_String+0x102>
	else if (__tmp > 65535)
    1a12:	20 e0       	ldi	r18, 0x00	; 0
    1a14:	3f ef       	ldi	r19, 0xFF	; 255
    1a16:	4f e7       	ldi	r20, 0x7F	; 127
    1a18:	57 e4       	ldi	r21, 0x47	; 71
    1a1a:	6e 81       	ldd	r22, Y+6	; 0x06
    1a1c:	7f 81       	ldd	r23, Y+7	; 0x07
    1a1e:	88 85       	ldd	r24, Y+8	; 0x08
    1a20:	99 85       	ldd	r25, Y+9	; 0x09
    1a22:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    1a26:	18 16       	cp	r1, r24
    1a28:	4c f5       	brge	.+82     	; 0x1a7c <LCD_Void_Write_Blinking_String+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a2a:	20 e0       	ldi	r18, 0x00	; 0
    1a2c:	30 e0       	ldi	r19, 0x00	; 0
    1a2e:	40 e2       	ldi	r20, 0x20	; 32
    1a30:	51 e4       	ldi	r21, 0x41	; 65
    1a32:	6a 81       	ldd	r22, Y+2	; 0x02
    1a34:	7b 81       	ldd	r23, Y+3	; 0x03
    1a36:	8c 81       	ldd	r24, Y+4	; 0x04
    1a38:	9d 81       	ldd	r25, Y+5	; 0x05
    1a3a:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    1a3e:	dc 01       	movw	r26, r24
    1a40:	cb 01       	movw	r24, r22
    1a42:	bc 01       	movw	r22, r24
    1a44:	cd 01       	movw	r24, r26
    1a46:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1a4a:	dc 01       	movw	r26, r24
    1a4c:	cb 01       	movw	r24, r22
    1a4e:	9b 87       	std	Y+11, r25	; 0x0b
    1a50:	8a 87       	std	Y+10, r24	; 0x0a
    1a52:	0f c0       	rjmp	.+30     	; 0x1a72 <LCD_Void_Write_Blinking_String+0xe4>
    1a54:	88 ec       	ldi	r24, 0xC8	; 200
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	9d 87       	std	Y+13, r25	; 0x0d
    1a5a:	8c 87       	std	Y+12, r24	; 0x0c
    1a5c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a5e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a60:	01 97       	sbiw	r24, 0x01	; 1
    1a62:	f1 f7       	brne	.-4      	; 0x1a60 <LCD_Void_Write_Blinking_String+0xd2>
    1a64:	9d 87       	std	Y+13, r25	; 0x0d
    1a66:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a68:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a6a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a6c:	01 97       	sbiw	r24, 0x01	; 1
    1a6e:	9b 87       	std	Y+11, r25	; 0x0b
    1a70:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a72:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a74:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a76:	89 2b       	or	r24, r25
    1a78:	69 f7       	brne	.-38     	; 0x1a54 <LCD_Void_Write_Blinking_String+0xc6>
    1a7a:	14 c0       	rjmp	.+40     	; 0x1aa4 <LCD_Void_Write_Blinking_String+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a7c:	6e 81       	ldd	r22, Y+6	; 0x06
    1a7e:	7f 81       	ldd	r23, Y+7	; 0x07
    1a80:	88 85       	ldd	r24, Y+8	; 0x08
    1a82:	99 85       	ldd	r25, Y+9	; 0x09
    1a84:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1a88:	dc 01       	movw	r26, r24
    1a8a:	cb 01       	movw	r24, r22
    1a8c:	9b 87       	std	Y+11, r25	; 0x0b
    1a8e:	8a 87       	std	Y+10, r24	; 0x0a
    1a90:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a92:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a94:	9f 87       	std	Y+15, r25	; 0x0f
    1a96:	8e 87       	std	Y+14, r24	; 0x0e
    1a98:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a9a:	9f 85       	ldd	r25, Y+15	; 0x0f
    1a9c:	01 97       	sbiw	r24, 0x01	; 1
    1a9e:	f1 f7       	brne	.-4      	; 0x1a9c <LCD_Void_Write_Blinking_String+0x10e>
    1aa0:	9f 87       	std	Y+15, r25	; 0x0f
    1aa2:	8e 87       	std	Y+14, r24	; 0x0e
		_delay_ms(500);
		i++;
    1aa4:	89 81       	ldd	r24, Y+1	; 0x01
    1aa6:	8f 5f       	subi	r24, 0xFF	; 255
    1aa8:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1aaa:	89 81       	ldd	r24, Y+1	; 0x01
    1aac:	88 2f       	mov	r24, r24
    1aae:	90 e0       	ldi	r25, 0x00	; 0
    1ab0:	28 89       	ldd	r18, Y+16	; 0x10
    1ab2:	39 89       	ldd	r19, Y+17	; 0x11
    1ab4:	82 0f       	add	r24, r18
    1ab6:	93 1f       	adc	r25, r19
    1ab8:	fc 01       	movw	r30, r24
    1aba:	80 81       	ld	r24, Z
    1abc:	88 23       	and	r24, r24
    1abe:	09 f0       	breq	.+2      	; 0x1ac2 <LCD_Void_Write_Blinking_String+0x134>
    1ac0:	74 cf       	rjmp	.-280    	; 0x19aa <LCD_Void_Write_Blinking_String+0x1c>
	{
		LCD_Void_Write_Data(copy_string[i]);
		_delay_ms(500);
		i++;
	}
}
    1ac2:	00 00       	nop
    1ac4:	61 96       	adiw	r28, 0x11	; 17
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	f8 94       	cli
    1aca:	de bf       	out	0x3e, r29	; 62
    1acc:	0f be       	out	0x3f, r0	; 63
    1ace:	cd bf       	out	0x3d, r28	; 61
    1ad0:	df 91       	pop	r29
    1ad2:	cf 91       	pop	r28
    1ad4:	08 95       	ret

00001ad6 <LCD_Set_Block>:

void LCD_Set_Block(u8 copy_block_nb) // sets the ddram address to the block you want to write
{
    1ad6:	cf 93       	push	r28
    1ad8:	df 93       	push	r29
    1ada:	1f 92       	push	r1
    1adc:	cd b7       	in	r28, 0x3d	; 61
    1ade:	de b7       	in	r29, 0x3e	; 62
    1ae0:	89 83       	std	Y+1, r24	; 0x01
	if(copy_block_nb<16)
    1ae2:	89 81       	ldd	r24, Y+1	; 0x01
    1ae4:	80 31       	cpi	r24, 0x10	; 16
    1ae6:	28 f4       	brcc	.+10     	; 0x1af2 <LCD_Set_Block+0x1c>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
    1ae8:	89 81       	ldd	r24, Y+1	; 0x01
    1aea:	80 58       	subi	r24, 0x80	; 128
    1aec:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
	}
}
    1af0:	04 c0       	rjmp	.+8      	; 0x1afa <LCD_Set_Block+0x24>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
    1af2:	89 81       	ldd	r24, Y+1	; 0x01
    1af4:	80 55       	subi	r24, 0x50	; 80
    1af6:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
	}
}
    1afa:	00 00       	nop
    1afc:	0f 90       	pop	r0
    1afe:	df 91       	pop	r29
    1b00:	cf 91       	pop	r28
    1b02:	08 95       	ret

00001b04 <LCD_Void_Write_Moving_String>:

void LCD_Void_Write_Moving_String(u8* copy_string)
{
    1b04:	cf 93       	push	r28
    1b06:	df 93       	push	r29
    1b08:	cd b7       	in	r28, 0x3d	; 61
    1b0a:	de b7       	in	r29, 0x3e	; 62
    1b0c:	63 97       	sbiw	r28, 0x13	; 19
    1b0e:	0f b6       	in	r0, 0x3f	; 63
    1b10:	f8 94       	cli
    1b12:	de bf       	out	0x3e, r29	; 62
    1b14:	0f be       	out	0x3f, r0	; 63
    1b16:	cd bf       	out	0x3d, r28	; 61
    1b18:	9b 8b       	std	Y+19, r25	; 0x13
    1b1a:	8a 8b       	std	Y+18, r24	; 0x12
	u8 i;
	for (int j = 0; j<5 ;j++)
    1b1c:	1b 82       	std	Y+3, r1	; 0x03
    1b1e:	1a 82       	std	Y+2, r1	; 0x02
    1b20:	97 c0       	rjmp	.+302    	; 0x1c50 <LCD_Void_Write_Moving_String+0x14c>
	{
		LCD_Set_Block(j);
    1b22:	8a 81       	ldd	r24, Y+2	; 0x02
    1b24:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <LCD_Set_Block>
		i = 0;
    1b28:	19 82       	std	Y+1, r1	; 0x01
		while(copy_string[i] != '\0')
    1b2a:	0e c0       	rjmp	.+28     	; 0x1b48 <LCD_Void_Write_Moving_String+0x44>
		{

			LCD_Void_Write_Data(copy_string[i]);
    1b2c:	89 81       	ldd	r24, Y+1	; 0x01
    1b2e:	88 2f       	mov	r24, r24
    1b30:	90 e0       	ldi	r25, 0x00	; 0
    1b32:	2a 89       	ldd	r18, Y+18	; 0x12
    1b34:	3b 89       	ldd	r19, Y+19	; 0x13
    1b36:	82 0f       	add	r24, r18
    1b38:	93 1f       	adc	r25, r19
    1b3a:	fc 01       	movw	r30, r24
    1b3c:	80 81       	ld	r24, Z
    1b3e:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
			i++;
    1b42:	89 81       	ldd	r24, Y+1	; 0x01
    1b44:	8f 5f       	subi	r24, 0xFF	; 255
    1b46:	89 83       	std	Y+1, r24	; 0x01
	u8 i;
	for (int j = 0; j<5 ;j++)
	{
		LCD_Set_Block(j);
		i = 0;
		while(copy_string[i] != '\0')
    1b48:	89 81       	ldd	r24, Y+1	; 0x01
    1b4a:	88 2f       	mov	r24, r24
    1b4c:	90 e0       	ldi	r25, 0x00	; 0
    1b4e:	2a 89       	ldd	r18, Y+18	; 0x12
    1b50:	3b 89       	ldd	r19, Y+19	; 0x13
    1b52:	82 0f       	add	r24, r18
    1b54:	93 1f       	adc	r25, r19
    1b56:	fc 01       	movw	r30, r24
    1b58:	80 81       	ld	r24, Z
    1b5a:	88 23       	and	r24, r24
    1b5c:	39 f7       	brne	.-50     	; 0x1b2c <LCD_Void_Write_Moving_String+0x28>
    1b5e:	80 e0       	ldi	r24, 0x00	; 0
    1b60:	90 e0       	ldi	r25, 0x00	; 0
    1b62:	aa e7       	ldi	r26, 0x7A	; 122
    1b64:	b4 e4       	ldi	r27, 0x44	; 68
    1b66:	8c 83       	std	Y+4, r24	; 0x04
    1b68:	9d 83       	std	Y+5, r25	; 0x05
    1b6a:	ae 83       	std	Y+6, r26	; 0x06
    1b6c:	bf 83       	std	Y+7, r27	; 0x07

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1b6e:	20 e0       	ldi	r18, 0x00	; 0
    1b70:	30 e0       	ldi	r19, 0x00	; 0
    1b72:	4a ef       	ldi	r20, 0xFA	; 250
    1b74:	54 e4       	ldi	r21, 0x44	; 68
    1b76:	6c 81       	ldd	r22, Y+4	; 0x04
    1b78:	7d 81       	ldd	r23, Y+5	; 0x05
    1b7a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b7c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b7e:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    1b82:	dc 01       	movw	r26, r24
    1b84:	cb 01       	movw	r24, r22
    1b86:	88 87       	std	Y+8, r24	; 0x08
    1b88:	99 87       	std	Y+9, r25	; 0x09
    1b8a:	aa 87       	std	Y+10, r26	; 0x0a
    1b8c:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1b8e:	20 e0       	ldi	r18, 0x00	; 0
    1b90:	30 e0       	ldi	r19, 0x00	; 0
    1b92:	40 e8       	ldi	r20, 0x80	; 128
    1b94:	5f e3       	ldi	r21, 0x3F	; 63
    1b96:	68 85       	ldd	r22, Y+8	; 0x08
    1b98:	79 85       	ldd	r23, Y+9	; 0x09
    1b9a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b9c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b9e:	0e 94 83 30 	call	0x6106	; 0x6106 <__cmpsf2>
    1ba2:	88 23       	and	r24, r24
    1ba4:	2c f4       	brge	.+10     	; 0x1bb0 <LCD_Void_Write_Moving_String+0xac>
		__ticks = 1;
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	9d 87       	std	Y+13, r25	; 0x0d
    1bac:	8c 87       	std	Y+12, r24	; 0x0c
    1bae:	3f c0       	rjmp	.+126    	; 0x1c2e <LCD_Void_Write_Moving_String+0x12a>
	else if (__tmp > 65535)
    1bb0:	20 e0       	ldi	r18, 0x00	; 0
    1bb2:	3f ef       	ldi	r19, 0xFF	; 255
    1bb4:	4f e7       	ldi	r20, 0x7F	; 127
    1bb6:	57 e4       	ldi	r21, 0x47	; 71
    1bb8:	68 85       	ldd	r22, Y+8	; 0x08
    1bba:	79 85       	ldd	r23, Y+9	; 0x09
    1bbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bbe:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bc0:	0e 94 9e 31 	call	0x633c	; 0x633c <__gesf2>
    1bc4:	18 16       	cp	r1, r24
    1bc6:	4c f5       	brge	.+82     	; 0x1c1a <LCD_Void_Write_Moving_String+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bc8:	20 e0       	ldi	r18, 0x00	; 0
    1bca:	30 e0       	ldi	r19, 0x00	; 0
    1bcc:	40 e2       	ldi	r20, 0x20	; 32
    1bce:	51 e4       	ldi	r21, 0x41	; 65
    1bd0:	6c 81       	ldd	r22, Y+4	; 0x04
    1bd2:	7d 81       	ldd	r23, Y+5	; 0x05
    1bd4:	8e 81       	ldd	r24, Y+6	; 0x06
    1bd6:	9f 81       	ldd	r25, Y+7	; 0x07
    1bd8:	0e 94 a3 31 	call	0x6346	; 0x6346 <__mulsf3>
    1bdc:	dc 01       	movw	r26, r24
    1bde:	cb 01       	movw	r24, r22
    1be0:	bc 01       	movw	r22, r24
    1be2:	cd 01       	movw	r24, r26
    1be4:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1be8:	dc 01       	movw	r26, r24
    1bea:	cb 01       	movw	r24, r22
    1bec:	9d 87       	std	Y+13, r25	; 0x0d
    1bee:	8c 87       	std	Y+12, r24	; 0x0c
    1bf0:	0f c0       	rjmp	.+30     	; 0x1c10 <LCD_Void_Write_Moving_String+0x10c>
    1bf2:	88 ec       	ldi	r24, 0xC8	; 200
    1bf4:	90 e0       	ldi	r25, 0x00	; 0
    1bf6:	9f 87       	std	Y+15, r25	; 0x0f
    1bf8:	8e 87       	std	Y+14, r24	; 0x0e
    1bfa:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bfc:	9f 85       	ldd	r25, Y+15	; 0x0f
    1bfe:	01 97       	sbiw	r24, 0x01	; 1
    1c00:	f1 f7       	brne	.-4      	; 0x1bfe <LCD_Void_Write_Moving_String+0xfa>
    1c02:	9f 87       	std	Y+15, r25	; 0x0f
    1c04:	8e 87       	std	Y+14, r24	; 0x0e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c06:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c08:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c0a:	01 97       	sbiw	r24, 0x01	; 1
    1c0c:	9d 87       	std	Y+13, r25	; 0x0d
    1c0e:	8c 87       	std	Y+12, r24	; 0x0c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c10:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c12:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c14:	89 2b       	or	r24, r25
    1c16:	69 f7       	brne	.-38     	; 0x1bf2 <LCD_Void_Write_Moving_String+0xee>
    1c18:	14 c0       	rjmp	.+40     	; 0x1c42 <LCD_Void_Write_Moving_String+0x13e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c1a:	68 85       	ldd	r22, Y+8	; 0x08
    1c1c:	79 85       	ldd	r23, Y+9	; 0x09
    1c1e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c20:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c22:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fixunssfsi>
    1c26:	dc 01       	movw	r26, r24
    1c28:	cb 01       	movw	r24, r22
    1c2a:	9d 87       	std	Y+13, r25	; 0x0d
    1c2c:	8c 87       	std	Y+12, r24	; 0x0c
    1c2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c30:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c32:	99 8b       	std	Y+17, r25	; 0x11
    1c34:	88 8b       	std	Y+16, r24	; 0x10
    1c36:	88 89       	ldd	r24, Y+16	; 0x10
    1c38:	99 89       	ldd	r25, Y+17	; 0x11
    1c3a:	01 97       	sbiw	r24, 0x01	; 1
    1c3c:	f1 f7       	brne	.-4      	; 0x1c3a <LCD_Void_Write_Moving_String+0x136>
    1c3e:	99 8b       	std	Y+17, r25	; 0x11
    1c40:	88 8b       	std	Y+16, r24	; 0x10

			LCD_Void_Write_Data(copy_string[i]);
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
    1c42:	0e 94 bc 0c 	call	0x1978	; 0x1978 <LCD_Void_Clear>
}

void LCD_Void_Write_Moving_String(u8* copy_string)
{
	u8 i;
	for (int j = 0; j<5 ;j++)
    1c46:	8a 81       	ldd	r24, Y+2	; 0x02
    1c48:	9b 81       	ldd	r25, Y+3	; 0x03
    1c4a:	01 96       	adiw	r24, 0x01	; 1
    1c4c:	9b 83       	std	Y+3, r25	; 0x03
    1c4e:	8a 83       	std	Y+2, r24	; 0x02
    1c50:	8a 81       	ldd	r24, Y+2	; 0x02
    1c52:	9b 81       	ldd	r25, Y+3	; 0x03
    1c54:	05 97       	sbiw	r24, 0x05	; 5
    1c56:	0c f4       	brge	.+2      	; 0x1c5a <LCD_Void_Write_Moving_String+0x156>
    1c58:	64 cf       	rjmp	.-312    	; 0x1b22 <LCD_Void_Write_Moving_String+0x1e>
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
	}
}
    1c5a:	00 00       	nop
    1c5c:	63 96       	adiw	r28, 0x13	; 19
    1c5e:	0f b6       	in	r0, 0x3f	; 63
    1c60:	f8 94       	cli
    1c62:	de bf       	out	0x3e, r29	; 62
    1c64:	0f be       	out	0x3f, r0	; 63
    1c66:	cd bf       	out	0x3d, r28	; 61
    1c68:	df 91       	pop	r29
    1c6a:	cf 91       	pop	r28
    1c6c:	08 95       	ret

00001c6e <LCD_Void_Write_CGRAM>:

void LCD_Void_Write_CGRAM(u8 copy_row_0,u8 copy_row_1,u8 copy_row_2,u8 copy_row_3,u8 copy_row_4,u8 copy_row_5,u8 copy_row_6,u8 copy_row_7,u8 copy_CGRAM_address)
{
    1c6e:	8f 92       	push	r8
    1c70:	af 92       	push	r10
    1c72:	cf 92       	push	r12
    1c74:	ef 92       	push	r14
    1c76:	0f 93       	push	r16
    1c78:	cf 93       	push	r28
    1c7a:	df 93       	push	r29
    1c7c:	cd b7       	in	r28, 0x3d	; 61
    1c7e:	de b7       	in	r29, 0x3e	; 62
    1c80:	29 97       	sbiw	r28, 0x09	; 9
    1c82:	0f b6       	in	r0, 0x3f	; 63
    1c84:	f8 94       	cli
    1c86:	de bf       	out	0x3e, r29	; 62
    1c88:	0f be       	out	0x3f, r0	; 63
    1c8a:	cd bf       	out	0x3d, r28	; 61
    1c8c:	89 83       	std	Y+1, r24	; 0x01
    1c8e:	6a 83       	std	Y+2, r22	; 0x02
    1c90:	4b 83       	std	Y+3, r20	; 0x03
    1c92:	2c 83       	std	Y+4, r18	; 0x04
    1c94:	0d 83       	std	Y+5, r16	; 0x05
    1c96:	ee 82       	std	Y+6, r14	; 0x06
    1c98:	cf 82       	std	Y+7, r12	; 0x07
    1c9a:	a8 86       	std	Y+8, r10	; 0x08
    1c9c:	89 86       	std	Y+9, r8	; 0x09
	LCD_Void_Write_Cmd(copy_CGRAM_address);
    1c9e:	89 85       	ldd	r24, Y+9	; 0x09
    1ca0:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
	LCD_Void_Write_Data(copy_row_0);
    1ca4:	89 81       	ldd	r24, Y+1	; 0x01
    1ca6:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_1);
    1caa:	8a 81       	ldd	r24, Y+2	; 0x02
    1cac:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_2);
    1cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb2:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_3);
    1cb6:	8c 81       	ldd	r24, Y+4	; 0x04
    1cb8:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_4);
    1cbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1cbe:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_5);
    1cc2:	8e 81       	ldd	r24, Y+6	; 0x06
    1cc4:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_6);
    1cc8:	8f 81       	ldd	r24, Y+7	; 0x07
    1cca:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_7);
    1cce:	88 85       	ldd	r24, Y+8	; 0x08
    1cd0:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Cmd(0b10000000);
    1cd4:	80 e8       	ldi	r24, 0x80	; 128
    1cd6:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <LCD_Void_Write_Cmd>
}
    1cda:	00 00       	nop
    1cdc:	29 96       	adiw	r28, 0x09	; 9
    1cde:	0f b6       	in	r0, 0x3f	; 63
    1ce0:	f8 94       	cli
    1ce2:	de bf       	out	0x3e, r29	; 62
    1ce4:	0f be       	out	0x3f, r0	; 63
    1ce6:	cd bf       	out	0x3d, r28	; 61
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	0f 91       	pop	r16
    1cee:	ef 90       	pop	r14
    1cf0:	cf 90       	pop	r12
    1cf2:	af 90       	pop	r10
    1cf4:	8f 90       	pop	r8
    1cf6:	08 95       	ret

00001cf8 <LCD_Void_Write_Number>:

void LCD_Void_Write_Number(u32 Number)
{
    1cf8:	cf 93       	push	r28
    1cfa:	df 93       	push	r29
    1cfc:	00 d0       	rcall	.+0      	; 0x1cfe <LCD_Void_Write_Number+0x6>
    1cfe:	00 d0       	rcall	.+0      	; 0x1d00 <LCD_Void_Write_Number+0x8>
    1d00:	1f 92       	push	r1
    1d02:	cd b7       	in	r28, 0x3d	; 61
    1d04:	de b7       	in	r29, 0x3e	; 62
    1d06:	9d 83       	std	Y+5, r25	; 0x05
    1d08:	8c 83       	std	Y+4, r24	; 0x04
	u32 Reversed_Num = 0;
    1d0a:	1a 82       	std	Y+2, r1	; 0x02
    1d0c:	19 82       	std	Y+1, r1	; 0x01
	u8 count = 0;
    1d0e:	1b 82       	std	Y+3, r1	; 0x03
	while(Number > 0)
    1d10:	3c c0       	rjmp	.+120    	; 0x1d8a <LCD_Void_Write_Number+0x92>
	{
		Reversed_Num = (Number%10) + (Reversed_Num*10);
    1d12:	4c 81       	ldd	r20, Y+4	; 0x04
    1d14:	5d 81       	ldd	r21, Y+5	; 0x05
    1d16:	9a 01       	movw	r18, r20
    1d18:	ad ec       	ldi	r26, 0xCD	; 205
    1d1a:	bc ec       	ldi	r27, 0xCC	; 204
    1d1c:	0e 94 07 30 	call	0x600e	; 0x600e <__umulhisi3>
    1d20:	9c 01       	movw	r18, r24
    1d22:	36 95       	lsr	r19
    1d24:	27 95       	ror	r18
    1d26:	36 95       	lsr	r19
    1d28:	27 95       	ror	r18
    1d2a:	36 95       	lsr	r19
    1d2c:	27 95       	ror	r18
    1d2e:	c9 01       	movw	r24, r18
    1d30:	88 0f       	add	r24, r24
    1d32:	99 1f       	adc	r25, r25
    1d34:	9c 01       	movw	r18, r24
    1d36:	22 0f       	add	r18, r18
    1d38:	33 1f       	adc	r19, r19
    1d3a:	22 0f       	add	r18, r18
    1d3c:	33 1f       	adc	r19, r19
    1d3e:	82 0f       	add	r24, r18
    1d40:	93 1f       	adc	r25, r19
    1d42:	9a 01       	movw	r18, r20
    1d44:	28 1b       	sub	r18, r24
    1d46:	39 0b       	sbc	r19, r25
    1d48:	89 81       	ldd	r24, Y+1	; 0x01
    1d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4c:	88 0f       	add	r24, r24
    1d4e:	99 1f       	adc	r25, r25
    1d50:	ac 01       	movw	r20, r24
    1d52:	44 0f       	add	r20, r20
    1d54:	55 1f       	adc	r21, r21
    1d56:	44 0f       	add	r20, r20
    1d58:	55 1f       	adc	r21, r21
    1d5a:	84 0f       	add	r24, r20
    1d5c:	95 1f       	adc	r25, r21
    1d5e:	82 0f       	add	r24, r18
    1d60:	93 1f       	adc	r25, r19
    1d62:	9a 83       	std	Y+2, r25	; 0x02
    1d64:	89 83       	std	Y+1, r24	; 0x01
		Number /= 10;
    1d66:	8c 81       	ldd	r24, Y+4	; 0x04
    1d68:	9d 81       	ldd	r25, Y+5	; 0x05
    1d6a:	9c 01       	movw	r18, r24
    1d6c:	ad ec       	ldi	r26, 0xCD	; 205
    1d6e:	bc ec       	ldi	r27, 0xCC	; 204
    1d70:	0e 94 07 30 	call	0x600e	; 0x600e <__umulhisi3>
    1d74:	96 95       	lsr	r25
    1d76:	87 95       	ror	r24
    1d78:	96 95       	lsr	r25
    1d7a:	87 95       	ror	r24
    1d7c:	96 95       	lsr	r25
    1d7e:	87 95       	ror	r24
    1d80:	9d 83       	std	Y+5, r25	; 0x05
    1d82:	8c 83       	std	Y+4, r24	; 0x04
		count ++;
    1d84:	8b 81       	ldd	r24, Y+3	; 0x03
    1d86:	8f 5f       	subi	r24, 0xFF	; 255
    1d88:	8b 83       	std	Y+3, r24	; 0x03

void LCD_Void_Write_Number(u32 Number)
{
	u32 Reversed_Num = 0;
	u8 count = 0;
	while(Number > 0)
    1d8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1d8e:	89 2b       	or	r24, r25
    1d90:	09 f0       	breq	.+2      	; 0x1d94 <LCD_Void_Write_Number+0x9c>
    1d92:	bf cf       	rjmp	.-130    	; 0x1d12 <LCD_Void_Write_Number+0x1a>
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1d94:	1d 82       	std	Y+5, r1	; 0x05
    1d96:	1c 82       	std	Y+4, r1	; 0x04
    1d98:	31 c0       	rjmp	.+98     	; 0x1dfc <LCD_Void_Write_Number+0x104>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
    1d9a:	49 81       	ldd	r20, Y+1	; 0x01
    1d9c:	5a 81       	ldd	r21, Y+2	; 0x02
    1d9e:	9a 01       	movw	r18, r20
    1da0:	ad ec       	ldi	r26, 0xCD	; 205
    1da2:	bc ec       	ldi	r27, 0xCC	; 204
    1da4:	0e 94 07 30 	call	0x600e	; 0x600e <__umulhisi3>
    1da8:	96 95       	lsr	r25
    1daa:	87 95       	ror	r24
    1dac:	96 95       	lsr	r25
    1dae:	87 95       	ror	r24
    1db0:	96 95       	lsr	r25
    1db2:	87 95       	ror	r24
    1db4:	88 0f       	add	r24, r24
    1db6:	99 1f       	adc	r25, r25
    1db8:	9c 01       	movw	r18, r24
    1dba:	22 0f       	add	r18, r18
    1dbc:	33 1f       	adc	r19, r19
    1dbe:	22 0f       	add	r18, r18
    1dc0:	33 1f       	adc	r19, r19
    1dc2:	82 0f       	add	r24, r18
    1dc4:	93 1f       	adc	r25, r19
    1dc6:	9a 01       	movw	r18, r20
    1dc8:	28 1b       	sub	r18, r24
    1dca:	39 0b       	sbc	r19, r25
    1dcc:	c9 01       	movw	r24, r18
    1dce:	80 5d       	subi	r24, 0xD0	; 208
    1dd0:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
		Reversed_Num /= 10;
    1dd4:	89 81       	ldd	r24, Y+1	; 0x01
    1dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    1dd8:	9c 01       	movw	r18, r24
    1dda:	ad ec       	ldi	r26, 0xCD	; 205
    1ddc:	bc ec       	ldi	r27, 0xCC	; 204
    1dde:	0e 94 07 30 	call	0x600e	; 0x600e <__umulhisi3>
    1de2:	96 95       	lsr	r25
    1de4:	87 95       	ror	r24
    1de6:	96 95       	lsr	r25
    1de8:	87 95       	ror	r24
    1dea:	96 95       	lsr	r25
    1dec:	87 95       	ror	r24
    1dee:	9a 83       	std	Y+2, r25	; 0x02
    1df0:	89 83       	std	Y+1, r24	; 0x01
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1df2:	8c 81       	ldd	r24, Y+4	; 0x04
    1df4:	9d 81       	ldd	r25, Y+5	; 0x05
    1df6:	01 96       	adiw	r24, 0x01	; 1
    1df8:	9d 83       	std	Y+5, r25	; 0x05
    1dfa:	8c 83       	std	Y+4, r24	; 0x04
    1dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfe:	28 2f       	mov	r18, r24
    1e00:	30 e0       	ldi	r19, 0x00	; 0
    1e02:	8c 81       	ldd	r24, Y+4	; 0x04
    1e04:	9d 81       	ldd	r25, Y+5	; 0x05
    1e06:	82 17       	cp	r24, r18
    1e08:	93 07       	cpc	r25, r19
    1e0a:	38 f2       	brcs	.-114    	; 0x1d9a <LCD_Void_Write_Number+0xa2>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
		Reversed_Num /= 10;
	}

}
    1e0c:	00 00       	nop
    1e0e:	0f 90       	pop	r0
    1e10:	0f 90       	pop	r0
    1e12:	0f 90       	pop	r0
    1e14:	0f 90       	pop	r0
    1e16:	0f 90       	pop	r0
    1e18:	df 91       	pop	r29
    1e1a:	cf 91       	pop	r28
    1e1c:	08 95       	ret

00001e1e <LCD_Void_Write_Number_2>:


void LCD_Void_Write_Number_2(u8 Number)
{
    1e1e:	cf 93       	push	r28
    1e20:	df 93       	push	r29
    1e22:	1f 92       	push	r1
    1e24:	cd b7       	in	r28, 0x3d	; 61
    1e26:	de b7       	in	r29, 0x3e	; 62
    1e28:	89 83       	std	Y+1, r24	; 0x01

	LCD_Void_Write_Data((Number/10)+'0');
    1e2a:	99 81       	ldd	r25, Y+1	; 0x01
    1e2c:	8d ec       	ldi	r24, 0xCD	; 205
    1e2e:	98 9f       	mul	r25, r24
    1e30:	81 2d       	mov	r24, r1
    1e32:	11 24       	eor	r1, r1
    1e34:	86 95       	lsr	r24
    1e36:	86 95       	lsr	r24
    1e38:	86 95       	lsr	r24
    1e3a:	80 5d       	subi	r24, 0xD0	; 208
    1e3c:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>
	LCD_Void_Write_Data((Number%10)+'0');
    1e40:	99 81       	ldd	r25, Y+1	; 0x01
    1e42:	8d ec       	ldi	r24, 0xCD	; 205
    1e44:	98 9f       	mul	r25, r24
    1e46:	81 2d       	mov	r24, r1
    1e48:	11 24       	eor	r1, r1
    1e4a:	86 95       	lsr	r24
    1e4c:	86 95       	lsr	r24
    1e4e:	86 95       	lsr	r24
    1e50:	88 0f       	add	r24, r24
    1e52:	28 2f       	mov	r18, r24
    1e54:	22 0f       	add	r18, r18
    1e56:	22 0f       	add	r18, r18
    1e58:	82 0f       	add	r24, r18
    1e5a:	29 2f       	mov	r18, r25
    1e5c:	28 1b       	sub	r18, r24
    1e5e:	82 2f       	mov	r24, r18
    1e60:	80 5d       	subi	r24, 0xD0	; 208
    1e62:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <LCD_Void_Write_Data>

}
    1e66:	00 00       	nop
    1e68:	0f 90       	pop	r0
    1e6a:	df 91       	pop	r29
    1e6c:	cf 91       	pop	r28
    1e6e:	08 95       	ret

00001e70 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1e70:	cf 93       	push	r28
    1e72:	df 93       	push	r29
    1e74:	00 d0       	rcall	.+0      	; 0x1e76 <xEventGroupCreate+0x6>
    1e76:	cd b7       	in	r28, 0x3d	; 61
    1e78:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1e7a:	8b e0       	ldi	r24, 0x0B	; 11
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	0e 94 99 12 	call	0x2532	; 0x2532 <pvPortMalloc>
    1e82:	9a 83       	std	Y+2, r25	; 0x02
    1e84:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    1e86:	89 81       	ldd	r24, Y+1	; 0x01
    1e88:	9a 81       	ldd	r25, Y+2	; 0x02
    1e8a:	89 2b       	or	r24, r25
    1e8c:	51 f0       	breq	.+20     	; 0x1ea2 <xEventGroupCreate+0x32>
		{
			pxEventBits->uxEventBits = 0;
    1e8e:	89 81       	ldd	r24, Y+1	; 0x01
    1e90:	9a 81       	ldd	r25, Y+2	; 0x02
    1e92:	fc 01       	movw	r30, r24
    1e94:	11 82       	std	Z+1, r1	; 0x01
    1e96:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9c:	02 96       	adiw	r24, 0x02	; 2
    1e9e:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1ea6:	0f 90       	pop	r0
    1ea8:	0f 90       	pop	r0
    1eaa:	df 91       	pop	r29
    1eac:	cf 91       	pop	r28
    1eae:	08 95       	ret

00001eb0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1eb0:	cf 93       	push	r28
    1eb2:	df 93       	push	r29
    1eb4:	cd b7       	in	r28, 0x3d	; 61
    1eb6:	de b7       	in	r29, 0x3e	; 62
    1eb8:	60 97       	sbiw	r28, 0x10	; 16
    1eba:	0f b6       	in	r0, 0x3f	; 63
    1ebc:	f8 94       	cli
    1ebe:	de bf       	out	0x3e, r29	; 62
    1ec0:	0f be       	out	0x3f, r0	; 63
    1ec2:	cd bf       	out	0x3d, r28	; 61
    1ec4:	9a 87       	std	Y+10, r25	; 0x0a
    1ec6:	89 87       	std	Y+9, r24	; 0x09
    1ec8:	7c 87       	std	Y+12, r23	; 0x0c
    1eca:	6b 87       	std	Y+11, r22	; 0x0b
    1ecc:	5e 87       	std	Y+14, r21	; 0x0e
    1ece:	4d 87       	std	Y+13, r20	; 0x0d
    1ed0:	38 8b       	std	Y+16, r19	; 0x10
    1ed2:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    1ed4:	89 85       	ldd	r24, Y+9	; 0x09
    1ed6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ed8:	9c 83       	std	Y+4, r25	; 0x04
    1eda:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1edc:	1d 82       	std	Y+5, r1	; 0x05
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1ede:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee6:	fc 01       	movw	r30, r24
    1ee8:	80 81       	ld	r24, Z
    1eea:	91 81       	ldd	r25, Z+1	; 0x01
    1eec:	9f 83       	std	Y+7, r25	; 0x07
    1eee:	8e 83       	std	Y+6, r24	; 0x06

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1ef0:	2b 85       	ldd	r18, Y+11	; 0x0b
    1ef2:	3c 85       	ldd	r19, Y+12	; 0x0c
    1ef4:	89 85       	ldd	r24, Y+9	; 0x09
    1ef6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ef8:	b9 01       	movw	r22, r18
    1efa:	0e 94 3a 11 	call	0x2274	; 0x2274 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1efe:	2e 81       	ldd	r18, Y+6	; 0x06
    1f00:	3f 81       	ldd	r19, Y+7	; 0x07
    1f02:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f04:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f06:	28 2b       	or	r18, r24
    1f08:	39 2b       	or	r19, r25
    1f0a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f0c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f0e:	28 23       	and	r18, r24
    1f10:	39 23       	and	r19, r25
    1f12:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f14:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f16:	28 17       	cp	r18, r24
    1f18:	39 07       	cpc	r19, r25
    1f1a:	d9 f4       	brne	.+54     	; 0x1f52 <xEventGroupSync+0xa2>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1f1c:	2e 81       	ldd	r18, Y+6	; 0x06
    1f1e:	3f 81       	ldd	r19, Y+7	; 0x07
    1f20:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f22:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f24:	82 2b       	or	r24, r18
    1f26:	93 2b       	or	r25, r19
    1f28:	9a 83       	std	Y+2, r25	; 0x02
    1f2a:	89 83       	std	Y+1, r24	; 0x01

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f30:	fc 01       	movw	r30, r24
    1f32:	20 81       	ld	r18, Z
    1f34:	31 81       	ldd	r19, Z+1	; 0x01
    1f36:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f38:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f3a:	80 95       	com	r24
    1f3c:	90 95       	com	r25
    1f3e:	28 23       	and	r18, r24
    1f40:	39 23       	and	r19, r25
    1f42:	8b 81       	ldd	r24, Y+3	; 0x03
    1f44:	9c 81       	ldd	r25, Y+4	; 0x04
    1f46:	fc 01       	movw	r30, r24
    1f48:	31 83       	std	Z+1, r19	; 0x01
    1f4a:	20 83       	st	Z, r18

			xTicksToWait = 0;
    1f4c:	18 8a       	std	Y+16, r1	; 0x10
    1f4e:	1f 86       	std	Y+15, r1	; 0x0f
    1f50:	1c c0       	rjmp	.+56     	; 0x1f8a <xEventGroupSync+0xda>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1f52:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f54:	98 89       	ldd	r25, Y+16	; 0x10
    1f56:	89 2b       	or	r24, r25
    1f58:	79 f0       	breq	.+30     	; 0x1f78 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1f5a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f5c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f5e:	9c 01       	movw	r18, r24
    1f60:	35 60       	ori	r19, 0x05	; 5
    1f62:	8b 81       	ldd	r24, Y+3	; 0x03
    1f64:	9c 81       	ldd	r25, Y+4	; 0x04
    1f66:	02 96       	adiw	r24, 0x02	; 2
    1f68:	4f 85       	ldd	r20, Y+15	; 0x0f
    1f6a:	58 89       	ldd	r21, Y+16	; 0x10
    1f6c:	b9 01       	movw	r22, r18
    1f6e:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1f72:	1a 82       	std	Y+2, r1	; 0x02
    1f74:	19 82       	std	Y+1, r1	; 0x01
    1f76:	09 c0       	rjmp	.+18     	; 0x1f8a <xEventGroupSync+0xda>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1f78:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f7c:	fc 01       	movw	r30, r24
    1f7e:	80 81       	ld	r24, Z
    1f80:	91 81       	ldd	r25, Z+1	; 0x01
    1f82:	9a 83       	std	Y+2, r25	; 0x02
    1f84:	89 83       	std	Y+1, r24	; 0x01
				xTimeoutOccurred = pdTRUE;
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1f8a:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    1f8e:	88 87       	std	Y+8, r24	; 0x08

	if( xTicksToWait != ( TickType_t ) 0 )
    1f90:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f92:	98 89       	ldd	r25, Y+16	; 0x10
    1f94:	89 2b       	or	r24, r25
    1f96:	09 f4       	brne	.+2      	; 0x1f9a <xEventGroupSync+0xea>
    1f98:	3d c0       	rjmp	.+122    	; 0x2014 <xEventGroupSync+0x164>
	{
		if( xAlreadyYielded == pdFALSE )
    1f9a:	88 85       	ldd	r24, Y+8	; 0x08
    1f9c:	88 23       	and	r24, r24
    1f9e:	11 f4       	brne	.+4      	; 0x1fa4 <xEventGroupSync+0xf4>
		{
			portYIELD_WITHIN_API();
    1fa0:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1fa4:	0e 94 8b 2b 	call	0x5716	; 0x5716 <uxTaskResetEventItemValue>
    1fa8:	9a 83       	std	Y+2, r25	; 0x02
    1faa:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1fac:	89 81       	ldd	r24, Y+1	; 0x01
    1fae:	9a 81       	ldd	r25, Y+2	; 0x02
    1fb0:	88 27       	eor	r24, r24
    1fb2:	92 70       	andi	r25, 0x02	; 2
    1fb4:	89 2b       	or	r24, r25
    1fb6:	49 f5       	brne	.+82     	; 0x200a <xEventGroupSync+0x15a>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1fb8:	0f b6       	in	r0, 0x3f	; 63
    1fba:	f8 94       	cli
    1fbc:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	80 81       	ld	r24, Z
    1fc6:	91 81       	ldd	r25, Z+1	; 0x01
    1fc8:	9a 83       	std	Y+2, r25	; 0x02
    1fca:	89 83       	std	Y+1, r24	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1fcc:	29 81       	ldd	r18, Y+1	; 0x01
    1fce:	3a 81       	ldd	r19, Y+2	; 0x02
    1fd0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fd2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fd4:	28 23       	and	r18, r24
    1fd6:	39 23       	and	r19, r25
    1fd8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fda:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fdc:	28 17       	cp	r18, r24
    1fde:	39 07       	cpc	r19, r25
    1fe0:	81 f4       	brne	.+32     	; 0x2002 <xEventGroupSync+0x152>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1fe2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe6:	fc 01       	movw	r30, r24
    1fe8:	20 81       	ld	r18, Z
    1fea:	31 81       	ldd	r19, Z+1	; 0x01
    1fec:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fee:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ff0:	80 95       	com	r24
    1ff2:	90 95       	com	r25
    1ff4:	28 23       	and	r18, r24
    1ff6:	39 23       	and	r19, r25
    1ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffc:	fc 01       	movw	r30, r24
    1ffe:	31 83       	std	Z+1, r19	; 0x01
    2000:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2002:	0f 90       	pop	r0
    2004:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2006:	81 e0       	ldi	r24, 0x01	; 1
    2008:	8d 83       	std	Y+5, r24	; 0x05
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    200a:	89 81       	ldd	r24, Y+1	; 0x01
    200c:	9a 81       	ldd	r25, Y+2	; 0x02
    200e:	99 27       	eor	r25, r25
    2010:	9a 83       	std	Y+2, r25	; 0x02
    2012:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2014:	89 81       	ldd	r24, Y+1	; 0x01
    2016:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2018:	60 96       	adiw	r28, 0x10	; 16
    201a:	0f b6       	in	r0, 0x3f	; 63
    201c:	f8 94       	cli
    201e:	de bf       	out	0x3e, r29	; 62
    2020:	0f be       	out	0x3f, r0	; 63
    2022:	cd bf       	out	0x3d, r28	; 61
    2024:	df 91       	pop	r29
    2026:	cf 91       	pop	r28
    2028:	08 95       	ret

0000202a <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    202a:	0f 93       	push	r16
    202c:	1f 93       	push	r17
    202e:	cf 93       	push	r28
    2030:	df 93       	push	r29
    2032:	cd b7       	in	r28, 0x3d	; 61
    2034:	de b7       	in	r29, 0x3e	; 62
    2036:	63 97       	sbiw	r28, 0x13	; 19
    2038:	0f b6       	in	r0, 0x3f	; 63
    203a:	f8 94       	cli
    203c:	de bf       	out	0x3e, r29	; 62
    203e:	0f be       	out	0x3f, r0	; 63
    2040:	cd bf       	out	0x3d, r28	; 61
    2042:	9d 87       	std	Y+13, r25	; 0x0d
    2044:	8c 87       	std	Y+12, r24	; 0x0c
    2046:	7f 87       	std	Y+15, r23	; 0x0f
    2048:	6e 87       	std	Y+14, r22	; 0x0e
    204a:	48 8b       	std	Y+16, r20	; 0x10
    204c:	29 8b       	std	Y+17, r18	; 0x11
    204e:	1b 8b       	std	Y+19, r17	; 0x13
    2050:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    2052:	8c 85       	ldd	r24, Y+12	; 0x0c
    2054:	9d 85       	ldd	r25, Y+13	; 0x0d
    2056:	9e 83       	std	Y+6, r25	; 0x06
    2058:	8d 83       	std	Y+5, r24	; 0x05
EventBits_t uxReturn, uxControlBits = 0;
    205a:	1c 82       	std	Y+4, r1	; 0x04
    205c:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    205e:	1f 82       	std	Y+7, r1	; 0x07
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2060:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2064:	8d 81       	ldd	r24, Y+5	; 0x05
    2066:	9e 81       	ldd	r25, Y+6	; 0x06
    2068:	fc 01       	movw	r30, r24
    206a:	80 81       	ld	r24, Z
    206c:	91 81       	ldd	r25, Z+1	; 0x01
    206e:	99 87       	std	Y+9, r25	; 0x09
    2070:	88 87       	std	Y+8, r24	; 0x08

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2072:	2e 85       	ldd	r18, Y+14	; 0x0e
    2074:	3f 85       	ldd	r19, Y+15	; 0x0f
    2076:	88 85       	ldd	r24, Y+8	; 0x08
    2078:	99 85       	ldd	r25, Y+9	; 0x09
    207a:	49 89       	ldd	r20, Y+17	; 0x11
    207c:	b9 01       	movw	r22, r18
    207e:	0e 94 67 12 	call	0x24ce	; 0x24ce <prvTestWaitCondition>
    2082:	8a 87       	std	Y+10, r24	; 0x0a

		if( xWaitConditionMet != pdFALSE )
    2084:	8a 85       	ldd	r24, Y+10	; 0x0a
    2086:	88 23       	and	r24, r24
    2088:	d1 f0       	breq	.+52     	; 0x20be <xEventGroupWaitBits+0x94>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    208a:	88 85       	ldd	r24, Y+8	; 0x08
    208c:	99 85       	ldd	r25, Y+9	; 0x09
    208e:	9a 83       	std	Y+2, r25	; 0x02
    2090:	89 83       	std	Y+1, r24	; 0x01
			xTicksToWait = ( TickType_t ) 0;
    2092:	1b 8a       	std	Y+19, r1	; 0x13
    2094:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2096:	88 89       	ldd	r24, Y+16	; 0x10
    2098:	88 23       	and	r24, r24
    209a:	e1 f1       	breq	.+120    	; 0x2114 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    209c:	8d 81       	ldd	r24, Y+5	; 0x05
    209e:	9e 81       	ldd	r25, Y+6	; 0x06
    20a0:	fc 01       	movw	r30, r24
    20a2:	20 81       	ld	r18, Z
    20a4:	31 81       	ldd	r19, Z+1	; 0x01
    20a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    20a8:	9f 85       	ldd	r25, Y+15	; 0x0f
    20aa:	80 95       	com	r24
    20ac:	90 95       	com	r25
    20ae:	28 23       	and	r18, r24
    20b0:	39 23       	and	r19, r25
    20b2:	8d 81       	ldd	r24, Y+5	; 0x05
    20b4:	9e 81       	ldd	r25, Y+6	; 0x06
    20b6:	fc 01       	movw	r30, r24
    20b8:	31 83       	std	Z+1, r19	; 0x01
    20ba:	20 83       	st	Z, r18
    20bc:	2b c0       	rjmp	.+86     	; 0x2114 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    20be:	8a 89       	ldd	r24, Y+18	; 0x12
    20c0:	9b 89       	ldd	r25, Y+19	; 0x13
    20c2:	89 2b       	or	r24, r25
    20c4:	39 f4       	brne	.+14     	; 0x20d4 <xEventGroupWaitBits+0xaa>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    20c6:	88 85       	ldd	r24, Y+8	; 0x08
    20c8:	99 85       	ldd	r25, Y+9	; 0x09
    20ca:	9a 83       	std	Y+2, r25	; 0x02
    20cc:	89 83       	std	Y+1, r24	; 0x01
			xTimeoutOccurred = pdTRUE;
    20ce:	81 e0       	ldi	r24, 0x01	; 1
    20d0:	8f 83       	std	Y+7, r24	; 0x07
    20d2:	20 c0       	rjmp	.+64     	; 0x2114 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    20d4:	88 89       	ldd	r24, Y+16	; 0x10
    20d6:	88 23       	and	r24, r24
    20d8:	29 f0       	breq	.+10     	; 0x20e4 <xEventGroupWaitBits+0xba>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    20da:	8b 81       	ldd	r24, Y+3	; 0x03
    20dc:	9c 81       	ldd	r25, Y+4	; 0x04
    20de:	91 60       	ori	r25, 0x01	; 1
    20e0:	9c 83       	std	Y+4, r25	; 0x04
    20e2:	8b 83       	std	Y+3, r24	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    20e4:	89 89       	ldd	r24, Y+17	; 0x11
    20e6:	88 23       	and	r24, r24
    20e8:	29 f0       	breq	.+10     	; 0x20f4 <xEventGroupWaitBits+0xca>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    20ea:	8b 81       	ldd	r24, Y+3	; 0x03
    20ec:	9c 81       	ldd	r25, Y+4	; 0x04
    20ee:	94 60       	ori	r25, 0x04	; 4
    20f0:	9c 83       	std	Y+4, r25	; 0x04
    20f2:	8b 83       	std	Y+3, r24	; 0x03
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    20f4:	2e 85       	ldd	r18, Y+14	; 0x0e
    20f6:	3f 85       	ldd	r19, Y+15	; 0x0f
    20f8:	8b 81       	ldd	r24, Y+3	; 0x03
    20fa:	9c 81       	ldd	r25, Y+4	; 0x04
    20fc:	28 2b       	or	r18, r24
    20fe:	39 2b       	or	r19, r25
    2100:	8d 81       	ldd	r24, Y+5	; 0x05
    2102:	9e 81       	ldd	r25, Y+6	; 0x06
    2104:	02 96       	adiw	r24, 0x02	; 2
    2106:	4a 89       	ldd	r20, Y+18	; 0x12
    2108:	5b 89       	ldd	r21, Y+19	; 0x13
    210a:	b9 01       	movw	r22, r18
    210c:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2110:	1a 82       	std	Y+2, r1	; 0x02
    2112:	19 82       	std	Y+1, r1	; 0x01

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2114:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    2118:	8b 87       	std	Y+11, r24	; 0x0b

	if( xTicksToWait != ( TickType_t ) 0 )
    211a:	8a 89       	ldd	r24, Y+18	; 0x12
    211c:	9b 89       	ldd	r25, Y+19	; 0x13
    211e:	89 2b       	or	r24, r25
    2120:	09 f4       	brne	.+2      	; 0x2124 <xEventGroupWaitBits+0xfa>
    2122:	3f c0       	rjmp	.+126    	; 0x21a2 <xEventGroupWaitBits+0x178>
	{
		if( xAlreadyYielded == pdFALSE )
    2124:	8b 85       	ldd	r24, Y+11	; 0x0b
    2126:	88 23       	and	r24, r24
    2128:	11 f4       	brne	.+4      	; 0x212e <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    212a:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    212e:	0e 94 8b 2b 	call	0x5716	; 0x5716 <uxTaskResetEventItemValue>
    2132:	9a 83       	std	Y+2, r25	; 0x02
    2134:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2136:	89 81       	ldd	r24, Y+1	; 0x01
    2138:	9a 81       	ldd	r25, Y+2	; 0x02
    213a:	88 27       	eor	r24, r24
    213c:	92 70       	andi	r25, 0x02	; 2
    213e:	89 2b       	or	r24, r25
    2140:	59 f5       	brne	.+86     	; 0x2198 <xEventGroupWaitBits+0x16e>
		{
			taskENTER_CRITICAL();
    2142:	0f b6       	in	r0, 0x3f	; 63
    2144:	f8 94       	cli
    2146:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2148:	8d 81       	ldd	r24, Y+5	; 0x05
    214a:	9e 81       	ldd	r25, Y+6	; 0x06
    214c:	fc 01       	movw	r30, r24
    214e:	80 81       	ld	r24, Z
    2150:	91 81       	ldd	r25, Z+1	; 0x01
    2152:	9a 83       	std	Y+2, r25	; 0x02
    2154:	89 83       	std	Y+1, r24	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2156:	2e 85       	ldd	r18, Y+14	; 0x0e
    2158:	3f 85       	ldd	r19, Y+15	; 0x0f
    215a:	89 81       	ldd	r24, Y+1	; 0x01
    215c:	9a 81       	ldd	r25, Y+2	; 0x02
    215e:	49 89       	ldd	r20, Y+17	; 0x11
    2160:	b9 01       	movw	r22, r18
    2162:	0e 94 67 12 	call	0x24ce	; 0x24ce <prvTestWaitCondition>
    2166:	88 23       	and	r24, r24
    2168:	99 f0       	breq	.+38     	; 0x2190 <xEventGroupWaitBits+0x166>
				{
					if( xClearOnExit != pdFALSE )
    216a:	88 89       	ldd	r24, Y+16	; 0x10
    216c:	88 23       	and	r24, r24
    216e:	81 f0       	breq	.+32     	; 0x2190 <xEventGroupWaitBits+0x166>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2170:	8d 81       	ldd	r24, Y+5	; 0x05
    2172:	9e 81       	ldd	r25, Y+6	; 0x06
    2174:	fc 01       	movw	r30, r24
    2176:	20 81       	ld	r18, Z
    2178:	31 81       	ldd	r19, Z+1	; 0x01
    217a:	8e 85       	ldd	r24, Y+14	; 0x0e
    217c:	9f 85       	ldd	r25, Y+15	; 0x0f
    217e:	80 95       	com	r24
    2180:	90 95       	com	r25
    2182:	28 23       	and	r18, r24
    2184:	39 23       	and	r19, r25
    2186:	8d 81       	ldd	r24, Y+5	; 0x05
    2188:	9e 81       	ldd	r25, Y+6	; 0x06
    218a:	fc 01       	movw	r30, r24
    218c:	31 83       	std	Z+1, r19	; 0x01
    218e:	20 83       	st	Z, r18
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    2190:	81 e0       	ldi	r24, 0x01	; 1
    2192:	8f 83       	std	Y+7, r24	; 0x07
			}
			taskEXIT_CRITICAL();
    2194:	0f 90       	pop	r0
    2196:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2198:	89 81       	ldd	r24, Y+1	; 0x01
    219a:	9a 81       	ldd	r25, Y+2	; 0x02
    219c:	99 27       	eor	r25, r25
    219e:	9a 83       	std	Y+2, r25	; 0x02
    21a0:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    21a2:	89 81       	ldd	r24, Y+1	; 0x01
    21a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    21a6:	63 96       	adiw	r28, 0x13	; 19
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	de bf       	out	0x3e, r29	; 62
    21ae:	0f be       	out	0x3f, r0	; 63
    21b0:	cd bf       	out	0x3d, r28	; 61
    21b2:	df 91       	pop	r29
    21b4:	cf 91       	pop	r28
    21b6:	1f 91       	pop	r17
    21b8:	0f 91       	pop	r16
    21ba:	08 95       	ret

000021bc <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    21bc:	cf 93       	push	r28
    21be:	df 93       	push	r29
    21c0:	cd b7       	in	r28, 0x3d	; 61
    21c2:	de b7       	in	r29, 0x3e	; 62
    21c4:	28 97       	sbiw	r28, 0x08	; 8
    21c6:	0f b6       	in	r0, 0x3f	; 63
    21c8:	f8 94       	cli
    21ca:	de bf       	out	0x3e, r29	; 62
    21cc:	0f be       	out	0x3f, r0	; 63
    21ce:	cd bf       	out	0x3d, r28	; 61
    21d0:	9e 83       	std	Y+6, r25	; 0x06
    21d2:	8d 83       	std	Y+5, r24	; 0x05
    21d4:	78 87       	std	Y+8, r23	; 0x08
    21d6:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    21d8:	8d 81       	ldd	r24, Y+5	; 0x05
    21da:	9e 81       	ldd	r25, Y+6	; 0x06
    21dc:	9a 83       	std	Y+2, r25	; 0x02
    21de:	89 83       	std	Y+1, r24	; 0x01
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
    21e4:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    21e6:	89 81       	ldd	r24, Y+1	; 0x01
    21e8:	9a 81       	ldd	r25, Y+2	; 0x02
    21ea:	fc 01       	movw	r30, r24
    21ec:	80 81       	ld	r24, Z
    21ee:	91 81       	ldd	r25, Z+1	; 0x01
    21f0:	9c 83       	std	Y+4, r25	; 0x04
    21f2:	8b 83       	std	Y+3, r24	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    21f4:	89 81       	ldd	r24, Y+1	; 0x01
    21f6:	9a 81       	ldd	r25, Y+2	; 0x02
    21f8:	fc 01       	movw	r30, r24
    21fa:	20 81       	ld	r18, Z
    21fc:	31 81       	ldd	r19, Z+1	; 0x01
    21fe:	8f 81       	ldd	r24, Y+7	; 0x07
    2200:	98 85       	ldd	r25, Y+8	; 0x08
    2202:	80 95       	com	r24
    2204:	90 95       	com	r25
    2206:	28 23       	and	r18, r24
    2208:	39 23       	and	r19, r25
    220a:	89 81       	ldd	r24, Y+1	; 0x01
    220c:	9a 81       	ldd	r25, Y+2	; 0x02
    220e:	fc 01       	movw	r30, r24
    2210:	31 83       	std	Z+1, r19	; 0x01
    2212:	20 83       	st	Z, r18
	}
	taskEXIT_CRITICAL();
    2214:	0f 90       	pop	r0
    2216:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2218:	8b 81       	ldd	r24, Y+3	; 0x03
    221a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    221c:	28 96       	adiw	r28, 0x08	; 8
    221e:	0f b6       	in	r0, 0x3f	; 63
    2220:	f8 94       	cli
    2222:	de bf       	out	0x3e, r29	; 62
    2224:	0f be       	out	0x3f, r0	; 63
    2226:	cd bf       	out	0x3d, r28	; 61
    2228:	df 91       	pop	r29
    222a:	cf 91       	pop	r28
    222c:	08 95       	ret

0000222e <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    222e:	cf 93       	push	r28
    2230:	df 93       	push	r29
    2232:	cd b7       	in	r28, 0x3d	; 61
    2234:	de b7       	in	r29, 0x3e	; 62
    2236:	27 97       	sbiw	r28, 0x07	; 7
    2238:	0f b6       	in	r0, 0x3f	; 63
    223a:	f8 94       	cli
    223c:	de bf       	out	0x3e, r29	; 62
    223e:	0f be       	out	0x3f, r0	; 63
    2240:	cd bf       	out	0x3d, r28	; 61
    2242:	9f 83       	std	Y+7, r25	; 0x07
    2244:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    2246:	8e 81       	ldd	r24, Y+6	; 0x06
    2248:	9f 81       	ldd	r25, Y+7	; 0x07
    224a:	9a 83       	std	Y+2, r25	; 0x02
    224c:	89 83       	std	Y+1, r24	; 0x01
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    224e:	1b 82       	std	Y+3, r1	; 0x03
	{
		uxReturn = pxEventBits->uxEventBits;
    2250:	89 81       	ldd	r24, Y+1	; 0x01
    2252:	9a 81       	ldd	r25, Y+2	; 0x02
    2254:	fc 01       	movw	r30, r24
    2256:	80 81       	ld	r24, Z
    2258:	91 81       	ldd	r25, Z+1	; 0x01
    225a:	9d 83       	std	Y+5, r25	; 0x05
    225c:	8c 83       	std	Y+4, r24	; 0x04
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    225e:	8c 81       	ldd	r24, Y+4	; 0x04
    2260:	9d 81       	ldd	r25, Y+5	; 0x05
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2262:	27 96       	adiw	r28, 0x07	; 7
    2264:	0f b6       	in	r0, 0x3f	; 63
    2266:	f8 94       	cli
    2268:	de bf       	out	0x3e, r29	; 62
    226a:	0f be       	out	0x3f, r0	; 63
    226c:	cd bf       	out	0x3d, r28	; 61
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	08 95       	ret

00002274 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2274:	cf 93       	push	r28
    2276:	df 93       	push	r29
    2278:	cd b7       	in	r28, 0x3d	; 61
    227a:	de b7       	in	r29, 0x3e	; 62
    227c:	65 97       	sbiw	r28, 0x15	; 21
    227e:	0f b6       	in	r0, 0x3f	; 63
    2280:	f8 94       	cli
    2282:	de bf       	out	0x3e, r29	; 62
    2284:	0f be       	out	0x3f, r0	; 63
    2286:	cd bf       	out	0x3d, r28	; 61
    2288:	9b 8b       	std	Y+19, r25	; 0x13
    228a:	8a 8b       	std	Y+18, r24	; 0x12
    228c:	7d 8b       	std	Y+21, r23	; 0x15
    228e:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2290:	1c 82       	std	Y+4, r1	; 0x04
    2292:	1b 82       	std	Y+3, r1	; 0x03
EventGroup_t *pxEventBits = xEventGroup;
    2294:	8a 89       	ldd	r24, Y+18	; 0x12
    2296:	9b 89       	ldd	r25, Y+19	; 0x13
    2298:	9f 83       	std	Y+7, r25	; 0x07
    229a:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xMatchFound = pdFALSE;
    229c:	1d 82       	std	Y+5, r1	; 0x05
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    229e:	8e 81       	ldd	r24, Y+6	; 0x06
    22a0:	9f 81       	ldd	r25, Y+7	; 0x07
    22a2:	02 96       	adiw	r24, 0x02	; 2
    22a4:	99 87       	std	Y+9, r25	; 0x09
    22a6:	88 87       	std	Y+8, r24	; 0x08
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    22a8:	88 85       	ldd	r24, Y+8	; 0x08
    22aa:	99 85       	ldd	r25, Y+9	; 0x09
    22ac:	03 96       	adiw	r24, 0x03	; 3
    22ae:	9b 87       	std	Y+11, r25	; 0x0b
    22b0:	8a 87       	std	Y+10, r24	; 0x0a
	vTaskSuspendAll();
    22b2:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    22b6:	88 85       	ldd	r24, Y+8	; 0x08
    22b8:	99 85       	ldd	r25, Y+9	; 0x09
    22ba:	fc 01       	movw	r30, r24
    22bc:	85 81       	ldd	r24, Z+5	; 0x05
    22be:	96 81       	ldd	r25, Z+6	; 0x06
    22c0:	9a 83       	std	Y+2, r25	; 0x02
    22c2:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    22c4:	8e 81       	ldd	r24, Y+6	; 0x06
    22c6:	9f 81       	ldd	r25, Y+7	; 0x07
    22c8:	fc 01       	movw	r30, r24
    22ca:	20 81       	ld	r18, Z
    22cc:	31 81       	ldd	r19, Z+1	; 0x01
    22ce:	8c 89       	ldd	r24, Y+20	; 0x14
    22d0:	9d 89       	ldd	r25, Y+21	; 0x15
    22d2:	28 2b       	or	r18, r24
    22d4:	39 2b       	or	r19, r25
    22d6:	8e 81       	ldd	r24, Y+6	; 0x06
    22d8:	9f 81       	ldd	r25, Y+7	; 0x07
    22da:	fc 01       	movw	r30, r24
    22dc:	31 83       	std	Z+1, r19	; 0x01
    22de:	20 83       	st	Z, r18

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    22e0:	5e c0       	rjmp	.+188    	; 0x239e <xEventGroupSetBits+0x12a>
		{
			pxNext = listGET_NEXT( pxListItem );
    22e2:	89 81       	ldd	r24, Y+1	; 0x01
    22e4:	9a 81       	ldd	r25, Y+2	; 0x02
    22e6:	fc 01       	movw	r30, r24
    22e8:	82 81       	ldd	r24, Z+2	; 0x02
    22ea:	93 81       	ldd	r25, Z+3	; 0x03
    22ec:	9d 87       	std	Y+13, r25	; 0x0d
    22ee:	8c 87       	std	Y+12, r24	; 0x0c
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    22f0:	89 81       	ldd	r24, Y+1	; 0x01
    22f2:	9a 81       	ldd	r25, Y+2	; 0x02
    22f4:	fc 01       	movw	r30, r24
    22f6:	80 81       	ld	r24, Z
    22f8:	91 81       	ldd	r25, Z+1	; 0x01
    22fa:	9f 87       	std	Y+15, r25	; 0x0f
    22fc:	8e 87       	std	Y+14, r24	; 0x0e
			xMatchFound = pdFALSE;
    22fe:	1d 82       	std	Y+5, r1	; 0x05

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2300:	8e 85       	ldd	r24, Y+14	; 0x0e
    2302:	9f 85       	ldd	r25, Y+15	; 0x0f
    2304:	88 27       	eor	r24, r24
    2306:	99 8b       	std	Y+17, r25	; 0x11
    2308:	88 8b       	std	Y+16, r24	; 0x10
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    230a:	8e 85       	ldd	r24, Y+14	; 0x0e
    230c:	9f 85       	ldd	r25, Y+15	; 0x0f
    230e:	99 27       	eor	r25, r25
    2310:	9f 87       	std	Y+15, r25	; 0x0f
    2312:	8e 87       	std	Y+14, r24	; 0x0e

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2314:	88 89       	ldd	r24, Y+16	; 0x10
    2316:	99 89       	ldd	r25, Y+17	; 0x11
    2318:	88 27       	eor	r24, r24
    231a:	94 70       	andi	r25, 0x04	; 4
    231c:	89 2b       	or	r24, r25
    231e:	71 f4       	brne	.+28     	; 0x233c <xEventGroupSetBits+0xc8>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2320:	8e 81       	ldd	r24, Y+6	; 0x06
    2322:	9f 81       	ldd	r25, Y+7	; 0x07
    2324:	fc 01       	movw	r30, r24
    2326:	20 81       	ld	r18, Z
    2328:	31 81       	ldd	r19, Z+1	; 0x01
    232a:	8e 85       	ldd	r24, Y+14	; 0x0e
    232c:	9f 85       	ldd	r25, Y+15	; 0x0f
    232e:	82 23       	and	r24, r18
    2330:	93 23       	and	r25, r19
    2332:	89 2b       	or	r24, r25
    2334:	99 f0       	breq	.+38     	; 0x235c <xEventGroupSetBits+0xe8>
				{
					xMatchFound = pdTRUE;
    2336:	81 e0       	ldi	r24, 0x01	; 1
    2338:	8d 83       	std	Y+5, r24	; 0x05
    233a:	10 c0       	rjmp	.+32     	; 0x235c <xEventGroupSetBits+0xe8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    233c:	8e 81       	ldd	r24, Y+6	; 0x06
    233e:	9f 81       	ldd	r25, Y+7	; 0x07
    2340:	fc 01       	movw	r30, r24
    2342:	20 81       	ld	r18, Z
    2344:	31 81       	ldd	r19, Z+1	; 0x01
    2346:	8e 85       	ldd	r24, Y+14	; 0x0e
    2348:	9f 85       	ldd	r25, Y+15	; 0x0f
    234a:	28 23       	and	r18, r24
    234c:	39 23       	and	r19, r25
    234e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2350:	9f 85       	ldd	r25, Y+15	; 0x0f
    2352:	28 17       	cp	r18, r24
    2354:	39 07       	cpc	r19, r25
    2356:	11 f4       	brne	.+4      	; 0x235c <xEventGroupSetBits+0xe8>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    2358:	81 e0       	ldi	r24, 0x01	; 1
    235a:	8d 83       	std	Y+5, r24	; 0x05
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    235c:	8d 81       	ldd	r24, Y+5	; 0x05
    235e:	88 23       	and	r24, r24
    2360:	d1 f0       	breq	.+52     	; 0x2396 <xEventGroupSetBits+0x122>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2362:	88 89       	ldd	r24, Y+16	; 0x10
    2364:	99 89       	ldd	r25, Y+17	; 0x11
    2366:	88 27       	eor	r24, r24
    2368:	91 70       	andi	r25, 0x01	; 1
    236a:	89 2b       	or	r24, r25
    236c:	41 f0       	breq	.+16     	; 0x237e <xEventGroupSetBits+0x10a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    236e:	2b 81       	ldd	r18, Y+3	; 0x03
    2370:	3c 81       	ldd	r19, Y+4	; 0x04
    2372:	8e 85       	ldd	r24, Y+14	; 0x0e
    2374:	9f 85       	ldd	r25, Y+15	; 0x0f
    2376:	82 2b       	or	r24, r18
    2378:	93 2b       	or	r25, r19
    237a:	9c 83       	std	Y+4, r25	; 0x04
    237c:	8b 83       	std	Y+3, r24	; 0x03
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    237e:	8e 81       	ldd	r24, Y+6	; 0x06
    2380:	9f 81       	ldd	r25, Y+7	; 0x07
    2382:	fc 01       	movw	r30, r24
    2384:	80 81       	ld	r24, Z
    2386:	91 81       	ldd	r25, Z+1	; 0x01
    2388:	9c 01       	movw	r18, r24
    238a:	32 60       	ori	r19, 0x02	; 2
    238c:	89 81       	ldd	r24, Y+1	; 0x01
    238e:	9a 81       	ldd	r25, Y+2	; 0x02
    2390:	b9 01       	movw	r22, r18
    2392:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2396:	8c 85       	ldd	r24, Y+12	; 0x0c
    2398:	9d 85       	ldd	r25, Y+13	; 0x0d
    239a:	9a 83       	std	Y+2, r25	; 0x02
    239c:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    239e:	29 81       	ldd	r18, Y+1	; 0x01
    23a0:	3a 81       	ldd	r19, Y+2	; 0x02
    23a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    23a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    23a6:	28 17       	cp	r18, r24
    23a8:	39 07       	cpc	r19, r25
    23aa:	09 f0       	breq	.+2      	; 0x23ae <xEventGroupSetBits+0x13a>
    23ac:	9a cf       	rjmp	.-204    	; 0x22e2 <xEventGroupSetBits+0x6e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    23ae:	8e 81       	ldd	r24, Y+6	; 0x06
    23b0:	9f 81       	ldd	r25, Y+7	; 0x07
    23b2:	fc 01       	movw	r30, r24
    23b4:	20 81       	ld	r18, Z
    23b6:	31 81       	ldd	r19, Z+1	; 0x01
    23b8:	8b 81       	ldd	r24, Y+3	; 0x03
    23ba:	9c 81       	ldd	r25, Y+4	; 0x04
    23bc:	80 95       	com	r24
    23be:	90 95       	com	r25
    23c0:	28 23       	and	r18, r24
    23c2:	39 23       	and	r19, r25
    23c4:	8e 81       	ldd	r24, Y+6	; 0x06
    23c6:	9f 81       	ldd	r25, Y+7	; 0x07
    23c8:	fc 01       	movw	r30, r24
    23ca:	31 83       	std	Z+1, r19	; 0x01
    23cc:	20 83       	st	Z, r18
	}
	( void ) xTaskResumeAll();
    23ce:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    23d2:	8e 81       	ldd	r24, Y+6	; 0x06
    23d4:	9f 81       	ldd	r25, Y+7	; 0x07
    23d6:	fc 01       	movw	r30, r24
    23d8:	80 81       	ld	r24, Z
    23da:	91 81       	ldd	r25, Z+1	; 0x01
}
    23dc:	65 96       	adiw	r28, 0x15	; 21
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	de bf       	out	0x3e, r29	; 62
    23e4:	0f be       	out	0x3f, r0	; 63
    23e6:	cd bf       	out	0x3d, r28	; 61
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	08 95       	ret

000023ee <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    23ee:	cf 93       	push	r28
    23f0:	df 93       	push	r29
    23f2:	00 d0       	rcall	.+0      	; 0x23f4 <vEventGroupDelete+0x6>
    23f4:	00 d0       	rcall	.+0      	; 0x23f6 <vEventGroupDelete+0x8>
    23f6:	00 d0       	rcall	.+0      	; 0x23f8 <vEventGroupDelete+0xa>
    23f8:	cd b7       	in	r28, 0x3d	; 61
    23fa:	de b7       	in	r29, 0x3e	; 62
    23fc:	9e 83       	std	Y+6, r25	; 0x06
    23fe:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    2400:	8d 81       	ldd	r24, Y+5	; 0x05
    2402:	9e 81       	ldd	r25, Y+6	; 0x06
    2404:	9a 83       	std	Y+2, r25	; 0x02
    2406:	89 83       	std	Y+1, r24	; 0x01
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2408:	89 81       	ldd	r24, Y+1	; 0x01
    240a:	9a 81       	ldd	r25, Y+2	; 0x02
    240c:	02 96       	adiw	r24, 0x02	; 2
    240e:	9c 83       	std	Y+4, r25	; 0x04
    2410:	8b 83       	std	Y+3, r24	; 0x03

	vTaskSuspendAll();
    2412:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2416:	09 c0       	rjmp	.+18     	; 0x242a <vEventGroupDelete+0x3c>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2418:	8b 81       	ldd	r24, Y+3	; 0x03
    241a:	9c 81       	ldd	r25, Y+4	; 0x04
    241c:	fc 01       	movw	r30, r24
    241e:	85 81       	ldd	r24, Z+5	; 0x05
    2420:	96 81       	ldd	r25, Z+6	; 0x06
    2422:	60 e0       	ldi	r22, 0x00	; 0
    2424:	72 e0       	ldi	r23, 0x02	; 2
    2426:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    242a:	8b 81       	ldd	r24, Y+3	; 0x03
    242c:	9c 81       	ldd	r25, Y+4	; 0x04
    242e:	fc 01       	movw	r30, r24
    2430:	80 81       	ld	r24, Z
    2432:	88 23       	and	r24, r24
    2434:	89 f7       	brne	.-30     	; 0x2418 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    2436:	89 81       	ldd	r24, Y+1	; 0x01
    2438:	9a 81       	ldd	r25, Y+2	; 0x02
    243a:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    243e:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
}
    2442:	00 00       	nop
    2444:	26 96       	adiw	r28, 0x06	; 6
    2446:	0f b6       	in	r0, 0x3f	; 63
    2448:	f8 94       	cli
    244a:	de bf       	out	0x3e, r29	; 62
    244c:	0f be       	out	0x3f, r0	; 63
    244e:	cd bf       	out	0x3d, r28	; 61
    2450:	df 91       	pop	r29
    2452:	cf 91       	pop	r28
    2454:	08 95       	ret

00002456 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    2456:	cf 93       	push	r28
    2458:	df 93       	push	r29
    245a:	00 d0       	rcall	.+0      	; 0x245c <vEventGroupSetBitsCallback+0x6>
    245c:	00 d0       	rcall	.+0      	; 0x245e <vEventGroupSetBitsCallback+0x8>
    245e:	00 d0       	rcall	.+0      	; 0x2460 <vEventGroupSetBitsCallback+0xa>
    2460:	cd b7       	in	r28, 0x3d	; 61
    2462:	de b7       	in	r29, 0x3e	; 62
    2464:	9a 83       	std	Y+2, r25	; 0x02
    2466:	89 83       	std	Y+1, r24	; 0x01
    2468:	4b 83       	std	Y+3, r20	; 0x03
    246a:	5c 83       	std	Y+4, r21	; 0x04
    246c:	6d 83       	std	Y+5, r22	; 0x05
    246e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2470:	2b 81       	ldd	r18, Y+3	; 0x03
    2472:	3c 81       	ldd	r19, Y+4	; 0x04
    2474:	89 81       	ldd	r24, Y+1	; 0x01
    2476:	9a 81       	ldd	r25, Y+2	; 0x02
    2478:	b9 01       	movw	r22, r18
    247a:	0e 94 3a 11 	call	0x2274	; 0x2274 <xEventGroupSetBits>
}
    247e:	00 00       	nop
    2480:	26 96       	adiw	r28, 0x06	; 6
    2482:	0f b6       	in	r0, 0x3f	; 63
    2484:	f8 94       	cli
    2486:	de bf       	out	0x3e, r29	; 62
    2488:	0f be       	out	0x3f, r0	; 63
    248a:	cd bf       	out	0x3d, r28	; 61
    248c:	df 91       	pop	r29
    248e:	cf 91       	pop	r28
    2490:	08 95       	ret

00002492 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    2492:	cf 93       	push	r28
    2494:	df 93       	push	r29
    2496:	00 d0       	rcall	.+0      	; 0x2498 <vEventGroupClearBitsCallback+0x6>
    2498:	00 d0       	rcall	.+0      	; 0x249a <vEventGroupClearBitsCallback+0x8>
    249a:	00 d0       	rcall	.+0      	; 0x249c <vEventGroupClearBitsCallback+0xa>
    249c:	cd b7       	in	r28, 0x3d	; 61
    249e:	de b7       	in	r29, 0x3e	; 62
    24a0:	9a 83       	std	Y+2, r25	; 0x02
    24a2:	89 83       	std	Y+1, r24	; 0x01
    24a4:	4b 83       	std	Y+3, r20	; 0x03
    24a6:	5c 83       	std	Y+4, r21	; 0x04
    24a8:	6d 83       	std	Y+5, r22	; 0x05
    24aa:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    24ac:	2b 81       	ldd	r18, Y+3	; 0x03
    24ae:	3c 81       	ldd	r19, Y+4	; 0x04
    24b0:	89 81       	ldd	r24, Y+1	; 0x01
    24b2:	9a 81       	ldd	r25, Y+2	; 0x02
    24b4:	b9 01       	movw	r22, r18
    24b6:	0e 94 de 10 	call	0x21bc	; 0x21bc <xEventGroupClearBits>
}
    24ba:	00 00       	nop
    24bc:	26 96       	adiw	r28, 0x06	; 6
    24be:	0f b6       	in	r0, 0x3f	; 63
    24c0:	f8 94       	cli
    24c2:	de bf       	out	0x3e, r29	; 62
    24c4:	0f be       	out	0x3f, r0	; 63
    24c6:	cd bf       	out	0x3d, r28	; 61
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	08 95       	ret

000024ce <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    24ce:	cf 93       	push	r28
    24d0:	df 93       	push	r29
    24d2:	00 d0       	rcall	.+0      	; 0x24d4 <prvTestWaitCondition+0x6>
    24d4:	00 d0       	rcall	.+0      	; 0x24d6 <prvTestWaitCondition+0x8>
    24d6:	00 d0       	rcall	.+0      	; 0x24d8 <prvTestWaitCondition+0xa>
    24d8:	cd b7       	in	r28, 0x3d	; 61
    24da:	de b7       	in	r29, 0x3e	; 62
    24dc:	9b 83       	std	Y+3, r25	; 0x03
    24de:	8a 83       	std	Y+2, r24	; 0x02
    24e0:	7d 83       	std	Y+5, r23	; 0x05
    24e2:	6c 83       	std	Y+4, r22	; 0x04
    24e4:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    24e6:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    24e8:	8e 81       	ldd	r24, Y+6	; 0x06
    24ea:	88 23       	and	r24, r24
    24ec:	59 f4       	brne	.+22     	; 0x2504 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    24ee:	2a 81       	ldd	r18, Y+2	; 0x02
    24f0:	3b 81       	ldd	r19, Y+3	; 0x03
    24f2:	8c 81       	ldd	r24, Y+4	; 0x04
    24f4:	9d 81       	ldd	r25, Y+5	; 0x05
    24f6:	82 23       	and	r24, r18
    24f8:	93 23       	and	r25, r19
    24fa:	89 2b       	or	r24, r25
    24fc:	81 f0       	breq	.+32     	; 0x251e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    24fe:	81 e0       	ldi	r24, 0x01	; 1
    2500:	89 83       	std	Y+1, r24	; 0x01
    2502:	0d c0       	rjmp	.+26     	; 0x251e <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2504:	2a 81       	ldd	r18, Y+2	; 0x02
    2506:	3b 81       	ldd	r19, Y+3	; 0x03
    2508:	8c 81       	ldd	r24, Y+4	; 0x04
    250a:	9d 81       	ldd	r25, Y+5	; 0x05
    250c:	28 23       	and	r18, r24
    250e:	39 23       	and	r19, r25
    2510:	8c 81       	ldd	r24, Y+4	; 0x04
    2512:	9d 81       	ldd	r25, Y+5	; 0x05
    2514:	28 17       	cp	r18, r24
    2516:	39 07       	cpc	r19, r25
    2518:	11 f4       	brne	.+4      	; 0x251e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    251a:	81 e0       	ldi	r24, 0x01	; 1
    251c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    251e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2520:	26 96       	adiw	r28, 0x06	; 6
    2522:	0f b6       	in	r0, 0x3f	; 63
    2524:	f8 94       	cli
    2526:	de bf       	out	0x3e, r29	; 62
    2528:	0f be       	out	0x3f, r0	; 63
    252a:	cd bf       	out	0x3d, r28	; 61
    252c:	df 91       	pop	r29
    252e:	cf 91       	pop	r28
    2530:	08 95       	ret

00002532 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2532:	cf 93       	push	r28
    2534:	df 93       	push	r29
    2536:	00 d0       	rcall	.+0      	; 0x2538 <pvPortMalloc+0x6>
    2538:	00 d0       	rcall	.+0      	; 0x253a <pvPortMalloc+0x8>
    253a:	cd b7       	in	r28, 0x3d	; 61
    253c:	de b7       	in	r29, 0x3e	; 62
    253e:	9c 83       	std	Y+4, r25	; 0x04
    2540:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2542:	1a 82       	std	Y+2, r1	; 0x02
    2544:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2546:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    254a:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pucAlignedHeap.2085>
    254e:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pucAlignedHeap.2085+0x1>
    2552:	89 2b       	or	r24, r25
    2554:	31 f4       	brne	.+12     	; 0x2562 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2556:	80 ec       	ldi	r24, 0xC0	; 192
    2558:	90 e0       	ldi	r25, 0x00	; 0
    255a:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <pucAlignedHeap.2085+0x1>
    255e:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2562:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <xNextFreeByte>
    2566:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    256a:	8b 81       	ldd	r24, Y+3	; 0x03
    256c:	9c 81       	ldd	r25, Y+4	; 0x04
    256e:	82 0f       	add	r24, r18
    2570:	93 1f       	adc	r25, r19
    2572:	8b 3d       	cpi	r24, 0xDB	; 219
    2574:	95 40       	sbci	r25, 0x05	; 5
    2576:	38 f5       	brcc	.+78     	; 0x25c6 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2578:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <xNextFreeByte>
    257c:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    2580:	8b 81       	ldd	r24, Y+3	; 0x03
    2582:	9c 81       	ldd	r25, Y+4	; 0x04
    2584:	28 0f       	add	r18, r24
    2586:	39 1f       	adc	r19, r25
    2588:	80 91 9b 06 	lds	r24, 0x069B	; 0x80069b <xNextFreeByte>
    258c:	90 91 9c 06 	lds	r25, 0x069C	; 0x80069c <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2590:	82 17       	cp	r24, r18
    2592:	93 07       	cpc	r25, r19
    2594:	c0 f4       	brcc	.+48     	; 0x25c6 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2596:	20 91 9d 06 	lds	r18, 0x069D	; 0x80069d <pucAlignedHeap.2085>
    259a:	30 91 9e 06 	lds	r19, 0x069E	; 0x80069e <pucAlignedHeap.2085+0x1>
    259e:	80 91 9b 06 	lds	r24, 0x069B	; 0x80069b <xNextFreeByte>
    25a2:	90 91 9c 06 	lds	r25, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    25a6:	82 0f       	add	r24, r18
    25a8:	93 1f       	adc	r25, r19
    25aa:	9a 83       	std	Y+2, r25	; 0x02
    25ac:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    25ae:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <xNextFreeByte>
    25b2:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    25b6:	8b 81       	ldd	r24, Y+3	; 0x03
    25b8:	9c 81       	ldd	r25, Y+4	; 0x04
    25ba:	82 0f       	add	r24, r18
    25bc:	93 1f       	adc	r25, r19
    25be:	90 93 9c 06 	sts	0x069C, r25	; 0x80069c <xNextFreeByte+0x1>
    25c2:	80 93 9b 06 	sts	0x069B, r24	; 0x80069b <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    25c6:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    25ca:	89 81       	ldd	r24, Y+1	; 0x01
    25cc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    25ce:	0f 90       	pop	r0
    25d0:	0f 90       	pop	r0
    25d2:	0f 90       	pop	r0
    25d4:	0f 90       	pop	r0
    25d6:	df 91       	pop	r29
    25d8:	cf 91       	pop	r28
    25da:	08 95       	ret

000025dc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    25dc:	cf 93       	push	r28
    25de:	df 93       	push	r29
    25e0:	00 d0       	rcall	.+0      	; 0x25e2 <vPortFree+0x6>
    25e2:	cd b7       	in	r28, 0x3d	; 61
    25e4:	de b7       	in	r29, 0x3e	; 62
    25e6:	9a 83       	std	Y+2, r25	; 0x02
    25e8:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    25ea:	00 00       	nop
    25ec:	0f 90       	pop	r0
    25ee:	0f 90       	pop	r0
    25f0:	df 91       	pop	r29
    25f2:	cf 91       	pop	r28
    25f4:	08 95       	ret

000025f6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    25f6:	cf 93       	push	r28
    25f8:	df 93       	push	r29
    25fa:	cd b7       	in	r28, 0x3d	; 61
    25fc:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    25fe:	10 92 9c 06 	sts	0x069C, r1	; 0x80069c <xNextFreeByte+0x1>
    2602:	10 92 9b 06 	sts	0x069B, r1	; 0x80069b <xNextFreeByte>
}
    2606:	00 00       	nop
    2608:	df 91       	pop	r29
    260a:	cf 91       	pop	r28
    260c:	08 95       	ret

0000260e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    260e:	cf 93       	push	r28
    2610:	df 93       	push	r29
    2612:	cd b7       	in	r28, 0x3d	; 61
    2614:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2616:	80 91 9b 06 	lds	r24, 0x069B	; 0x80069b <xNextFreeByte>
    261a:	90 91 9c 06 	lds	r25, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    261e:	2b ed       	ldi	r18, 0xDB	; 219
    2620:	35 e0       	ldi	r19, 0x05	; 5
    2622:	a9 01       	movw	r20, r18
    2624:	48 1b       	sub	r20, r24
    2626:	59 0b       	sbc	r21, r25
    2628:	ca 01       	movw	r24, r20
}
    262a:	df 91       	pop	r29
    262c:	cf 91       	pop	r28
    262e:	08 95       	ret

00002630 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2630:	cf 93       	push	r28
    2632:	df 93       	push	r29
    2634:	00 d0       	rcall	.+0      	; 0x2636 <vListInitialise+0x6>
    2636:	cd b7       	in	r28, 0x3d	; 61
    2638:	de b7       	in	r29, 0x3e	; 62
    263a:	9a 83       	std	Y+2, r25	; 0x02
    263c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	9a 81       	ldd	r25, Y+2	; 0x02
    2642:	9c 01       	movw	r18, r24
    2644:	2d 5f       	subi	r18, 0xFD	; 253
    2646:	3f 4f       	sbci	r19, 0xFF	; 255
    2648:	89 81       	ldd	r24, Y+1	; 0x01
    264a:	9a 81       	ldd	r25, Y+2	; 0x02
    264c:	fc 01       	movw	r30, r24
    264e:	32 83       	std	Z+2, r19	; 0x02
    2650:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2652:	89 81       	ldd	r24, Y+1	; 0x01
    2654:	9a 81       	ldd	r25, Y+2	; 0x02
    2656:	2f ef       	ldi	r18, 0xFF	; 255
    2658:	3f ef       	ldi	r19, 0xFF	; 255
    265a:	fc 01       	movw	r30, r24
    265c:	34 83       	std	Z+4, r19	; 0x04
    265e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2660:	89 81       	ldd	r24, Y+1	; 0x01
    2662:	9a 81       	ldd	r25, Y+2	; 0x02
    2664:	9c 01       	movw	r18, r24
    2666:	2d 5f       	subi	r18, 0xFD	; 253
    2668:	3f 4f       	sbci	r19, 0xFF	; 255
    266a:	89 81       	ldd	r24, Y+1	; 0x01
    266c:	9a 81       	ldd	r25, Y+2	; 0x02
    266e:	fc 01       	movw	r30, r24
    2670:	36 83       	std	Z+6, r19	; 0x06
    2672:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2674:	89 81       	ldd	r24, Y+1	; 0x01
    2676:	9a 81       	ldd	r25, Y+2	; 0x02
    2678:	9c 01       	movw	r18, r24
    267a:	2d 5f       	subi	r18, 0xFD	; 253
    267c:	3f 4f       	sbci	r19, 0xFF	; 255
    267e:	89 81       	ldd	r24, Y+1	; 0x01
    2680:	9a 81       	ldd	r25, Y+2	; 0x02
    2682:	fc 01       	movw	r30, r24
    2684:	30 87       	std	Z+8, r19	; 0x08
    2686:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2688:	89 81       	ldd	r24, Y+1	; 0x01
    268a:	9a 81       	ldd	r25, Y+2	; 0x02
    268c:	fc 01       	movw	r30, r24
    268e:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2690:	00 00       	nop
    2692:	0f 90       	pop	r0
    2694:	0f 90       	pop	r0
    2696:	df 91       	pop	r29
    2698:	cf 91       	pop	r28
    269a:	08 95       	ret

0000269c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    269c:	cf 93       	push	r28
    269e:	df 93       	push	r29
    26a0:	00 d0       	rcall	.+0      	; 0x26a2 <vListInitialiseItem+0x6>
    26a2:	cd b7       	in	r28, 0x3d	; 61
    26a4:	de b7       	in	r29, 0x3e	; 62
    26a6:	9a 83       	std	Y+2, r25	; 0x02
    26a8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    26aa:	89 81       	ldd	r24, Y+1	; 0x01
    26ac:	9a 81       	ldd	r25, Y+2	; 0x02
    26ae:	fc 01       	movw	r30, r24
    26b0:	11 86       	std	Z+9, r1	; 0x09
    26b2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    26b4:	00 00       	nop
    26b6:	0f 90       	pop	r0
    26b8:	0f 90       	pop	r0
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	08 95       	ret

000026c0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    26c0:	cf 93       	push	r28
    26c2:	df 93       	push	r29
    26c4:	00 d0       	rcall	.+0      	; 0x26c6 <vListInsertEnd+0x6>
    26c6:	00 d0       	rcall	.+0      	; 0x26c8 <vListInsertEnd+0x8>
    26c8:	00 d0       	rcall	.+0      	; 0x26ca <vListInsertEnd+0xa>
    26ca:	cd b7       	in	r28, 0x3d	; 61
    26cc:	de b7       	in	r29, 0x3e	; 62
    26ce:	9c 83       	std	Y+4, r25	; 0x04
    26d0:	8b 83       	std	Y+3, r24	; 0x03
    26d2:	7e 83       	std	Y+6, r23	; 0x06
    26d4:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    26d6:	8b 81       	ldd	r24, Y+3	; 0x03
    26d8:	9c 81       	ldd	r25, Y+4	; 0x04
    26da:	fc 01       	movw	r30, r24
    26dc:	81 81       	ldd	r24, Z+1	; 0x01
    26de:	92 81       	ldd	r25, Z+2	; 0x02
    26e0:	9a 83       	std	Y+2, r25	; 0x02
    26e2:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    26e4:	8d 81       	ldd	r24, Y+5	; 0x05
    26e6:	9e 81       	ldd	r25, Y+6	; 0x06
    26e8:	29 81       	ldd	r18, Y+1	; 0x01
    26ea:	3a 81       	ldd	r19, Y+2	; 0x02
    26ec:	fc 01       	movw	r30, r24
    26ee:	33 83       	std	Z+3, r19	; 0x03
    26f0:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    26f2:	89 81       	ldd	r24, Y+1	; 0x01
    26f4:	9a 81       	ldd	r25, Y+2	; 0x02
    26f6:	fc 01       	movw	r30, r24
    26f8:	24 81       	ldd	r18, Z+4	; 0x04
    26fa:	35 81       	ldd	r19, Z+5	; 0x05
    26fc:	8d 81       	ldd	r24, Y+5	; 0x05
    26fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2700:	fc 01       	movw	r30, r24
    2702:	35 83       	std	Z+5, r19	; 0x05
    2704:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2706:	89 81       	ldd	r24, Y+1	; 0x01
    2708:	9a 81       	ldd	r25, Y+2	; 0x02
    270a:	fc 01       	movw	r30, r24
    270c:	84 81       	ldd	r24, Z+4	; 0x04
    270e:	95 81       	ldd	r25, Z+5	; 0x05
    2710:	2d 81       	ldd	r18, Y+5	; 0x05
    2712:	3e 81       	ldd	r19, Y+6	; 0x06
    2714:	fc 01       	movw	r30, r24
    2716:	33 83       	std	Z+3, r19	; 0x03
    2718:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    271a:	89 81       	ldd	r24, Y+1	; 0x01
    271c:	9a 81       	ldd	r25, Y+2	; 0x02
    271e:	2d 81       	ldd	r18, Y+5	; 0x05
    2720:	3e 81       	ldd	r19, Y+6	; 0x06
    2722:	fc 01       	movw	r30, r24
    2724:	35 83       	std	Z+5, r19	; 0x05
    2726:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2728:	8d 81       	ldd	r24, Y+5	; 0x05
    272a:	9e 81       	ldd	r25, Y+6	; 0x06
    272c:	2b 81       	ldd	r18, Y+3	; 0x03
    272e:	3c 81       	ldd	r19, Y+4	; 0x04
    2730:	fc 01       	movw	r30, r24
    2732:	31 87       	std	Z+9, r19	; 0x09
    2734:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2736:	8b 81       	ldd	r24, Y+3	; 0x03
    2738:	9c 81       	ldd	r25, Y+4	; 0x04
    273a:	fc 01       	movw	r30, r24
    273c:	80 81       	ld	r24, Z
    273e:	21 e0       	ldi	r18, 0x01	; 1
    2740:	28 0f       	add	r18, r24
    2742:	8b 81       	ldd	r24, Y+3	; 0x03
    2744:	9c 81       	ldd	r25, Y+4	; 0x04
    2746:	fc 01       	movw	r30, r24
    2748:	20 83       	st	Z, r18
}
    274a:	00 00       	nop
    274c:	26 96       	adiw	r28, 0x06	; 6
    274e:	0f b6       	in	r0, 0x3f	; 63
    2750:	f8 94       	cli
    2752:	de bf       	out	0x3e, r29	; 62
    2754:	0f be       	out	0x3f, r0	; 63
    2756:	cd bf       	out	0x3d, r28	; 61
    2758:	df 91       	pop	r29
    275a:	cf 91       	pop	r28
    275c:	08 95       	ret

0000275e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    275e:	cf 93       	push	r28
    2760:	df 93       	push	r29
    2762:	cd b7       	in	r28, 0x3d	; 61
    2764:	de b7       	in	r29, 0x3e	; 62
    2766:	28 97       	sbiw	r28, 0x08	; 8
    2768:	0f b6       	in	r0, 0x3f	; 63
    276a:	f8 94       	cli
    276c:	de bf       	out	0x3e, r29	; 62
    276e:	0f be       	out	0x3f, r0	; 63
    2770:	cd bf       	out	0x3d, r28	; 61
    2772:	9e 83       	std	Y+6, r25	; 0x06
    2774:	8d 83       	std	Y+5, r24	; 0x05
    2776:	78 87       	std	Y+8, r23	; 0x08
    2778:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    277a:	8f 81       	ldd	r24, Y+7	; 0x07
    277c:	98 85       	ldd	r25, Y+8	; 0x08
    277e:	fc 01       	movw	r30, r24
    2780:	80 81       	ld	r24, Z
    2782:	91 81       	ldd	r25, Z+1	; 0x01
    2784:	9c 83       	std	Y+4, r25	; 0x04
    2786:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2788:	8b 81       	ldd	r24, Y+3	; 0x03
    278a:	9c 81       	ldd	r25, Y+4	; 0x04
    278c:	01 96       	adiw	r24, 0x01	; 1
    278e:	41 f4       	brne	.+16     	; 0x27a0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2790:	8d 81       	ldd	r24, Y+5	; 0x05
    2792:	9e 81       	ldd	r25, Y+6	; 0x06
    2794:	fc 01       	movw	r30, r24
    2796:	87 81       	ldd	r24, Z+7	; 0x07
    2798:	90 85       	ldd	r25, Z+8	; 0x08
    279a:	9a 83       	std	Y+2, r25	; 0x02
    279c:	89 83       	std	Y+1, r24	; 0x01
    279e:	1a c0       	rjmp	.+52     	; 0x27d4 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    27a0:	8d 81       	ldd	r24, Y+5	; 0x05
    27a2:	9e 81       	ldd	r25, Y+6	; 0x06
    27a4:	03 96       	adiw	r24, 0x03	; 3
    27a6:	9a 83       	std	Y+2, r25	; 0x02
    27a8:	89 83       	std	Y+1, r24	; 0x01
    27aa:	07 c0       	rjmp	.+14     	; 0x27ba <vListInsert+0x5c>
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
    27ae:	9a 81       	ldd	r25, Y+2	; 0x02
    27b0:	fc 01       	movw	r30, r24
    27b2:	82 81       	ldd	r24, Z+2	; 0x02
    27b4:	93 81       	ldd	r25, Z+3	; 0x03
    27b6:	9a 83       	std	Y+2, r25	; 0x02
    27b8:	89 83       	std	Y+1, r24	; 0x01
    27ba:	89 81       	ldd	r24, Y+1	; 0x01
    27bc:	9a 81       	ldd	r25, Y+2	; 0x02
    27be:	fc 01       	movw	r30, r24
    27c0:	82 81       	ldd	r24, Z+2	; 0x02
    27c2:	93 81       	ldd	r25, Z+3	; 0x03
    27c4:	fc 01       	movw	r30, r24
    27c6:	20 81       	ld	r18, Z
    27c8:	31 81       	ldd	r19, Z+1	; 0x01
    27ca:	8b 81       	ldd	r24, Y+3	; 0x03
    27cc:	9c 81       	ldd	r25, Y+4	; 0x04
    27ce:	82 17       	cp	r24, r18
    27d0:	93 07       	cpc	r25, r19
    27d2:	60 f7       	brcc	.-40     	; 0x27ac <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    27d4:	89 81       	ldd	r24, Y+1	; 0x01
    27d6:	9a 81       	ldd	r25, Y+2	; 0x02
    27d8:	fc 01       	movw	r30, r24
    27da:	22 81       	ldd	r18, Z+2	; 0x02
    27dc:	33 81       	ldd	r19, Z+3	; 0x03
    27de:	8f 81       	ldd	r24, Y+7	; 0x07
    27e0:	98 85       	ldd	r25, Y+8	; 0x08
    27e2:	fc 01       	movw	r30, r24
    27e4:	33 83       	std	Z+3, r19	; 0x03
    27e6:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    27e8:	8f 81       	ldd	r24, Y+7	; 0x07
    27ea:	98 85       	ldd	r25, Y+8	; 0x08
    27ec:	fc 01       	movw	r30, r24
    27ee:	82 81       	ldd	r24, Z+2	; 0x02
    27f0:	93 81       	ldd	r25, Z+3	; 0x03
    27f2:	2f 81       	ldd	r18, Y+7	; 0x07
    27f4:	38 85       	ldd	r19, Y+8	; 0x08
    27f6:	fc 01       	movw	r30, r24
    27f8:	35 83       	std	Z+5, r19	; 0x05
    27fa:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    27fc:	8f 81       	ldd	r24, Y+7	; 0x07
    27fe:	98 85       	ldd	r25, Y+8	; 0x08
    2800:	29 81       	ldd	r18, Y+1	; 0x01
    2802:	3a 81       	ldd	r19, Y+2	; 0x02
    2804:	fc 01       	movw	r30, r24
    2806:	35 83       	std	Z+5, r19	; 0x05
    2808:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    280a:	89 81       	ldd	r24, Y+1	; 0x01
    280c:	9a 81       	ldd	r25, Y+2	; 0x02
    280e:	2f 81       	ldd	r18, Y+7	; 0x07
    2810:	38 85       	ldd	r19, Y+8	; 0x08
    2812:	fc 01       	movw	r30, r24
    2814:	33 83       	std	Z+3, r19	; 0x03
    2816:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2818:	8f 81       	ldd	r24, Y+7	; 0x07
    281a:	98 85       	ldd	r25, Y+8	; 0x08
    281c:	2d 81       	ldd	r18, Y+5	; 0x05
    281e:	3e 81       	ldd	r19, Y+6	; 0x06
    2820:	fc 01       	movw	r30, r24
    2822:	31 87       	std	Z+9, r19	; 0x09
    2824:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2826:	8d 81       	ldd	r24, Y+5	; 0x05
    2828:	9e 81       	ldd	r25, Y+6	; 0x06
    282a:	fc 01       	movw	r30, r24
    282c:	80 81       	ld	r24, Z
    282e:	21 e0       	ldi	r18, 0x01	; 1
    2830:	28 0f       	add	r18, r24
    2832:	8d 81       	ldd	r24, Y+5	; 0x05
    2834:	9e 81       	ldd	r25, Y+6	; 0x06
    2836:	fc 01       	movw	r30, r24
    2838:	20 83       	st	Z, r18
}
    283a:	00 00       	nop
    283c:	28 96       	adiw	r28, 0x08	; 8
    283e:	0f b6       	in	r0, 0x3f	; 63
    2840:	f8 94       	cli
    2842:	de bf       	out	0x3e, r29	; 62
    2844:	0f be       	out	0x3f, r0	; 63
    2846:	cd bf       	out	0x3d, r28	; 61
    2848:	df 91       	pop	r29
    284a:	cf 91       	pop	r28
    284c:	08 95       	ret

0000284e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    284e:	cf 93       	push	r28
    2850:	df 93       	push	r29
    2852:	00 d0       	rcall	.+0      	; 0x2854 <uxListRemove+0x6>
    2854:	00 d0       	rcall	.+0      	; 0x2856 <uxListRemove+0x8>
    2856:	cd b7       	in	r28, 0x3d	; 61
    2858:	de b7       	in	r29, 0x3e	; 62
    285a:	9c 83       	std	Y+4, r25	; 0x04
    285c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    285e:	8b 81       	ldd	r24, Y+3	; 0x03
    2860:	9c 81       	ldd	r25, Y+4	; 0x04
    2862:	fc 01       	movw	r30, r24
    2864:	80 85       	ldd	r24, Z+8	; 0x08
    2866:	91 85       	ldd	r25, Z+9	; 0x09
    2868:	9a 83       	std	Y+2, r25	; 0x02
    286a:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    286c:	8b 81       	ldd	r24, Y+3	; 0x03
    286e:	9c 81       	ldd	r25, Y+4	; 0x04
    2870:	fc 01       	movw	r30, r24
    2872:	82 81       	ldd	r24, Z+2	; 0x02
    2874:	93 81       	ldd	r25, Z+3	; 0x03
    2876:	2b 81       	ldd	r18, Y+3	; 0x03
    2878:	3c 81       	ldd	r19, Y+4	; 0x04
    287a:	f9 01       	movw	r30, r18
    287c:	24 81       	ldd	r18, Z+4	; 0x04
    287e:	35 81       	ldd	r19, Z+5	; 0x05
    2880:	fc 01       	movw	r30, r24
    2882:	35 83       	std	Z+5, r19	; 0x05
    2884:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2886:	8b 81       	ldd	r24, Y+3	; 0x03
    2888:	9c 81       	ldd	r25, Y+4	; 0x04
    288a:	fc 01       	movw	r30, r24
    288c:	84 81       	ldd	r24, Z+4	; 0x04
    288e:	95 81       	ldd	r25, Z+5	; 0x05
    2890:	2b 81       	ldd	r18, Y+3	; 0x03
    2892:	3c 81       	ldd	r19, Y+4	; 0x04
    2894:	f9 01       	movw	r30, r18
    2896:	22 81       	ldd	r18, Z+2	; 0x02
    2898:	33 81       	ldd	r19, Z+3	; 0x03
    289a:	fc 01       	movw	r30, r24
    289c:	33 83       	std	Z+3, r19	; 0x03
    289e:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    28a0:	89 81       	ldd	r24, Y+1	; 0x01
    28a2:	9a 81       	ldd	r25, Y+2	; 0x02
    28a4:	fc 01       	movw	r30, r24
    28a6:	21 81       	ldd	r18, Z+1	; 0x01
    28a8:	32 81       	ldd	r19, Z+2	; 0x02
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	28 17       	cp	r18, r24
    28b0:	39 07       	cpc	r19, r25
    28b2:	51 f4       	brne	.+20     	; 0x28c8 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    28b4:	8b 81       	ldd	r24, Y+3	; 0x03
    28b6:	9c 81       	ldd	r25, Y+4	; 0x04
    28b8:	fc 01       	movw	r30, r24
    28ba:	24 81       	ldd	r18, Z+4	; 0x04
    28bc:	35 81       	ldd	r19, Z+5	; 0x05
    28be:	89 81       	ldd	r24, Y+1	; 0x01
    28c0:	9a 81       	ldd	r25, Y+2	; 0x02
    28c2:	fc 01       	movw	r30, r24
    28c4:	32 83       	std	Z+2, r19	; 0x02
    28c6:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    28c8:	8b 81       	ldd	r24, Y+3	; 0x03
    28ca:	9c 81       	ldd	r25, Y+4	; 0x04
    28cc:	fc 01       	movw	r30, r24
    28ce:	11 86       	std	Z+9, r1	; 0x09
    28d0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    28d2:	89 81       	ldd	r24, Y+1	; 0x01
    28d4:	9a 81       	ldd	r25, Y+2	; 0x02
    28d6:	fc 01       	movw	r30, r24
    28d8:	80 81       	ld	r24, Z
    28da:	2f ef       	ldi	r18, 0xFF	; 255
    28dc:	28 0f       	add	r18, r24
    28de:	89 81       	ldd	r24, Y+1	; 0x01
    28e0:	9a 81       	ldd	r25, Y+2	; 0x02
    28e2:	fc 01       	movw	r30, r24
    28e4:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    28e6:	89 81       	ldd	r24, Y+1	; 0x01
    28e8:	9a 81       	ldd	r25, Y+2	; 0x02
    28ea:	fc 01       	movw	r30, r24
    28ec:	80 81       	ld	r24, Z
}
    28ee:	0f 90       	pop	r0
    28f0:	0f 90       	pop	r0
    28f2:	0f 90       	pop	r0
    28f4:	0f 90       	pop	r0
    28f6:	df 91       	pop	r29
    28f8:	cf 91       	pop	r28
    28fa:	08 95       	ret

000028fc <main>:
#include "avr/sleep.h"
#include "KBD_interface.h"


int main(void)
{
    28fc:	ef 92       	push	r14
    28fe:	ff 92       	push	r15
    2900:	0f 93       	push	r16
    2902:	cf 93       	push	r28
    2904:	df 93       	push	r29
    2906:	cd b7       	in	r28, 0x3d	; 61
    2908:	de b7       	in	r29, 0x3e	; 62
	LCD_initialize();
    290a:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <LCD_initialize>
	LCD_Void_Clear();
    290e:	0e 94 bc 0c 	call	0x1978	; 0x1978 <LCD_Void_Clear>
	Clock_Print_Default_Interface();
    2912:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
	KBD_u8Initialize(GROUP_B);
    2916:	81 e0       	ldi	r24, 0x01	; 1
    2918:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <KBD_u8Initialize>
	xTaskCreate(Clock_Second,"seconds",150,NULL,1,NULL);
    291c:	e1 2c       	mov	r14, r1
    291e:	f1 2c       	mov	r15, r1
    2920:	01 e0       	ldi	r16, 0x01	; 1
    2922:	20 e0       	ldi	r18, 0x00	; 0
    2924:	30 e0       	ldi	r19, 0x00	; 0
    2926:	46 e9       	ldi	r20, 0x96	; 150
    2928:	50 e0       	ldi	r21, 0x00	; 0
    292a:	62 e8       	ldi	r22, 0x82	; 130
    292c:	70 e0       	ldi	r23, 0x00	; 0
    292e:	8c e6       	ldi	r24, 0x6C	; 108
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCreate>
	xTaskCreate(Clock_Minute,"minutes",150,NULL,1,NULL);
    2936:	e1 2c       	mov	r14, r1
    2938:	f1 2c       	mov	r15, r1
    293a:	01 e0       	ldi	r16, 0x01	; 1
    293c:	20 e0       	ldi	r18, 0x00	; 0
    293e:	30 e0       	ldi	r19, 0x00	; 0
    2940:	46 e9       	ldi	r20, 0x96	; 150
    2942:	50 e0       	ldi	r21, 0x00	; 0
    2944:	6a e8       	ldi	r22, 0x8A	; 138
    2946:	70 e0       	ldi	r23, 0x00	; 0
    2948:	8f eb       	ldi	r24, 0xBF	; 191
    294a:	90 e0       	ldi	r25, 0x00	; 0
    294c:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCreate>
	xTaskCreate(Clock_Hours,"hours",150,NULL,1,NULL);
    2950:	e1 2c       	mov	r14, r1
    2952:	f1 2c       	mov	r15, r1
    2954:	01 e0       	ldi	r16, 0x01	; 1
    2956:	20 e0       	ldi	r18, 0x00	; 0
    2958:	30 e0       	ldi	r19, 0x00	; 0
    295a:	46 e9       	ldi	r20, 0x96	; 150
    295c:	50 e0       	ldi	r21, 0x00	; 0
    295e:	62 e9       	ldi	r22, 0x92	; 146
    2960:	70 e0       	ldi	r23, 0x00	; 0
    2962:	8b e0       	ldi	r24, 0x0B	; 11
    2964:	91 e0       	ldi	r25, 0x01	; 1
    2966:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCreate>
	xTaskCreate(Clock_Check_KPD,"KPD_check",150,NULL,2,NULL);
    296a:	e1 2c       	mov	r14, r1
    296c:	f1 2c       	mov	r15, r1
    296e:	02 e0       	ldi	r16, 0x02	; 2
    2970:	20 e0       	ldi	r18, 0x00	; 0
    2972:	30 e0       	ldi	r19, 0x00	; 0
    2974:	46 e9       	ldi	r20, 0x96	; 150
    2976:	50 e0       	ldi	r21, 0x00	; 0
    2978:	68 e9       	ldi	r22, 0x98	; 152
    297a:	70 e0       	ldi	r23, 0x00	; 0
    297c:	87 e6       	ldi	r24, 0x67	; 103
    297e:	91 e0       	ldi	r25, 0x01	; 1
    2980:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCreate>
	xTaskCreate(Clock_Enter_Typing_Mode,"Enter typing mode",300,NULL,2,NULL);
    2984:	e1 2c       	mov	r14, r1
    2986:	f1 2c       	mov	r15, r1
    2988:	02 e0       	ldi	r16, 0x02	; 2
    298a:	20 e0       	ldi	r18, 0x00	; 0
    298c:	30 e0       	ldi	r19, 0x00	; 0
    298e:	4c e2       	ldi	r20, 0x2C	; 44
    2990:	51 e0       	ldi	r21, 0x01	; 1
    2992:	62 ea       	ldi	r22, 0xA2	; 162
    2994:	70 e0       	ldi	r23, 0x00	; 0
    2996:	8e e9       	ldi	r24, 0x9E	; 158
    2998:	91 e0       	ldi	r25, 0x01	; 1
    299a:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCreate>
	vTaskStartScheduler();
    299e:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <vTaskStartScheduler>

	while(1)
	{

	}
    29a2:	ff cf       	rjmp	.-2      	; 0x29a2 <main+0xa6>

000029a4 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    29a4:	cf 93       	push	r28
    29a6:	df 93       	push	r29
    29a8:	cd b7       	in	r28, 0x3d	; 61
    29aa:	de b7       	in	r29, 0x3e	; 62
    29ac:	28 97       	sbiw	r28, 0x08	; 8
    29ae:	0f b6       	in	r0, 0x3f	; 63
    29b0:	f8 94       	cli
    29b2:	de bf       	out	0x3e, r29	; 62
    29b4:	0f be       	out	0x3f, r0	; 63
    29b6:	cd bf       	out	0x3d, r28	; 61
    29b8:	9c 83       	std	Y+4, r25	; 0x04
    29ba:	8b 83       	std	Y+3, r24	; 0x03
    29bc:	7e 83       	std	Y+6, r23	; 0x06
    29be:	6d 83       	std	Y+5, r22	; 0x05
    29c0:	58 87       	std	Y+8, r21	; 0x08
    29c2:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    29c4:	8b 81       	ldd	r24, Y+3	; 0x03
    29c6:	9c 81       	ldd	r25, Y+4	; 0x04
    29c8:	21 e1       	ldi	r18, 0x11	; 17
    29ca:	fc 01       	movw	r30, r24
    29cc:	20 83       	st	Z, r18
	pxTopOfStack--;
    29ce:	8b 81       	ldd	r24, Y+3	; 0x03
    29d0:	9c 81       	ldd	r25, Y+4	; 0x04
    29d2:	01 97       	sbiw	r24, 0x01	; 1
    29d4:	9c 83       	std	Y+4, r25	; 0x04
    29d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    29d8:	8b 81       	ldd	r24, Y+3	; 0x03
    29da:	9c 81       	ldd	r25, Y+4	; 0x04
    29dc:	22 e2       	ldi	r18, 0x22	; 34
    29de:	fc 01       	movw	r30, r24
    29e0:	20 83       	st	Z, r18
	pxTopOfStack--;
    29e2:	8b 81       	ldd	r24, Y+3	; 0x03
    29e4:	9c 81       	ldd	r25, Y+4	; 0x04
    29e6:	01 97       	sbiw	r24, 0x01	; 1
    29e8:	9c 83       	std	Y+4, r25	; 0x04
    29ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    29ec:	8b 81       	ldd	r24, Y+3	; 0x03
    29ee:	9c 81       	ldd	r25, Y+4	; 0x04
    29f0:	23 e3       	ldi	r18, 0x33	; 51
    29f2:	fc 01       	movw	r30, r24
    29f4:	20 83       	st	Z, r18
	pxTopOfStack--;
    29f6:	8b 81       	ldd	r24, Y+3	; 0x03
    29f8:	9c 81       	ldd	r25, Y+4	; 0x04
    29fa:	01 97       	sbiw	r24, 0x01	; 1
    29fc:	9c 83       	std	Y+4, r25	; 0x04
    29fe:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2a00:	8d 81       	ldd	r24, Y+5	; 0x05
    2a02:	9e 81       	ldd	r25, Y+6	; 0x06
    2a04:	9a 83       	std	Y+2, r25	; 0x02
    2a06:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2a08:	29 81       	ldd	r18, Y+1	; 0x01
    2a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a0e:	fc 01       	movw	r30, r24
    2a10:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a12:	8b 81       	ldd	r24, Y+3	; 0x03
    2a14:	9c 81       	ldd	r25, Y+4	; 0x04
    2a16:	01 97       	sbiw	r24, 0x01	; 1
    2a18:	9c 83       	std	Y+4, r25	; 0x04
    2a1a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2a1c:	89 81       	ldd	r24, Y+1	; 0x01
    2a1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a20:	89 2f       	mov	r24, r25
    2a22:	99 27       	eor	r25, r25
    2a24:	9a 83       	std	Y+2, r25	; 0x02
    2a26:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2a28:	29 81       	ldd	r18, Y+1	; 0x01
    2a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2e:	fc 01       	movw	r30, r24
    2a30:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a32:	8b 81       	ldd	r24, Y+3	; 0x03
    2a34:	9c 81       	ldd	r25, Y+4	; 0x04
    2a36:	01 97       	sbiw	r24, 0x01	; 1
    2a38:	9c 83       	std	Y+4, r25	; 0x04
    2a3a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a40:	fc 01       	movw	r30, r24
    2a42:	10 82       	st	Z, r1
	pxTopOfStack--;
    2a44:	8b 81       	ldd	r24, Y+3	; 0x03
    2a46:	9c 81       	ldd	r25, Y+4	; 0x04
    2a48:	01 97       	sbiw	r24, 0x01	; 1
    2a4a:	9c 83       	std	Y+4, r25	; 0x04
    2a4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a50:	9c 81       	ldd	r25, Y+4	; 0x04
    2a52:	20 e8       	ldi	r18, 0x80	; 128
    2a54:	fc 01       	movw	r30, r24
    2a56:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a58:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5c:	01 97       	sbiw	r24, 0x01	; 1
    2a5e:	9c 83       	std	Y+4, r25	; 0x04
    2a60:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2a62:	8b 81       	ldd	r24, Y+3	; 0x03
    2a64:	9c 81       	ldd	r25, Y+4	; 0x04
    2a66:	fc 01       	movw	r30, r24
    2a68:	10 82       	st	Z, r1
	pxTopOfStack--;
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	01 97       	sbiw	r24, 0x01	; 1
    2a70:	9c 83       	std	Y+4, r25	; 0x04
    2a72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2a74:	8b 81       	ldd	r24, Y+3	; 0x03
    2a76:	9c 81       	ldd	r25, Y+4	; 0x04
    2a78:	22 e0       	ldi	r18, 0x02	; 2
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a80:	9c 81       	ldd	r25, Y+4	; 0x04
    2a82:	01 97       	sbiw	r24, 0x01	; 1
    2a84:	9c 83       	std	Y+4, r25	; 0x04
    2a86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2a88:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8c:	23 e0       	ldi	r18, 0x03	; 3
    2a8e:	fc 01       	movw	r30, r24
    2a90:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a92:	8b 81       	ldd	r24, Y+3	; 0x03
    2a94:	9c 81       	ldd	r25, Y+4	; 0x04
    2a96:	01 97       	sbiw	r24, 0x01	; 1
    2a98:	9c 83       	std	Y+4, r25	; 0x04
    2a9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa0:	24 e0       	ldi	r18, 0x04	; 4
    2aa2:	fc 01       	movw	r30, r24
    2aa4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aaa:	01 97       	sbiw	r24, 0x01	; 1
    2aac:	9c 83       	std	Y+4, r25	; 0x04
    2aae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab4:	25 e0       	ldi	r18, 0x05	; 5
    2ab6:	fc 01       	movw	r30, r24
    2ab8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2aba:	8b 81       	ldd	r24, Y+3	; 0x03
    2abc:	9c 81       	ldd	r25, Y+4	; 0x04
    2abe:	01 97       	sbiw	r24, 0x01	; 1
    2ac0:	9c 83       	std	Y+4, r25	; 0x04
    2ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac8:	26 e0       	ldi	r18, 0x06	; 6
    2aca:	fc 01       	movw	r30, r24
    2acc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ace:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad2:	01 97       	sbiw	r24, 0x01	; 1
    2ad4:	9c 83       	std	Y+4, r25	; 0x04
    2ad6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2ad8:	8b 81       	ldd	r24, Y+3	; 0x03
    2ada:	9c 81       	ldd	r25, Y+4	; 0x04
    2adc:	27 e0       	ldi	r18, 0x07	; 7
    2ade:	fc 01       	movw	r30, r24
    2ae0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae6:	01 97       	sbiw	r24, 0x01	; 1
    2ae8:	9c 83       	std	Y+4, r25	; 0x04
    2aea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2aec:	8b 81       	ldd	r24, Y+3	; 0x03
    2aee:	9c 81       	ldd	r25, Y+4	; 0x04
    2af0:	28 e0       	ldi	r18, 0x08	; 8
    2af2:	fc 01       	movw	r30, r24
    2af4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2af6:	8b 81       	ldd	r24, Y+3	; 0x03
    2af8:	9c 81       	ldd	r25, Y+4	; 0x04
    2afa:	01 97       	sbiw	r24, 0x01	; 1
    2afc:	9c 83       	std	Y+4, r25	; 0x04
    2afe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2b00:	8b 81       	ldd	r24, Y+3	; 0x03
    2b02:	9c 81       	ldd	r25, Y+4	; 0x04
    2b04:	29 e0       	ldi	r18, 0x09	; 9
    2b06:	fc 01       	movw	r30, r24
    2b08:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0e:	01 97       	sbiw	r24, 0x01	; 1
    2b10:	9c 83       	std	Y+4, r25	; 0x04
    2b12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2b14:	8b 81       	ldd	r24, Y+3	; 0x03
    2b16:	9c 81       	ldd	r25, Y+4	; 0x04
    2b18:	20 e1       	ldi	r18, 0x10	; 16
    2b1a:	fc 01       	movw	r30, r24
    2b1c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b20:	9c 81       	ldd	r25, Y+4	; 0x04
    2b22:	01 97       	sbiw	r24, 0x01	; 1
    2b24:	9c 83       	std	Y+4, r25	; 0x04
    2b26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2b28:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2c:	21 e1       	ldi	r18, 0x11	; 17
    2b2e:	fc 01       	movw	r30, r24
    2b30:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b32:	8b 81       	ldd	r24, Y+3	; 0x03
    2b34:	9c 81       	ldd	r25, Y+4	; 0x04
    2b36:	01 97       	sbiw	r24, 0x01	; 1
    2b38:	9c 83       	std	Y+4, r25	; 0x04
    2b3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b40:	22 e1       	ldi	r18, 0x12	; 18
    2b42:	fc 01       	movw	r30, r24
    2b44:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b46:	8b 81       	ldd	r24, Y+3	; 0x03
    2b48:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4a:	01 97       	sbiw	r24, 0x01	; 1
    2b4c:	9c 83       	std	Y+4, r25	; 0x04
    2b4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2b50:	8b 81       	ldd	r24, Y+3	; 0x03
    2b52:	9c 81       	ldd	r25, Y+4	; 0x04
    2b54:	23 e1       	ldi	r18, 0x13	; 19
    2b56:	fc 01       	movw	r30, r24
    2b58:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5e:	01 97       	sbiw	r24, 0x01	; 1
    2b60:	9c 83       	std	Y+4, r25	; 0x04
    2b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2b64:	8b 81       	ldd	r24, Y+3	; 0x03
    2b66:	9c 81       	ldd	r25, Y+4	; 0x04
    2b68:	24 e1       	ldi	r18, 0x14	; 20
    2b6a:	fc 01       	movw	r30, r24
    2b6c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b70:	9c 81       	ldd	r25, Y+4	; 0x04
    2b72:	01 97       	sbiw	r24, 0x01	; 1
    2b74:	9c 83       	std	Y+4, r25	; 0x04
    2b76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2b78:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7c:	25 e1       	ldi	r18, 0x15	; 21
    2b7e:	fc 01       	movw	r30, r24
    2b80:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b82:	8b 81       	ldd	r24, Y+3	; 0x03
    2b84:	9c 81       	ldd	r25, Y+4	; 0x04
    2b86:	01 97       	sbiw	r24, 0x01	; 1
    2b88:	9c 83       	std	Y+4, r25	; 0x04
    2b8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b90:	26 e1       	ldi	r18, 0x16	; 22
    2b92:	fc 01       	movw	r30, r24
    2b94:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b96:	8b 81       	ldd	r24, Y+3	; 0x03
    2b98:	9c 81       	ldd	r25, Y+4	; 0x04
    2b9a:	01 97       	sbiw	r24, 0x01	; 1
    2b9c:	9c 83       	std	Y+4, r25	; 0x04
    2b9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba4:	27 e1       	ldi	r18, 0x17	; 23
    2ba6:	fc 01       	movw	r30, r24
    2ba8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2baa:	8b 81       	ldd	r24, Y+3	; 0x03
    2bac:	9c 81       	ldd	r25, Y+4	; 0x04
    2bae:	01 97       	sbiw	r24, 0x01	; 1
    2bb0:	9c 83       	std	Y+4, r25	; 0x04
    2bb2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb8:	28 e1       	ldi	r18, 0x18	; 24
    2bba:	fc 01       	movw	r30, r24
    2bbc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc2:	01 97       	sbiw	r24, 0x01	; 1
    2bc4:	9c 83       	std	Y+4, r25	; 0x04
    2bc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bca:	9c 81       	ldd	r25, Y+4	; 0x04
    2bcc:	29 e1       	ldi	r18, 0x19	; 25
    2bce:	fc 01       	movw	r30, r24
    2bd0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bd6:	01 97       	sbiw	r24, 0x01	; 1
    2bd8:	9c 83       	std	Y+4, r25	; 0x04
    2bda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bde:	9c 81       	ldd	r25, Y+4	; 0x04
    2be0:	20 e2       	ldi	r18, 0x20	; 32
    2be2:	fc 01       	movw	r30, r24
    2be4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2be6:	8b 81       	ldd	r24, Y+3	; 0x03
    2be8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bea:	01 97       	sbiw	r24, 0x01	; 1
    2bec:	9c 83       	std	Y+4, r25	; 0x04
    2bee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf2:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf4:	21 e2       	ldi	r18, 0x21	; 33
    2bf6:	fc 01       	movw	r30, r24
    2bf8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bfa:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfe:	01 97       	sbiw	r24, 0x01	; 1
    2c00:	9c 83       	std	Y+4, r25	; 0x04
    2c02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2c04:	8b 81       	ldd	r24, Y+3	; 0x03
    2c06:	9c 81       	ldd	r25, Y+4	; 0x04
    2c08:	22 e2       	ldi	r18, 0x22	; 34
    2c0a:	fc 01       	movw	r30, r24
    2c0c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c10:	9c 81       	ldd	r25, Y+4	; 0x04
    2c12:	01 97       	sbiw	r24, 0x01	; 1
    2c14:	9c 83       	std	Y+4, r25	; 0x04
    2c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2c18:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1c:	23 e2       	ldi	r18, 0x23	; 35
    2c1e:	fc 01       	movw	r30, r24
    2c20:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c22:	8b 81       	ldd	r24, Y+3	; 0x03
    2c24:	9c 81       	ldd	r25, Y+4	; 0x04
    2c26:	01 97       	sbiw	r24, 0x01	; 1
    2c28:	9c 83       	std	Y+4, r25	; 0x04
    2c2a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2c2c:	8f 81       	ldd	r24, Y+7	; 0x07
    2c2e:	98 85       	ldd	r25, Y+8	; 0x08
    2c30:	9a 83       	std	Y+2, r25	; 0x02
    2c32:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c34:	29 81       	ldd	r18, Y+1	; 0x01
    2c36:	8b 81       	ldd	r24, Y+3	; 0x03
    2c38:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3a:	fc 01       	movw	r30, r24
    2c3c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c40:	9c 81       	ldd	r25, Y+4	; 0x04
    2c42:	01 97       	sbiw	r24, 0x01	; 1
    2c44:	9c 83       	std	Y+4, r25	; 0x04
    2c46:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2c48:	89 81       	ldd	r24, Y+1	; 0x01
    2c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c4c:	89 2f       	mov	r24, r25
    2c4e:	99 27       	eor	r25, r25
    2c50:	9a 83       	std	Y+2, r25	; 0x02
    2c52:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c54:	29 81       	ldd	r18, Y+1	; 0x01
    2c56:	8b 81       	ldd	r24, Y+3	; 0x03
    2c58:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5a:	fc 01       	movw	r30, r24
    2c5c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c60:	9c 81       	ldd	r25, Y+4	; 0x04
    2c62:	01 97       	sbiw	r24, 0x01	; 1
    2c64:	9c 83       	std	Y+4, r25	; 0x04
    2c66:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2c68:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c6c:	26 e2       	ldi	r18, 0x26	; 38
    2c6e:	fc 01       	movw	r30, r24
    2c70:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c72:	8b 81       	ldd	r24, Y+3	; 0x03
    2c74:	9c 81       	ldd	r25, Y+4	; 0x04
    2c76:	01 97       	sbiw	r24, 0x01	; 1
    2c78:	9c 83       	std	Y+4, r25	; 0x04
    2c7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2c7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c80:	27 e2       	ldi	r18, 0x27	; 39
    2c82:	fc 01       	movw	r30, r24
    2c84:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c86:	8b 81       	ldd	r24, Y+3	; 0x03
    2c88:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8a:	01 97       	sbiw	r24, 0x01	; 1
    2c8c:	9c 83       	std	Y+4, r25	; 0x04
    2c8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2c90:	8b 81       	ldd	r24, Y+3	; 0x03
    2c92:	9c 81       	ldd	r25, Y+4	; 0x04
    2c94:	28 e2       	ldi	r18, 0x28	; 40
    2c96:	fc 01       	movw	r30, r24
    2c98:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9e:	01 97       	sbiw	r24, 0x01	; 1
    2ca0:	9c 83       	std	Y+4, r25	; 0x04
    2ca2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca8:	29 e2       	ldi	r18, 0x29	; 41
    2caa:	fc 01       	movw	r30, r24
    2cac:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cae:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb2:	01 97       	sbiw	r24, 0x01	; 1
    2cb4:	9c 83       	std	Y+4, r25	; 0x04
    2cb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2cb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cba:	9c 81       	ldd	r25, Y+4	; 0x04
    2cbc:	20 e3       	ldi	r18, 0x30	; 48
    2cbe:	fc 01       	movw	r30, r24
    2cc0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc6:	01 97       	sbiw	r24, 0x01	; 1
    2cc8:	9c 83       	std	Y+4, r25	; 0x04
    2cca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cce:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd0:	21 e3       	ldi	r18, 0x31	; 49
    2cd2:	fc 01       	movw	r30, r24
    2cd4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cda:	01 97       	sbiw	r24, 0x01	; 1
    2cdc:	9c 83       	std	Y+4, r25	; 0x04
    2cde:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce2:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2ce4:	28 96       	adiw	r28, 0x08	; 8
    2ce6:	0f b6       	in	r0, 0x3f	; 63
    2ce8:	f8 94       	cli
    2cea:	de bf       	out	0x3e, r29	; 62
    2cec:	0f be       	out	0x3f, r0	; 63
    2cee:	cd bf       	out	0x3d, r28	; 61
    2cf0:	df 91       	pop	r29
    2cf2:	cf 91       	pop	r28
    2cf4:	08 95       	ret

00002cf6 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2cf6:	cf 93       	push	r28
    2cf8:	df 93       	push	r29
    2cfa:	cd b7       	in	r28, 0x3d	; 61
    2cfc:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2cfe:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2d02:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2d06:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2d0a:	cd 91       	ld	r28, X+
    2d0c:	cd bf       	out	0x3d, r28	; 61
    2d0e:	dd 91       	ld	r29, X+
    2d10:	de bf       	out	0x3e, r29	; 62
    2d12:	ff 91       	pop	r31
    2d14:	ef 91       	pop	r30
    2d16:	df 91       	pop	r29
    2d18:	cf 91       	pop	r28
    2d1a:	bf 91       	pop	r27
    2d1c:	af 91       	pop	r26
    2d1e:	9f 91       	pop	r25
    2d20:	8f 91       	pop	r24
    2d22:	7f 91       	pop	r23
    2d24:	6f 91       	pop	r22
    2d26:	5f 91       	pop	r21
    2d28:	4f 91       	pop	r20
    2d2a:	3f 91       	pop	r19
    2d2c:	2f 91       	pop	r18
    2d2e:	1f 91       	pop	r17
    2d30:	0f 91       	pop	r16
    2d32:	ff 90       	pop	r15
    2d34:	ef 90       	pop	r14
    2d36:	df 90       	pop	r13
    2d38:	cf 90       	pop	r12
    2d3a:	bf 90       	pop	r11
    2d3c:	af 90       	pop	r10
    2d3e:	9f 90       	pop	r9
    2d40:	8f 90       	pop	r8
    2d42:	7f 90       	pop	r7
    2d44:	6f 90       	pop	r6
    2d46:	5f 90       	pop	r5
    2d48:	4f 90       	pop	r4
    2d4a:	3f 90       	pop	r3
    2d4c:	2f 90       	pop	r2
    2d4e:	1f 90       	pop	r1
    2d50:	0f 90       	pop	r0
    2d52:	0f be       	out	0x3f, r0	; 63
    2d54:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2d56:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2d58:	81 e0       	ldi	r24, 0x01	; 1
}
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	08 95       	ret

00002d60 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2d60:	cf 93       	push	r28
    2d62:	df 93       	push	r29
    2d64:	cd b7       	in	r28, 0x3d	; 61
    2d66:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2d68:	00 00       	nop
    2d6a:	df 91       	pop	r29
    2d6c:	cf 91       	pop	r28
    2d6e:	08 95       	ret

00002d70 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2d70:	0f 92       	push	r0
    2d72:	0f b6       	in	r0, 0x3f	; 63
    2d74:	f8 94       	cli
    2d76:	0f 92       	push	r0
    2d78:	1f 92       	push	r1
    2d7a:	11 24       	eor	r1, r1
    2d7c:	2f 92       	push	r2
    2d7e:	3f 92       	push	r3
    2d80:	4f 92       	push	r4
    2d82:	5f 92       	push	r5
    2d84:	6f 92       	push	r6
    2d86:	7f 92       	push	r7
    2d88:	8f 92       	push	r8
    2d8a:	9f 92       	push	r9
    2d8c:	af 92       	push	r10
    2d8e:	bf 92       	push	r11
    2d90:	cf 92       	push	r12
    2d92:	df 92       	push	r13
    2d94:	ef 92       	push	r14
    2d96:	ff 92       	push	r15
    2d98:	0f 93       	push	r16
    2d9a:	1f 93       	push	r17
    2d9c:	2f 93       	push	r18
    2d9e:	3f 93       	push	r19
    2da0:	4f 93       	push	r20
    2da2:	5f 93       	push	r21
    2da4:	6f 93       	push	r22
    2da6:	7f 93       	push	r23
    2da8:	8f 93       	push	r24
    2daa:	9f 93       	push	r25
    2dac:	af 93       	push	r26
    2dae:	bf 93       	push	r27
    2db0:	cf 93       	push	r28
    2db2:	df 93       	push	r29
    2db4:	ef 93       	push	r30
    2db6:	ff 93       	push	r31
    2db8:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2dbc:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2dc0:	0d b6       	in	r0, 0x3d	; 61
    2dc2:	0d 92       	st	X+, r0
    2dc4:	0e b6       	in	r0, 0x3e	; 62
    2dc6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2dc8:	0e 94 91 26 	call	0x4d22	; 0x4d22 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2dcc:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2dd0:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2dd4:	cd 91       	ld	r28, X+
    2dd6:	cd bf       	out	0x3d, r28	; 61
    2dd8:	dd 91       	ld	r29, X+
    2dda:	de bf       	out	0x3e, r29	; 62
    2ddc:	ff 91       	pop	r31
    2dde:	ef 91       	pop	r30
    2de0:	df 91       	pop	r29
    2de2:	cf 91       	pop	r28
    2de4:	bf 91       	pop	r27
    2de6:	af 91       	pop	r26
    2de8:	9f 91       	pop	r25
    2dea:	8f 91       	pop	r24
    2dec:	7f 91       	pop	r23
    2dee:	6f 91       	pop	r22
    2df0:	5f 91       	pop	r21
    2df2:	4f 91       	pop	r20
    2df4:	3f 91       	pop	r19
    2df6:	2f 91       	pop	r18
    2df8:	1f 91       	pop	r17
    2dfa:	0f 91       	pop	r16
    2dfc:	ff 90       	pop	r15
    2dfe:	ef 90       	pop	r14
    2e00:	df 90       	pop	r13
    2e02:	cf 90       	pop	r12
    2e04:	bf 90       	pop	r11
    2e06:	af 90       	pop	r10
    2e08:	9f 90       	pop	r9
    2e0a:	8f 90       	pop	r8
    2e0c:	7f 90       	pop	r7
    2e0e:	6f 90       	pop	r6
    2e10:	5f 90       	pop	r5
    2e12:	4f 90       	pop	r4
    2e14:	3f 90       	pop	r3
    2e16:	2f 90       	pop	r2
    2e18:	1f 90       	pop	r1
    2e1a:	0f 90       	pop	r0
    2e1c:	0f be       	out	0x3f, r0	; 63
    2e1e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e20:	08 95       	ret
	...

00002e24 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2e24:	0f 92       	push	r0
    2e26:	0f b6       	in	r0, 0x3f	; 63
    2e28:	f8 94       	cli
    2e2a:	0f 92       	push	r0
    2e2c:	1f 92       	push	r1
    2e2e:	11 24       	eor	r1, r1
    2e30:	2f 92       	push	r2
    2e32:	3f 92       	push	r3
    2e34:	4f 92       	push	r4
    2e36:	5f 92       	push	r5
    2e38:	6f 92       	push	r6
    2e3a:	7f 92       	push	r7
    2e3c:	8f 92       	push	r8
    2e3e:	9f 92       	push	r9
    2e40:	af 92       	push	r10
    2e42:	bf 92       	push	r11
    2e44:	cf 92       	push	r12
    2e46:	df 92       	push	r13
    2e48:	ef 92       	push	r14
    2e4a:	ff 92       	push	r15
    2e4c:	0f 93       	push	r16
    2e4e:	1f 93       	push	r17
    2e50:	2f 93       	push	r18
    2e52:	3f 93       	push	r19
    2e54:	4f 93       	push	r20
    2e56:	5f 93       	push	r21
    2e58:	6f 93       	push	r22
    2e5a:	7f 93       	push	r23
    2e5c:	8f 93       	push	r24
    2e5e:	9f 93       	push	r25
    2e60:	af 93       	push	r26
    2e62:	bf 93       	push	r27
    2e64:	cf 93       	push	r28
    2e66:	df 93       	push	r29
    2e68:	ef 93       	push	r30
    2e6a:	ff 93       	push	r31
    2e6c:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2e70:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2e74:	0d b6       	in	r0, 0x3d	; 61
    2e76:	0d 92       	st	X+, r0
    2e78:	0e b6       	in	r0, 0x3e	; 62
    2e7a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2e7c:	0e 94 a4 25 	call	0x4b48	; 0x4b48 <xTaskIncrementTick>
    2e80:	88 23       	and	r24, r24
    2e82:	11 f0       	breq	.+4      	; 0x2e88 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2e84:	0e 94 91 26 	call	0x4d22	; 0x4d22 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2e88:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2e8c:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2e90:	cd 91       	ld	r28, X+
    2e92:	cd bf       	out	0x3d, r28	; 61
    2e94:	dd 91       	ld	r29, X+
    2e96:	de bf       	out	0x3e, r29	; 62
    2e98:	ff 91       	pop	r31
    2e9a:	ef 91       	pop	r30
    2e9c:	df 91       	pop	r29
    2e9e:	cf 91       	pop	r28
    2ea0:	bf 91       	pop	r27
    2ea2:	af 91       	pop	r26
    2ea4:	9f 91       	pop	r25
    2ea6:	8f 91       	pop	r24
    2ea8:	7f 91       	pop	r23
    2eaa:	6f 91       	pop	r22
    2eac:	5f 91       	pop	r21
    2eae:	4f 91       	pop	r20
    2eb0:	3f 91       	pop	r19
    2eb2:	2f 91       	pop	r18
    2eb4:	1f 91       	pop	r17
    2eb6:	0f 91       	pop	r16
    2eb8:	ff 90       	pop	r15
    2eba:	ef 90       	pop	r14
    2ebc:	df 90       	pop	r13
    2ebe:	cf 90       	pop	r12
    2ec0:	bf 90       	pop	r11
    2ec2:	af 90       	pop	r10
    2ec4:	9f 90       	pop	r9
    2ec6:	8f 90       	pop	r8
    2ec8:	7f 90       	pop	r7
    2eca:	6f 90       	pop	r6
    2ecc:	5f 90       	pop	r5
    2ece:	4f 90       	pop	r4
    2ed0:	3f 90       	pop	r3
    2ed2:	2f 90       	pop	r2
    2ed4:	1f 90       	pop	r1
    2ed6:	0f 90       	pop	r0
    2ed8:	0f be       	out	0x3f, r0	; 63
    2eda:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2edc:	08 95       	ret
	...

00002ee0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2ee0:	cf 93       	push	r28
    2ee2:	df 93       	push	r29
    2ee4:	00 d0       	rcall	.+0      	; 0x2ee6 <prvSetupTimerInterrupt+0x6>
    2ee6:	00 d0       	rcall	.+0      	; 0x2ee8 <prvSetupTimerInterrupt+0x8>
    2ee8:	00 d0       	rcall	.+0      	; 0x2eea <prvSetupTimerInterrupt+0xa>
    2eea:	cd b7       	in	r28, 0x3d	; 61
    2eec:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2eee:	80 e0       	ldi	r24, 0x00	; 0
    2ef0:	95 e3       	ldi	r25, 0x35	; 53
    2ef2:	ac e0       	ldi	r26, 0x0C	; 12
    2ef4:	b0 e0       	ldi	r27, 0x00	; 0
    2ef6:	89 83       	std	Y+1, r24	; 0x01
    2ef8:	9a 83       	std	Y+2, r25	; 0x02
    2efa:	ab 83       	std	Y+3, r26	; 0x03
    2efc:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2efe:	89 81       	ldd	r24, Y+1	; 0x01
    2f00:	9a 81       	ldd	r25, Y+2	; 0x02
    2f02:	ab 81       	ldd	r26, Y+3	; 0x03
    2f04:	bc 81       	ldd	r27, Y+4	; 0x04
    2f06:	68 94       	set
    2f08:	15 f8       	bld	r1, 5
    2f0a:	b6 95       	lsr	r27
    2f0c:	a7 95       	ror	r26
    2f0e:	97 95       	ror	r25
    2f10:	87 95       	ror	r24
    2f12:	16 94       	lsr	r1
    2f14:	d1 f7       	brne	.-12     	; 0x2f0a <prvSetupTimerInterrupt+0x2a>
    2f16:	89 83       	std	Y+1, r24	; 0x01
    2f18:	9a 83       	std	Y+2, r25	; 0x02
    2f1a:	ab 83       	std	Y+3, r26	; 0x03
    2f1c:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2f1e:	89 81       	ldd	r24, Y+1	; 0x01
    2f20:	9a 81       	ldd	r25, Y+2	; 0x02
    2f22:	ab 81       	ldd	r26, Y+3	; 0x03
    2f24:	bc 81       	ldd	r27, Y+4	; 0x04
    2f26:	01 97       	sbiw	r24, 0x01	; 1
    2f28:	a1 09       	sbc	r26, r1
    2f2a:	b1 09       	sbc	r27, r1
    2f2c:	89 83       	std	Y+1, r24	; 0x01
    2f2e:	9a 83       	std	Y+2, r25	; 0x02
    2f30:	ab 83       	std	Y+3, r26	; 0x03
    2f32:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2f34:	89 81       	ldd	r24, Y+1	; 0x01
    2f36:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    2f38:	89 81       	ldd	r24, Y+1	; 0x01
    2f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f3c:	ab 81       	ldd	r26, Y+3	; 0x03
    2f3e:	bc 81       	ldd	r27, Y+4	; 0x04
    2f40:	89 2f       	mov	r24, r25
    2f42:	9a 2f       	mov	r25, r26
    2f44:	ab 2f       	mov	r26, r27
    2f46:	bb 27       	eor	r27, r27
    2f48:	89 83       	std	Y+1, r24	; 0x01
    2f4a:	9a 83       	std	Y+2, r25	; 0x02
    2f4c:	ab 83       	std	Y+3, r26	; 0x03
    2f4e:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2f50:	89 81       	ldd	r24, Y+1	; 0x01
    2f52:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    2f54:	8b e4       	ldi	r24, 0x4B	; 75
    2f56:	90 e0       	ldi	r25, 0x00	; 0
    2f58:	2e 81       	ldd	r18, Y+6	; 0x06
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    2f5e:	8a e4       	ldi	r24, 0x4A	; 74
    2f60:	90 e0       	ldi	r25, 0x00	; 0
    2f62:	2d 81       	ldd	r18, Y+5	; 0x05
    2f64:	fc 01       	movw	r30, r24
    2f66:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2f68:	8b e0       	ldi	r24, 0x0B	; 11
    2f6a:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    2f6c:	8e e4       	ldi	r24, 0x4E	; 78
    2f6e:	90 e0       	ldi	r25, 0x00	; 0
    2f70:	2d 81       	ldd	r18, Y+5	; 0x05
    2f72:	fc 01       	movw	r30, r24
    2f74:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2f76:	89 e5       	ldi	r24, 0x59	; 89
    2f78:	90 e0       	ldi	r25, 0x00	; 0
    2f7a:	fc 01       	movw	r30, r24
    2f7c:	80 81       	ld	r24, Z
    2f7e:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2f80:	8d 81       	ldd	r24, Y+5	; 0x05
    2f82:	80 61       	ori	r24, 0x10	; 16
    2f84:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK = ucLowByte;
    2f86:	89 e5       	ldi	r24, 0x59	; 89
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	2d 81       	ldd	r18, Y+5	; 0x05
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	20 83       	st	Z, r18
}
    2f90:	00 00       	nop
    2f92:	26 96       	adiw	r28, 0x06	; 6
    2f94:	0f b6       	in	r0, 0x3f	; 63
    2f96:	f8 94       	cli
    2f98:	de bf       	out	0x3e, r29	; 62
    2f9a:	0f be       	out	0x3f, r0	; 63
    2f9c:	cd bf       	out	0x3d, r28	; 61
    2f9e:	df 91       	pop	r29
    2fa0:	cf 91       	pop	r28
    2fa2:	08 95       	ret

00002fa4 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void _VECTOR(7)( void ) __attribute__ ( ( signal, naked ) );
	void _VECTOR(7)( void )
	{
		vPortYieldFromTick();
    2fa4:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2fa8:	18 95       	reti
	...

00002fac <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2fac:	cf 93       	push	r28
    2fae:	df 93       	push	r29
    2fb0:	00 d0       	rcall	.+0      	; 0x2fb2 <xQueueGenericReset+0x6>
    2fb2:	00 d0       	rcall	.+0      	; 0x2fb4 <xQueueGenericReset+0x8>
    2fb4:	1f 92       	push	r1
    2fb6:	cd b7       	in	r28, 0x3d	; 61
    2fb8:	de b7       	in	r29, 0x3e	; 62
    2fba:	9c 83       	std	Y+4, r25	; 0x04
    2fbc:	8b 83       	std	Y+3, r24	; 0x03
    2fbe:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2fc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc4:	9a 83       	std	Y+2, r25	; 0x02
    2fc6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2fc8:	0f b6       	in	r0, 0x3f	; 63
    2fca:	f8 94       	cli
    2fcc:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2fce:	89 81       	ldd	r24, Y+1	; 0x01
    2fd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd2:	fc 01       	movw	r30, r24
    2fd4:	80 81       	ld	r24, Z
    2fd6:	91 81       	ldd	r25, Z+1	; 0x01
    2fd8:	29 81       	ldd	r18, Y+1	; 0x01
    2fda:	3a 81       	ldd	r19, Y+2	; 0x02
    2fdc:	f9 01       	movw	r30, r18
    2fde:	23 8d       	ldd	r18, Z+27	; 0x1b
    2fe0:	42 2f       	mov	r20, r18
    2fe2:	50 e0       	ldi	r21, 0x00	; 0
    2fe4:	29 81       	ldd	r18, Y+1	; 0x01
    2fe6:	3a 81       	ldd	r19, Y+2	; 0x02
    2fe8:	f9 01       	movw	r30, r18
    2fea:	24 8d       	ldd	r18, Z+28	; 0x1c
    2fec:	22 2f       	mov	r18, r18
    2fee:	30 e0       	ldi	r19, 0x00	; 0
    2ff0:	42 9f       	mul	r20, r18
    2ff2:	b0 01       	movw	r22, r0
    2ff4:	43 9f       	mul	r20, r19
    2ff6:	70 0d       	add	r23, r0
    2ff8:	52 9f       	mul	r21, r18
    2ffa:	70 0d       	add	r23, r0
    2ffc:	11 24       	eor	r1, r1
    2ffe:	9b 01       	movw	r18, r22
    3000:	28 0f       	add	r18, r24
    3002:	39 1f       	adc	r19, r25
    3004:	89 81       	ldd	r24, Y+1	; 0x01
    3006:	9a 81       	ldd	r25, Y+2	; 0x02
    3008:	fc 01       	movw	r30, r24
    300a:	35 83       	std	Z+5, r19	; 0x05
    300c:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    300e:	89 81       	ldd	r24, Y+1	; 0x01
    3010:	9a 81       	ldd	r25, Y+2	; 0x02
    3012:	fc 01       	movw	r30, r24
    3014:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3016:	89 81       	ldd	r24, Y+1	; 0x01
    3018:	9a 81       	ldd	r25, Y+2	; 0x02
    301a:	fc 01       	movw	r30, r24
    301c:	20 81       	ld	r18, Z
    301e:	31 81       	ldd	r19, Z+1	; 0x01
    3020:	89 81       	ldd	r24, Y+1	; 0x01
    3022:	9a 81       	ldd	r25, Y+2	; 0x02
    3024:	fc 01       	movw	r30, r24
    3026:	33 83       	std	Z+3, r19	; 0x03
    3028:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    302a:	89 81       	ldd	r24, Y+1	; 0x01
    302c:	9a 81       	ldd	r25, Y+2	; 0x02
    302e:	fc 01       	movw	r30, r24
    3030:	20 81       	ld	r18, Z
    3032:	31 81       	ldd	r19, Z+1	; 0x01
    3034:	89 81       	ldd	r24, Y+1	; 0x01
    3036:	9a 81       	ldd	r25, Y+2	; 0x02
    3038:	fc 01       	movw	r30, r24
    303a:	83 8d       	ldd	r24, Z+27	; 0x1b
    303c:	88 2f       	mov	r24, r24
    303e:	90 e0       	ldi	r25, 0x00	; 0
    3040:	bc 01       	movw	r22, r24
    3042:	61 50       	subi	r22, 0x01	; 1
    3044:	71 09       	sbc	r23, r1
    3046:	89 81       	ldd	r24, Y+1	; 0x01
    3048:	9a 81       	ldd	r25, Y+2	; 0x02
    304a:	fc 01       	movw	r30, r24
    304c:	84 8d       	ldd	r24, Z+28	; 0x1c
    304e:	48 2f       	mov	r20, r24
    3050:	50 e0       	ldi	r21, 0x00	; 0
    3052:	64 9f       	mul	r22, r20
    3054:	c0 01       	movw	r24, r0
    3056:	65 9f       	mul	r22, r21
    3058:	90 0d       	add	r25, r0
    305a:	74 9f       	mul	r23, r20
    305c:	90 0d       	add	r25, r0
    305e:	11 24       	eor	r1, r1
    3060:	28 0f       	add	r18, r24
    3062:	39 1f       	adc	r19, r25
    3064:	89 81       	ldd	r24, Y+1	; 0x01
    3066:	9a 81       	ldd	r25, Y+2	; 0x02
    3068:	fc 01       	movw	r30, r24
    306a:	37 83       	std	Z+7, r19	; 0x07
    306c:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    306e:	89 81       	ldd	r24, Y+1	; 0x01
    3070:	9a 81       	ldd	r25, Y+2	; 0x02
    3072:	2f ef       	ldi	r18, 0xFF	; 255
    3074:	fc 01       	movw	r30, r24
    3076:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    3078:	89 81       	ldd	r24, Y+1	; 0x01
    307a:	9a 81       	ldd	r25, Y+2	; 0x02
    307c:	2f ef       	ldi	r18, 0xFF	; 255
    307e:	fc 01       	movw	r30, r24
    3080:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    3082:	8d 81       	ldd	r24, Y+5	; 0x05
    3084:	88 23       	and	r24, r24
    3086:	81 f4       	brne	.+32     	; 0x30a8 <xQueueGenericReset+0xfc>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3088:	89 81       	ldd	r24, Y+1	; 0x01
    308a:	9a 81       	ldd	r25, Y+2	; 0x02
    308c:	fc 01       	movw	r30, r24
    308e:	80 85       	ldd	r24, Z+8	; 0x08
    3090:	88 23       	and	r24, r24
    3092:	a1 f0       	breq	.+40     	; 0x30bc <xQueueGenericReset+0x110>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3094:	89 81       	ldd	r24, Y+1	; 0x01
    3096:	9a 81       	ldd	r25, Y+2	; 0x02
    3098:	08 96       	adiw	r24, 0x08	; 8
    309a:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    309e:	88 23       	and	r24, r24
    30a0:	69 f0       	breq	.+26     	; 0x30bc <xQueueGenericReset+0x110>
				{
					queueYIELD_IF_USING_PREEMPTION();
    30a2:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
    30a6:	0a c0       	rjmp	.+20     	; 0x30bc <xQueueGenericReset+0x110>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    30a8:	89 81       	ldd	r24, Y+1	; 0x01
    30aa:	9a 81       	ldd	r25, Y+2	; 0x02
    30ac:	08 96       	adiw	r24, 0x08	; 8
    30ae:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    30b2:	89 81       	ldd	r24, Y+1	; 0x01
    30b4:	9a 81       	ldd	r25, Y+2	; 0x02
    30b6:	41 96       	adiw	r24, 0x11	; 17
    30b8:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    30bc:	0f 90       	pop	r0
    30be:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    30c0:	81 e0       	ldi	r24, 0x01	; 1
}
    30c2:	0f 90       	pop	r0
    30c4:	0f 90       	pop	r0
    30c6:	0f 90       	pop	r0
    30c8:	0f 90       	pop	r0
    30ca:	0f 90       	pop	r0
    30cc:	df 91       	pop	r29
    30ce:	cf 91       	pop	r28
    30d0:	08 95       	ret

000030d2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    30d2:	0f 93       	push	r16
    30d4:	1f 93       	push	r17
    30d6:	cf 93       	push	r28
    30d8:	df 93       	push	r29
    30da:	cd b7       	in	r28, 0x3d	; 61
    30dc:	de b7       	in	r29, 0x3e	; 62
    30de:	29 97       	sbiw	r28, 0x09	; 9
    30e0:	0f b6       	in	r0, 0x3f	; 63
    30e2:	f8 94       	cli
    30e4:	de bf       	out	0x3e, r29	; 62
    30e6:	0f be       	out	0x3f, r0	; 63
    30e8:	cd bf       	out	0x3d, r28	; 61
    30ea:	8f 83       	std	Y+7, r24	; 0x07
    30ec:	68 87       	std	Y+8, r22	; 0x08
    30ee:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    30f0:	88 85       	ldd	r24, Y+8	; 0x08
    30f2:	88 23       	and	r24, r24
    30f4:	19 f4       	brne	.+6      	; 0x30fc <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    30f6:	1a 82       	std	Y+2, r1	; 0x02
    30f8:	19 82       	std	Y+1, r1	; 0x01
    30fa:	0f c0       	rjmp	.+30     	; 0x311a <xQueueGenericCreate+0x48>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    30fc:	8f 81       	ldd	r24, Y+7	; 0x07
    30fe:	48 2f       	mov	r20, r24
    3100:	50 e0       	ldi	r21, 0x00	; 0
    3102:	88 85       	ldd	r24, Y+8	; 0x08
    3104:	28 2f       	mov	r18, r24
    3106:	30 e0       	ldi	r19, 0x00	; 0
    3108:	42 9f       	mul	r20, r18
    310a:	c0 01       	movw	r24, r0
    310c:	43 9f       	mul	r20, r19
    310e:	90 0d       	add	r25, r0
    3110:	52 9f       	mul	r21, r18
    3112:	90 0d       	add	r25, r0
    3114:	11 24       	eor	r1, r1
    3116:	9a 83       	std	Y+2, r25	; 0x02
    3118:	89 83       	std	Y+1, r24	; 0x01
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    311a:	89 81       	ldd	r24, Y+1	; 0x01
    311c:	9a 81       	ldd	r25, Y+2	; 0x02
    311e:	4f 96       	adiw	r24, 0x1f	; 31
    3120:	0e 94 99 12 	call	0x2532	; 0x2532 <pvPortMalloc>
    3124:	9c 83       	std	Y+4, r25	; 0x04
    3126:	8b 83       	std	Y+3, r24	; 0x03

		if( pxNewQueue != NULL )
    3128:	8b 81       	ldd	r24, Y+3	; 0x03
    312a:	9c 81       	ldd	r25, Y+4	; 0x04
    312c:	89 2b       	or	r24, r25
    312e:	a1 f0       	breq	.+40     	; 0x3158 <xQueueGenericCreate+0x86>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    3130:	8b 81       	ldd	r24, Y+3	; 0x03
    3132:	9c 81       	ldd	r25, Y+4	; 0x04
    3134:	9e 83       	std	Y+6, r25	; 0x06
    3136:	8d 83       	std	Y+5, r24	; 0x05
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3138:	8d 81       	ldd	r24, Y+5	; 0x05
    313a:	9e 81       	ldd	r25, Y+6	; 0x06
    313c:	4f 96       	adiw	r24, 0x1f	; 31
    313e:	9e 83       	std	Y+6, r25	; 0x06
    3140:	8d 83       	std	Y+5, r24	; 0x05
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    3142:	2b 81       	ldd	r18, Y+3	; 0x03
    3144:	3c 81       	ldd	r19, Y+4	; 0x04
    3146:	8d 81       	ldd	r24, Y+5	; 0x05
    3148:	9e 81       	ldd	r25, Y+6	; 0x06
    314a:	89 01       	movw	r16, r18
    314c:	29 85       	ldd	r18, Y+9	; 0x09
    314e:	ac 01       	movw	r20, r24
    3150:	68 85       	ldd	r22, Y+8	; 0x08
    3152:	8f 81       	ldd	r24, Y+7	; 0x07
    3154:	0e 94 b9 18 	call	0x3172	; 0x3172 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    3158:	8b 81       	ldd	r24, Y+3	; 0x03
    315a:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    315c:	29 96       	adiw	r28, 0x09	; 9
    315e:	0f b6       	in	r0, 0x3f	; 63
    3160:	f8 94       	cli
    3162:	de bf       	out	0x3e, r29	; 62
    3164:	0f be       	out	0x3f, r0	; 63
    3166:	cd bf       	out	0x3d, r28	; 61
    3168:	df 91       	pop	r29
    316a:	cf 91       	pop	r28
    316c:	1f 91       	pop	r17
    316e:	0f 91       	pop	r16
    3170:	08 95       	ret

00003172 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    3172:	0f 93       	push	r16
    3174:	1f 93       	push	r17
    3176:	cf 93       	push	r28
    3178:	df 93       	push	r29
    317a:	cd b7       	in	r28, 0x3d	; 61
    317c:	de b7       	in	r29, 0x3e	; 62
    317e:	27 97       	sbiw	r28, 0x07	; 7
    3180:	0f b6       	in	r0, 0x3f	; 63
    3182:	f8 94       	cli
    3184:	de bf       	out	0x3e, r29	; 62
    3186:	0f be       	out	0x3f, r0	; 63
    3188:	cd bf       	out	0x3d, r28	; 61
    318a:	89 83       	std	Y+1, r24	; 0x01
    318c:	6a 83       	std	Y+2, r22	; 0x02
    318e:	5c 83       	std	Y+4, r21	; 0x04
    3190:	4b 83       	std	Y+3, r20	; 0x03
    3192:	2d 83       	std	Y+5, r18	; 0x05
    3194:	1f 83       	std	Y+7, r17	; 0x07
    3196:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    3198:	8a 81       	ldd	r24, Y+2	; 0x02
    319a:	88 23       	and	r24, r24
    319c:	41 f4       	brne	.+16     	; 0x31ae <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    319e:	8e 81       	ldd	r24, Y+6	; 0x06
    31a0:	9f 81       	ldd	r25, Y+7	; 0x07
    31a2:	2e 81       	ldd	r18, Y+6	; 0x06
    31a4:	3f 81       	ldd	r19, Y+7	; 0x07
    31a6:	fc 01       	movw	r30, r24
    31a8:	31 83       	std	Z+1, r19	; 0x01
    31aa:	20 83       	st	Z, r18
    31ac:	07 c0       	rjmp	.+14     	; 0x31bc <prvInitialiseNewQueue+0x4a>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    31ae:	8e 81       	ldd	r24, Y+6	; 0x06
    31b0:	9f 81       	ldd	r25, Y+7	; 0x07
    31b2:	2b 81       	ldd	r18, Y+3	; 0x03
    31b4:	3c 81       	ldd	r19, Y+4	; 0x04
    31b6:	fc 01       	movw	r30, r24
    31b8:	31 83       	std	Z+1, r19	; 0x01
    31ba:	20 83       	st	Z, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    31bc:	8e 81       	ldd	r24, Y+6	; 0x06
    31be:	9f 81       	ldd	r25, Y+7	; 0x07
    31c0:	29 81       	ldd	r18, Y+1	; 0x01
    31c2:	fc 01       	movw	r30, r24
    31c4:	23 8f       	std	Z+27, r18	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    31c6:	8e 81       	ldd	r24, Y+6	; 0x06
    31c8:	9f 81       	ldd	r25, Y+7	; 0x07
    31ca:	2a 81       	ldd	r18, Y+2	; 0x02
    31cc:	fc 01       	movw	r30, r24
    31ce:	24 8f       	std	Z+28, r18	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    31d0:	8e 81       	ldd	r24, Y+6	; 0x06
    31d2:	9f 81       	ldd	r25, Y+7	; 0x07
    31d4:	61 e0       	ldi	r22, 0x01	; 1
    31d6:	0e 94 d6 17 	call	0x2fac	; 0x2fac <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    31da:	00 00       	nop
    31dc:	27 96       	adiw	r28, 0x07	; 7
    31de:	0f b6       	in	r0, 0x3f	; 63
    31e0:	f8 94       	cli
    31e2:	de bf       	out	0x3e, r29	; 62
    31e4:	0f be       	out	0x3f, r0	; 63
    31e6:	cd bf       	out	0x3d, r28	; 61
    31e8:	df 91       	pop	r29
    31ea:	cf 91       	pop	r28
    31ec:	1f 91       	pop	r17
    31ee:	0f 91       	pop	r16
    31f0:	08 95       	ret

000031f2 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    31f2:	cf 93       	push	r28
    31f4:	df 93       	push	r29
    31f6:	00 d0       	rcall	.+0      	; 0x31f8 <prvInitialiseMutex+0x6>
    31f8:	cd b7       	in	r28, 0x3d	; 61
    31fa:	de b7       	in	r29, 0x3e	; 62
    31fc:	9a 83       	std	Y+2, r25	; 0x02
    31fe:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    3200:	89 81       	ldd	r24, Y+1	; 0x01
    3202:	9a 81       	ldd	r25, Y+2	; 0x02
    3204:	89 2b       	or	r24, r25
    3206:	b9 f0       	breq	.+46     	; 0x3236 <prvInitialiseMutex+0x44>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    3208:	89 81       	ldd	r24, Y+1	; 0x01
    320a:	9a 81       	ldd	r25, Y+2	; 0x02
    320c:	fc 01       	movw	r30, r24
    320e:	15 82       	std	Z+5, r1	; 0x05
    3210:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    3212:	89 81       	ldd	r24, Y+1	; 0x01
    3214:	9a 81       	ldd	r25, Y+2	; 0x02
    3216:	fc 01       	movw	r30, r24
    3218:	11 82       	std	Z+1, r1	; 0x01
    321a:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    321c:	89 81       	ldd	r24, Y+1	; 0x01
    321e:	9a 81       	ldd	r25, Y+2	; 0x02
    3220:	fc 01       	movw	r30, r24
    3222:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    3224:	89 81       	ldd	r24, Y+1	; 0x01
    3226:	9a 81       	ldd	r25, Y+2	; 0x02
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	40 e0       	ldi	r20, 0x00	; 0
    322c:	50 e0       	ldi	r21, 0x00	; 0
    322e:	60 e0       	ldi	r22, 0x00	; 0
    3230:	70 e0       	ldi	r23, 0x00	; 0
    3232:	0e 94 41 19 	call	0x3282	; 0x3282 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    3236:	00 00       	nop
    3238:	0f 90       	pop	r0
    323a:	0f 90       	pop	r0
    323c:	df 91       	pop	r29
    323e:	cf 91       	pop	r28
    3240:	08 95       	ret

00003242 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    3242:	cf 93       	push	r28
    3244:	df 93       	push	r29
    3246:	00 d0       	rcall	.+0      	; 0x3248 <xQueueCreateMutex+0x6>
    3248:	00 d0       	rcall	.+0      	; 0x324a <xQueueCreateMutex+0x8>
    324a:	1f 92       	push	r1
    324c:	cd b7       	in	r28, 0x3d	; 61
    324e:	de b7       	in	r29, 0x3e	; 62
    3250:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    3252:	81 e0       	ldi	r24, 0x01	; 1
    3254:	89 83       	std	Y+1, r24	; 0x01
    3256:	1a 82       	std	Y+2, r1	; 0x02

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    3258:	4d 81       	ldd	r20, Y+5	; 0x05
    325a:	6a 81       	ldd	r22, Y+2	; 0x02
    325c:	89 81       	ldd	r24, Y+1	; 0x01
    325e:	0e 94 69 18 	call	0x30d2	; 0x30d2 <xQueueGenericCreate>
    3262:	9c 83       	std	Y+4, r25	; 0x04
    3264:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    3266:	8b 81       	ldd	r24, Y+3	; 0x03
    3268:	9c 81       	ldd	r25, Y+4	; 0x04
    326a:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <prvInitialiseMutex>

		return xNewQueue;
    326e:	8b 81       	ldd	r24, Y+3	; 0x03
    3270:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    3272:	0f 90       	pop	r0
    3274:	0f 90       	pop	r0
    3276:	0f 90       	pop	r0
    3278:	0f 90       	pop	r0
    327a:	0f 90       	pop	r0
    327c:	df 91       	pop	r29
    327e:	cf 91       	pop	r28
    3280:	08 95       	ret

00003282 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3282:	cf 93       	push	r28
    3284:	df 93       	push	r29
    3286:	cd b7       	in	r28, 0x3d	; 61
    3288:	de b7       	in	r29, 0x3e	; 62
    328a:	2e 97       	sbiw	r28, 0x0e	; 14
    328c:	0f b6       	in	r0, 0x3f	; 63
    328e:	f8 94       	cli
    3290:	de bf       	out	0x3e, r29	; 62
    3292:	0f be       	out	0x3f, r0	; 63
    3294:	cd bf       	out	0x3d, r28	; 61
    3296:	99 87       	std	Y+9, r25	; 0x09
    3298:	88 87       	std	Y+8, r24	; 0x08
    329a:	7b 87       	std	Y+11, r23	; 0x0b
    329c:	6a 87       	std	Y+10, r22	; 0x0a
    329e:	5d 87       	std	Y+13, r21	; 0x0d
    32a0:	4c 87       	std	Y+12, r20	; 0x0c
    32a2:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    32a4:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    32a6:	88 85       	ldd	r24, Y+8	; 0x08
    32a8:	99 85       	ldd	r25, Y+9	; 0x09
    32aa:	9b 83       	std	Y+3, r25	; 0x03
    32ac:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    32ae:	0f b6       	in	r0, 0x3f	; 63
    32b0:	f8 94       	cli
    32b2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    32b4:	8a 81       	ldd	r24, Y+2	; 0x02
    32b6:	9b 81       	ldd	r25, Y+3	; 0x03
    32b8:	fc 01       	movw	r30, r24
    32ba:	22 8d       	ldd	r18, Z+26	; 0x1a
    32bc:	8a 81       	ldd	r24, Y+2	; 0x02
    32be:	9b 81       	ldd	r25, Y+3	; 0x03
    32c0:	fc 01       	movw	r30, r24
    32c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    32c4:	28 17       	cp	r18, r24
    32c6:	18 f0       	brcs	.+6      	; 0x32ce <xQueueGenericSend+0x4c>
    32c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    32ca:	82 30       	cpi	r24, 0x02	; 2
    32cc:	11 f5       	brne	.+68     	; 0x3312 <xQueueGenericSend+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    32ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    32d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    32d2:	8a 81       	ldd	r24, Y+2	; 0x02
    32d4:	9b 81       	ldd	r25, Y+3	; 0x03
    32d6:	4e 85       	ldd	r20, Y+14	; 0x0e
    32d8:	b9 01       	movw	r22, r18
    32da:	0e 94 26 1e 	call	0x3c4c	; 0x3c4c <prvCopyDataToQueue>
    32de:	8c 83       	std	Y+4, r24	; 0x04

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    32e0:	8a 81       	ldd	r24, Y+2	; 0x02
    32e2:	9b 81       	ldd	r25, Y+3	; 0x03
    32e4:	fc 01       	movw	r30, r24
    32e6:	81 89       	ldd	r24, Z+17	; 0x11
    32e8:	88 23       	and	r24, r24
    32ea:	51 f0       	breq	.+20     	; 0x3300 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32ec:	8a 81       	ldd	r24, Y+2	; 0x02
    32ee:	9b 81       	ldd	r25, Y+3	; 0x03
    32f0:	41 96       	adiw	r24, 0x11	; 17
    32f2:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    32f6:	88 23       	and	r24, r24
    32f8:	41 f0       	breq	.+16     	; 0x330a <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    32fa:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
    32fe:	05 c0       	rjmp	.+10     	; 0x330a <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3300:	8c 81       	ldd	r24, Y+4	; 0x04
    3302:	88 23       	and	r24, r24
    3304:	11 f0       	breq	.+4      	; 0x330a <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3306:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    330a:	0f 90       	pop	r0
    330c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    330e:	81 e0       	ldi	r24, 0x01	; 1
    3310:	60 c0       	rjmp	.+192    	; 0x33d2 <xQueueGenericSend+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3312:	8c 85       	ldd	r24, Y+12	; 0x0c
    3314:	9d 85       	ldd	r25, Y+13	; 0x0d
    3316:	89 2b       	or	r24, r25
    3318:	21 f4       	brne	.+8      	; 0x3322 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    331a:	0f 90       	pop	r0
    331c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    331e:	80 e0       	ldi	r24, 0x00	; 0
    3320:	58 c0       	rjmp	.+176    	; 0x33d2 <xQueueGenericSend+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    3322:	89 81       	ldd	r24, Y+1	; 0x01
    3324:	88 23       	and	r24, r24
    3326:	31 f4       	brne	.+12     	; 0x3334 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3328:	ce 01       	movw	r24, r28
    332a:	05 96       	adiw	r24, 0x05	; 5
    332c:	0e 94 4c 28 	call	0x5098	; 0x5098 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3330:	81 e0       	ldi	r24, 0x01	; 1
    3332:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3334:	0f 90       	pop	r0
    3336:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3338:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    333c:	0f b6       	in	r0, 0x3f	; 63
    333e:	f8 94       	cli
    3340:	0f 92       	push	r0
    3342:	8a 81       	ldd	r24, Y+2	; 0x02
    3344:	9b 81       	ldd	r25, Y+3	; 0x03
    3346:	fc 01       	movw	r30, r24
    3348:	85 8d       	ldd	r24, Z+29	; 0x1d
    334a:	8f 3f       	cpi	r24, 0xFF	; 255
    334c:	21 f4       	brne	.+8      	; 0x3356 <xQueueGenericSend+0xd4>
    334e:	8a 81       	ldd	r24, Y+2	; 0x02
    3350:	9b 81       	ldd	r25, Y+3	; 0x03
    3352:	fc 01       	movw	r30, r24
    3354:	15 8e       	std	Z+29, r1	; 0x1d
    3356:	8a 81       	ldd	r24, Y+2	; 0x02
    3358:	9b 81       	ldd	r25, Y+3	; 0x03
    335a:	fc 01       	movw	r30, r24
    335c:	86 8d       	ldd	r24, Z+30	; 0x1e
    335e:	8f 3f       	cpi	r24, 0xFF	; 255
    3360:	21 f4       	brne	.+8      	; 0x336a <xQueueGenericSend+0xe8>
    3362:	8a 81       	ldd	r24, Y+2	; 0x02
    3364:	9b 81       	ldd	r25, Y+3	; 0x03
    3366:	fc 01       	movw	r30, r24
    3368:	16 8e       	std	Z+30, r1	; 0x1e
    336a:	0f 90       	pop	r0
    336c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    336e:	9e 01       	movw	r18, r28
    3370:	24 5f       	subi	r18, 0xF4	; 244
    3372:	3f 4f       	sbci	r19, 0xFF	; 255
    3374:	ce 01       	movw	r24, r28
    3376:	05 96       	adiw	r24, 0x05	; 5
    3378:	b9 01       	movw	r22, r18
    337a:	0e 94 68 28 	call	0x50d0	; 0x50d0 <xTaskCheckForTimeOut>
    337e:	88 23       	and	r24, r24
    3380:	09 f5       	brne	.+66     	; 0x33c4 <xQueueGenericSend+0x142>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3382:	8a 81       	ldd	r24, Y+2	; 0x02
    3384:	9b 81       	ldd	r25, Y+3	; 0x03
    3386:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <prvIsQueueFull>
    338a:	88 23       	and	r24, r24
    338c:	a1 f0       	breq	.+40     	; 0x33b6 <xQueueGenericSend+0x134>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    338e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3390:	3d 85       	ldd	r19, Y+13	; 0x0d
    3392:	8a 81       	ldd	r24, Y+2	; 0x02
    3394:	9b 81       	ldd	r25, Y+3	; 0x03
    3396:	08 96       	adiw	r24, 0x08	; 8
    3398:	b9 01       	movw	r22, r18
    339a:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    339e:	8a 81       	ldd	r24, Y+2	; 0x02
    33a0:	9b 81       	ldd	r25, Y+3	; 0x03
    33a2:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    33a6:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    33aa:	88 23       	and	r24, r24
    33ac:	09 f0       	breq	.+2      	; 0x33b0 <xQueueGenericSend+0x12e>
    33ae:	7f cf       	rjmp	.-258    	; 0x32ae <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    33b0:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
    33b4:	7c cf       	rjmp	.-264    	; 0x32ae <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    33b6:	8a 81       	ldd	r24, Y+2	; 0x02
    33b8:	9b 81       	ldd	r25, Y+3	; 0x03
    33ba:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    33be:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    33c2:	75 cf       	rjmp	.-278    	; 0x32ae <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    33c4:	8a 81       	ldd	r24, Y+2	; 0x02
    33c6:	9b 81       	ldd	r25, Y+3	; 0x03
    33c8:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    33cc:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    33d0:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    33d2:	2e 96       	adiw	r28, 0x0e	; 14
    33d4:	0f b6       	in	r0, 0x3f	; 63
    33d6:	f8 94       	cli
    33d8:	de bf       	out	0x3e, r29	; 62
    33da:	0f be       	out	0x3f, r0	; 63
    33dc:	cd bf       	out	0x3d, r28	; 61
    33de:	df 91       	pop	r29
    33e0:	cf 91       	pop	r28
    33e2:	08 95       	ret

000033e4 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    33e4:	cf 93       	push	r28
    33e6:	df 93       	push	r29
    33e8:	cd b7       	in	r28, 0x3d	; 61
    33ea:	de b7       	in	r29, 0x3e	; 62
    33ec:	2c 97       	sbiw	r28, 0x0c	; 12
    33ee:	0f b6       	in	r0, 0x3f	; 63
    33f0:	f8 94       	cli
    33f2:	de bf       	out	0x3e, r29	; 62
    33f4:	0f be       	out	0x3f, r0	; 63
    33f6:	cd bf       	out	0x3d, r28	; 61
    33f8:	9f 83       	std	Y+7, r25	; 0x07
    33fa:	8e 83       	std	Y+6, r24	; 0x06
    33fc:	79 87       	std	Y+9, r23	; 0x09
    33fe:	68 87       	std	Y+8, r22	; 0x08
    3400:	5b 87       	std	Y+11, r21	; 0x0b
    3402:	4a 87       	std	Y+10, r20	; 0x0a
    3404:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3406:	8e 81       	ldd	r24, Y+6	; 0x06
    3408:	9f 81       	ldd	r25, Y+7	; 0x07
    340a:	9b 83       	std	Y+3, r25	; 0x03
    340c:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    340e:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3410:	8a 81       	ldd	r24, Y+2	; 0x02
    3412:	9b 81       	ldd	r25, Y+3	; 0x03
    3414:	fc 01       	movw	r30, r24
    3416:	22 8d       	ldd	r18, Z+26	; 0x1a
    3418:	8a 81       	ldd	r24, Y+2	; 0x02
    341a:	9b 81       	ldd	r25, Y+3	; 0x03
    341c:	fc 01       	movw	r30, r24
    341e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3420:	28 17       	cp	r18, r24
    3422:	18 f0       	brcs	.+6      	; 0x342a <xQueueGenericSendFromISR+0x46>
    3424:	8c 85       	ldd	r24, Y+12	; 0x0c
    3426:	82 30       	cpi	r24, 0x02	; 2
    3428:	89 f5       	brne	.+98     	; 0x348c <xQueueGenericSendFromISR+0xa8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    342a:	8a 81       	ldd	r24, Y+2	; 0x02
    342c:	9b 81       	ldd	r25, Y+3	; 0x03
    342e:	fc 01       	movw	r30, r24
    3430:	86 8d       	ldd	r24, Z+30	; 0x1e
    3432:	8d 83       	std	Y+5, r24	; 0x05
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3434:	28 85       	ldd	r18, Y+8	; 0x08
    3436:	39 85       	ldd	r19, Y+9	; 0x09
    3438:	8a 81       	ldd	r24, Y+2	; 0x02
    343a:	9b 81       	ldd	r25, Y+3	; 0x03
    343c:	4c 85       	ldd	r20, Y+12	; 0x0c
    343e:	b9 01       	movw	r22, r18
    3440:	0e 94 26 1e 	call	0x3c4c	; 0x3c4c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3444:	8d 81       	ldd	r24, Y+5	; 0x05
    3446:	8f 3f       	cpi	r24, 0xFF	; 255
    3448:	b9 f4       	brne	.+46     	; 0x3478 <xQueueGenericSendFromISR+0x94>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    344a:	8a 81       	ldd	r24, Y+2	; 0x02
    344c:	9b 81       	ldd	r25, Y+3	; 0x03
    344e:	fc 01       	movw	r30, r24
    3450:	81 89       	ldd	r24, Z+17	; 0x11
    3452:	88 23       	and	r24, r24
    3454:	c1 f0       	breq	.+48     	; 0x3486 <xQueueGenericSendFromISR+0xa2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3456:	8a 81       	ldd	r24, Y+2	; 0x02
    3458:	9b 81       	ldd	r25, Y+3	; 0x03
    345a:	41 96       	adiw	r24, 0x11	; 17
    345c:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    3460:	88 23       	and	r24, r24
    3462:	89 f0       	breq	.+34     	; 0x3486 <xQueueGenericSendFromISR+0xa2>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3464:	8a 85       	ldd	r24, Y+10	; 0x0a
    3466:	9b 85       	ldd	r25, Y+11	; 0x0b
    3468:	89 2b       	or	r24, r25
    346a:	69 f0       	breq	.+26     	; 0x3486 <xQueueGenericSendFromISR+0xa2>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    346c:	8a 85       	ldd	r24, Y+10	; 0x0a
    346e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3470:	21 e0       	ldi	r18, 0x01	; 1
    3472:	fc 01       	movw	r30, r24
    3474:	20 83       	st	Z, r18
    3476:	07 c0       	rjmp	.+14     	; 0x3486 <xQueueGenericSendFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3478:	8d 81       	ldd	r24, Y+5	; 0x05
    347a:	8f 5f       	subi	r24, 0xFF	; 255
    347c:	28 2f       	mov	r18, r24
    347e:	8a 81       	ldd	r24, Y+2	; 0x02
    3480:	9b 81       	ldd	r25, Y+3	; 0x03
    3482:	fc 01       	movw	r30, r24
    3484:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    3486:	81 e0       	ldi	r24, 0x01	; 1
    3488:	89 83       	std	Y+1, r24	; 0x01
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
    348a:	01 c0       	rjmp	.+2      	; 0x348e <xQueueGenericSendFromISR+0xaa>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    348c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    348e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3490:	2c 96       	adiw	r28, 0x0c	; 12
    3492:	0f b6       	in	r0, 0x3f	; 63
    3494:	f8 94       	cli
    3496:	de bf       	out	0x3e, r29	; 62
    3498:	0f be       	out	0x3f, r0	; 63
    349a:	cd bf       	out	0x3d, r28	; 61
    349c:	df 91       	pop	r29
    349e:	cf 91       	pop	r28
    34a0:	08 95       	ret

000034a2 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    34a2:	cf 93       	push	r28
    34a4:	df 93       	push	r29
    34a6:	cd b7       	in	r28, 0x3d	; 61
    34a8:	de b7       	in	r29, 0x3e	; 62
    34aa:	2a 97       	sbiw	r28, 0x0a	; 10
    34ac:	0f b6       	in	r0, 0x3f	; 63
    34ae:	f8 94       	cli
    34b0:	de bf       	out	0x3e, r29	; 62
    34b2:	0f be       	out	0x3f, r0	; 63
    34b4:	cd bf       	out	0x3d, r28	; 61
    34b6:	98 87       	std	Y+8, r25	; 0x08
    34b8:	8f 83       	std	Y+7, r24	; 0x07
    34ba:	7a 87       	std	Y+10, r23	; 0x0a
    34bc:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    34be:	8f 81       	ldd	r24, Y+7	; 0x07
    34c0:	98 85       	ldd	r25, Y+8	; 0x08
    34c2:	9b 83       	std	Y+3, r25	; 0x03
    34c4:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    34c6:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    34c8:	8a 81       	ldd	r24, Y+2	; 0x02
    34ca:	9b 81       	ldd	r25, Y+3	; 0x03
    34cc:	fc 01       	movw	r30, r24
    34ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    34d0:	8d 83       	std	Y+5, r24	; 0x05

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    34d2:	8a 81       	ldd	r24, Y+2	; 0x02
    34d4:	9b 81       	ldd	r25, Y+3	; 0x03
    34d6:	fc 01       	movw	r30, r24
    34d8:	93 8d       	ldd	r25, Z+27	; 0x1b
    34da:	8d 81       	ldd	r24, Y+5	; 0x05
    34dc:	89 17       	cp	r24, r25
    34de:	80 f5       	brcc	.+96     	; 0x3540 <xQueueGiveFromISR+0x9e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    34e0:	8a 81       	ldd	r24, Y+2	; 0x02
    34e2:	9b 81       	ldd	r25, Y+3	; 0x03
    34e4:	fc 01       	movw	r30, r24
    34e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    34e8:	8e 83       	std	Y+6, r24	; 0x06
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    34ea:	8d 81       	ldd	r24, Y+5	; 0x05
    34ec:	21 e0       	ldi	r18, 0x01	; 1
    34ee:	28 0f       	add	r18, r24
    34f0:	8a 81       	ldd	r24, Y+2	; 0x02
    34f2:	9b 81       	ldd	r25, Y+3	; 0x03
    34f4:	fc 01       	movw	r30, r24
    34f6:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    34f8:	8e 81       	ldd	r24, Y+6	; 0x06
    34fa:	8f 3f       	cpi	r24, 0xFF	; 255
    34fc:	b9 f4       	brne	.+46     	; 0x352c <xQueueGiveFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3500:	9b 81       	ldd	r25, Y+3	; 0x03
    3502:	fc 01       	movw	r30, r24
    3504:	81 89       	ldd	r24, Z+17	; 0x11
    3506:	88 23       	and	r24, r24
    3508:	c1 f0       	breq	.+48     	; 0x353a <xQueueGiveFromISR+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    350a:	8a 81       	ldd	r24, Y+2	; 0x02
    350c:	9b 81       	ldd	r25, Y+3	; 0x03
    350e:	41 96       	adiw	r24, 0x11	; 17
    3510:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    3514:	88 23       	and	r24, r24
    3516:	89 f0       	breq	.+34     	; 0x353a <xQueueGiveFromISR+0x98>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3518:	89 85       	ldd	r24, Y+9	; 0x09
    351a:	9a 85       	ldd	r25, Y+10	; 0x0a
    351c:	89 2b       	or	r24, r25
    351e:	69 f0       	breq	.+26     	; 0x353a <xQueueGiveFromISR+0x98>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3520:	89 85       	ldd	r24, Y+9	; 0x09
    3522:	9a 85       	ldd	r25, Y+10	; 0x0a
    3524:	21 e0       	ldi	r18, 0x01	; 1
    3526:	fc 01       	movw	r30, r24
    3528:	20 83       	st	Z, r18
    352a:	07 c0       	rjmp	.+14     	; 0x353a <xQueueGiveFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    352c:	8e 81       	ldd	r24, Y+6	; 0x06
    352e:	8f 5f       	subi	r24, 0xFF	; 255
    3530:	28 2f       	mov	r18, r24
    3532:	8a 81       	ldd	r24, Y+2	; 0x02
    3534:	9b 81       	ldd	r25, Y+3	; 0x03
    3536:	fc 01       	movw	r30, r24
    3538:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    353a:	81 e0       	ldi	r24, 0x01	; 1
    353c:	89 83       	std	Y+1, r24	; 0x01
    353e:	01 c0       	rjmp	.+2      	; 0x3542 <xQueueGiveFromISR+0xa0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3540:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3542:	89 81       	ldd	r24, Y+1	; 0x01
}
    3544:	2a 96       	adiw	r28, 0x0a	; 10
    3546:	0f b6       	in	r0, 0x3f	; 63
    3548:	f8 94       	cli
    354a:	de bf       	out	0x3e, r29	; 62
    354c:	0f be       	out	0x3f, r0	; 63
    354e:	cd bf       	out	0x3d, r28	; 61
    3550:	df 91       	pop	r29
    3552:	cf 91       	pop	r28
    3554:	08 95       	ret

00003556 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3556:	cf 93       	push	r28
    3558:	df 93       	push	r29
    355a:	cd b7       	in	r28, 0x3d	; 61
    355c:	de b7       	in	r29, 0x3e	; 62
    355e:	2d 97       	sbiw	r28, 0x0d	; 13
    3560:	0f b6       	in	r0, 0x3f	; 63
    3562:	f8 94       	cli
    3564:	de bf       	out	0x3e, r29	; 62
    3566:	0f be       	out	0x3f, r0	; 63
    3568:	cd bf       	out	0x3d, r28	; 61
    356a:	99 87       	std	Y+9, r25	; 0x09
    356c:	88 87       	std	Y+8, r24	; 0x08
    356e:	7b 87       	std	Y+11, r23	; 0x0b
    3570:	6a 87       	std	Y+10, r22	; 0x0a
    3572:	5d 87       	std	Y+13, r21	; 0x0d
    3574:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3576:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3578:	88 85       	ldd	r24, Y+8	; 0x08
    357a:	99 85       	ldd	r25, Y+9	; 0x09
    357c:	9b 83       	std	Y+3, r25	; 0x03
    357e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3580:	0f b6       	in	r0, 0x3f	; 63
    3582:	f8 94       	cli
    3584:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3586:	8a 81       	ldd	r24, Y+2	; 0x02
    3588:	9b 81       	ldd	r25, Y+3	; 0x03
    358a:	fc 01       	movw	r30, r24
    358c:	82 8d       	ldd	r24, Z+26	; 0x1a
    358e:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3590:	8c 81       	ldd	r24, Y+4	; 0x04
    3592:	88 23       	and	r24, r24
    3594:	09 f1       	breq	.+66     	; 0x35d8 <xQueueReceive+0x82>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3596:	2a 85       	ldd	r18, Y+10	; 0x0a
    3598:	3b 85       	ldd	r19, Y+11	; 0x0b
    359a:	8a 81       	ldd	r24, Y+2	; 0x02
    359c:	9b 81       	ldd	r25, Y+3	; 0x03
    359e:	b9 01       	movw	r22, r18
    35a0:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    35a4:	8c 81       	ldd	r24, Y+4	; 0x04
    35a6:	2f ef       	ldi	r18, 0xFF	; 255
    35a8:	28 0f       	add	r18, r24
    35aa:	8a 81       	ldd	r24, Y+2	; 0x02
    35ac:	9b 81       	ldd	r25, Y+3	; 0x03
    35ae:	fc 01       	movw	r30, r24
    35b0:	22 8f       	std	Z+26, r18	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35b2:	8a 81       	ldd	r24, Y+2	; 0x02
    35b4:	9b 81       	ldd	r25, Y+3	; 0x03
    35b6:	fc 01       	movw	r30, r24
    35b8:	80 85       	ldd	r24, Z+8	; 0x08
    35ba:	88 23       	and	r24, r24
    35bc:	49 f0       	breq	.+18     	; 0x35d0 <xQueueReceive+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    35be:	8a 81       	ldd	r24, Y+2	; 0x02
    35c0:	9b 81       	ldd	r25, Y+3	; 0x03
    35c2:	08 96       	adiw	r24, 0x08	; 8
    35c4:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    35c8:	88 23       	and	r24, r24
    35ca:	11 f0       	breq	.+4      	; 0x35d0 <xQueueReceive+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    35cc:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    35d0:	0f 90       	pop	r0
    35d2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    35d4:	81 e0       	ldi	r24, 0x01	; 1
    35d6:	67 c0       	rjmp	.+206    	; 0x36a6 <xQueueReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    35d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    35da:	9d 85       	ldd	r25, Y+13	; 0x0d
    35dc:	89 2b       	or	r24, r25
    35de:	21 f4       	brne	.+8      	; 0x35e8 <xQueueReceive+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    35e0:	0f 90       	pop	r0
    35e2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    35e4:	80 e0       	ldi	r24, 0x00	; 0
    35e6:	5f c0       	rjmp	.+190    	; 0x36a6 <xQueueReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    35e8:	89 81       	ldd	r24, Y+1	; 0x01
    35ea:	88 23       	and	r24, r24
    35ec:	31 f4       	brne	.+12     	; 0x35fa <xQueueReceive+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    35ee:	ce 01       	movw	r24, r28
    35f0:	05 96       	adiw	r24, 0x05	; 5
    35f2:	0e 94 4c 28 	call	0x5098	; 0x5098 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    35f6:	81 e0       	ldi	r24, 0x01	; 1
    35f8:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    35fa:	0f 90       	pop	r0
    35fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    35fe:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3602:	0f b6       	in	r0, 0x3f	; 63
    3604:	f8 94       	cli
    3606:	0f 92       	push	r0
    3608:	8a 81       	ldd	r24, Y+2	; 0x02
    360a:	9b 81       	ldd	r25, Y+3	; 0x03
    360c:	fc 01       	movw	r30, r24
    360e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3610:	8f 3f       	cpi	r24, 0xFF	; 255
    3612:	21 f4       	brne	.+8      	; 0x361c <xQueueReceive+0xc6>
    3614:	8a 81       	ldd	r24, Y+2	; 0x02
    3616:	9b 81       	ldd	r25, Y+3	; 0x03
    3618:	fc 01       	movw	r30, r24
    361a:	15 8e       	std	Z+29, r1	; 0x1d
    361c:	8a 81       	ldd	r24, Y+2	; 0x02
    361e:	9b 81       	ldd	r25, Y+3	; 0x03
    3620:	fc 01       	movw	r30, r24
    3622:	86 8d       	ldd	r24, Z+30	; 0x1e
    3624:	8f 3f       	cpi	r24, 0xFF	; 255
    3626:	21 f4       	brne	.+8      	; 0x3630 <xQueueReceive+0xda>
    3628:	8a 81       	ldd	r24, Y+2	; 0x02
    362a:	9b 81       	ldd	r25, Y+3	; 0x03
    362c:	fc 01       	movw	r30, r24
    362e:	16 8e       	std	Z+30, r1	; 0x1e
    3630:	0f 90       	pop	r0
    3632:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3634:	9e 01       	movw	r18, r28
    3636:	24 5f       	subi	r18, 0xF4	; 244
    3638:	3f 4f       	sbci	r19, 0xFF	; 255
    363a:	ce 01       	movw	r24, r28
    363c:	05 96       	adiw	r24, 0x05	; 5
    363e:	b9 01       	movw	r22, r18
    3640:	0e 94 68 28 	call	0x50d0	; 0x50d0 <xTaskCheckForTimeOut>
    3644:	88 23       	and	r24, r24
    3646:	09 f5       	brne	.+66     	; 0x368a <xQueueReceive+0x134>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3648:	8a 81       	ldd	r24, Y+2	; 0x02
    364a:	9b 81       	ldd	r25, Y+3	; 0x03
    364c:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvIsQueueEmpty>
    3650:	88 23       	and	r24, r24
    3652:	a1 f0       	breq	.+40     	; 0x367c <xQueueReceive+0x126>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3654:	2c 85       	ldd	r18, Y+12	; 0x0c
    3656:	3d 85       	ldd	r19, Y+13	; 0x0d
    3658:	8a 81       	ldd	r24, Y+2	; 0x02
    365a:	9b 81       	ldd	r25, Y+3	; 0x03
    365c:	41 96       	adiw	r24, 0x11	; 17
    365e:	b9 01       	movw	r22, r18
    3660:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3664:	8a 81       	ldd	r24, Y+2	; 0x02
    3666:	9b 81       	ldd	r25, Y+3	; 0x03
    3668:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    366c:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    3670:	88 23       	and	r24, r24
    3672:	09 f0       	breq	.+2      	; 0x3676 <xQueueReceive+0x120>
    3674:	85 cf       	rjmp	.-246    	; 0x3580 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    3676:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
    367a:	82 cf       	rjmp	.-252    	; 0x3580 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    367c:	8a 81       	ldd	r24, Y+2	; 0x02
    367e:	9b 81       	ldd	r25, Y+3	; 0x03
    3680:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3684:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    3688:	7b cf       	rjmp	.-266    	; 0x3580 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    368a:	8a 81       	ldd	r24, Y+2	; 0x02
    368c:	9b 81       	ldd	r25, Y+3	; 0x03
    368e:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3692:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3696:	8a 81       	ldd	r24, Y+2	; 0x02
    3698:	9b 81       	ldd	r25, Y+3	; 0x03
    369a:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvIsQueueEmpty>
    369e:	88 23       	and	r24, r24
    36a0:	09 f4       	brne	.+2      	; 0x36a4 <xQueueReceive+0x14e>
    36a2:	6e cf       	rjmp	.-292    	; 0x3580 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    36a4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    36a6:	2d 96       	adiw	r28, 0x0d	; 13
    36a8:	0f b6       	in	r0, 0x3f	; 63
    36aa:	f8 94       	cli
    36ac:	de bf       	out	0x3e, r29	; 62
    36ae:	0f be       	out	0x3f, r0	; 63
    36b0:	cd bf       	out	0x3d, r28	; 61
    36b2:	df 91       	pop	r29
    36b4:	cf 91       	pop	r28
    36b6:	08 95       	ret

000036b8 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    36b8:	cf 93       	push	r28
    36ba:	df 93       	push	r29
    36bc:	cd b7       	in	r28, 0x3d	; 61
    36be:	de b7       	in	r29, 0x3e	; 62
    36c0:	2d 97       	sbiw	r28, 0x0d	; 13
    36c2:	0f b6       	in	r0, 0x3f	; 63
    36c4:	f8 94       	cli
    36c6:	de bf       	out	0x3e, r29	; 62
    36c8:	0f be       	out	0x3f, r0	; 63
    36ca:	cd bf       	out	0x3d, r28	; 61
    36cc:	9b 87       	std	Y+11, r25	; 0x0b
    36ce:	8a 87       	std	Y+10, r24	; 0x0a
    36d0:	7d 87       	std	Y+13, r23	; 0x0d
    36d2:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    36d4:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    36d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    36d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    36da:	9c 83       	std	Y+4, r25	; 0x04
    36dc:	8b 83       	std	Y+3, r24	; 0x03

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    36de:	1a 82       	std	Y+2, r1	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    36e0:	0f b6       	in	r0, 0x3f	; 63
    36e2:	f8 94       	cli
    36e4:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    36e6:	8b 81       	ldd	r24, Y+3	; 0x03
    36e8:	9c 81       	ldd	r25, Y+4	; 0x04
    36ea:	fc 01       	movw	r30, r24
    36ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    36ee:	8d 83       	std	Y+5, r24	; 0x05

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    36f0:	8d 81       	ldd	r24, Y+5	; 0x05
    36f2:	88 23       	and	r24, r24
    36f4:	49 f1       	breq	.+82     	; 0x3748 <xQueueSemaphoreTake+0x90>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    36f6:	8d 81       	ldd	r24, Y+5	; 0x05
    36f8:	2f ef       	ldi	r18, 0xFF	; 255
    36fa:	28 0f       	add	r18, r24
    36fc:	8b 81       	ldd	r24, Y+3	; 0x03
    36fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3700:	fc 01       	movw	r30, r24
    3702:	22 8f       	std	Z+26, r18	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3704:	8b 81       	ldd	r24, Y+3	; 0x03
    3706:	9c 81       	ldd	r25, Y+4	; 0x04
    3708:	fc 01       	movw	r30, r24
    370a:	80 81       	ld	r24, Z
    370c:	91 81       	ldd	r25, Z+1	; 0x01
    370e:	89 2b       	or	r24, r25
    3710:	41 f4       	brne	.+16     	; 0x3722 <xQueueSemaphoreTake+0x6a>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    3712:	0e 94 b5 2b 	call	0x576a	; 0x576a <pvTaskIncrementMutexHeldCount>
    3716:	9c 01       	movw	r18, r24
    3718:	8b 81       	ldd	r24, Y+3	; 0x03
    371a:	9c 81       	ldd	r25, Y+4	; 0x04
    371c:	fc 01       	movw	r30, r24
    371e:	35 83       	std	Z+5, r19	; 0x05
    3720:	24 83       	std	Z+4, r18	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3722:	8b 81       	ldd	r24, Y+3	; 0x03
    3724:	9c 81       	ldd	r25, Y+4	; 0x04
    3726:	fc 01       	movw	r30, r24
    3728:	80 85       	ldd	r24, Z+8	; 0x08
    372a:	88 23       	and	r24, r24
    372c:	49 f0       	breq	.+18     	; 0x3740 <xQueueSemaphoreTake+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    372e:	8b 81       	ldd	r24, Y+3	; 0x03
    3730:	9c 81       	ldd	r25, Y+4	; 0x04
    3732:	08 96       	adiw	r24, 0x08	; 8
    3734:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    3738:	88 23       	and	r24, r24
    373a:	11 f0       	breq	.+4      	; 0x3740 <xQueueSemaphoreTake+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
    373c:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3740:	0f 90       	pop	r0
    3742:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3744:	81 e0       	ldi	r24, 0x01	; 1
    3746:	90 c0       	rjmp	.+288    	; 0x3868 <xQueueSemaphoreTake+0x1b0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3748:	8c 85       	ldd	r24, Y+12	; 0x0c
    374a:	9d 85       	ldd	r25, Y+13	; 0x0d
    374c:	89 2b       	or	r24, r25
    374e:	21 f4       	brne	.+8      	; 0x3758 <xQueueSemaphoreTake+0xa0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    3750:	0f 90       	pop	r0
    3752:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3754:	80 e0       	ldi	r24, 0x00	; 0
    3756:	88 c0       	rjmp	.+272    	; 0x3868 <xQueueSemaphoreTake+0x1b0>
				}
				else if( xEntryTimeSet == pdFALSE )
    3758:	89 81       	ldd	r24, Y+1	; 0x01
    375a:	88 23       	and	r24, r24
    375c:	31 f4       	brne	.+12     	; 0x376a <xQueueSemaphoreTake+0xb2>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    375e:	ce 01       	movw	r24, r28
    3760:	07 96       	adiw	r24, 0x07	; 7
    3762:	0e 94 4c 28 	call	0x5098	; 0x5098 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3766:	81 e0       	ldi	r24, 0x01	; 1
    3768:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    376a:	0f 90       	pop	r0
    376c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    376e:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3772:	0f b6       	in	r0, 0x3f	; 63
    3774:	f8 94       	cli
    3776:	0f 92       	push	r0
    3778:	8b 81       	ldd	r24, Y+3	; 0x03
    377a:	9c 81       	ldd	r25, Y+4	; 0x04
    377c:	fc 01       	movw	r30, r24
    377e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3780:	8f 3f       	cpi	r24, 0xFF	; 255
    3782:	21 f4       	brne	.+8      	; 0x378c <xQueueSemaphoreTake+0xd4>
    3784:	8b 81       	ldd	r24, Y+3	; 0x03
    3786:	9c 81       	ldd	r25, Y+4	; 0x04
    3788:	fc 01       	movw	r30, r24
    378a:	15 8e       	std	Z+29, r1	; 0x1d
    378c:	8b 81       	ldd	r24, Y+3	; 0x03
    378e:	9c 81       	ldd	r25, Y+4	; 0x04
    3790:	fc 01       	movw	r30, r24
    3792:	86 8d       	ldd	r24, Z+30	; 0x1e
    3794:	8f 3f       	cpi	r24, 0xFF	; 255
    3796:	21 f4       	brne	.+8      	; 0x37a0 <xQueueSemaphoreTake+0xe8>
    3798:	8b 81       	ldd	r24, Y+3	; 0x03
    379a:	9c 81       	ldd	r25, Y+4	; 0x04
    379c:	fc 01       	movw	r30, r24
    379e:	16 8e       	std	Z+30, r1	; 0x1e
    37a0:	0f 90       	pop	r0
    37a2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    37a4:	9e 01       	movw	r18, r28
    37a6:	24 5f       	subi	r18, 0xF4	; 244
    37a8:	3f 4f       	sbci	r19, 0xFF	; 255
    37aa:	ce 01       	movw	r24, r28
    37ac:	07 96       	adiw	r24, 0x07	; 7
    37ae:	b9 01       	movw	r22, r18
    37b0:	0e 94 68 28 	call	0x50d0	; 0x50d0 <xTaskCheckForTimeOut>
    37b4:	88 23       	and	r24, r24
    37b6:	a9 f5       	brne	.+106    	; 0x3822 <xQueueSemaphoreTake+0x16a>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37b8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ba:	9c 81       	ldd	r25, Y+4	; 0x04
    37bc:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvIsQueueEmpty>
    37c0:	88 23       	and	r24, r24
    37c2:	41 f1       	breq	.+80     	; 0x3814 <xQueueSemaphoreTake+0x15c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    37c4:	8b 81       	ldd	r24, Y+3	; 0x03
    37c6:	9c 81       	ldd	r25, Y+4	; 0x04
    37c8:	fc 01       	movw	r30, r24
    37ca:	80 81       	ld	r24, Z
    37cc:	91 81       	ldd	r25, Z+1	; 0x01
    37ce:	89 2b       	or	r24, r25
    37d0:	69 f4       	brne	.+26     	; 0x37ec <xQueueSemaphoreTake+0x134>
					{
						taskENTER_CRITICAL();
    37d2:	0f b6       	in	r0, 0x3f	; 63
    37d4:	f8 94       	cli
    37d6:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    37d8:	8b 81       	ldd	r24, Y+3	; 0x03
    37da:	9c 81       	ldd	r25, Y+4	; 0x04
    37dc:	fc 01       	movw	r30, r24
    37de:	84 81       	ldd	r24, Z+4	; 0x04
    37e0:	95 81       	ldd	r25, Z+5	; 0x05
    37e2:	0e 94 c2 29 	call	0x5384	; 0x5384 <xTaskPriorityInherit>
    37e6:	8a 83       	std	Y+2, r24	; 0x02
						}
						taskEXIT_CRITICAL();
    37e8:	0f 90       	pop	r0
    37ea:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    37ec:	2c 85       	ldd	r18, Y+12	; 0x0c
    37ee:	3d 85       	ldd	r19, Y+13	; 0x0d
    37f0:	8b 81       	ldd	r24, Y+3	; 0x03
    37f2:	9c 81       	ldd	r25, Y+4	; 0x04
    37f4:	41 96       	adiw	r24, 0x11	; 17
    37f6:	b9 01       	movw	r22, r18
    37f8:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    37fc:	8b 81       	ldd	r24, Y+3	; 0x03
    37fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3800:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3804:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    3808:	88 23       	and	r24, r24
    380a:	09 f0       	breq	.+2      	; 0x380e <xQueueSemaphoreTake+0x156>
    380c:	69 cf       	rjmp	.-302    	; 0x36e0 <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    380e:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
    3812:	66 cf       	rjmp	.-308    	; 0x36e0 <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    3814:	8b 81       	ldd	r24, Y+3	; 0x03
    3816:	9c 81       	ldd	r25, Y+4	; 0x04
    3818:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    381c:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    3820:	5f cf       	rjmp	.-322    	; 0x36e0 <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    3822:	8b 81       	ldd	r24, Y+3	; 0x03
    3824:	9c 81       	ldd	r25, Y+4	; 0x04
    3826:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    382a:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    382e:	8b 81       	ldd	r24, Y+3	; 0x03
    3830:	9c 81       	ldd	r25, Y+4	; 0x04
    3832:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvIsQueueEmpty>
    3836:	88 23       	and	r24, r24
    3838:	09 f4       	brne	.+2      	; 0x383c <xQueueSemaphoreTake+0x184>
    383a:	52 cf       	rjmp	.-348    	; 0x36e0 <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    383c:	8a 81       	ldd	r24, Y+2	; 0x02
    383e:	88 23       	and	r24, r24
    3840:	91 f0       	breq	.+36     	; 0x3866 <xQueueSemaphoreTake+0x1ae>
					{
						taskENTER_CRITICAL();
    3842:	0f b6       	in	r0, 0x3f	; 63
    3844:	f8 94       	cli
    3846:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    3848:	8b 81       	ldd	r24, Y+3	; 0x03
    384a:	9c 81       	ldd	r25, Y+4	; 0x04
    384c:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <prvGetDisinheritPriorityAfterTimeout>
    3850:	8e 83       	std	Y+6, r24	; 0x06
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    3852:	8b 81       	ldd	r24, Y+3	; 0x03
    3854:	9c 81       	ldd	r25, Y+4	; 0x04
    3856:	fc 01       	movw	r30, r24
    3858:	84 81       	ldd	r24, Z+4	; 0x04
    385a:	95 81       	ldd	r25, Z+5	; 0x05
    385c:	6e 81       	ldd	r22, Y+6	; 0x06
    385e:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    3862:	0f 90       	pop	r0
    3864:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3866:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3868:	2d 96       	adiw	r28, 0x0d	; 13
    386a:	0f b6       	in	r0, 0x3f	; 63
    386c:	f8 94       	cli
    386e:	de bf       	out	0x3e, r29	; 62
    3870:	0f be       	out	0x3f, r0	; 63
    3872:	cd bf       	out	0x3d, r28	; 61
    3874:	df 91       	pop	r29
    3876:	cf 91       	pop	r28
    3878:	08 95       	ret

0000387a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    387a:	cf 93       	push	r28
    387c:	df 93       	push	r29
    387e:	cd b7       	in	r28, 0x3d	; 61
    3880:	de b7       	in	r29, 0x3e	; 62
    3882:	2f 97       	sbiw	r28, 0x0f	; 15
    3884:	0f b6       	in	r0, 0x3f	; 63
    3886:	f8 94       	cli
    3888:	de bf       	out	0x3e, r29	; 62
    388a:	0f be       	out	0x3f, r0	; 63
    388c:	cd bf       	out	0x3d, r28	; 61
    388e:	9b 87       	std	Y+11, r25	; 0x0b
    3890:	8a 87       	std	Y+10, r24	; 0x0a
    3892:	7d 87       	std	Y+13, r23	; 0x0d
    3894:	6c 87       	std	Y+12, r22	; 0x0c
    3896:	5f 87       	std	Y+15, r21	; 0x0f
    3898:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    389a:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    389c:	8a 85       	ldd	r24, Y+10	; 0x0a
    389e:	9b 85       	ldd	r25, Y+11	; 0x0b
    38a0:	9b 83       	std	Y+3, r25	; 0x03
    38a2:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    38a4:	0f b6       	in	r0, 0x3f	; 63
    38a6:	f8 94       	cli
    38a8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    38aa:	8a 81       	ldd	r24, Y+2	; 0x02
    38ac:	9b 81       	ldd	r25, Y+3	; 0x03
    38ae:	fc 01       	movw	r30, r24
    38b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    38b2:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    38b4:	8c 81       	ldd	r24, Y+4	; 0x04
    38b6:	88 23       	and	r24, r24
    38b8:	41 f1       	breq	.+80     	; 0x390a <xQueuePeek+0x90>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    38ba:	8a 81       	ldd	r24, Y+2	; 0x02
    38bc:	9b 81       	ldd	r25, Y+3	; 0x03
    38be:	fc 01       	movw	r30, r24
    38c0:	86 81       	ldd	r24, Z+6	; 0x06
    38c2:	97 81       	ldd	r25, Z+7	; 0x07
    38c4:	9e 83       	std	Y+6, r25	; 0x06
    38c6:	8d 83       	std	Y+5, r24	; 0x05

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    38c8:	2c 85       	ldd	r18, Y+12	; 0x0c
    38ca:	3d 85       	ldd	r19, Y+13	; 0x0d
    38cc:	8a 81       	ldd	r24, Y+2	; 0x02
    38ce:	9b 81       	ldd	r25, Y+3	; 0x03
    38d0:	b9 01       	movw	r22, r18
    38d2:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    38d6:	8a 81       	ldd	r24, Y+2	; 0x02
    38d8:	9b 81       	ldd	r25, Y+3	; 0x03
    38da:	2d 81       	ldd	r18, Y+5	; 0x05
    38dc:	3e 81       	ldd	r19, Y+6	; 0x06
    38de:	fc 01       	movw	r30, r24
    38e0:	37 83       	std	Z+7, r19	; 0x07
    38e2:	26 83       	std	Z+6, r18	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    38e4:	8a 81       	ldd	r24, Y+2	; 0x02
    38e6:	9b 81       	ldd	r25, Y+3	; 0x03
    38e8:	fc 01       	movw	r30, r24
    38ea:	81 89       	ldd	r24, Z+17	; 0x11
    38ec:	88 23       	and	r24, r24
    38ee:	49 f0       	breq	.+18     	; 0x3902 <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    38f0:	8a 81       	ldd	r24, Y+2	; 0x02
    38f2:	9b 81       	ldd	r25, Y+3	; 0x03
    38f4:	41 96       	adiw	r24, 0x11	; 17
    38f6:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    38fa:	88 23       	and	r24, r24
    38fc:	11 f0       	breq	.+4      	; 0x3902 <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    38fe:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3902:	0f 90       	pop	r0
    3904:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3906:	81 e0       	ldi	r24, 0x01	; 1
    3908:	67 c0       	rjmp	.+206    	; 0x39d8 <xQueuePeek+0x15e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    390a:	8e 85       	ldd	r24, Y+14	; 0x0e
    390c:	9f 85       	ldd	r25, Y+15	; 0x0f
    390e:	89 2b       	or	r24, r25
    3910:	21 f4       	brne	.+8      	; 0x391a <xQueuePeek+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3912:	0f 90       	pop	r0
    3914:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3916:	80 e0       	ldi	r24, 0x00	; 0
    3918:	5f c0       	rjmp	.+190    	; 0x39d8 <xQueuePeek+0x15e>
				}
				else if( xEntryTimeSet == pdFALSE )
    391a:	89 81       	ldd	r24, Y+1	; 0x01
    391c:	88 23       	and	r24, r24
    391e:	31 f4       	brne	.+12     	; 0x392c <xQueuePeek+0xb2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3920:	ce 01       	movw	r24, r28
    3922:	07 96       	adiw	r24, 0x07	; 7
    3924:	0e 94 4c 28 	call	0x5098	; 0x5098 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3928:	81 e0       	ldi	r24, 0x01	; 1
    392a:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    392c:	0f 90       	pop	r0
    392e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3930:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3934:	0f b6       	in	r0, 0x3f	; 63
    3936:	f8 94       	cli
    3938:	0f 92       	push	r0
    393a:	8a 81       	ldd	r24, Y+2	; 0x02
    393c:	9b 81       	ldd	r25, Y+3	; 0x03
    393e:	fc 01       	movw	r30, r24
    3940:	85 8d       	ldd	r24, Z+29	; 0x1d
    3942:	8f 3f       	cpi	r24, 0xFF	; 255
    3944:	21 f4       	brne	.+8      	; 0x394e <xQueuePeek+0xd4>
    3946:	8a 81       	ldd	r24, Y+2	; 0x02
    3948:	9b 81       	ldd	r25, Y+3	; 0x03
    394a:	fc 01       	movw	r30, r24
    394c:	15 8e       	std	Z+29, r1	; 0x1d
    394e:	8a 81       	ldd	r24, Y+2	; 0x02
    3950:	9b 81       	ldd	r25, Y+3	; 0x03
    3952:	fc 01       	movw	r30, r24
    3954:	86 8d       	ldd	r24, Z+30	; 0x1e
    3956:	8f 3f       	cpi	r24, 0xFF	; 255
    3958:	21 f4       	brne	.+8      	; 0x3962 <xQueuePeek+0xe8>
    395a:	8a 81       	ldd	r24, Y+2	; 0x02
    395c:	9b 81       	ldd	r25, Y+3	; 0x03
    395e:	fc 01       	movw	r30, r24
    3960:	16 8e       	std	Z+30, r1	; 0x1e
    3962:	0f 90       	pop	r0
    3964:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3966:	9e 01       	movw	r18, r28
    3968:	22 5f       	subi	r18, 0xF2	; 242
    396a:	3f 4f       	sbci	r19, 0xFF	; 255
    396c:	ce 01       	movw	r24, r28
    396e:	07 96       	adiw	r24, 0x07	; 7
    3970:	b9 01       	movw	r22, r18
    3972:	0e 94 68 28 	call	0x50d0	; 0x50d0 <xTaskCheckForTimeOut>
    3976:	88 23       	and	r24, r24
    3978:	09 f5       	brne	.+66     	; 0x39bc <xQueuePeek+0x142>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    397a:	8a 81       	ldd	r24, Y+2	; 0x02
    397c:	9b 81       	ldd	r25, Y+3	; 0x03
    397e:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvIsQueueEmpty>
    3982:	88 23       	and	r24, r24
    3984:	a1 f0       	breq	.+40     	; 0x39ae <xQueuePeek+0x134>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3986:	2e 85       	ldd	r18, Y+14	; 0x0e
    3988:	3f 85       	ldd	r19, Y+15	; 0x0f
    398a:	8a 81       	ldd	r24, Y+2	; 0x02
    398c:	9b 81       	ldd	r25, Y+3	; 0x03
    398e:	41 96       	adiw	r24, 0x11	; 17
    3990:	b9 01       	movw	r22, r18
    3992:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3996:	8a 81       	ldd	r24, Y+2	; 0x02
    3998:	9b 81       	ldd	r25, Y+3	; 0x03
    399a:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    399e:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    39a2:	88 23       	and	r24, r24
    39a4:	09 f0       	breq	.+2      	; 0x39a8 <xQueuePeek+0x12e>
    39a6:	7e cf       	rjmp	.-260    	; 0x38a4 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    39a8:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
    39ac:	7b cf       	rjmp	.-266    	; 0x38a4 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    39ae:	8a 81       	ldd	r24, Y+2	; 0x02
    39b0:	9b 81       	ldd	r25, Y+3	; 0x03
    39b2:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    39b6:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    39ba:	74 cf       	rjmp	.-280    	; 0x38a4 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    39bc:	8a 81       	ldd	r24, Y+2	; 0x02
    39be:	9b 81       	ldd	r25, Y+3	; 0x03
    39c0:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    39c4:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    39c8:	8a 81       	ldd	r24, Y+2	; 0x02
    39ca:	9b 81       	ldd	r25, Y+3	; 0x03
    39cc:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvIsQueueEmpty>
    39d0:	88 23       	and	r24, r24
    39d2:	09 f4       	brne	.+2      	; 0x39d6 <xQueuePeek+0x15c>
    39d4:	67 cf       	rjmp	.-306    	; 0x38a4 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    39d6:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    39d8:	2f 96       	adiw	r28, 0x0f	; 15
    39da:	0f b6       	in	r0, 0x3f	; 63
    39dc:	f8 94       	cli
    39de:	de bf       	out	0x3e, r29	; 62
    39e0:	0f be       	out	0x3f, r0	; 63
    39e2:	cd bf       	out	0x3d, r28	; 61
    39e4:	df 91       	pop	r29
    39e6:	cf 91       	pop	r28
    39e8:	08 95       	ret

000039ea <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    39ea:	cf 93       	push	r28
    39ec:	df 93       	push	r29
    39ee:	cd b7       	in	r28, 0x3d	; 61
    39f0:	de b7       	in	r29, 0x3e	; 62
    39f2:	2c 97       	sbiw	r28, 0x0c	; 12
    39f4:	0f b6       	in	r0, 0x3f	; 63
    39f6:	f8 94       	cli
    39f8:	de bf       	out	0x3e, r29	; 62
    39fa:	0f be       	out	0x3f, r0	; 63
    39fc:	cd bf       	out	0x3d, r28	; 61
    39fe:	98 87       	std	Y+8, r25	; 0x08
    3a00:	8f 83       	std	Y+7, r24	; 0x07
    3a02:	7a 87       	std	Y+10, r23	; 0x0a
    3a04:	69 87       	std	Y+9, r22	; 0x09
    3a06:	5c 87       	std	Y+12, r21	; 0x0c
    3a08:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3a0a:	8f 81       	ldd	r24, Y+7	; 0x07
    3a0c:	98 85       	ldd	r25, Y+8	; 0x08
    3a0e:	9b 83       	std	Y+3, r25	; 0x03
    3a10:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3a12:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3a14:	8a 81       	ldd	r24, Y+2	; 0x02
    3a16:	9b 81       	ldd	r25, Y+3	; 0x03
    3a18:	fc 01       	movw	r30, r24
    3a1a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a1c:	8d 83       	std	Y+5, r24	; 0x05

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a1e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a20:	88 23       	and	r24, r24
    3a22:	b9 f1       	breq	.+110    	; 0x3a92 <xQueueReceiveFromISR+0xa8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    3a24:	8a 81       	ldd	r24, Y+2	; 0x02
    3a26:	9b 81       	ldd	r25, Y+3	; 0x03
    3a28:	fc 01       	movw	r30, r24
    3a2a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a2c:	8e 83       	std	Y+6, r24	; 0x06

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a2e:	29 85       	ldd	r18, Y+9	; 0x09
    3a30:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a32:	8a 81       	ldd	r24, Y+2	; 0x02
    3a34:	9b 81       	ldd	r25, Y+3	; 0x03
    3a36:	b9 01       	movw	r22, r18
    3a38:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3a3c:	8d 81       	ldd	r24, Y+5	; 0x05
    3a3e:	2f ef       	ldi	r18, 0xFF	; 255
    3a40:	28 0f       	add	r18, r24
    3a42:	8a 81       	ldd	r24, Y+2	; 0x02
    3a44:	9b 81       	ldd	r25, Y+3	; 0x03
    3a46:	fc 01       	movw	r30, r24
    3a48:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    3a4a:	8e 81       	ldd	r24, Y+6	; 0x06
    3a4c:	8f 3f       	cpi	r24, 0xFF	; 255
    3a4e:	b9 f4       	brne	.+46     	; 0x3a7e <xQueueReceiveFromISR+0x94>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3a50:	8a 81       	ldd	r24, Y+2	; 0x02
    3a52:	9b 81       	ldd	r25, Y+3	; 0x03
    3a54:	fc 01       	movw	r30, r24
    3a56:	80 85       	ldd	r24, Z+8	; 0x08
    3a58:	88 23       	and	r24, r24
    3a5a:	c1 f0       	breq	.+48     	; 0x3a8c <xQueueReceiveFromISR+0xa2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a60:	08 96       	adiw	r24, 0x08	; 8
    3a62:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    3a66:	88 23       	and	r24, r24
    3a68:	89 f0       	breq	.+34     	; 0x3a8c <xQueueReceiveFromISR+0xa2>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3a6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a6c:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a6e:	89 2b       	or	r24, r25
    3a70:	69 f0       	breq	.+26     	; 0x3a8c <xQueueReceiveFromISR+0xa2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3a72:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a74:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a76:	21 e0       	ldi	r18, 0x01	; 1
    3a78:	fc 01       	movw	r30, r24
    3a7a:	20 83       	st	Z, r18
    3a7c:	07 c0       	rjmp	.+14     	; 0x3a8c <xQueueReceiveFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3a7e:	8e 81       	ldd	r24, Y+6	; 0x06
    3a80:	8f 5f       	subi	r24, 0xFF	; 255
    3a82:	28 2f       	mov	r18, r24
    3a84:	8a 81       	ldd	r24, Y+2	; 0x02
    3a86:	9b 81       	ldd	r25, Y+3	; 0x03
    3a88:	fc 01       	movw	r30, r24
    3a8a:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3a8c:	81 e0       	ldi	r24, 0x01	; 1
    3a8e:	89 83       	std	Y+1, r24	; 0x01
    3a90:	01 c0       	rjmp	.+2      	; 0x3a94 <xQueueReceiveFromISR+0xaa>
		}
		else
		{
			xReturn = pdFAIL;
    3a92:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3a94:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a96:	2c 96       	adiw	r28, 0x0c	; 12
    3a98:	0f b6       	in	r0, 0x3f	; 63
    3a9a:	f8 94       	cli
    3a9c:	de bf       	out	0x3e, r29	; 62
    3a9e:	0f be       	out	0x3f, r0	; 63
    3aa0:	cd bf       	out	0x3d, r28	; 61
    3aa2:	df 91       	pop	r29
    3aa4:	cf 91       	pop	r28
    3aa6:	08 95       	ret

00003aa8 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3aa8:	cf 93       	push	r28
    3aaa:	df 93       	push	r29
    3aac:	cd b7       	in	r28, 0x3d	; 61
    3aae:	de b7       	in	r29, 0x3e	; 62
    3ab0:	2a 97       	sbiw	r28, 0x0a	; 10
    3ab2:	0f b6       	in	r0, 0x3f	; 63
    3ab4:	f8 94       	cli
    3ab6:	de bf       	out	0x3e, r29	; 62
    3ab8:	0f be       	out	0x3f, r0	; 63
    3aba:	cd bf       	out	0x3d, r28	; 61
    3abc:	98 87       	std	Y+8, r25	; 0x08
    3abe:	8f 83       	std	Y+7, r24	; 0x07
    3ac0:	7a 87       	std	Y+10, r23	; 0x0a
    3ac2:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3ac4:	8f 81       	ldd	r24, Y+7	; 0x07
    3ac6:	98 85       	ldd	r25, Y+8	; 0x08
    3ac8:	9b 83       	std	Y+3, r25	; 0x03
    3aca:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3acc:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3ace:	8a 81       	ldd	r24, Y+2	; 0x02
    3ad0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ad2:	fc 01       	movw	r30, r24
    3ad4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ad6:	88 23       	and	r24, r24
    3ad8:	c1 f0       	breq	.+48     	; 0x3b0a <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3ada:	8a 81       	ldd	r24, Y+2	; 0x02
    3adc:	9b 81       	ldd	r25, Y+3	; 0x03
    3ade:	fc 01       	movw	r30, r24
    3ae0:	86 81       	ldd	r24, Z+6	; 0x06
    3ae2:	97 81       	ldd	r25, Z+7	; 0x07
    3ae4:	9e 83       	std	Y+6, r25	; 0x06
    3ae6:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3ae8:	29 85       	ldd	r18, Y+9	; 0x09
    3aea:	3a 85       	ldd	r19, Y+10	; 0x0a
    3aec:	8a 81       	ldd	r24, Y+2	; 0x02
    3aee:	9b 81       	ldd	r25, Y+3	; 0x03
    3af0:	b9 01       	movw	r22, r18
    3af2:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3af6:	8a 81       	ldd	r24, Y+2	; 0x02
    3af8:	9b 81       	ldd	r25, Y+3	; 0x03
    3afa:	2d 81       	ldd	r18, Y+5	; 0x05
    3afc:	3e 81       	ldd	r19, Y+6	; 0x06
    3afe:	fc 01       	movw	r30, r24
    3b00:	37 83       	std	Z+7, r19	; 0x07
    3b02:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3b04:	81 e0       	ldi	r24, 0x01	; 1
    3b06:	89 83       	std	Y+1, r24	; 0x01
    3b08:	01 c0       	rjmp	.+2      	; 0x3b0c <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    3b0a:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b0c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b0e:	2a 96       	adiw	r28, 0x0a	; 10
    3b10:	0f b6       	in	r0, 0x3f	; 63
    3b12:	f8 94       	cli
    3b14:	de bf       	out	0x3e, r29	; 62
    3b16:	0f be       	out	0x3f, r0	; 63
    3b18:	cd bf       	out	0x3d, r28	; 61
    3b1a:	df 91       	pop	r29
    3b1c:	cf 91       	pop	r28
    3b1e:	08 95       	ret

00003b20 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3b20:	cf 93       	push	r28
    3b22:	df 93       	push	r29
    3b24:	00 d0       	rcall	.+0      	; 0x3b26 <uxQueueMessagesWaiting+0x6>
    3b26:	1f 92       	push	r1
    3b28:	cd b7       	in	r28, 0x3d	; 61
    3b2a:	de b7       	in	r29, 0x3e	; 62
    3b2c:	9b 83       	std	Y+3, r25	; 0x03
    3b2e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3b30:	0f b6       	in	r0, 0x3f	; 63
    3b32:	f8 94       	cli
    3b34:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3b36:	8a 81       	ldd	r24, Y+2	; 0x02
    3b38:	9b 81       	ldd	r25, Y+3	; 0x03
    3b3a:	fc 01       	movw	r30, r24
    3b3c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b3e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3b40:	0f 90       	pop	r0
    3b42:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3b44:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b46:	0f 90       	pop	r0
    3b48:	0f 90       	pop	r0
    3b4a:	0f 90       	pop	r0
    3b4c:	df 91       	pop	r29
    3b4e:	cf 91       	pop	r28
    3b50:	08 95       	ret

00003b52 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3b52:	cf 93       	push	r28
    3b54:	df 93       	push	r29
    3b56:	00 d0       	rcall	.+0      	; 0x3b58 <uxQueueSpacesAvailable+0x6>
    3b58:	00 d0       	rcall	.+0      	; 0x3b5a <uxQueueSpacesAvailable+0x8>
    3b5a:	1f 92       	push	r1
    3b5c:	cd b7       	in	r28, 0x3d	; 61
    3b5e:	de b7       	in	r29, 0x3e	; 62
    3b60:	9d 83       	std	Y+5, r25	; 0x05
    3b62:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3b64:	8c 81       	ldd	r24, Y+4	; 0x04
    3b66:	9d 81       	ldd	r25, Y+5	; 0x05
    3b68:	9a 83       	std	Y+2, r25	; 0x02
    3b6a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3b6c:	0f b6       	in	r0, 0x3f	; 63
    3b6e:	f8 94       	cli
    3b70:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3b72:	89 81       	ldd	r24, Y+1	; 0x01
    3b74:	9a 81       	ldd	r25, Y+2	; 0x02
    3b76:	fc 01       	movw	r30, r24
    3b78:	23 8d       	ldd	r18, Z+27	; 0x1b
    3b7a:	89 81       	ldd	r24, Y+1	; 0x01
    3b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b7e:	fc 01       	movw	r30, r24
    3b80:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b82:	f2 2f       	mov	r31, r18
    3b84:	f8 1b       	sub	r31, r24
    3b86:	8f 2f       	mov	r24, r31
    3b88:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3b8a:	0f 90       	pop	r0
    3b8c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3b8e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b90:	0f 90       	pop	r0
    3b92:	0f 90       	pop	r0
    3b94:	0f 90       	pop	r0
    3b96:	0f 90       	pop	r0
    3b98:	0f 90       	pop	r0
    3b9a:	df 91       	pop	r29
    3b9c:	cf 91       	pop	r28
    3b9e:	08 95       	ret

00003ba0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3ba0:	cf 93       	push	r28
    3ba2:	df 93       	push	r29
    3ba4:	00 d0       	rcall	.+0      	; 0x3ba6 <uxQueueMessagesWaitingFromISR+0x6>
    3ba6:	00 d0       	rcall	.+0      	; 0x3ba8 <uxQueueMessagesWaitingFromISR+0x8>
    3ba8:	1f 92       	push	r1
    3baa:	cd b7       	in	r28, 0x3d	; 61
    3bac:	de b7       	in	r29, 0x3e	; 62
    3bae:	9d 83       	std	Y+5, r25	; 0x05
    3bb0:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3bb2:	8c 81       	ldd	r24, Y+4	; 0x04
    3bb4:	9d 81       	ldd	r25, Y+5	; 0x05
    3bb6:	9a 83       	std	Y+2, r25	; 0x02
    3bb8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3bba:	89 81       	ldd	r24, Y+1	; 0x01
    3bbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bbe:	fc 01       	movw	r30, r24
    3bc0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bc2:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3bc4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3bc6:	0f 90       	pop	r0
    3bc8:	0f 90       	pop	r0
    3bca:	0f 90       	pop	r0
    3bcc:	0f 90       	pop	r0
    3bce:	0f 90       	pop	r0
    3bd0:	df 91       	pop	r29
    3bd2:	cf 91       	pop	r28
    3bd4:	08 95       	ret

00003bd6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3bd6:	cf 93       	push	r28
    3bd8:	df 93       	push	r29
    3bda:	00 d0       	rcall	.+0      	; 0x3bdc <vQueueDelete+0x6>
    3bdc:	00 d0       	rcall	.+0      	; 0x3bde <vQueueDelete+0x8>
    3bde:	cd b7       	in	r28, 0x3d	; 61
    3be0:	de b7       	in	r29, 0x3e	; 62
    3be2:	9c 83       	std	Y+4, r25	; 0x04
    3be4:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3be6:	8b 81       	ldd	r24, Y+3	; 0x03
    3be8:	9c 81       	ldd	r25, Y+4	; 0x04
    3bea:	9a 83       	std	Y+2, r25	; 0x02
    3bec:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3bee:	89 81       	ldd	r24, Y+1	; 0x01
    3bf0:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf2:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3bf6:	00 00       	nop
    3bf8:	0f 90       	pop	r0
    3bfa:	0f 90       	pop	r0
    3bfc:	0f 90       	pop	r0
    3bfe:	0f 90       	pop	r0
    3c00:	df 91       	pop	r29
    3c02:	cf 91       	pop	r28
    3c04:	08 95       	ret

00003c06 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    3c06:	cf 93       	push	r28
    3c08:	df 93       	push	r29
    3c0a:	00 d0       	rcall	.+0      	; 0x3c0c <prvGetDisinheritPriorityAfterTimeout+0x6>
    3c0c:	1f 92       	push	r1
    3c0e:	cd b7       	in	r28, 0x3d	; 61
    3c10:	de b7       	in	r29, 0x3e	; 62
    3c12:	9b 83       	std	Y+3, r25	; 0x03
    3c14:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    3c16:	8a 81       	ldd	r24, Y+2	; 0x02
    3c18:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1a:	fc 01       	movw	r30, r24
    3c1c:	81 89       	ldd	r24, Z+17	; 0x11
    3c1e:	88 23       	and	r24, r24
    3c20:	69 f0       	breq	.+26     	; 0x3c3c <prvGetDisinheritPriorityAfterTimeout+0x36>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    3c22:	8a 81       	ldd	r24, Y+2	; 0x02
    3c24:	9b 81       	ldd	r25, Y+3	; 0x03
    3c26:	fc 01       	movw	r30, r24
    3c28:	86 89       	ldd	r24, Z+22	; 0x16
    3c2a:	97 89       	ldd	r25, Z+23	; 0x17
    3c2c:	fc 01       	movw	r30, r24
    3c2e:	80 81       	ld	r24, Z
    3c30:	91 81       	ldd	r25, Z+1	; 0x01
    3c32:	98 2f       	mov	r25, r24
    3c34:	85 e0       	ldi	r24, 0x05	; 5
    3c36:	89 1b       	sub	r24, r25
    3c38:	89 83       	std	Y+1, r24	; 0x01
    3c3a:	01 c0       	rjmp	.+2      	; 0x3c3e <prvGetDisinheritPriorityAfterTimeout+0x38>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    3c3c:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    3c3e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3c40:	0f 90       	pop	r0
    3c42:	0f 90       	pop	r0
    3c44:	0f 90       	pop	r0
    3c46:	df 91       	pop	r29
    3c48:	cf 91       	pop	r28
    3c4a:	08 95       	ret

00003c4c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3c4c:	cf 93       	push	r28
    3c4e:	df 93       	push	r29
    3c50:	cd b7       	in	r28, 0x3d	; 61
    3c52:	de b7       	in	r29, 0x3e	; 62
    3c54:	27 97       	sbiw	r28, 0x07	; 7
    3c56:	0f b6       	in	r0, 0x3f	; 63
    3c58:	f8 94       	cli
    3c5a:	de bf       	out	0x3e, r29	; 62
    3c5c:	0f be       	out	0x3f, r0	; 63
    3c5e:	cd bf       	out	0x3d, r28	; 61
    3c60:	9c 83       	std	Y+4, r25	; 0x04
    3c62:	8b 83       	std	Y+3, r24	; 0x03
    3c64:	7e 83       	std	Y+6, r23	; 0x06
    3c66:	6d 83       	std	Y+5, r22	; 0x05
    3c68:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3c6a:	19 82       	std	Y+1, r1	; 0x01
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c70:	fc 01       	movw	r30, r24
    3c72:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c74:	8a 83       	std	Y+2, r24	; 0x02

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3c76:	8b 81       	ldd	r24, Y+3	; 0x03
    3c78:	9c 81       	ldd	r25, Y+4	; 0x04
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c7e:	88 23       	and	r24, r24
    3c80:	b1 f4       	brne	.+44     	; 0x3cae <prvCopyDataToQueue+0x62>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3c82:	8b 81       	ldd	r24, Y+3	; 0x03
    3c84:	9c 81       	ldd	r25, Y+4	; 0x04
    3c86:	fc 01       	movw	r30, r24
    3c88:	80 81       	ld	r24, Z
    3c8a:	91 81       	ldd	r25, Z+1	; 0x01
    3c8c:	89 2b       	or	r24, r25
    3c8e:	09 f0       	breq	.+2      	; 0x3c92 <prvCopyDataToQueue+0x46>
    3c90:	9c c0       	rjmp	.+312    	; 0x3dca <prvCopyDataToQueue+0x17e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    3c92:	8b 81       	ldd	r24, Y+3	; 0x03
    3c94:	9c 81       	ldd	r25, Y+4	; 0x04
    3c96:	fc 01       	movw	r30, r24
    3c98:	84 81       	ldd	r24, Z+4	; 0x04
    3c9a:	95 81       	ldd	r25, Z+5	; 0x05
    3c9c:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <xTaskPriorityDisinherit>
    3ca0:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    3ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ca6:	fc 01       	movw	r30, r24
    3ca8:	15 82       	std	Z+5, r1	; 0x05
    3caa:	14 82       	std	Z+4, r1	; 0x04
    3cac:	8e c0       	rjmp	.+284    	; 0x3dca <prvCopyDataToQueue+0x17e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3cae:	8f 81       	ldd	r24, Y+7	; 0x07
    3cb0:	88 23       	and	r24, r24
    3cb2:	d9 f5       	brne	.+118    	; 0x3d2a <prvCopyDataToQueue+0xde>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb8:	fc 01       	movw	r30, r24
    3cba:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cbc:	48 2f       	mov	r20, r24
    3cbe:	50 e0       	ldi	r21, 0x00	; 0
    3cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc4:	fc 01       	movw	r30, r24
    3cc6:	82 81       	ldd	r24, Z+2	; 0x02
    3cc8:	93 81       	ldd	r25, Z+3	; 0x03
    3cca:	2d 81       	ldd	r18, Y+5	; 0x05
    3ccc:	3e 81       	ldd	r19, Y+6	; 0x06
    3cce:	b9 01       	movw	r22, r18
    3cd0:	0e 94 10 32 	call	0x6420	; 0x6420 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd8:	fc 01       	movw	r30, r24
    3cda:	22 81       	ldd	r18, Z+2	; 0x02
    3cdc:	33 81       	ldd	r19, Z+3	; 0x03
    3cde:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce2:	fc 01       	movw	r30, r24
    3ce4:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ce6:	88 2f       	mov	r24, r24
    3ce8:	90 e0       	ldi	r25, 0x00	; 0
    3cea:	28 0f       	add	r18, r24
    3cec:	39 1f       	adc	r19, r25
    3cee:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf0:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf2:	fc 01       	movw	r30, r24
    3cf4:	33 83       	std	Z+3, r19	; 0x03
    3cf6:	22 83       	std	Z+2, r18	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    3cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    3cfc:	fc 01       	movw	r30, r24
    3cfe:	22 81       	ldd	r18, Z+2	; 0x02
    3d00:	33 81       	ldd	r19, Z+3	; 0x03
    3d02:	8b 81       	ldd	r24, Y+3	; 0x03
    3d04:	9c 81       	ldd	r25, Y+4	; 0x04
    3d06:	fc 01       	movw	r30, r24
    3d08:	84 81       	ldd	r24, Z+4	; 0x04
    3d0a:	95 81       	ldd	r25, Z+5	; 0x05
    3d0c:	28 17       	cp	r18, r24
    3d0e:	39 07       	cpc	r19, r25
    3d10:	08 f4       	brcc	.+2      	; 0x3d14 <prvCopyDataToQueue+0xc8>
    3d12:	5b c0       	rjmp	.+182    	; 0x3dca <prvCopyDataToQueue+0x17e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3d14:	8b 81       	ldd	r24, Y+3	; 0x03
    3d16:	9c 81       	ldd	r25, Y+4	; 0x04
    3d18:	fc 01       	movw	r30, r24
    3d1a:	20 81       	ld	r18, Z
    3d1c:	31 81       	ldd	r19, Z+1	; 0x01
    3d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d20:	9c 81       	ldd	r25, Y+4	; 0x04
    3d22:	fc 01       	movw	r30, r24
    3d24:	33 83       	std	Z+3, r19	; 0x03
    3d26:	22 83       	std	Z+2, r18	; 0x02
    3d28:	50 c0       	rjmp	.+160    	; 0x3dca <prvCopyDataToQueue+0x17e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d2e:	fc 01       	movw	r30, r24
    3d30:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d32:	48 2f       	mov	r20, r24
    3d34:	50 e0       	ldi	r21, 0x00	; 0
    3d36:	8b 81       	ldd	r24, Y+3	; 0x03
    3d38:	9c 81       	ldd	r25, Y+4	; 0x04
    3d3a:	fc 01       	movw	r30, r24
    3d3c:	86 81       	ldd	r24, Z+6	; 0x06
    3d3e:	97 81       	ldd	r25, Z+7	; 0x07
    3d40:	2d 81       	ldd	r18, Y+5	; 0x05
    3d42:	3e 81       	ldd	r19, Y+6	; 0x06
    3d44:	b9 01       	movw	r22, r18
    3d46:	0e 94 10 32 	call	0x6420	; 0x6420 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d4e:	fc 01       	movw	r30, r24
    3d50:	26 81       	ldd	r18, Z+6	; 0x06
    3d52:	37 81       	ldd	r19, Z+7	; 0x07
    3d54:	8b 81       	ldd	r24, Y+3	; 0x03
    3d56:	9c 81       	ldd	r25, Y+4	; 0x04
    3d58:	fc 01       	movw	r30, r24
    3d5a:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d5c:	88 2f       	mov	r24, r24
    3d5e:	90 e0       	ldi	r25, 0x00	; 0
    3d60:	91 95       	neg	r25
    3d62:	81 95       	neg	r24
    3d64:	91 09       	sbc	r25, r1
    3d66:	28 0f       	add	r18, r24
    3d68:	39 1f       	adc	r19, r25
    3d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d6e:	fc 01       	movw	r30, r24
    3d70:	37 83       	std	Z+7, r19	; 0x07
    3d72:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d74:	8b 81       	ldd	r24, Y+3	; 0x03
    3d76:	9c 81       	ldd	r25, Y+4	; 0x04
    3d78:	fc 01       	movw	r30, r24
    3d7a:	26 81       	ldd	r18, Z+6	; 0x06
    3d7c:	37 81       	ldd	r19, Z+7	; 0x07
    3d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d80:	9c 81       	ldd	r25, Y+4	; 0x04
    3d82:	fc 01       	movw	r30, r24
    3d84:	80 81       	ld	r24, Z
    3d86:	91 81       	ldd	r25, Z+1	; 0x01
    3d88:	28 17       	cp	r18, r24
    3d8a:	39 07       	cpc	r19, r25
    3d8c:	a8 f4       	brcc	.+42     	; 0x3db8 <prvCopyDataToQueue+0x16c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d90:	9c 81       	ldd	r25, Y+4	; 0x04
    3d92:	fc 01       	movw	r30, r24
    3d94:	24 81       	ldd	r18, Z+4	; 0x04
    3d96:	35 81       	ldd	r19, Z+5	; 0x05
    3d98:	8b 81       	ldd	r24, Y+3	; 0x03
    3d9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d9c:	fc 01       	movw	r30, r24
    3d9e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3da0:	88 2f       	mov	r24, r24
    3da2:	90 e0       	ldi	r25, 0x00	; 0
    3da4:	91 95       	neg	r25
    3da6:	81 95       	neg	r24
    3da8:	91 09       	sbc	r25, r1
    3daa:	28 0f       	add	r18, r24
    3dac:	39 1f       	adc	r19, r25
    3dae:	8b 81       	ldd	r24, Y+3	; 0x03
    3db0:	9c 81       	ldd	r25, Y+4	; 0x04
    3db2:	fc 01       	movw	r30, r24
    3db4:	37 83       	std	Z+7, r19	; 0x07
    3db6:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3db8:	8f 81       	ldd	r24, Y+7	; 0x07
    3dba:	82 30       	cpi	r24, 0x02	; 2
    3dbc:	31 f4       	brne	.+12     	; 0x3dca <prvCopyDataToQueue+0x17e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc0:	88 23       	and	r24, r24
    3dc2:	19 f0       	breq	.+6      	; 0x3dca <prvCopyDataToQueue+0x17e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc6:	81 50       	subi	r24, 0x01	; 1
    3dc8:	8a 83       	std	Y+2, r24	; 0x02
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3dca:	8a 81       	ldd	r24, Y+2	; 0x02
    3dcc:	21 e0       	ldi	r18, 0x01	; 1
    3dce:	28 0f       	add	r18, r24
    3dd0:	8b 81       	ldd	r24, Y+3	; 0x03
    3dd2:	9c 81       	ldd	r25, Y+4	; 0x04
    3dd4:	fc 01       	movw	r30, r24
    3dd6:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3dd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dda:	27 96       	adiw	r28, 0x07	; 7
    3ddc:	0f b6       	in	r0, 0x3f	; 63
    3dde:	f8 94       	cli
    3de0:	de bf       	out	0x3e, r29	; 62
    3de2:	0f be       	out	0x3f, r0	; 63
    3de4:	cd bf       	out	0x3d, r28	; 61
    3de6:	df 91       	pop	r29
    3de8:	cf 91       	pop	r28
    3dea:	08 95       	ret

00003dec <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3dec:	cf 93       	push	r28
    3dee:	df 93       	push	r29
    3df0:	00 d0       	rcall	.+0      	; 0x3df2 <prvCopyDataFromQueue+0x6>
    3df2:	00 d0       	rcall	.+0      	; 0x3df4 <prvCopyDataFromQueue+0x8>
    3df4:	cd b7       	in	r28, 0x3d	; 61
    3df6:	de b7       	in	r29, 0x3e	; 62
    3df8:	9a 83       	std	Y+2, r25	; 0x02
    3dfa:	89 83       	std	Y+1, r24	; 0x01
    3dfc:	7c 83       	std	Y+4, r23	; 0x04
    3dfe:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3e00:	89 81       	ldd	r24, Y+1	; 0x01
    3e02:	9a 81       	ldd	r25, Y+2	; 0x02
    3e04:	fc 01       	movw	r30, r24
    3e06:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e08:	88 23       	and	r24, r24
    3e0a:	c9 f1       	breq	.+114    	; 0x3e7e <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3e0c:	89 81       	ldd	r24, Y+1	; 0x01
    3e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e10:	fc 01       	movw	r30, r24
    3e12:	26 81       	ldd	r18, Z+6	; 0x06
    3e14:	37 81       	ldd	r19, Z+7	; 0x07
    3e16:	89 81       	ldd	r24, Y+1	; 0x01
    3e18:	9a 81       	ldd	r25, Y+2	; 0x02
    3e1a:	fc 01       	movw	r30, r24
    3e1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e1e:	88 2f       	mov	r24, r24
    3e20:	90 e0       	ldi	r25, 0x00	; 0
    3e22:	28 0f       	add	r18, r24
    3e24:	39 1f       	adc	r19, r25
    3e26:	89 81       	ldd	r24, Y+1	; 0x01
    3e28:	9a 81       	ldd	r25, Y+2	; 0x02
    3e2a:	fc 01       	movw	r30, r24
    3e2c:	37 83       	std	Z+7, r19	; 0x07
    3e2e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3e30:	89 81       	ldd	r24, Y+1	; 0x01
    3e32:	9a 81       	ldd	r25, Y+2	; 0x02
    3e34:	fc 01       	movw	r30, r24
    3e36:	26 81       	ldd	r18, Z+6	; 0x06
    3e38:	37 81       	ldd	r19, Z+7	; 0x07
    3e3a:	89 81       	ldd	r24, Y+1	; 0x01
    3e3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e3e:	fc 01       	movw	r30, r24
    3e40:	84 81       	ldd	r24, Z+4	; 0x04
    3e42:	95 81       	ldd	r25, Z+5	; 0x05
    3e44:	28 17       	cp	r18, r24
    3e46:	39 07       	cpc	r19, r25
    3e48:	50 f0       	brcs	.+20     	; 0x3e5e <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3e4a:	89 81       	ldd	r24, Y+1	; 0x01
    3e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4e:	fc 01       	movw	r30, r24
    3e50:	20 81       	ld	r18, Z
    3e52:	31 81       	ldd	r19, Z+1	; 0x01
    3e54:	89 81       	ldd	r24, Y+1	; 0x01
    3e56:	9a 81       	ldd	r25, Y+2	; 0x02
    3e58:	fc 01       	movw	r30, r24
    3e5a:	37 83       	std	Z+7, r19	; 0x07
    3e5c:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3e5e:	89 81       	ldd	r24, Y+1	; 0x01
    3e60:	9a 81       	ldd	r25, Y+2	; 0x02
    3e62:	fc 01       	movw	r30, r24
    3e64:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e66:	48 2f       	mov	r20, r24
    3e68:	50 e0       	ldi	r21, 0x00	; 0
    3e6a:	89 81       	ldd	r24, Y+1	; 0x01
    3e6c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6e:	fc 01       	movw	r30, r24
    3e70:	26 81       	ldd	r18, Z+6	; 0x06
    3e72:	37 81       	ldd	r19, Z+7	; 0x07
    3e74:	8b 81       	ldd	r24, Y+3	; 0x03
    3e76:	9c 81       	ldd	r25, Y+4	; 0x04
    3e78:	b9 01       	movw	r22, r18
    3e7a:	0e 94 10 32 	call	0x6420	; 0x6420 <memcpy>
	}
}
    3e7e:	00 00       	nop
    3e80:	0f 90       	pop	r0
    3e82:	0f 90       	pop	r0
    3e84:	0f 90       	pop	r0
    3e86:	0f 90       	pop	r0
    3e88:	df 91       	pop	r29
    3e8a:	cf 91       	pop	r28
    3e8c:	08 95       	ret

00003e8e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3e8e:	cf 93       	push	r28
    3e90:	df 93       	push	r29
    3e92:	00 d0       	rcall	.+0      	; 0x3e94 <prvUnlockQueue+0x6>
    3e94:	00 d0       	rcall	.+0      	; 0x3e96 <prvUnlockQueue+0x8>
    3e96:	cd b7       	in	r28, 0x3d	; 61
    3e98:	de b7       	in	r29, 0x3e	; 62
    3e9a:	9c 83       	std	Y+4, r25	; 0x04
    3e9c:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3e9e:	0f b6       	in	r0, 0x3f	; 63
    3ea0:	f8 94       	cli
    3ea2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3ea4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ea8:	fc 01       	movw	r30, r24
    3eaa:	86 8d       	ldd	r24, Z+30	; 0x1e
    3eac:	89 83       	std	Y+1, r24	; 0x01

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3eae:	12 c0       	rjmp	.+36     	; 0x3ed4 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    3eb4:	fc 01       	movw	r30, r24
    3eb6:	81 89       	ldd	r24, Z+17	; 0x11
    3eb8:	88 23       	and	r24, r24
    3eba:	81 f0       	breq	.+32     	; 0x3edc <prvUnlockQueue+0x4e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    3ec0:	41 96       	adiw	r24, 0x11	; 17
    3ec2:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    3ec6:	88 23       	and	r24, r24
    3ec8:	11 f0       	breq	.+4      	; 0x3ece <prvUnlockQueue+0x40>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3eca:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3ece:	89 81       	ldd	r24, Y+1	; 0x01
    3ed0:	81 50       	subi	r24, 0x01	; 1
    3ed2:	89 83       	std	Y+1, r24	; 0x01
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3ed4:	89 81       	ldd	r24, Y+1	; 0x01
    3ed6:	18 16       	cp	r1, r24
    3ed8:	5c f3       	brlt	.-42     	; 0x3eb0 <prvUnlockQueue+0x22>
    3eda:	01 c0       	rjmp	.+2      	; 0x3ede <prvUnlockQueue+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3edc:	00 00       	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3ede:	8b 81       	ldd	r24, Y+3	; 0x03
    3ee0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee2:	2f ef       	ldi	r18, 0xFF	; 255
    3ee4:	fc 01       	movw	r30, r24
    3ee6:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3ee8:	0f 90       	pop	r0
    3eea:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3eec:	0f b6       	in	r0, 0x3f	; 63
    3eee:	f8 94       	cli
    3ef0:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3ef2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef6:	fc 01       	movw	r30, r24
    3ef8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3efa:	8a 83       	std	Y+2, r24	; 0x02

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3efc:	12 c0       	rjmp	.+36     	; 0x3f22 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3efe:	8b 81       	ldd	r24, Y+3	; 0x03
    3f00:	9c 81       	ldd	r25, Y+4	; 0x04
    3f02:	fc 01       	movw	r30, r24
    3f04:	80 85       	ldd	r24, Z+8	; 0x08
    3f06:	88 23       	and	r24, r24
    3f08:	81 f0       	breq	.+32     	; 0x3f2a <prvUnlockQueue+0x9c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f0e:	08 96       	adiw	r24, 0x08	; 8
    3f10:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <xTaskRemoveFromEventList>
    3f14:	88 23       	and	r24, r24
    3f16:	11 f0       	breq	.+4      	; 0x3f1c <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    3f18:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f1e:	81 50       	subi	r24, 0x01	; 1
    3f20:	8a 83       	std	Y+2, r24	; 0x02
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3f22:	8a 81       	ldd	r24, Y+2	; 0x02
    3f24:	18 16       	cp	r1, r24
    3f26:	5c f3       	brlt	.-42     	; 0x3efe <prvUnlockQueue+0x70>
    3f28:	01 c0       	rjmp	.+2      	; 0x3f2c <prvUnlockQueue+0x9e>

				--cRxLock;
			}
			else
			{
				break;
    3f2a:	00 00       	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f30:	2f ef       	ldi	r18, 0xFF	; 255
    3f32:	fc 01       	movw	r30, r24
    3f34:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    3f36:	0f 90       	pop	r0
    3f38:	0f be       	out	0x3f, r0	; 63
}
    3f3a:	00 00       	nop
    3f3c:	0f 90       	pop	r0
    3f3e:	0f 90       	pop	r0
    3f40:	0f 90       	pop	r0
    3f42:	0f 90       	pop	r0
    3f44:	df 91       	pop	r29
    3f46:	cf 91       	pop	r28
    3f48:	08 95       	ret

00003f4a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3f4a:	cf 93       	push	r28
    3f4c:	df 93       	push	r29
    3f4e:	00 d0       	rcall	.+0      	; 0x3f50 <prvIsQueueEmpty+0x6>
    3f50:	1f 92       	push	r1
    3f52:	cd b7       	in	r28, 0x3d	; 61
    3f54:	de b7       	in	r29, 0x3e	; 62
    3f56:	9b 83       	std	Y+3, r25	; 0x03
    3f58:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3f5a:	0f b6       	in	r0, 0x3f	; 63
    3f5c:	f8 94       	cli
    3f5e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3f60:	8a 81       	ldd	r24, Y+2	; 0x02
    3f62:	9b 81       	ldd	r25, Y+3	; 0x03
    3f64:	fc 01       	movw	r30, r24
    3f66:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f68:	88 23       	and	r24, r24
    3f6a:	19 f4       	brne	.+6      	; 0x3f72 <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    3f6c:	81 e0       	ldi	r24, 0x01	; 1
    3f6e:	89 83       	std	Y+1, r24	; 0x01
    3f70:	01 c0       	rjmp	.+2      	; 0x3f74 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    3f72:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3f74:	0f 90       	pop	r0
    3f76:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f78:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f7a:	0f 90       	pop	r0
    3f7c:	0f 90       	pop	r0
    3f7e:	0f 90       	pop	r0
    3f80:	df 91       	pop	r29
    3f82:	cf 91       	pop	r28
    3f84:	08 95       	ret

00003f86 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3f86:	cf 93       	push	r28
    3f88:	df 93       	push	r29
    3f8a:	00 d0       	rcall	.+0      	; 0x3f8c <xQueueIsQueueEmptyFromISR+0x6>
    3f8c:	00 d0       	rcall	.+0      	; 0x3f8e <xQueueIsQueueEmptyFromISR+0x8>
    3f8e:	1f 92       	push	r1
    3f90:	cd b7       	in	r28, 0x3d	; 61
    3f92:	de b7       	in	r29, 0x3e	; 62
    3f94:	9d 83       	std	Y+5, r25	; 0x05
    3f96:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3f98:	8c 81       	ldd	r24, Y+4	; 0x04
    3f9a:	9d 81       	ldd	r25, Y+5	; 0x05
    3f9c:	9b 83       	std	Y+3, r25	; 0x03
    3f9e:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3fa0:	8a 81       	ldd	r24, Y+2	; 0x02
    3fa2:	9b 81       	ldd	r25, Y+3	; 0x03
    3fa4:	fc 01       	movw	r30, r24
    3fa6:	82 8d       	ldd	r24, Z+26	; 0x1a
    3fa8:	88 23       	and	r24, r24
    3faa:	19 f4       	brne	.+6      	; 0x3fb2 <xQueueIsQueueEmptyFromISR+0x2c>
	{
		xReturn = pdTRUE;
    3fac:	81 e0       	ldi	r24, 0x01	; 1
    3fae:	89 83       	std	Y+1, r24	; 0x01
    3fb0:	01 c0       	rjmp	.+2      	; 0x3fb4 <xQueueIsQueueEmptyFromISR+0x2e>
	}
	else
	{
		xReturn = pdFALSE;
    3fb2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3fb4:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3fb6:	0f 90       	pop	r0
    3fb8:	0f 90       	pop	r0
    3fba:	0f 90       	pop	r0
    3fbc:	0f 90       	pop	r0
    3fbe:	0f 90       	pop	r0
    3fc0:	df 91       	pop	r29
    3fc2:	cf 91       	pop	r28
    3fc4:	08 95       	ret

00003fc6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3fc6:	cf 93       	push	r28
    3fc8:	df 93       	push	r29
    3fca:	00 d0       	rcall	.+0      	; 0x3fcc <prvIsQueueFull+0x6>
    3fcc:	1f 92       	push	r1
    3fce:	cd b7       	in	r28, 0x3d	; 61
    3fd0:	de b7       	in	r29, 0x3e	; 62
    3fd2:	9b 83       	std	Y+3, r25	; 0x03
    3fd4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3fd6:	0f b6       	in	r0, 0x3f	; 63
    3fd8:	f8 94       	cli
    3fda:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    3fde:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe0:	fc 01       	movw	r30, r24
    3fe2:	22 8d       	ldd	r18, Z+26	; 0x1a
    3fe4:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe6:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe8:	fc 01       	movw	r30, r24
    3fea:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fec:	28 17       	cp	r18, r24
    3fee:	19 f4       	brne	.+6      	; 0x3ff6 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    3ff0:	81 e0       	ldi	r24, 0x01	; 1
    3ff2:	89 83       	std	Y+1, r24	; 0x01
    3ff4:	01 c0       	rjmp	.+2      	; 0x3ff8 <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    3ff6:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3ff8:	0f 90       	pop	r0
    3ffa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3ffc:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ffe:	0f 90       	pop	r0
    4000:	0f 90       	pop	r0
    4002:	0f 90       	pop	r0
    4004:	df 91       	pop	r29
    4006:	cf 91       	pop	r28
    4008:	08 95       	ret

0000400a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    400a:	cf 93       	push	r28
    400c:	df 93       	push	r29
    400e:	00 d0       	rcall	.+0      	; 0x4010 <xQueueIsQueueFullFromISR+0x6>
    4010:	00 d0       	rcall	.+0      	; 0x4012 <xQueueIsQueueFullFromISR+0x8>
    4012:	1f 92       	push	r1
    4014:	cd b7       	in	r28, 0x3d	; 61
    4016:	de b7       	in	r29, 0x3e	; 62
    4018:	9d 83       	std	Y+5, r25	; 0x05
    401a:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    401c:	8c 81       	ldd	r24, Y+4	; 0x04
    401e:	9d 81       	ldd	r25, Y+5	; 0x05
    4020:	9b 83       	std	Y+3, r25	; 0x03
    4022:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4024:	8a 81       	ldd	r24, Y+2	; 0x02
    4026:	9b 81       	ldd	r25, Y+3	; 0x03
    4028:	fc 01       	movw	r30, r24
    402a:	22 8d       	ldd	r18, Z+26	; 0x1a
    402c:	8a 81       	ldd	r24, Y+2	; 0x02
    402e:	9b 81       	ldd	r25, Y+3	; 0x03
    4030:	fc 01       	movw	r30, r24
    4032:	83 8d       	ldd	r24, Z+27	; 0x1b
    4034:	28 17       	cp	r18, r24
    4036:	19 f4       	brne	.+6      	; 0x403e <xQueueIsQueueFullFromISR+0x34>
	{
		xReturn = pdTRUE;
    4038:	81 e0       	ldi	r24, 0x01	; 1
    403a:	89 83       	std	Y+1, r24	; 0x01
    403c:	01 c0       	rjmp	.+2      	; 0x4040 <xQueueIsQueueFullFromISR+0x36>
	}
	else
	{
		xReturn = pdFALSE;
    403e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4040:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4042:	0f 90       	pop	r0
    4044:	0f 90       	pop	r0
    4046:	0f 90       	pop	r0
    4048:	0f 90       	pop	r0
    404a:	0f 90       	pop	r0
    404c:	df 91       	pop	r29
    404e:	cf 91       	pop	r28
    4050:	08 95       	ret

00004052 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4052:	8f 92       	push	r8
    4054:	9f 92       	push	r9
    4056:	af 92       	push	r10
    4058:	bf 92       	push	r11
    405a:	cf 92       	push	r12
    405c:	df 92       	push	r13
    405e:	ef 92       	push	r14
    4060:	ff 92       	push	r15
    4062:	0f 93       	push	r16
    4064:	1f 93       	push	r17
    4066:	cf 93       	push	r28
    4068:	df 93       	push	r29
    406a:	cd b7       	in	r28, 0x3d	; 61
    406c:	de b7       	in	r29, 0x3e	; 62
    406e:	60 97       	sbiw	r28, 0x10	; 16
    4070:	0f b6       	in	r0, 0x3f	; 63
    4072:	f8 94       	cli
    4074:	de bf       	out	0x3e, r29	; 62
    4076:	0f be       	out	0x3f, r0	; 63
    4078:	cd bf       	out	0x3d, r28	; 61
    407a:	9f 83       	std	Y+7, r25	; 0x07
    407c:	8e 83       	std	Y+6, r24	; 0x06
    407e:	79 87       	std	Y+9, r23	; 0x09
    4080:	68 87       	std	Y+8, r22	; 0x08
    4082:	5b 87       	std	Y+11, r21	; 0x0b
    4084:	4a 87       	std	Y+10, r20	; 0x0a
    4086:	3d 87       	std	Y+13, r19	; 0x0d
    4088:	2c 87       	std	Y+12, r18	; 0x0c
    408a:	0e 87       	std	Y+14, r16	; 0x0e
    408c:	f8 8a       	std	Y+16, r15	; 0x10
    408e:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4090:	8a 85       	ldd	r24, Y+10	; 0x0a
    4092:	9b 85       	ldd	r25, Y+11	; 0x0b
    4094:	0e 94 99 12 	call	0x2532	; 0x2532 <pvPortMalloc>
    4098:	9d 83       	std	Y+5, r25	; 0x05
    409a:	8c 83       	std	Y+4, r24	; 0x04

			if( pxStack != NULL )
    409c:	8c 81       	ldd	r24, Y+4	; 0x04
    409e:	9d 81       	ldd	r25, Y+5	; 0x05
    40a0:	89 2b       	or	r24, r25
    40a2:	b9 f0       	breq	.+46     	; 0x40d2 <xTaskCreate+0x80>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    40a4:	88 e2       	ldi	r24, 0x28	; 40
    40a6:	90 e0       	ldi	r25, 0x00	; 0
    40a8:	0e 94 99 12 	call	0x2532	; 0x2532 <pvPortMalloc>
    40ac:	9a 83       	std	Y+2, r25	; 0x02
    40ae:	89 83       	std	Y+1, r24	; 0x01

				if( pxNewTCB != NULL )
    40b0:	89 81       	ldd	r24, Y+1	; 0x01
    40b2:	9a 81       	ldd	r25, Y+2	; 0x02
    40b4:	89 2b       	or	r24, r25
    40b6:	41 f0       	breq	.+16     	; 0x40c8 <xTaskCreate+0x76>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    40b8:	89 81       	ldd	r24, Y+1	; 0x01
    40ba:	9a 81       	ldd	r25, Y+2	; 0x02
    40bc:	2c 81       	ldd	r18, Y+4	; 0x04
    40be:	3d 81       	ldd	r19, Y+5	; 0x05
    40c0:	fc 01       	movw	r30, r24
    40c2:	30 8f       	std	Z+24, r19	; 0x18
    40c4:	27 8b       	std	Z+23, r18	; 0x17
    40c6:	07 c0       	rjmp	.+14     	; 0x40d6 <xTaskCreate+0x84>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    40c8:	8c 81       	ldd	r24, Y+4	; 0x04
    40ca:	9d 81       	ldd	r25, Y+5	; 0x05
    40cc:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vPortFree>
    40d0:	02 c0       	rjmp	.+4      	; 0x40d6 <xTaskCreate+0x84>
				}
			}
			else
			{
				pxNewTCB = NULL;
    40d2:	1a 82       	std	Y+2, r1	; 0x02
    40d4:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    40d6:	89 81       	ldd	r24, Y+1	; 0x01
    40d8:	9a 81       	ldd	r25, Y+2	; 0x02
    40da:	89 2b       	or	r24, r25
    40dc:	09 f1       	breq	.+66     	; 0x4120 <xTaskCreate+0xce>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    40de:	8a 85       	ldd	r24, Y+10	; 0x0a
    40e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    40e2:	cc 01       	movw	r24, r24
    40e4:	a0 e0       	ldi	r26, 0x00	; 0
    40e6:	b0 e0       	ldi	r27, 0x00	; 0
    40e8:	09 81       	ldd	r16, Y+1	; 0x01
    40ea:	1a 81       	ldd	r17, Y+2	; 0x02
    40ec:	4f 85       	ldd	r20, Y+15	; 0x0f
    40ee:	58 89       	ldd	r21, Y+16	; 0x10
    40f0:	2c 85       	ldd	r18, Y+12	; 0x0c
    40f2:	3d 85       	ldd	r19, Y+13	; 0x0d
    40f4:	68 85       	ldd	r22, Y+8	; 0x08
    40f6:	79 85       	ldd	r23, Y+9	; 0x09
    40f8:	ee 81       	ldd	r30, Y+6	; 0x06
    40fa:	ff 81       	ldd	r31, Y+7	; 0x07
    40fc:	81 2c       	mov	r8, r1
    40fe:	91 2c       	mov	r9, r1
    4100:	58 01       	movw	r10, r16
    4102:	6a 01       	movw	r12, r20
    4104:	ee 84       	ldd	r14, Y+14	; 0x0e
    4106:	89 01       	movw	r16, r18
    4108:	9c 01       	movw	r18, r24
    410a:	ad 01       	movw	r20, r26
    410c:	cf 01       	movw	r24, r30
    410e:	0e 94 a6 20 	call	0x414c	; 0x414c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4112:	89 81       	ldd	r24, Y+1	; 0x01
    4114:	9a 81       	ldd	r25, Y+2	; 0x02
    4116:	0e 94 7a 21 	call	0x42f4	; 0x42f4 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    411a:	81 e0       	ldi	r24, 0x01	; 1
    411c:	8b 83       	std	Y+3, r24	; 0x03
    411e:	02 c0       	rjmp	.+4      	; 0x4124 <xTaskCreate+0xd2>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4120:	8f ef       	ldi	r24, 0xFF	; 255
    4122:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4124:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4126:	60 96       	adiw	r28, 0x10	; 16
    4128:	0f b6       	in	r0, 0x3f	; 63
    412a:	f8 94       	cli
    412c:	de bf       	out	0x3e, r29	; 62
    412e:	0f be       	out	0x3f, r0	; 63
    4130:	cd bf       	out	0x3d, r28	; 61
    4132:	df 91       	pop	r29
    4134:	cf 91       	pop	r28
    4136:	1f 91       	pop	r17
    4138:	0f 91       	pop	r16
    413a:	ff 90       	pop	r15
    413c:	ef 90       	pop	r14
    413e:	df 90       	pop	r13
    4140:	cf 90       	pop	r12
    4142:	bf 90       	pop	r11
    4144:	af 90       	pop	r10
    4146:	9f 90       	pop	r9
    4148:	8f 90       	pop	r8
    414a:	08 95       	ret

0000414c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    414c:	8f 92       	push	r8
    414e:	9f 92       	push	r9
    4150:	af 92       	push	r10
    4152:	bf 92       	push	r11
    4154:	cf 92       	push	r12
    4156:	df 92       	push	r13
    4158:	ef 92       	push	r14
    415a:	0f 93       	push	r16
    415c:	1f 93       	push	r17
    415e:	cf 93       	push	r28
    4160:	df 93       	push	r29
    4162:	cd b7       	in	r28, 0x3d	; 61
    4164:	de b7       	in	r29, 0x3e	; 62
    4166:	64 97       	sbiw	r28, 0x14	; 20
    4168:	0f b6       	in	r0, 0x3f	; 63
    416a:	f8 94       	cli
    416c:	de bf       	out	0x3e, r29	; 62
    416e:	0f be       	out	0x3f, r0	; 63
    4170:	cd bf       	out	0x3d, r28	; 61
    4172:	9d 83       	std	Y+5, r25	; 0x05
    4174:	8c 83       	std	Y+4, r24	; 0x04
    4176:	7f 83       	std	Y+7, r23	; 0x07
    4178:	6e 83       	std	Y+6, r22	; 0x06
    417a:	28 87       	std	Y+8, r18	; 0x08
    417c:	39 87       	std	Y+9, r19	; 0x09
    417e:	4a 87       	std	Y+10, r20	; 0x0a
    4180:	5b 87       	std	Y+11, r21	; 0x0b
    4182:	1d 87       	std	Y+13, r17	; 0x0d
    4184:	0c 87       	std	Y+12, r16	; 0x0c
    4186:	ee 86       	std	Y+14, r14	; 0x0e
    4188:	d8 8a       	std	Y+16, r13	; 0x10
    418a:	cf 86       	std	Y+15, r12	; 0x0f
    418c:	ba 8a       	std	Y+18, r11	; 0x12
    418e:	a9 8a       	std	Y+17, r10	; 0x11
    4190:	9c 8a       	std	Y+20, r9	; 0x14
    4192:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4194:	89 89       	ldd	r24, Y+17	; 0x11
    4196:	9a 89       	ldd	r25, Y+18	; 0x12
    4198:	fc 01       	movw	r30, r24
    419a:	27 89       	ldd	r18, Z+23	; 0x17
    419c:	30 8d       	ldd	r19, Z+24	; 0x18
    419e:	88 85       	ldd	r24, Y+8	; 0x08
    41a0:	99 85       	ldd	r25, Y+9	; 0x09
    41a2:	01 97       	sbiw	r24, 0x01	; 1
    41a4:	82 0f       	add	r24, r18
    41a6:	93 1f       	adc	r25, r19
    41a8:	9b 83       	std	Y+3, r25	; 0x03
    41aa:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    41ac:	8e 81       	ldd	r24, Y+6	; 0x06
    41ae:	9f 81       	ldd	r25, Y+7	; 0x07
    41b0:	89 2b       	or	r24, r25
    41b2:	69 f1       	breq	.+90     	; 0x420e <prvInitialiseNewTask+0xc2>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    41b4:	19 82       	std	Y+1, r1	; 0x01
    41b6:	21 c0       	rjmp	.+66     	; 0x41fa <prvInitialiseNewTask+0xae>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    41b8:	89 81       	ldd	r24, Y+1	; 0x01
    41ba:	88 2f       	mov	r24, r24
    41bc:	90 e0       	ldi	r25, 0x00	; 0
    41be:	29 81       	ldd	r18, Y+1	; 0x01
    41c0:	22 2f       	mov	r18, r18
    41c2:	30 e0       	ldi	r19, 0x00	; 0
    41c4:	4e 81       	ldd	r20, Y+6	; 0x06
    41c6:	5f 81       	ldd	r21, Y+7	; 0x07
    41c8:	24 0f       	add	r18, r20
    41ca:	35 1f       	adc	r19, r21
    41cc:	f9 01       	movw	r30, r18
    41ce:	40 81       	ld	r20, Z
    41d0:	29 89       	ldd	r18, Y+17	; 0x11
    41d2:	3a 89       	ldd	r19, Y+18	; 0x12
    41d4:	82 0f       	add	r24, r18
    41d6:	93 1f       	adc	r25, r19
    41d8:	49 96       	adiw	r24, 0x19	; 25
    41da:	fc 01       	movw	r30, r24
    41dc:	40 83       	st	Z, r20

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    41de:	89 81       	ldd	r24, Y+1	; 0x01
    41e0:	88 2f       	mov	r24, r24
    41e2:	90 e0       	ldi	r25, 0x00	; 0
    41e4:	2e 81       	ldd	r18, Y+6	; 0x06
    41e6:	3f 81       	ldd	r19, Y+7	; 0x07
    41e8:	82 0f       	add	r24, r18
    41ea:	93 1f       	adc	r25, r19
    41ec:	fc 01       	movw	r30, r24
    41ee:	80 81       	ld	r24, Z
    41f0:	88 23       	and	r24, r24
    41f2:	39 f0       	breq	.+14     	; 0x4202 <prvInitialiseNewTask+0xb6>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    41f4:	89 81       	ldd	r24, Y+1	; 0x01
    41f6:	8f 5f       	subi	r24, 0xFF	; 255
    41f8:	89 83       	std	Y+1, r24	; 0x01
    41fa:	89 81       	ldd	r24, Y+1	; 0x01
    41fc:	88 30       	cpi	r24, 0x08	; 8
    41fe:	e0 f2       	brcs	.-72     	; 0x41b8 <prvInitialiseNewTask+0x6c>
    4200:	01 c0       	rjmp	.+2      	; 0x4204 <prvInitialiseNewTask+0xb8>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
    4202:	00 00       	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4204:	89 89       	ldd	r24, Y+17	; 0x11
    4206:	9a 89       	ldd	r25, Y+18	; 0x12
    4208:	fc 01       	movw	r30, r24
    420a:	10 a2       	std	Z+32, r1	; 0x20
    420c:	04 c0       	rjmp	.+8      	; 0x4216 <prvInitialiseNewTask+0xca>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    420e:	89 89       	ldd	r24, Y+17	; 0x11
    4210:	9a 89       	ldd	r25, Y+18	; 0x12
    4212:	fc 01       	movw	r30, r24
    4214:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4216:	8e 85       	ldd	r24, Y+14	; 0x0e
    4218:	85 30       	cpi	r24, 0x05	; 5
    421a:	10 f0       	brcs	.+4      	; 0x4220 <prvInitialiseNewTask+0xd4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    421c:	84 e0       	ldi	r24, 0x04	; 4
    421e:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4220:	89 89       	ldd	r24, Y+17	; 0x11
    4222:	9a 89       	ldd	r25, Y+18	; 0x12
    4224:	2e 85       	ldd	r18, Y+14	; 0x0e
    4226:	fc 01       	movw	r30, r24
    4228:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    422a:	89 89       	ldd	r24, Y+17	; 0x11
    422c:	9a 89       	ldd	r25, Y+18	; 0x12
    422e:	2e 85       	ldd	r18, Y+14	; 0x0e
    4230:	fc 01       	movw	r30, r24
    4232:	21 a3       	std	Z+33, r18	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    4234:	89 89       	ldd	r24, Y+17	; 0x11
    4236:	9a 89       	ldd	r25, Y+18	; 0x12
    4238:	fc 01       	movw	r30, r24
    423a:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    423c:	89 89       	ldd	r24, Y+17	; 0x11
    423e:	9a 89       	ldd	r25, Y+18	; 0x12
    4240:	02 96       	adiw	r24, 0x02	; 2
    4242:	0e 94 4e 13 	call	0x269c	; 0x269c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4246:	89 89       	ldd	r24, Y+17	; 0x11
    4248:	9a 89       	ldd	r25, Y+18	; 0x12
    424a:	0c 96       	adiw	r24, 0x0c	; 12
    424c:	0e 94 4e 13 	call	0x269c	; 0x269c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4250:	89 89       	ldd	r24, Y+17	; 0x11
    4252:	9a 89       	ldd	r25, Y+18	; 0x12
    4254:	29 89       	ldd	r18, Y+17	; 0x11
    4256:	3a 89       	ldd	r19, Y+18	; 0x12
    4258:	fc 01       	movw	r30, r24
    425a:	31 87       	std	Z+9, r19	; 0x09
    425c:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    425e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4260:	88 2f       	mov	r24, r24
    4262:	90 e0       	ldi	r25, 0x00	; 0
    4264:	25 e0       	ldi	r18, 0x05	; 5
    4266:	30 e0       	ldi	r19, 0x00	; 0
    4268:	28 1b       	sub	r18, r24
    426a:	39 0b       	sbc	r19, r25
    426c:	89 89       	ldd	r24, Y+17	; 0x11
    426e:	9a 89       	ldd	r25, Y+18	; 0x12
    4270:	fc 01       	movw	r30, r24
    4272:	35 87       	std	Z+13, r19	; 0x0d
    4274:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4276:	89 89       	ldd	r24, Y+17	; 0x11
    4278:	9a 89       	ldd	r25, Y+18	; 0x12
    427a:	29 89       	ldd	r18, Y+17	; 0x11
    427c:	3a 89       	ldd	r19, Y+18	; 0x12
    427e:	fc 01       	movw	r30, r24
    4280:	33 8b       	std	Z+19, r19	; 0x13
    4282:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4284:	89 89       	ldd	r24, Y+17	; 0x11
    4286:	9a 89       	ldd	r25, Y+18	; 0x12
    4288:	fc 01       	movw	r30, r24
    428a:	13 a2       	std	Z+35, r1	; 0x23
    428c:	14 a2       	std	Z+36, r1	; 0x24
    428e:	15 a2       	std	Z+37, r1	; 0x25
    4290:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4292:	89 89       	ldd	r24, Y+17	; 0x11
    4294:	9a 89       	ldd	r25, Y+18	; 0x12
    4296:	fc 01       	movw	r30, r24
    4298:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    429a:	4c 85       	ldd	r20, Y+12	; 0x0c
    429c:	5d 85       	ldd	r21, Y+13	; 0x0d
    429e:	2c 81       	ldd	r18, Y+4	; 0x04
    42a0:	3d 81       	ldd	r19, Y+5	; 0x05
    42a2:	8a 81       	ldd	r24, Y+2	; 0x02
    42a4:	9b 81       	ldd	r25, Y+3	; 0x03
    42a6:	b9 01       	movw	r22, r18
    42a8:	0e 94 d2 14 	call	0x29a4	; 0x29a4 <pxPortInitialiseStack>
    42ac:	9c 01       	movw	r18, r24
    42ae:	89 89       	ldd	r24, Y+17	; 0x11
    42b0:	9a 89       	ldd	r25, Y+18	; 0x12
    42b2:	fc 01       	movw	r30, r24
    42b4:	31 83       	std	Z+1, r19	; 0x01
    42b6:	20 83       	st	Z, r18
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    42b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    42ba:	98 89       	ldd	r25, Y+16	; 0x10
    42bc:	89 2b       	or	r24, r25
    42be:	39 f0       	breq	.+14     	; 0x42ce <prvInitialiseNewTask+0x182>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    42c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    42c2:	98 89       	ldd	r25, Y+16	; 0x10
    42c4:	29 89       	ldd	r18, Y+17	; 0x11
    42c6:	3a 89       	ldd	r19, Y+18	; 0x12
    42c8:	fc 01       	movw	r30, r24
    42ca:	31 83       	std	Z+1, r19	; 0x01
    42cc:	20 83       	st	Z, r18
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    42ce:	00 00       	nop
    42d0:	64 96       	adiw	r28, 0x14	; 20
    42d2:	0f b6       	in	r0, 0x3f	; 63
    42d4:	f8 94       	cli
    42d6:	de bf       	out	0x3e, r29	; 62
    42d8:	0f be       	out	0x3f, r0	; 63
    42da:	cd bf       	out	0x3d, r28	; 61
    42dc:	df 91       	pop	r29
    42de:	cf 91       	pop	r28
    42e0:	1f 91       	pop	r17
    42e2:	0f 91       	pop	r16
    42e4:	ef 90       	pop	r14
    42e6:	df 90       	pop	r13
    42e8:	cf 90       	pop	r12
    42ea:	bf 90       	pop	r11
    42ec:	af 90       	pop	r10
    42ee:	9f 90       	pop	r9
    42f0:	8f 90       	pop	r8
    42f2:	08 95       	ret

000042f4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    42f4:	cf 93       	push	r28
    42f6:	df 93       	push	r29
    42f8:	00 d0       	rcall	.+0      	; 0x42fa <prvAddNewTaskToReadyList+0x6>
    42fa:	cd b7       	in	r28, 0x3d	; 61
    42fc:	de b7       	in	r29, 0x3e	; 62
    42fe:	9a 83       	std	Y+2, r25	; 0x02
    4300:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4302:	0f b6       	in	r0, 0x3f	; 63
    4304:	f8 94       	cli
    4306:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4308:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    430c:	8f 5f       	subi	r24, 0xFF	; 255
    430e:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    4312:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4316:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    431a:	89 2b       	or	r24, r25
    431c:	69 f4       	brne	.+26     	; 0x4338 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    431e:	89 81       	ldd	r24, Y+1	; 0x01
    4320:	9a 81       	ldd	r25, Y+2	; 0x02
    4322:	90 93 a0 06 	sts	0x06A0, r25	; 0x8006a0 <pxCurrentTCB+0x1>
    4326:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    432a:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    432e:	81 30       	cpi	r24, 0x01	; 1
    4330:	c9 f4       	brne	.+50     	; 0x4364 <prvAddNewTaskToReadyList+0x70>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4332:	0e 94 f6 28 	call	0x51ec	; 0x51ec <prvInitialiseTaskLists>
    4336:	16 c0       	rjmp	.+44     	; 0x4364 <prvAddNewTaskToReadyList+0x70>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4338:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    433c:	88 23       	and	r24, r24
    433e:	91 f4       	brne	.+36     	; 0x4364 <prvAddNewTaskToReadyList+0x70>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4340:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4344:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4348:	fc 01       	movw	r30, r24
    434a:	26 89       	ldd	r18, Z+22	; 0x16
    434c:	89 81       	ldd	r24, Y+1	; 0x01
    434e:	9a 81       	ldd	r25, Y+2	; 0x02
    4350:	fc 01       	movw	r30, r24
    4352:	86 89       	ldd	r24, Z+22	; 0x16
    4354:	82 17       	cp	r24, r18
    4356:	30 f0       	brcs	.+12     	; 0x4364 <prvAddNewTaskToReadyList+0x70>
				{
					pxCurrentTCB = pxNewTCB;
    4358:	89 81       	ldd	r24, Y+1	; 0x01
    435a:	9a 81       	ldd	r25, Y+2	; 0x02
    435c:	90 93 a0 06 	sts	0x06A0, r25	; 0x8006a0 <pxCurrentTCB+0x1>
    4360:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4364:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTaskNumber>
    4368:	8f 5f       	subi	r24, 0xFF	; 255
    436a:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    436e:	89 81       	ldd	r24, Y+1	; 0x01
    4370:	9a 81       	ldd	r25, Y+2	; 0x02
    4372:	fc 01       	movw	r30, r24
    4374:	96 89       	ldd	r25, Z+22	; 0x16
    4376:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    437a:	89 17       	cp	r24, r25
    437c:	30 f4       	brcc	.+12     	; 0x438a <prvAddNewTaskToReadyList+0x96>
    437e:	89 81       	ldd	r24, Y+1	; 0x01
    4380:	9a 81       	ldd	r25, Y+2	; 0x02
    4382:	fc 01       	movw	r30, r24
    4384:	86 89       	ldd	r24, Z+22	; 0x16
    4386:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    438a:	89 81       	ldd	r24, Y+1	; 0x01
    438c:	9a 81       	ldd	r25, Y+2	; 0x02
    438e:	ac 01       	movw	r20, r24
    4390:	4e 5f       	subi	r20, 0xFE	; 254
    4392:	5f 4f       	sbci	r21, 0xFF	; 255
    4394:	89 81       	ldd	r24, Y+1	; 0x01
    4396:	9a 81       	ldd	r25, Y+2	; 0x02
    4398:	fc 01       	movw	r30, r24
    439a:	86 89       	ldd	r24, Z+22	; 0x16
    439c:	28 2f       	mov	r18, r24
    439e:	30 e0       	ldi	r19, 0x00	; 0
    43a0:	c9 01       	movw	r24, r18
    43a2:	88 0f       	add	r24, r24
    43a4:	99 1f       	adc	r25, r25
    43a6:	88 0f       	add	r24, r24
    43a8:	99 1f       	adc	r25, r25
    43aa:	88 0f       	add	r24, r24
    43ac:	99 1f       	adc	r25, r25
    43ae:	82 0f       	add	r24, r18
    43b0:	93 1f       	adc	r25, r19
    43b2:	8f 55       	subi	r24, 0x5F	; 95
    43b4:	99 4f       	sbci	r25, 0xF9	; 249
    43b6:	ba 01       	movw	r22, r20
    43b8:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    43bc:	0f 90       	pop	r0
    43be:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    43c0:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    43c4:	88 23       	and	r24, r24
    43c6:	71 f0       	breq	.+28     	; 0x43e4 <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    43c8:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    43cc:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    43d0:	fc 01       	movw	r30, r24
    43d2:	26 89       	ldd	r18, Z+22	; 0x16
    43d4:	89 81       	ldd	r24, Y+1	; 0x01
    43d6:	9a 81       	ldd	r25, Y+2	; 0x02
    43d8:	fc 01       	movw	r30, r24
    43da:	86 89       	ldd	r24, Z+22	; 0x16
    43dc:	28 17       	cp	r18, r24
    43de:	10 f4       	brcc	.+4      	; 0x43e4 <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    43e0:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    43e4:	00 00       	nop
    43e6:	0f 90       	pop	r0
    43e8:	0f 90       	pop	r0
    43ea:	df 91       	pop	r29
    43ec:	cf 91       	pop	r28
    43ee:	08 95       	ret

000043f0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    43f0:	cf 93       	push	r28
    43f2:	df 93       	push	r29
    43f4:	00 d0       	rcall	.+0      	; 0x43f6 <vTaskDelete+0x6>
    43f6:	00 d0       	rcall	.+0      	; 0x43f8 <vTaskDelete+0x8>
    43f8:	cd b7       	in	r28, 0x3d	; 61
    43fa:	de b7       	in	r29, 0x3e	; 62
    43fc:	9c 83       	std	Y+4, r25	; 0x04
    43fe:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4400:	0f b6       	in	r0, 0x3f	; 63
    4402:	f8 94       	cli
    4404:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4406:	8b 81       	ldd	r24, Y+3	; 0x03
    4408:	9c 81       	ldd	r25, Y+4	; 0x04
    440a:	89 2b       	or	r24, r25
    440c:	29 f4       	brne	.+10     	; 0x4418 <vTaskDelete+0x28>
    440e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4412:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4416:	02 c0       	rjmp	.+4      	; 0x441c <vTaskDelete+0x2c>
    4418:	8b 81       	ldd	r24, Y+3	; 0x03
    441a:	9c 81       	ldd	r25, Y+4	; 0x04
    441c:	9a 83       	std	Y+2, r25	; 0x02
    441e:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4420:	89 81       	ldd	r24, Y+1	; 0x01
    4422:	9a 81       	ldd	r25, Y+2	; 0x02
    4424:	02 96       	adiw	r24, 0x02	; 2
    4426:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    442a:	89 81       	ldd	r24, Y+1	; 0x01
    442c:	9a 81       	ldd	r25, Y+2	; 0x02
    442e:	fc 01       	movw	r30, r24
    4430:	84 89       	ldd	r24, Z+20	; 0x14
    4432:	95 89       	ldd	r25, Z+21	; 0x15
    4434:	89 2b       	or	r24, r25
    4436:	29 f0       	breq	.+10     	; 0x4442 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4438:	89 81       	ldd	r24, Y+1	; 0x01
    443a:	9a 81       	ldd	r25, Y+2	; 0x02
    443c:	0c 96       	adiw	r24, 0x0c	; 12
    443e:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4442:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTaskNumber>
    4446:	8f 5f       	subi	r24, 0xFF	; 255
    4448:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    444c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4450:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4454:	29 81       	ldd	r18, Y+1	; 0x01
    4456:	3a 81       	ldd	r19, Y+2	; 0x02
    4458:	28 17       	cp	r18, r24
    445a:	39 07       	cpc	r19, r25
    445c:	71 f4       	brne	.+28     	; 0x447a <vTaskDelete+0x8a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    445e:	89 81       	ldd	r24, Y+1	; 0x01
    4460:	9a 81       	ldd	r25, Y+2	; 0x02
    4462:	02 96       	adiw	r24, 0x02	; 2
    4464:	bc 01       	movw	r22, r24
    4466:	8d ee       	ldi	r24, 0xED	; 237
    4468:	96 e0       	ldi	r25, 0x06	; 6
    446a:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    446e:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    4472:	8f 5f       	subi	r24, 0xFF	; 255
    4474:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    4478:	0b c0       	rjmp	.+22     	; 0x4490 <vTaskDelete+0xa0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    447a:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    447e:	81 50       	subi	r24, 0x01	; 1
    4480:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxCurrentNumberOfTasks>
				prvDeleteTCB( pxTCB );
    4484:	89 81       	ldd	r24, Y+1	; 0x01
    4486:	9a 81       	ldd	r25, Y+2	; 0x02
    4488:	0e 94 69 29 	call	0x52d2	; 0x52d2 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    448c:	0e 94 81 29 	call	0x5302	; 0x5302 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4490:	0f 90       	pop	r0
    4492:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4494:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    4498:	88 23       	and	r24, r24
    449a:	59 f0       	breq	.+22     	; 0x44b2 <vTaskDelete+0xc2>
		{
			if( pxTCB == pxCurrentTCB )
    449c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    44a0:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    44a4:	29 81       	ldd	r18, Y+1	; 0x01
    44a6:	3a 81       	ldd	r19, Y+2	; 0x02
    44a8:	28 17       	cp	r18, r24
    44aa:	39 07       	cpc	r19, r25
    44ac:	11 f4       	brne	.+4      	; 0x44b2 <vTaskDelete+0xc2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    44ae:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    44b2:	00 00       	nop
    44b4:	0f 90       	pop	r0
    44b6:	0f 90       	pop	r0
    44b8:	0f 90       	pop	r0
    44ba:	0f 90       	pop	r0
    44bc:	df 91       	pop	r29
    44be:	cf 91       	pop	r28
    44c0:	08 95       	ret

000044c2 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    44c2:	cf 93       	push	r28
    44c4:	df 93       	push	r29
    44c6:	cd b7       	in	r28, 0x3d	; 61
    44c8:	de b7       	in	r29, 0x3e	; 62
    44ca:	2a 97       	sbiw	r28, 0x0a	; 10
    44cc:	0f b6       	in	r0, 0x3f	; 63
    44ce:	f8 94       	cli
    44d0:	de bf       	out	0x3e, r29	; 62
    44d2:	0f be       	out	0x3f, r0	; 63
    44d4:	cd bf       	out	0x3d, r28	; 61
    44d6:	98 87       	std	Y+8, r25	; 0x08
    44d8:	8f 83       	std	Y+7, r24	; 0x07
    44da:	7a 87       	std	Y+10, r23	; 0x0a
    44dc:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    44de:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    44e0:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    44e4:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    44e8:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    44ec:	9b 83       	std	Y+3, r25	; 0x03
    44ee:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    44f0:	8f 81       	ldd	r24, Y+7	; 0x07
    44f2:	98 85       	ldd	r25, Y+8	; 0x08
    44f4:	fc 01       	movw	r30, r24
    44f6:	20 81       	ld	r18, Z
    44f8:	31 81       	ldd	r19, Z+1	; 0x01
    44fa:	89 85       	ldd	r24, Y+9	; 0x09
    44fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    44fe:	82 0f       	add	r24, r18
    4500:	93 1f       	adc	r25, r19
    4502:	9d 83       	std	Y+5, r25	; 0x05
    4504:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    4506:	8f 81       	ldd	r24, Y+7	; 0x07
    4508:	98 85       	ldd	r25, Y+8	; 0x08
    450a:	fc 01       	movw	r30, r24
    450c:	20 81       	ld	r18, Z
    450e:	31 81       	ldd	r19, Z+1	; 0x01
    4510:	8a 81       	ldd	r24, Y+2	; 0x02
    4512:	9b 81       	ldd	r25, Y+3	; 0x03
    4514:	82 17       	cp	r24, r18
    4516:	93 07       	cpc	r25, r19
    4518:	a0 f4       	brcc	.+40     	; 0x4542 <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    451a:	8f 81       	ldd	r24, Y+7	; 0x07
    451c:	98 85       	ldd	r25, Y+8	; 0x08
    451e:	fc 01       	movw	r30, r24
    4520:	20 81       	ld	r18, Z
    4522:	31 81       	ldd	r19, Z+1	; 0x01
    4524:	8c 81       	ldd	r24, Y+4	; 0x04
    4526:	9d 81       	ldd	r25, Y+5	; 0x05
    4528:	82 17       	cp	r24, r18
    452a:	93 07       	cpc	r25, r19
    452c:	e8 f4       	brcc	.+58     	; 0x4568 <vTaskDelayUntil+0xa6>
    452e:	2c 81       	ldd	r18, Y+4	; 0x04
    4530:	3d 81       	ldd	r19, Y+5	; 0x05
    4532:	8a 81       	ldd	r24, Y+2	; 0x02
    4534:	9b 81       	ldd	r25, Y+3	; 0x03
    4536:	82 17       	cp	r24, r18
    4538:	93 07       	cpc	r25, r19
    453a:	b0 f4       	brcc	.+44     	; 0x4568 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    453c:	81 e0       	ldi	r24, 0x01	; 1
    453e:	89 83       	std	Y+1, r24	; 0x01
    4540:	13 c0       	rjmp	.+38     	; 0x4568 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4542:	8f 81       	ldd	r24, Y+7	; 0x07
    4544:	98 85       	ldd	r25, Y+8	; 0x08
    4546:	fc 01       	movw	r30, r24
    4548:	20 81       	ld	r18, Z
    454a:	31 81       	ldd	r19, Z+1	; 0x01
    454c:	8c 81       	ldd	r24, Y+4	; 0x04
    454e:	9d 81       	ldd	r25, Y+5	; 0x05
    4550:	82 17       	cp	r24, r18
    4552:	93 07       	cpc	r25, r19
    4554:	38 f0       	brcs	.+14     	; 0x4564 <vTaskDelayUntil+0xa2>
    4556:	2c 81       	ldd	r18, Y+4	; 0x04
    4558:	3d 81       	ldd	r19, Y+5	; 0x05
    455a:	8a 81       	ldd	r24, Y+2	; 0x02
    455c:	9b 81       	ldd	r25, Y+3	; 0x03
    455e:	82 17       	cp	r24, r18
    4560:	93 07       	cpc	r25, r19
    4562:	10 f4       	brcc	.+4      	; 0x4568 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    4564:	81 e0       	ldi	r24, 0x01	; 1
    4566:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4568:	8f 81       	ldd	r24, Y+7	; 0x07
    456a:	98 85       	ldd	r25, Y+8	; 0x08
    456c:	2c 81       	ldd	r18, Y+4	; 0x04
    456e:	3d 81       	ldd	r19, Y+5	; 0x05
    4570:	fc 01       	movw	r30, r24
    4572:	31 83       	std	Z+1, r19	; 0x01
    4574:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    4576:	89 81       	ldd	r24, Y+1	; 0x01
    4578:	88 23       	and	r24, r24
    457a:	59 f0       	breq	.+22     	; 0x4592 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    457c:	2c 81       	ldd	r18, Y+4	; 0x04
    457e:	3d 81       	ldd	r19, Y+5	; 0x05
    4580:	8a 81       	ldd	r24, Y+2	; 0x02
    4582:	9b 81       	ldd	r25, Y+3	; 0x03
    4584:	a9 01       	movw	r20, r18
    4586:	48 1b       	sub	r20, r24
    4588:	59 0b       	sbc	r21, r25
    458a:	ca 01       	movw	r24, r20
    458c:	60 e0       	ldi	r22, 0x00	; 0
    458e:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4592:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    4596:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4598:	8e 81       	ldd	r24, Y+6	; 0x06
    459a:	88 23       	and	r24, r24
    459c:	11 f4       	brne	.+4      	; 0x45a2 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    459e:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    45a2:	00 00       	nop
    45a4:	2a 96       	adiw	r28, 0x0a	; 10
    45a6:	0f b6       	in	r0, 0x3f	; 63
    45a8:	f8 94       	cli
    45aa:	de bf       	out	0x3e, r29	; 62
    45ac:	0f be       	out	0x3f, r0	; 63
    45ae:	cd bf       	out	0x3d, r28	; 61
    45b0:	df 91       	pop	r29
    45b2:	cf 91       	pop	r28
    45b4:	08 95       	ret

000045b6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    45b6:	cf 93       	push	r28
    45b8:	df 93       	push	r29
    45ba:	00 d0       	rcall	.+0      	; 0x45bc <vTaskDelay+0x6>
    45bc:	1f 92       	push	r1
    45be:	cd b7       	in	r28, 0x3d	; 61
    45c0:	de b7       	in	r29, 0x3e	; 62
    45c2:	9b 83       	std	Y+3, r25	; 0x03
    45c4:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    45c6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    45c8:	8a 81       	ldd	r24, Y+2	; 0x02
    45ca:	9b 81       	ldd	r25, Y+3	; 0x03
    45cc:	89 2b       	or	r24, r25
    45ce:	51 f0       	breq	.+20     	; 0x45e4 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    45d0:	0e 94 ac 24 	call	0x4958	; 0x4958 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    45d4:	8a 81       	ldd	r24, Y+2	; 0x02
    45d6:	9b 81       	ldd	r25, Y+3	; 0x03
    45d8:	60 e0       	ldi	r22, 0x00	; 0
    45da:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    45de:	0e 94 b9 24 	call	0x4972	; 0x4972 <xTaskResumeAll>
    45e2:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    45e4:	89 81       	ldd	r24, Y+1	; 0x01
    45e6:	88 23       	and	r24, r24
    45e8:	11 f4       	brne	.+4      	; 0x45ee <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    45ea:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    45ee:	00 00       	nop
    45f0:	0f 90       	pop	r0
    45f2:	0f 90       	pop	r0
    45f4:	0f 90       	pop	r0
    45f6:	df 91       	pop	r29
    45f8:	cf 91       	pop	r28
    45fa:	08 95       	ret

000045fc <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    45fc:	cf 93       	push	r28
    45fe:	df 93       	push	r29
    4600:	00 d0       	rcall	.+0      	; 0x4602 <vTaskSuspend+0x6>
    4602:	00 d0       	rcall	.+0      	; 0x4604 <vTaskSuspend+0x8>
    4604:	cd b7       	in	r28, 0x3d	; 61
    4606:	de b7       	in	r29, 0x3e	; 62
    4608:	9c 83       	std	Y+4, r25	; 0x04
    460a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    460c:	0f b6       	in	r0, 0x3f	; 63
    460e:	f8 94       	cli
    4610:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4612:	8b 81       	ldd	r24, Y+3	; 0x03
    4614:	9c 81       	ldd	r25, Y+4	; 0x04
    4616:	89 2b       	or	r24, r25
    4618:	29 f4       	brne	.+10     	; 0x4624 <vTaskSuspend+0x28>
    461a:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    461e:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4622:	02 c0       	rjmp	.+4      	; 0x4628 <vTaskSuspend+0x2c>
    4624:	8b 81       	ldd	r24, Y+3	; 0x03
    4626:	9c 81       	ldd	r25, Y+4	; 0x04
    4628:	9a 83       	std	Y+2, r25	; 0x02
    462a:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    462c:	89 81       	ldd	r24, Y+1	; 0x01
    462e:	9a 81       	ldd	r25, Y+2	; 0x02
    4630:	02 96       	adiw	r24, 0x02	; 2
    4632:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4636:	89 81       	ldd	r24, Y+1	; 0x01
    4638:	9a 81       	ldd	r25, Y+2	; 0x02
    463a:	fc 01       	movw	r30, r24
    463c:	84 89       	ldd	r24, Z+20	; 0x14
    463e:	95 89       	ldd	r25, Z+21	; 0x15
    4640:	89 2b       	or	r24, r25
    4642:	29 f0       	breq	.+10     	; 0x464e <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4644:	89 81       	ldd	r24, Y+1	; 0x01
    4646:	9a 81       	ldd	r25, Y+2	; 0x02
    4648:	0c 96       	adiw	r24, 0x0c	; 12
    464a:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    464e:	89 81       	ldd	r24, Y+1	; 0x01
    4650:	9a 81       	ldd	r25, Y+2	; 0x02
    4652:	02 96       	adiw	r24, 0x02	; 2
    4654:	bc 01       	movw	r22, r24
    4656:	87 ef       	ldi	r24, 0xF7	; 247
    4658:	96 e0       	ldi	r25, 0x06	; 6
    465a:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    465e:	89 81       	ldd	r24, Y+1	; 0x01
    4660:	9a 81       	ldd	r25, Y+2	; 0x02
    4662:	fc 01       	movw	r30, r24
    4664:	87 a1       	ldd	r24, Z+39	; 0x27
    4666:	81 30       	cpi	r24, 0x01	; 1
    4668:	21 f4       	brne	.+8      	; 0x4672 <vTaskSuspend+0x76>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    466a:	89 81       	ldd	r24, Y+1	; 0x01
    466c:	9a 81       	ldd	r25, Y+2	; 0x02
    466e:	fc 01       	movw	r30, r24
    4670:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4672:	0f 90       	pop	r0
    4674:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    4676:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    467a:	88 23       	and	r24, r24
    467c:	39 f0       	breq	.+14     	; 0x468c <vTaskSuspend+0x90>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    467e:	0f b6       	in	r0, 0x3f	; 63
    4680:	f8 94       	cli
    4682:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    4684:	0e 94 81 29 	call	0x5302	; 0x5302 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    4688:	0f 90       	pop	r0
    468a:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    468c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4690:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4694:	29 81       	ldd	r18, Y+1	; 0x01
    4696:	3a 81       	ldd	r19, Y+2	; 0x02
    4698:	28 17       	cp	r18, r24
    469a:	39 07       	cpc	r19, r25
    469c:	a1 f4       	brne	.+40     	; 0x46c6 <vTaskSuspend+0xca>
		{
			if( xSchedulerRunning != pdFALSE )
    469e:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    46a2:	88 23       	and	r24, r24
    46a4:	19 f0       	breq	.+6      	; 0x46ac <vTaskSuspend+0xb0>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    46a6:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46aa:	0d c0       	rjmp	.+26     	; 0x46c6 <vTaskSuspend+0xca>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    46ac:	90 91 f7 06 	lds	r25, 0x06F7	; 0x8006f7 <xSuspendedTaskList>
    46b0:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    46b4:	98 17       	cp	r25, r24
    46b6:	29 f4       	brne	.+10     	; 0x46c2 <vTaskSuspend+0xc6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    46b8:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <pxCurrentTCB+0x1>
    46bc:	10 92 9f 06 	sts	0x069F, r1	; 0x80069f <pxCurrentTCB>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46c0:	02 c0       	rjmp	.+4      	; 0x46c6 <vTaskSuspend+0xca>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
    46c2:	0e 94 91 26 	call	0x4d22	; 0x4d22 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46c6:	00 00       	nop
    46c8:	0f 90       	pop	r0
    46ca:	0f 90       	pop	r0
    46cc:	0f 90       	pop	r0
    46ce:	0f 90       	pop	r0
    46d0:	df 91       	pop	r29
    46d2:	cf 91       	pop	r28
    46d4:	08 95       	ret

000046d6 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    46d6:	cf 93       	push	r28
    46d8:	df 93       	push	r29
    46da:	00 d0       	rcall	.+0      	; 0x46dc <prvTaskIsTaskSuspended+0x6>
    46dc:	00 d0       	rcall	.+0      	; 0x46de <prvTaskIsTaskSuspended+0x8>
    46de:	1f 92       	push	r1
    46e0:	cd b7       	in	r28, 0x3d	; 61
    46e2:	de b7       	in	r29, 0x3e	; 62
    46e4:	9d 83       	std	Y+5, r25	; 0x05
    46e6:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    46e8:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = xTask;
    46ea:	8c 81       	ldd	r24, Y+4	; 0x04
    46ec:	9d 81       	ldd	r25, Y+5	; 0x05
    46ee:	9b 83       	std	Y+3, r25	; 0x03
    46f0:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    46f2:	8a 81       	ldd	r24, Y+2	; 0x02
    46f4:	9b 81       	ldd	r25, Y+3	; 0x03
    46f6:	fc 01       	movw	r30, r24
    46f8:	82 85       	ldd	r24, Z+10	; 0x0a
    46fa:	93 85       	ldd	r25, Z+11	; 0x0b
    46fc:	87 5f       	subi	r24, 0xF7	; 247
    46fe:	96 40       	sbci	r25, 0x06	; 6
    4700:	89 f4       	brne	.+34     	; 0x4724 <prvTaskIsTaskSuspended+0x4e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    4702:	8a 81       	ldd	r24, Y+2	; 0x02
    4704:	9b 81       	ldd	r25, Y+3	; 0x03
    4706:	fc 01       	movw	r30, r24
    4708:	84 89       	ldd	r24, Z+20	; 0x14
    470a:	95 89       	ldd	r25, Z+21	; 0x15
    470c:	84 5e       	subi	r24, 0xE4	; 228
    470e:	96 40       	sbci	r25, 0x06	; 6
    4710:	49 f0       	breq	.+18     	; 0x4724 <prvTaskIsTaskSuspended+0x4e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    4712:	8a 81       	ldd	r24, Y+2	; 0x02
    4714:	9b 81       	ldd	r25, Y+3	; 0x03
    4716:	fc 01       	movw	r30, r24
    4718:	84 89       	ldd	r24, Z+20	; 0x14
    471a:	95 89       	ldd	r25, Z+21	; 0x15
    471c:	89 2b       	or	r24, r25
    471e:	11 f4       	brne	.+4      	; 0x4724 <prvTaskIsTaskSuspended+0x4e>
				{
					xReturn = pdTRUE;
    4720:	81 e0       	ldi	r24, 0x01	; 1
    4722:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4724:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4726:	0f 90       	pop	r0
    4728:	0f 90       	pop	r0
    472a:	0f 90       	pop	r0
    472c:	0f 90       	pop	r0
    472e:	0f 90       	pop	r0
    4730:	df 91       	pop	r29
    4732:	cf 91       	pop	r28
    4734:	08 95       	ret

00004736 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4736:	cf 93       	push	r28
    4738:	df 93       	push	r29
    473a:	00 d0       	rcall	.+0      	; 0x473c <vTaskResume+0x6>
    473c:	00 d0       	rcall	.+0      	; 0x473e <vTaskResume+0x8>
    473e:	cd b7       	in	r28, 0x3d	; 61
    4740:	de b7       	in	r29, 0x3e	; 62
    4742:	9c 83       	std	Y+4, r25	; 0x04
    4744:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4746:	8b 81       	ldd	r24, Y+3	; 0x03
    4748:	9c 81       	ldd	r25, Y+4	; 0x04
    474a:	9a 83       	std	Y+2, r25	; 0x02
    474c:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    474e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4752:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4756:	29 81       	ldd	r18, Y+1	; 0x01
    4758:	3a 81       	ldd	r19, Y+2	; 0x02
    475a:	28 17       	cp	r18, r24
    475c:	39 07       	cpc	r19, r25
    475e:	09 f4       	brne	.+2      	; 0x4762 <vTaskResume+0x2c>
    4760:	4a c0       	rjmp	.+148    	; 0x47f6 <vTaskResume+0xc0>
    4762:	89 81       	ldd	r24, Y+1	; 0x01
    4764:	9a 81       	ldd	r25, Y+2	; 0x02
    4766:	89 2b       	or	r24, r25
    4768:	09 f4       	brne	.+2      	; 0x476c <vTaskResume+0x36>
    476a:	45 c0       	rjmp	.+138    	; 0x47f6 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    476c:	0f b6       	in	r0, 0x3f	; 63
    476e:	f8 94       	cli
    4770:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4772:	89 81       	ldd	r24, Y+1	; 0x01
    4774:	9a 81       	ldd	r25, Y+2	; 0x02
    4776:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <prvTaskIsTaskSuspended>
    477a:	88 23       	and	r24, r24
    477c:	d1 f1       	breq	.+116    	; 0x47f2 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    477e:	89 81       	ldd	r24, Y+1	; 0x01
    4780:	9a 81       	ldd	r25, Y+2	; 0x02
    4782:	02 96       	adiw	r24, 0x02	; 2
    4784:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4788:	89 81       	ldd	r24, Y+1	; 0x01
    478a:	9a 81       	ldd	r25, Y+2	; 0x02
    478c:	fc 01       	movw	r30, r24
    478e:	96 89       	ldd	r25, Z+22	; 0x16
    4790:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4794:	89 17       	cp	r24, r25
    4796:	30 f4       	brcc	.+12     	; 0x47a4 <vTaskResume+0x6e>
    4798:	89 81       	ldd	r24, Y+1	; 0x01
    479a:	9a 81       	ldd	r25, Y+2	; 0x02
    479c:	fc 01       	movw	r30, r24
    479e:	86 89       	ldd	r24, Z+22	; 0x16
    47a0:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    47a4:	89 81       	ldd	r24, Y+1	; 0x01
    47a6:	9a 81       	ldd	r25, Y+2	; 0x02
    47a8:	ac 01       	movw	r20, r24
    47aa:	4e 5f       	subi	r20, 0xFE	; 254
    47ac:	5f 4f       	sbci	r21, 0xFF	; 255
    47ae:	89 81       	ldd	r24, Y+1	; 0x01
    47b0:	9a 81       	ldd	r25, Y+2	; 0x02
    47b2:	fc 01       	movw	r30, r24
    47b4:	86 89       	ldd	r24, Z+22	; 0x16
    47b6:	28 2f       	mov	r18, r24
    47b8:	30 e0       	ldi	r19, 0x00	; 0
    47ba:	c9 01       	movw	r24, r18
    47bc:	88 0f       	add	r24, r24
    47be:	99 1f       	adc	r25, r25
    47c0:	88 0f       	add	r24, r24
    47c2:	99 1f       	adc	r25, r25
    47c4:	88 0f       	add	r24, r24
    47c6:	99 1f       	adc	r25, r25
    47c8:	82 0f       	add	r24, r18
    47ca:	93 1f       	adc	r25, r19
    47cc:	8f 55       	subi	r24, 0x5F	; 95
    47ce:	99 4f       	sbci	r25, 0xF9	; 249
    47d0:	ba 01       	movw	r22, r20
    47d2:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    47d6:	89 81       	ldd	r24, Y+1	; 0x01
    47d8:	9a 81       	ldd	r25, Y+2	; 0x02
    47da:	fc 01       	movw	r30, r24
    47dc:	26 89       	ldd	r18, Z+22	; 0x16
    47de:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    47e2:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    47e6:	fc 01       	movw	r30, r24
    47e8:	86 89       	ldd	r24, Z+22	; 0x16
    47ea:	28 17       	cp	r18, r24
    47ec:	10 f0       	brcs	.+4      	; 0x47f2 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    47ee:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    47f2:	0f 90       	pop	r0
    47f4:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    47f6:	00 00       	nop
    47f8:	0f 90       	pop	r0
    47fa:	0f 90       	pop	r0
    47fc:	0f 90       	pop	r0
    47fe:	0f 90       	pop	r0
    4800:	df 91       	pop	r29
    4802:	cf 91       	pop	r28
    4804:	08 95       	ret

00004806 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4806:	cf 93       	push	r28
    4808:	df 93       	push	r29
    480a:	00 d0       	rcall	.+0      	; 0x480c <xTaskResumeFromISR+0x6>
    480c:	00 d0       	rcall	.+0      	; 0x480e <xTaskResumeFromISR+0x8>
    480e:	00 d0       	rcall	.+0      	; 0x4810 <xTaskResumeFromISR+0xa>
    4810:	cd b7       	in	r28, 0x3d	; 61
    4812:	de b7       	in	r29, 0x3e	; 62
    4814:	9e 83       	std	Y+6, r25	; 0x06
    4816:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4818:	19 82       	std	Y+1, r1	; 0x01
	TCB_t * const pxTCB = xTaskToResume;
    481a:	8d 81       	ldd	r24, Y+5	; 0x05
    481c:	9e 81       	ldd	r25, Y+6	; 0x06
    481e:	9b 83       	std	Y+3, r25	; 0x03
    4820:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4822:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4824:	8a 81       	ldd	r24, Y+2	; 0x02
    4826:	9b 81       	ldd	r25, Y+3	; 0x03
    4828:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <prvTaskIsTaskSuspended>
    482c:	88 23       	and	r24, r24
    482e:	09 f4       	brne	.+2      	; 0x4832 <xTaskResumeFromISR+0x2c>
    4830:	47 c0       	rjmp	.+142    	; 0x48c0 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4832:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4836:	88 23       	and	r24, r24
    4838:	d9 f5       	brne	.+118    	; 0x48b0 <xTaskResumeFromISR+0xaa>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    483a:	8a 81       	ldd	r24, Y+2	; 0x02
    483c:	9b 81       	ldd	r25, Y+3	; 0x03
    483e:	fc 01       	movw	r30, r24
    4840:	26 89       	ldd	r18, Z+22	; 0x16
    4842:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4846:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    484a:	fc 01       	movw	r30, r24
    484c:	86 89       	ldd	r24, Z+22	; 0x16
    484e:	28 17       	cp	r18, r24
    4850:	10 f0       	brcs	.+4      	; 0x4856 <xTaskResumeFromISR+0x50>
					{
						xYieldRequired = pdTRUE;
    4852:	81 e0       	ldi	r24, 0x01	; 1
    4854:	89 83       	std	Y+1, r24	; 0x01
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4856:	8a 81       	ldd	r24, Y+2	; 0x02
    4858:	9b 81       	ldd	r25, Y+3	; 0x03
    485a:	02 96       	adiw	r24, 0x02	; 2
    485c:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4860:	8a 81       	ldd	r24, Y+2	; 0x02
    4862:	9b 81       	ldd	r25, Y+3	; 0x03
    4864:	fc 01       	movw	r30, r24
    4866:	96 89       	ldd	r25, Z+22	; 0x16
    4868:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    486c:	89 17       	cp	r24, r25
    486e:	30 f4       	brcc	.+12     	; 0x487c <xTaskResumeFromISR+0x76>
    4870:	8a 81       	ldd	r24, Y+2	; 0x02
    4872:	9b 81       	ldd	r25, Y+3	; 0x03
    4874:	fc 01       	movw	r30, r24
    4876:	86 89       	ldd	r24, Z+22	; 0x16
    4878:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    487c:	8a 81       	ldd	r24, Y+2	; 0x02
    487e:	9b 81       	ldd	r25, Y+3	; 0x03
    4880:	ac 01       	movw	r20, r24
    4882:	4e 5f       	subi	r20, 0xFE	; 254
    4884:	5f 4f       	sbci	r21, 0xFF	; 255
    4886:	8a 81       	ldd	r24, Y+2	; 0x02
    4888:	9b 81       	ldd	r25, Y+3	; 0x03
    488a:	fc 01       	movw	r30, r24
    488c:	86 89       	ldd	r24, Z+22	; 0x16
    488e:	28 2f       	mov	r18, r24
    4890:	30 e0       	ldi	r19, 0x00	; 0
    4892:	c9 01       	movw	r24, r18
    4894:	88 0f       	add	r24, r24
    4896:	99 1f       	adc	r25, r25
    4898:	88 0f       	add	r24, r24
    489a:	99 1f       	adc	r25, r25
    489c:	88 0f       	add	r24, r24
    489e:	99 1f       	adc	r25, r25
    48a0:	82 0f       	add	r24, r18
    48a2:	93 1f       	adc	r25, r19
    48a4:	8f 55       	subi	r24, 0x5F	; 95
    48a6:	99 4f       	sbci	r25, 0xF9	; 249
    48a8:	ba 01       	movw	r22, r20
    48aa:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
    48ae:	08 c0       	rjmp	.+16     	; 0x48c0 <xTaskResumeFromISR+0xba>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    48b0:	8a 81       	ldd	r24, Y+2	; 0x02
    48b2:	9b 81       	ldd	r25, Y+3	; 0x03
    48b4:	0c 96       	adiw	r24, 0x0c	; 12
    48b6:	bc 01       	movw	r22, r24
    48b8:	84 ee       	ldi	r24, 0xE4	; 228
    48ba:	96 e0       	ldi	r25, 0x06	; 6
    48bc:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    48c0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    48c2:	26 96       	adiw	r28, 0x06	; 6
    48c4:	0f b6       	in	r0, 0x3f	; 63
    48c6:	f8 94       	cli
    48c8:	de bf       	out	0x3e, r29	; 62
    48ca:	0f be       	out	0x3f, r0	; 63
    48cc:	cd bf       	out	0x3d, r28	; 61
    48ce:	df 91       	pop	r29
    48d0:	cf 91       	pop	r28
    48d2:	08 95       	ret

000048d4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    48d4:	ef 92       	push	r14
    48d6:	ff 92       	push	r15
    48d8:	0f 93       	push	r16
    48da:	cf 93       	push	r28
    48dc:	df 93       	push	r29
    48de:	1f 92       	push	r1
    48e0:	cd b7       	in	r28, 0x3d	; 61
    48e2:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    48e4:	0f 2e       	mov	r0, r31
    48e6:	fb e0       	ldi	r31, 0x0B	; 11
    48e8:	ef 2e       	mov	r14, r31
    48ea:	f7 e0       	ldi	r31, 0x07	; 7
    48ec:	ff 2e       	mov	r15, r31
    48ee:	f0 2d       	mov	r31, r0
    48f0:	00 e0       	ldi	r16, 0x00	; 0
    48f2:	20 e0       	ldi	r18, 0x00	; 0
    48f4:	30 e0       	ldi	r19, 0x00	; 0
    48f6:	45 e5       	ldi	r20, 0x55	; 85
    48f8:	50 e0       	ldi	r21, 0x00	; 0
    48fa:	64 eb       	ldi	r22, 0xB4	; 180
    48fc:	70 e0       	ldi	r23, 0x00	; 0
    48fe:	86 ee       	ldi	r24, 0xE6	; 230
    4900:	98 e2       	ldi	r25, 0x28	; 40
    4902:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCreate>
    4906:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4908:	89 81       	ldd	r24, Y+1	; 0x01
    490a:	81 30       	cpi	r24, 0x01	; 1
    490c:	81 f4       	brne	.+32     	; 0x492e <vTaskStartScheduler+0x5a>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    490e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4910:	8f ef       	ldi	r24, 0xFF	; 255
    4912:	9f ef       	ldi	r25, 0xFF	; 255
    4914:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    4918:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    491c:	81 e0       	ldi	r24, 0x01	; 1
    491e:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4922:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <xTickCount+0x1>
    4926:	10 92 01 07 	sts	0x0701, r1	; 0x800701 <xTickCount>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    492a:	0e 94 7b 16 	call	0x2cf6	; 0x2cf6 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    492e:	00 00       	nop
    4930:	0f 90       	pop	r0
    4932:	df 91       	pop	r29
    4934:	cf 91       	pop	r28
    4936:	0f 91       	pop	r16
    4938:	ff 90       	pop	r15
    493a:	ef 90       	pop	r14
    493c:	08 95       	ret

0000493e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    493e:	cf 93       	push	r28
    4940:	df 93       	push	r29
    4942:	cd b7       	in	r28, 0x3d	; 61
    4944:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4946:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4948:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <xSchedulerRunning>
	vPortEndScheduler();
    494c:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <vPortEndScheduler>
}
    4950:	00 00       	nop
    4952:	df 91       	pop	r29
    4954:	cf 91       	pop	r28
    4956:	08 95       	ret

00004958 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4958:	cf 93       	push	r28
    495a:	df 93       	push	r29
    495c:	cd b7       	in	r28, 0x3d	; 61
    495e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4960:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4964:	8f 5f       	subi	r24, 0xFF	; 255
    4966:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxSchedulerSuspended>
	portMEMORY_BARRIER();
}
    496a:	00 00       	nop
    496c:	df 91       	pop	r29
    496e:	cf 91       	pop	r28
    4970:	08 95       	ret

00004972 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4972:	cf 93       	push	r28
    4974:	df 93       	push	r29
    4976:	00 d0       	rcall	.+0      	; 0x4978 <xTaskResumeAll+0x6>
    4978:	00 d0       	rcall	.+0      	; 0x497a <xTaskResumeAll+0x8>
    497a:	cd b7       	in	r28, 0x3d	; 61
    497c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    497e:	1a 82       	std	Y+2, r1	; 0x02
    4980:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xAlreadyYielded = pdFALSE;
    4982:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4984:	0f b6       	in	r0, 0x3f	; 63
    4986:	f8 94       	cli
    4988:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    498a:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    498e:	81 50       	subi	r24, 0x01	; 1
    4990:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4994:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4998:	88 23       	and	r24, r24
    499a:	09 f0       	breq	.+2      	; 0x499e <xTaskResumeAll+0x2c>
    499c:	77 c0       	rjmp	.+238    	; 0x4a8c <xTaskResumeAll+0x11a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    499e:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    49a2:	88 23       	and	r24, r24
    49a4:	09 f4       	brne	.+2      	; 0x49a8 <xTaskResumeAll+0x36>
    49a6:	72 c0       	rjmp	.+228    	; 0x4a8c <xTaskResumeAll+0x11a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    49a8:	49 c0       	rjmp	.+146    	; 0x4a3c <xTaskResumeAll+0xca>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49aa:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <xPendingReadyList+0x5>
    49ae:	90 91 ea 06 	lds	r25, 0x06EA	; 0x8006ea <xPendingReadyList+0x6>
    49b2:	fc 01       	movw	r30, r24
    49b4:	86 81       	ldd	r24, Z+6	; 0x06
    49b6:	97 81       	ldd	r25, Z+7	; 0x07
    49b8:	9a 83       	std	Y+2, r25	; 0x02
    49ba:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    49bc:	89 81       	ldd	r24, Y+1	; 0x01
    49be:	9a 81       	ldd	r25, Y+2	; 0x02
    49c0:	0c 96       	adiw	r24, 0x0c	; 12
    49c2:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    49c6:	89 81       	ldd	r24, Y+1	; 0x01
    49c8:	9a 81       	ldd	r25, Y+2	; 0x02
    49ca:	02 96       	adiw	r24, 0x02	; 2
    49cc:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    49d0:	89 81       	ldd	r24, Y+1	; 0x01
    49d2:	9a 81       	ldd	r25, Y+2	; 0x02
    49d4:	fc 01       	movw	r30, r24
    49d6:	96 89       	ldd	r25, Z+22	; 0x16
    49d8:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    49dc:	89 17       	cp	r24, r25
    49de:	30 f4       	brcc	.+12     	; 0x49ec <xTaskResumeAll+0x7a>
    49e0:	89 81       	ldd	r24, Y+1	; 0x01
    49e2:	9a 81       	ldd	r25, Y+2	; 0x02
    49e4:	fc 01       	movw	r30, r24
    49e6:	86 89       	ldd	r24, Z+22	; 0x16
    49e8:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    49ec:	89 81       	ldd	r24, Y+1	; 0x01
    49ee:	9a 81       	ldd	r25, Y+2	; 0x02
    49f0:	ac 01       	movw	r20, r24
    49f2:	4e 5f       	subi	r20, 0xFE	; 254
    49f4:	5f 4f       	sbci	r21, 0xFF	; 255
    49f6:	89 81       	ldd	r24, Y+1	; 0x01
    49f8:	9a 81       	ldd	r25, Y+2	; 0x02
    49fa:	fc 01       	movw	r30, r24
    49fc:	86 89       	ldd	r24, Z+22	; 0x16
    49fe:	28 2f       	mov	r18, r24
    4a00:	30 e0       	ldi	r19, 0x00	; 0
    4a02:	c9 01       	movw	r24, r18
    4a04:	88 0f       	add	r24, r24
    4a06:	99 1f       	adc	r25, r25
    4a08:	88 0f       	add	r24, r24
    4a0a:	99 1f       	adc	r25, r25
    4a0c:	88 0f       	add	r24, r24
    4a0e:	99 1f       	adc	r25, r25
    4a10:	82 0f       	add	r24, r18
    4a12:	93 1f       	adc	r25, r19
    4a14:	8f 55       	subi	r24, 0x5F	; 95
    4a16:	99 4f       	sbci	r25, 0xF9	; 249
    4a18:	ba 01       	movw	r22, r20
    4a1a:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4a1e:	89 81       	ldd	r24, Y+1	; 0x01
    4a20:	9a 81       	ldd	r25, Y+2	; 0x02
    4a22:	fc 01       	movw	r30, r24
    4a24:	26 89       	ldd	r18, Z+22	; 0x16
    4a26:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4a2a:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4a2e:	fc 01       	movw	r30, r24
    4a30:	86 89       	ldd	r24, Z+22	; 0x16
    4a32:	28 17       	cp	r18, r24
    4a34:	18 f0       	brcs	.+6      	; 0x4a3c <xTaskResumeAll+0xca>
					{
						xYieldPending = pdTRUE;
    4a36:	81 e0       	ldi	r24, 0x01	; 1
    4a38:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4a3c:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <xPendingReadyList>
    4a40:	88 23       	and	r24, r24
    4a42:	09 f0       	breq	.+2      	; 0x4a46 <xTaskResumeAll+0xd4>
    4a44:	b2 cf       	rjmp	.-156    	; 0x49aa <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4a46:	89 81       	ldd	r24, Y+1	; 0x01
    4a48:	9a 81       	ldd	r25, Y+2	; 0x02
    4a4a:	89 2b       	or	r24, r25
    4a4c:	11 f0       	breq	.+4      	; 0x4a52 <xTaskResumeAll+0xe0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4a4e:	0e 94 81 29 	call	0x5302	; 0x5302 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4a52:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxPendedTicks>
    4a56:	8c 83       	std	Y+4, r24	; 0x04

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4a58:	8c 81       	ldd	r24, Y+4	; 0x04
    4a5a:	88 23       	and	r24, r24
    4a5c:	79 f0       	breq	.+30     	; 0x4a7c <xTaskResumeAll+0x10a>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4a5e:	0e 94 a4 25 	call	0x4b48	; 0x4b48 <xTaskIncrementTick>
    4a62:	88 23       	and	r24, r24
    4a64:	19 f0       	breq	.+6      	; 0x4a6c <xTaskResumeAll+0xfa>
							{
								xYieldPending = pdTRUE;
    4a66:	81 e0       	ldi	r24, 0x01	; 1
    4a68:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4a6c:	8c 81       	ldd	r24, Y+4	; 0x04
    4a6e:	81 50       	subi	r24, 0x01	; 1
    4a70:	8c 83       	std	Y+4, r24	; 0x04
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4a72:	8c 81       	ldd	r24, Y+4	; 0x04
    4a74:	88 23       	and	r24, r24
    4a76:	99 f7       	brne	.-26     	; 0x4a5e <xTaskResumeAll+0xec>

						uxPendedTicks = 0;
    4a78:	10 92 05 07 	sts	0x0705, r1	; 0x800705 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4a7c:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xYieldPending>
    4a80:	88 23       	and	r24, r24
    4a82:	21 f0       	breq	.+8      	; 0x4a8c <xTaskResumeAll+0x11a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4a84:	81 e0       	ldi	r24, 0x01	; 1
    4a86:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4a88:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4a8c:	0f 90       	pop	r0
    4a8e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4a90:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4a92:	0f 90       	pop	r0
    4a94:	0f 90       	pop	r0
    4a96:	0f 90       	pop	r0
    4a98:	0f 90       	pop	r0
    4a9a:	df 91       	pop	r29
    4a9c:	cf 91       	pop	r28
    4a9e:	08 95       	ret

00004aa0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4aa0:	cf 93       	push	r28
    4aa2:	df 93       	push	r29
    4aa4:	00 d0       	rcall	.+0      	; 0x4aa6 <xTaskGetTickCount+0x6>
    4aa6:	cd b7       	in	r28, 0x3d	; 61
    4aa8:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4aaa:	0f b6       	in	r0, 0x3f	; 63
    4aac:	f8 94       	cli
    4aae:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4ab0:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    4ab4:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    4ab8:	9a 83       	std	Y+2, r25	; 0x02
    4aba:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4abc:	0f 90       	pop	r0
    4abe:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4ac0:	89 81       	ldd	r24, Y+1	; 0x01
    4ac2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4ac4:	0f 90       	pop	r0
    4ac6:	0f 90       	pop	r0
    4ac8:	df 91       	pop	r29
    4aca:	cf 91       	pop	r28
    4acc:	08 95       	ret

00004ace <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4ace:	cf 93       	push	r28
    4ad0:	df 93       	push	r29
    4ad2:	00 d0       	rcall	.+0      	; 0x4ad4 <xTaskGetTickCountFromISR+0x6>
    4ad4:	1f 92       	push	r1
    4ad6:	cd b7       	in	r28, 0x3d	; 61
    4ad8:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4ada:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4adc:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    4ae0:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    4ae4:	9b 83       	std	Y+3, r25	; 0x03
    4ae6:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4ae8:	8a 81       	ldd	r24, Y+2	; 0x02
    4aea:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4aec:	0f 90       	pop	r0
    4aee:	0f 90       	pop	r0
    4af0:	0f 90       	pop	r0
    4af2:	df 91       	pop	r29
    4af4:	cf 91       	pop	r28
    4af6:	08 95       	ret

00004af8 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4af8:	cf 93       	push	r28
    4afa:	df 93       	push	r29
    4afc:	cd b7       	in	r28, 0x3d	; 61
    4afe:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4b00:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
}
    4b04:	df 91       	pop	r29
    4b06:	cf 91       	pop	r28
    4b08:	08 95       	ret

00004b0a <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4b0a:	cf 93       	push	r28
    4b0c:	df 93       	push	r29
    4b0e:	00 d0       	rcall	.+0      	; 0x4b10 <pcTaskGetName+0x6>
    4b10:	00 d0       	rcall	.+0      	; 0x4b12 <pcTaskGetName+0x8>
    4b12:	cd b7       	in	r28, 0x3d	; 61
    4b14:	de b7       	in	r29, 0x3e	; 62
    4b16:	9c 83       	std	Y+4, r25	; 0x04
    4b18:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b1c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b1e:	89 2b       	or	r24, r25
    4b20:	29 f4       	brne	.+10     	; 0x4b2c <pcTaskGetName+0x22>
    4b22:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4b26:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4b2a:	02 c0       	rjmp	.+4      	; 0x4b30 <pcTaskGetName+0x26>
    4b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b30:	9a 83       	std	Y+2, r25	; 0x02
    4b32:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4b34:	89 81       	ldd	r24, Y+1	; 0x01
    4b36:	9a 81       	ldd	r25, Y+2	; 0x02
    4b38:	49 96       	adiw	r24, 0x19	; 25
}
    4b3a:	0f 90       	pop	r0
    4b3c:	0f 90       	pop	r0
    4b3e:	0f 90       	pop	r0
    4b40:	0f 90       	pop	r0
    4b42:	df 91       	pop	r29
    4b44:	cf 91       	pop	r28
    4b46:	08 95       	ret

00004b48 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4b48:	cf 93       	push	r28
    4b4a:	df 93       	push	r29
    4b4c:	cd b7       	in	r28, 0x3d	; 61
    4b4e:	de b7       	in	r29, 0x3e	; 62
    4b50:	29 97       	sbiw	r28, 0x09	; 9
    4b52:	0f b6       	in	r0, 0x3f	; 63
    4b54:	f8 94       	cli
    4b56:	de bf       	out	0x3e, r29	; 62
    4b58:	0f be       	out	0x3f, r0	; 63
    4b5a:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4b5c:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b5e:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4b62:	88 23       	and	r24, r24
    4b64:	09 f0       	breq	.+2      	; 0x4b68 <xTaskIncrementTick+0x20>
    4b66:	c8 c0       	rjmp	.+400    	; 0x4cf8 <xTaskIncrementTick+0x1b0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4b68:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    4b6c:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    4b70:	01 96       	adiw	r24, 0x01	; 1
    4b72:	9b 83       	std	Y+3, r25	; 0x03
    4b74:	8a 83       	std	Y+2, r24	; 0x02

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4b76:	8a 81       	ldd	r24, Y+2	; 0x02
    4b78:	9b 81       	ldd	r25, Y+3	; 0x03
    4b7a:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <xTickCount+0x1>
    4b7e:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4b82:	8a 81       	ldd	r24, Y+2	; 0x02
    4b84:	9b 81       	ldd	r25, Y+3	; 0x03
    4b86:	89 2b       	or	r24, r25
    4b88:	d9 f4       	brne	.+54     	; 0x4bc0 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4b8a:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    4b8e:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    4b92:	9d 83       	std	Y+5, r25	; 0x05
    4b94:	8c 83       	std	Y+4, r24	; 0x04
    4b96:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <pxOverflowDelayedTaskList>
    4b9a:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    4b9e:	90 93 e1 06 	sts	0x06E1, r25	; 0x8006e1 <pxDelayedTaskList+0x1>
    4ba2:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <pxDelayedTaskList>
    4ba6:	8c 81       	ldd	r24, Y+4	; 0x04
    4ba8:	9d 81       	ldd	r25, Y+5	; 0x05
    4baa:	90 93 e3 06 	sts	0x06E3, r25	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    4bae:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <pxOverflowDelayedTaskList>
    4bb2:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xNumOfOverflows>
    4bb6:	8f 5f       	subi	r24, 0xFF	; 255
    4bb8:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNumOfOverflows>
    4bbc:	0e 94 81 29 	call	0x5302	; 0x5302 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4bc0:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xNextTaskUnblockTime>
    4bc4:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xNextTaskUnblockTime+0x1>
    4bc8:	2a 81       	ldd	r18, Y+2	; 0x02
    4bca:	3b 81       	ldd	r19, Y+3	; 0x03
    4bcc:	28 17       	cp	r18, r24
    4bce:	39 07       	cpc	r19, r25
    4bd0:	08 f4       	brcc	.+2      	; 0x4bd4 <xTaskIncrementTick+0x8c>
    4bd2:	78 c0       	rjmp	.+240    	; 0x4cc4 <xTaskIncrementTick+0x17c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4bd4:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    4bd8:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    4bdc:	fc 01       	movw	r30, r24
    4bde:	80 81       	ld	r24, Z
    4be0:	88 23       	and	r24, r24
    4be2:	39 f4       	brne	.+14     	; 0x4bf2 <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4be4:	8f ef       	ldi	r24, 0xFF	; 255
    4be6:	9f ef       	ldi	r25, 0xFF	; 255
    4be8:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    4bec:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
					break;
    4bf0:	69 c0       	rjmp	.+210    	; 0x4cc4 <xTaskIncrementTick+0x17c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4bf2:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    4bf6:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    4bfa:	fc 01       	movw	r30, r24
    4bfc:	85 81       	ldd	r24, Z+5	; 0x05
    4bfe:	96 81       	ldd	r25, Z+6	; 0x06
    4c00:	fc 01       	movw	r30, r24
    4c02:	86 81       	ldd	r24, Z+6	; 0x06
    4c04:	97 81       	ldd	r25, Z+7	; 0x07
    4c06:	9f 83       	std	Y+7, r25	; 0x07
    4c08:	8e 83       	std	Y+6, r24	; 0x06
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4c0a:	8e 81       	ldd	r24, Y+6	; 0x06
    4c0c:	9f 81       	ldd	r25, Y+7	; 0x07
    4c0e:	fc 01       	movw	r30, r24
    4c10:	82 81       	ldd	r24, Z+2	; 0x02
    4c12:	93 81       	ldd	r25, Z+3	; 0x03
    4c14:	99 87       	std	Y+9, r25	; 0x09
    4c16:	88 87       	std	Y+8, r24	; 0x08

					if( xConstTickCount < xItemValue )
    4c18:	2a 81       	ldd	r18, Y+2	; 0x02
    4c1a:	3b 81       	ldd	r19, Y+3	; 0x03
    4c1c:	88 85       	ldd	r24, Y+8	; 0x08
    4c1e:	99 85       	ldd	r25, Y+9	; 0x09
    4c20:	28 17       	cp	r18, r24
    4c22:	39 07       	cpc	r19, r25
    4c24:	38 f4       	brcc	.+14     	; 0x4c34 <xTaskIncrementTick+0xec>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4c26:	88 85       	ldd	r24, Y+8	; 0x08
    4c28:	99 85       	ldd	r25, Y+9	; 0x09
    4c2a:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    4c2e:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    4c32:	48 c0       	rjmp	.+144    	; 0x4cc4 <xTaskIncrementTick+0x17c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4c34:	8e 81       	ldd	r24, Y+6	; 0x06
    4c36:	9f 81       	ldd	r25, Y+7	; 0x07
    4c38:	02 96       	adiw	r24, 0x02	; 2
    4c3a:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4c3e:	8e 81       	ldd	r24, Y+6	; 0x06
    4c40:	9f 81       	ldd	r25, Y+7	; 0x07
    4c42:	fc 01       	movw	r30, r24
    4c44:	84 89       	ldd	r24, Z+20	; 0x14
    4c46:	95 89       	ldd	r25, Z+21	; 0x15
    4c48:	89 2b       	or	r24, r25
    4c4a:	29 f0       	breq	.+10     	; 0x4c56 <xTaskIncrementTick+0x10e>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4c4c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c4e:	9f 81       	ldd	r25, Y+7	; 0x07
    4c50:	0c 96       	adiw	r24, 0x0c	; 12
    4c52:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4c56:	8e 81       	ldd	r24, Y+6	; 0x06
    4c58:	9f 81       	ldd	r25, Y+7	; 0x07
    4c5a:	fc 01       	movw	r30, r24
    4c5c:	96 89       	ldd	r25, Z+22	; 0x16
    4c5e:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4c62:	89 17       	cp	r24, r25
    4c64:	30 f4       	brcc	.+12     	; 0x4c72 <xTaskIncrementTick+0x12a>
    4c66:	8e 81       	ldd	r24, Y+6	; 0x06
    4c68:	9f 81       	ldd	r25, Y+7	; 0x07
    4c6a:	fc 01       	movw	r30, r24
    4c6c:	86 89       	ldd	r24, Z+22	; 0x16
    4c6e:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    4c72:	8e 81       	ldd	r24, Y+6	; 0x06
    4c74:	9f 81       	ldd	r25, Y+7	; 0x07
    4c76:	ac 01       	movw	r20, r24
    4c78:	4e 5f       	subi	r20, 0xFE	; 254
    4c7a:	5f 4f       	sbci	r21, 0xFF	; 255
    4c7c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c7e:	9f 81       	ldd	r25, Y+7	; 0x07
    4c80:	fc 01       	movw	r30, r24
    4c82:	86 89       	ldd	r24, Z+22	; 0x16
    4c84:	28 2f       	mov	r18, r24
    4c86:	30 e0       	ldi	r19, 0x00	; 0
    4c88:	c9 01       	movw	r24, r18
    4c8a:	88 0f       	add	r24, r24
    4c8c:	99 1f       	adc	r25, r25
    4c8e:	88 0f       	add	r24, r24
    4c90:	99 1f       	adc	r25, r25
    4c92:	88 0f       	add	r24, r24
    4c94:	99 1f       	adc	r25, r25
    4c96:	82 0f       	add	r24, r18
    4c98:	93 1f       	adc	r25, r19
    4c9a:	8f 55       	subi	r24, 0x5F	; 95
    4c9c:	99 4f       	sbci	r25, 0xF9	; 249
    4c9e:	ba 01       	movw	r22, r20
    4ca0:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4ca4:	8e 81       	ldd	r24, Y+6	; 0x06
    4ca6:	9f 81       	ldd	r25, Y+7	; 0x07
    4ca8:	fc 01       	movw	r30, r24
    4caa:	26 89       	ldd	r18, Z+22	; 0x16
    4cac:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4cb0:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4cb4:	fc 01       	movw	r30, r24
    4cb6:	86 89       	ldd	r24, Z+22	; 0x16
    4cb8:	28 17       	cp	r18, r24
    4cba:	08 f4       	brcc	.+2      	; 0x4cbe <xTaskIncrementTick+0x176>
    4cbc:	8b cf       	rjmp	.-234    	; 0x4bd4 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4cbe:	81 e0       	ldi	r24, 0x01	; 1
    4cc0:	89 83       	std	Y+1, r24	; 0x01
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    4cc2:	88 cf       	rjmp	.-240    	; 0x4bd4 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4cc4:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4cc8:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4ccc:	fc 01       	movw	r30, r24
    4cce:	86 89       	ldd	r24, Z+22	; 0x16
    4cd0:	28 2f       	mov	r18, r24
    4cd2:	30 e0       	ldi	r19, 0x00	; 0
    4cd4:	c9 01       	movw	r24, r18
    4cd6:	88 0f       	add	r24, r24
    4cd8:	99 1f       	adc	r25, r25
    4cda:	88 0f       	add	r24, r24
    4cdc:	99 1f       	adc	r25, r25
    4cde:	88 0f       	add	r24, r24
    4ce0:	99 1f       	adc	r25, r25
    4ce2:	82 0f       	add	r24, r18
    4ce4:	93 1f       	adc	r25, r19
    4ce6:	8f 55       	subi	r24, 0x5F	; 95
    4ce8:	99 4f       	sbci	r25, 0xF9	; 249
    4cea:	fc 01       	movw	r30, r24
    4cec:	80 81       	ld	r24, Z
    4cee:	82 30       	cpi	r24, 0x02	; 2
    4cf0:	40 f0       	brcs	.+16     	; 0x4d02 <xTaskIncrementTick+0x1ba>
			{
				xSwitchRequired = pdTRUE;
    4cf2:	81 e0       	ldi	r24, 0x01	; 1
    4cf4:	89 83       	std	Y+1, r24	; 0x01
    4cf6:	05 c0       	rjmp	.+10     	; 0x4d02 <xTaskIncrementTick+0x1ba>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4cf8:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxPendedTicks>
    4cfc:	8f 5f       	subi	r24, 0xFF	; 255
    4cfe:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxPendedTicks>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4d02:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xYieldPending>
    4d06:	88 23       	and	r24, r24
    4d08:	11 f0       	breq	.+4      	; 0x4d0e <xTaskIncrementTick+0x1c6>
		{
			xSwitchRequired = pdTRUE;
    4d0a:	81 e0       	ldi	r24, 0x01	; 1
    4d0c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4d0e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4d10:	29 96       	adiw	r28, 0x09	; 9
    4d12:	0f b6       	in	r0, 0x3f	; 63
    4d14:	f8 94       	cli
    4d16:	de bf       	out	0x3e, r29	; 62
    4d18:	0f be       	out	0x3f, r0	; 63
    4d1a:	cd bf       	out	0x3d, r28	; 61
    4d1c:	df 91       	pop	r29
    4d1e:	cf 91       	pop	r28
    4d20:	08 95       	ret

00004d22 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4d22:	cf 93       	push	r28
    4d24:	df 93       	push	r29
    4d26:	00 d0       	rcall	.+0      	; 0x4d28 <vTaskSwitchContext+0x6>
    4d28:	1f 92       	push	r1
    4d2a:	cd b7       	in	r28, 0x3d	; 61
    4d2c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4d2e:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4d32:	88 23       	and	r24, r24
    4d34:	21 f0       	breq	.+8      	; 0x4d3e <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4d36:	81 e0       	ldi	r24, 0x01	; 1
    4d38:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4d3c:	5f c0       	rjmp	.+190    	; 0x4dfc <vTaskSwitchContext+0xda>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    4d3e:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d42:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4d46:	89 83       	std	Y+1, r24	; 0x01
    4d48:	03 c0       	rjmp	.+6      	; 0x4d50 <vTaskSwitchContext+0x2e>
    4d4a:	89 81       	ldd	r24, Y+1	; 0x01
    4d4c:	81 50       	subi	r24, 0x01	; 1
    4d4e:	89 83       	std	Y+1, r24	; 0x01
    4d50:	89 81       	ldd	r24, Y+1	; 0x01
    4d52:	28 2f       	mov	r18, r24
    4d54:	30 e0       	ldi	r19, 0x00	; 0
    4d56:	c9 01       	movw	r24, r18
    4d58:	88 0f       	add	r24, r24
    4d5a:	99 1f       	adc	r25, r25
    4d5c:	88 0f       	add	r24, r24
    4d5e:	99 1f       	adc	r25, r25
    4d60:	88 0f       	add	r24, r24
    4d62:	99 1f       	adc	r25, r25
    4d64:	82 0f       	add	r24, r18
    4d66:	93 1f       	adc	r25, r19
    4d68:	8f 55       	subi	r24, 0x5F	; 95
    4d6a:	99 4f       	sbci	r25, 0xF9	; 249
    4d6c:	fc 01       	movw	r30, r24
    4d6e:	80 81       	ld	r24, Z
    4d70:	88 23       	and	r24, r24
    4d72:	59 f3       	breq	.-42     	; 0x4d4a <vTaskSwitchContext+0x28>
    4d74:	89 81       	ldd	r24, Y+1	; 0x01
    4d76:	28 2f       	mov	r18, r24
    4d78:	30 e0       	ldi	r19, 0x00	; 0
    4d7a:	c9 01       	movw	r24, r18
    4d7c:	88 0f       	add	r24, r24
    4d7e:	99 1f       	adc	r25, r25
    4d80:	88 0f       	add	r24, r24
    4d82:	99 1f       	adc	r25, r25
    4d84:	88 0f       	add	r24, r24
    4d86:	99 1f       	adc	r25, r25
    4d88:	82 0f       	add	r24, r18
    4d8a:	93 1f       	adc	r25, r19
    4d8c:	8f 55       	subi	r24, 0x5F	; 95
    4d8e:	99 4f       	sbci	r25, 0xF9	; 249
    4d90:	9b 83       	std	Y+3, r25	; 0x03
    4d92:	8a 83       	std	Y+2, r24	; 0x02
    4d94:	8a 81       	ldd	r24, Y+2	; 0x02
    4d96:	9b 81       	ldd	r25, Y+3	; 0x03
    4d98:	fc 01       	movw	r30, r24
    4d9a:	81 81       	ldd	r24, Z+1	; 0x01
    4d9c:	92 81       	ldd	r25, Z+2	; 0x02
    4d9e:	fc 01       	movw	r30, r24
    4da0:	22 81       	ldd	r18, Z+2	; 0x02
    4da2:	33 81       	ldd	r19, Z+3	; 0x03
    4da4:	8a 81       	ldd	r24, Y+2	; 0x02
    4da6:	9b 81       	ldd	r25, Y+3	; 0x03
    4da8:	fc 01       	movw	r30, r24
    4daa:	32 83       	std	Z+2, r19	; 0x02
    4dac:	21 83       	std	Z+1, r18	; 0x01
    4dae:	8a 81       	ldd	r24, Y+2	; 0x02
    4db0:	9b 81       	ldd	r25, Y+3	; 0x03
    4db2:	fc 01       	movw	r30, r24
    4db4:	21 81       	ldd	r18, Z+1	; 0x01
    4db6:	32 81       	ldd	r19, Z+2	; 0x02
    4db8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dba:	9b 81       	ldd	r25, Y+3	; 0x03
    4dbc:	03 96       	adiw	r24, 0x03	; 3
    4dbe:	28 17       	cp	r18, r24
    4dc0:	39 07       	cpc	r19, r25
    4dc2:	69 f4       	brne	.+26     	; 0x4dde <vTaskSwitchContext+0xbc>
    4dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    4dc6:	9b 81       	ldd	r25, Y+3	; 0x03
    4dc8:	fc 01       	movw	r30, r24
    4dca:	81 81       	ldd	r24, Z+1	; 0x01
    4dcc:	92 81       	ldd	r25, Z+2	; 0x02
    4dce:	fc 01       	movw	r30, r24
    4dd0:	22 81       	ldd	r18, Z+2	; 0x02
    4dd2:	33 81       	ldd	r19, Z+3	; 0x03
    4dd4:	8a 81       	ldd	r24, Y+2	; 0x02
    4dd6:	9b 81       	ldd	r25, Y+3	; 0x03
    4dd8:	fc 01       	movw	r30, r24
    4dda:	32 83       	std	Z+2, r19	; 0x02
    4ddc:	21 83       	std	Z+1, r18	; 0x01
    4dde:	8a 81       	ldd	r24, Y+2	; 0x02
    4de0:	9b 81       	ldd	r25, Y+3	; 0x03
    4de2:	fc 01       	movw	r30, r24
    4de4:	81 81       	ldd	r24, Z+1	; 0x01
    4de6:	92 81       	ldd	r25, Z+2	; 0x02
    4de8:	fc 01       	movw	r30, r24
    4dea:	86 81       	ldd	r24, Z+6	; 0x06
    4dec:	97 81       	ldd	r25, Z+7	; 0x07
    4dee:	90 93 a0 06 	sts	0x06A0, r25	; 0x8006a0 <pxCurrentTCB+0x1>
    4df2:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <pxCurrentTCB>
    4df6:	89 81       	ldd	r24, Y+1	; 0x01
    4df8:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4dfc:	00 00       	nop
    4dfe:	0f 90       	pop	r0
    4e00:	0f 90       	pop	r0
    4e02:	0f 90       	pop	r0
    4e04:	df 91       	pop	r29
    4e06:	cf 91       	pop	r28
    4e08:	08 95       	ret

00004e0a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4e0a:	cf 93       	push	r28
    4e0c:	df 93       	push	r29
    4e0e:	00 d0       	rcall	.+0      	; 0x4e10 <vTaskPlaceOnEventList+0x6>
    4e10:	00 d0       	rcall	.+0      	; 0x4e12 <vTaskPlaceOnEventList+0x8>
    4e12:	cd b7       	in	r28, 0x3d	; 61
    4e14:	de b7       	in	r29, 0x3e	; 62
    4e16:	9a 83       	std	Y+2, r25	; 0x02
    4e18:	89 83       	std	Y+1, r24	; 0x01
    4e1a:	7c 83       	std	Y+4, r23	; 0x04
    4e1c:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4e1e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4e22:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4e26:	9c 01       	movw	r18, r24
    4e28:	24 5f       	subi	r18, 0xF4	; 244
    4e2a:	3f 4f       	sbci	r19, 0xFF	; 255
    4e2c:	89 81       	ldd	r24, Y+1	; 0x01
    4e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    4e30:	b9 01       	movw	r22, r18
    4e32:	0e 94 af 13 	call	0x275e	; 0x275e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e36:	8b 81       	ldd	r24, Y+3	; 0x03
    4e38:	9c 81       	ldd	r25, Y+4	; 0x04
    4e3a:	61 e0       	ldi	r22, 0x01	; 1
    4e3c:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <prvAddCurrentTaskToDelayedList>
}
    4e40:	00 00       	nop
    4e42:	0f 90       	pop	r0
    4e44:	0f 90       	pop	r0
    4e46:	0f 90       	pop	r0
    4e48:	0f 90       	pop	r0
    4e4a:	df 91       	pop	r29
    4e4c:	cf 91       	pop	r28
    4e4e:	08 95       	ret

00004e50 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4e50:	cf 93       	push	r28
    4e52:	df 93       	push	r29
    4e54:	00 d0       	rcall	.+0      	; 0x4e56 <vTaskPlaceOnUnorderedEventList+0x6>
    4e56:	00 d0       	rcall	.+0      	; 0x4e58 <vTaskPlaceOnUnorderedEventList+0x8>
    4e58:	00 d0       	rcall	.+0      	; 0x4e5a <vTaskPlaceOnUnorderedEventList+0xa>
    4e5a:	cd b7       	in	r28, 0x3d	; 61
    4e5c:	de b7       	in	r29, 0x3e	; 62
    4e5e:	9a 83       	std	Y+2, r25	; 0x02
    4e60:	89 83       	std	Y+1, r24	; 0x01
    4e62:	7c 83       	std	Y+4, r23	; 0x04
    4e64:	6b 83       	std	Y+3, r22	; 0x03
    4e66:	5e 83       	std	Y+6, r21	; 0x06
    4e68:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4e6a:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4e6e:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4e72:	2b 81       	ldd	r18, Y+3	; 0x03
    4e74:	3c 81       	ldd	r19, Y+4	; 0x04
    4e76:	30 68       	ori	r19, 0x80	; 128
    4e78:	fc 01       	movw	r30, r24
    4e7a:	35 87       	std	Z+13, r19	; 0x0d
    4e7c:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4e7e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4e82:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4e86:	9c 01       	movw	r18, r24
    4e88:	24 5f       	subi	r18, 0xF4	; 244
    4e8a:	3f 4f       	sbci	r19, 0xFF	; 255
    4e8c:	89 81       	ldd	r24, Y+1	; 0x01
    4e8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4e90:	b9 01       	movw	r22, r18
    4e92:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e96:	8d 81       	ldd	r24, Y+5	; 0x05
    4e98:	9e 81       	ldd	r25, Y+6	; 0x06
    4e9a:	61 e0       	ldi	r22, 0x01	; 1
    4e9c:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <prvAddCurrentTaskToDelayedList>
}
    4ea0:	00 00       	nop
    4ea2:	26 96       	adiw	r28, 0x06	; 6
    4ea4:	0f b6       	in	r0, 0x3f	; 63
    4ea6:	f8 94       	cli
    4ea8:	de bf       	out	0x3e, r29	; 62
    4eaa:	0f be       	out	0x3f, r0	; 63
    4eac:	cd bf       	out	0x3d, r28	; 61
    4eae:	df 91       	pop	r29
    4eb0:	cf 91       	pop	r28
    4eb2:	08 95       	ret

00004eb4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4eb4:	cf 93       	push	r28
    4eb6:	df 93       	push	r29
    4eb8:	00 d0       	rcall	.+0      	; 0x4eba <xTaskRemoveFromEventList+0x6>
    4eba:	00 d0       	rcall	.+0      	; 0x4ebc <xTaskRemoveFromEventList+0x8>
    4ebc:	1f 92       	push	r1
    4ebe:	cd b7       	in	r28, 0x3d	; 61
    4ec0:	de b7       	in	r29, 0x3e	; 62
    4ec2:	9d 83       	std	Y+5, r25	; 0x05
    4ec4:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ec6:	8c 81       	ldd	r24, Y+4	; 0x04
    4ec8:	9d 81       	ldd	r25, Y+5	; 0x05
    4eca:	fc 01       	movw	r30, r24
    4ecc:	85 81       	ldd	r24, Z+5	; 0x05
    4ece:	96 81       	ldd	r25, Z+6	; 0x06
    4ed0:	fc 01       	movw	r30, r24
    4ed2:	86 81       	ldd	r24, Z+6	; 0x06
    4ed4:	97 81       	ldd	r25, Z+7	; 0x07
    4ed6:	9b 83       	std	Y+3, r25	; 0x03
    4ed8:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4eda:	8a 81       	ldd	r24, Y+2	; 0x02
    4edc:	9b 81       	ldd	r25, Y+3	; 0x03
    4ede:	0c 96       	adiw	r24, 0x0c	; 12
    4ee0:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ee4:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4ee8:	88 23       	and	r24, r24
    4eea:	69 f5       	brne	.+90     	; 0x4f46 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4eec:	8a 81       	ldd	r24, Y+2	; 0x02
    4eee:	9b 81       	ldd	r25, Y+3	; 0x03
    4ef0:	02 96       	adiw	r24, 0x02	; 2
    4ef2:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4ef6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ef8:	9b 81       	ldd	r25, Y+3	; 0x03
    4efa:	fc 01       	movw	r30, r24
    4efc:	96 89       	ldd	r25, Z+22	; 0x16
    4efe:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4f02:	89 17       	cp	r24, r25
    4f04:	30 f4       	brcc	.+12     	; 0x4f12 <xTaskRemoveFromEventList+0x5e>
    4f06:	8a 81       	ldd	r24, Y+2	; 0x02
    4f08:	9b 81       	ldd	r25, Y+3	; 0x03
    4f0a:	fc 01       	movw	r30, r24
    4f0c:	86 89       	ldd	r24, Z+22	; 0x16
    4f0e:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    4f12:	8a 81       	ldd	r24, Y+2	; 0x02
    4f14:	9b 81       	ldd	r25, Y+3	; 0x03
    4f16:	ac 01       	movw	r20, r24
    4f18:	4e 5f       	subi	r20, 0xFE	; 254
    4f1a:	5f 4f       	sbci	r21, 0xFF	; 255
    4f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f1e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f20:	fc 01       	movw	r30, r24
    4f22:	86 89       	ldd	r24, Z+22	; 0x16
    4f24:	28 2f       	mov	r18, r24
    4f26:	30 e0       	ldi	r19, 0x00	; 0
    4f28:	c9 01       	movw	r24, r18
    4f2a:	88 0f       	add	r24, r24
    4f2c:	99 1f       	adc	r25, r25
    4f2e:	88 0f       	add	r24, r24
    4f30:	99 1f       	adc	r25, r25
    4f32:	88 0f       	add	r24, r24
    4f34:	99 1f       	adc	r25, r25
    4f36:	82 0f       	add	r24, r18
    4f38:	93 1f       	adc	r25, r19
    4f3a:	8f 55       	subi	r24, 0x5F	; 95
    4f3c:	99 4f       	sbci	r25, 0xF9	; 249
    4f3e:	ba 01       	movw	r22, r20
    4f40:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
    4f44:	08 c0       	rjmp	.+16     	; 0x4f56 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4f46:	8a 81       	ldd	r24, Y+2	; 0x02
    4f48:	9b 81       	ldd	r25, Y+3	; 0x03
    4f4a:	0c 96       	adiw	r24, 0x0c	; 12
    4f4c:	bc 01       	movw	r22, r24
    4f4e:	84 ee       	ldi	r24, 0xE4	; 228
    4f50:	96 e0       	ldi	r25, 0x06	; 6
    4f52:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f56:	8a 81       	ldd	r24, Y+2	; 0x02
    4f58:	9b 81       	ldd	r25, Y+3	; 0x03
    4f5a:	fc 01       	movw	r30, r24
    4f5c:	26 89       	ldd	r18, Z+22	; 0x16
    4f5e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4f62:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4f66:	fc 01       	movw	r30, r24
    4f68:	86 89       	ldd	r24, Z+22	; 0x16
    4f6a:	82 17       	cp	r24, r18
    4f6c:	30 f4       	brcc	.+12     	; 0x4f7a <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4f6e:	81 e0       	ldi	r24, 0x01	; 1
    4f70:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4f72:	81 e0       	ldi	r24, 0x01	; 1
    4f74:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
    4f78:	01 c0       	rjmp	.+2      	; 0x4f7c <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    4f7a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4f7c:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f7e:	0f 90       	pop	r0
    4f80:	0f 90       	pop	r0
    4f82:	0f 90       	pop	r0
    4f84:	0f 90       	pop	r0
    4f86:	0f 90       	pop	r0
    4f88:	df 91       	pop	r29
    4f8a:	cf 91       	pop	r28
    4f8c:	08 95       	ret

00004f8e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4f8e:	cf 93       	push	r28
    4f90:	df 93       	push	r29
    4f92:	00 d0       	rcall	.+0      	; 0x4f94 <vTaskRemoveFromUnorderedEventList+0x6>
    4f94:	00 d0       	rcall	.+0      	; 0x4f96 <vTaskRemoveFromUnorderedEventList+0x8>
    4f96:	00 d0       	rcall	.+0      	; 0x4f98 <vTaskRemoveFromUnorderedEventList+0xa>
    4f98:	cd b7       	in	r28, 0x3d	; 61
    4f9a:	de b7       	in	r29, 0x3e	; 62
    4f9c:	9c 83       	std	Y+4, r25	; 0x04
    4f9e:	8b 83       	std	Y+3, r24	; 0x03
    4fa0:	7e 83       	std	Y+6, r23	; 0x06
    4fa2:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4fa4:	8d 81       	ldd	r24, Y+5	; 0x05
    4fa6:	9e 81       	ldd	r25, Y+6	; 0x06
    4fa8:	9c 01       	movw	r18, r24
    4faa:	30 68       	ori	r19, 0x80	; 128
    4fac:	8b 81       	ldd	r24, Y+3	; 0x03
    4fae:	9c 81       	ldd	r25, Y+4	; 0x04
    4fb0:	fc 01       	movw	r30, r24
    4fb2:	31 83       	std	Z+1, r19	; 0x01
    4fb4:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    4fb8:	9c 81       	ldd	r25, Y+4	; 0x04
    4fba:	fc 01       	movw	r30, r24
    4fbc:	86 81       	ldd	r24, Z+6	; 0x06
    4fbe:	97 81       	ldd	r25, Z+7	; 0x07
    4fc0:	9a 83       	std	Y+2, r25	; 0x02
    4fc2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4fc4:	8b 81       	ldd	r24, Y+3	; 0x03
    4fc6:	9c 81       	ldd	r25, Y+4	; 0x04
    4fc8:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4fcc:	89 81       	ldd	r24, Y+1	; 0x01
    4fce:	9a 81       	ldd	r25, Y+2	; 0x02
    4fd0:	02 96       	adiw	r24, 0x02	; 2
    4fd2:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4fd6:	89 81       	ldd	r24, Y+1	; 0x01
    4fd8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fda:	fc 01       	movw	r30, r24
    4fdc:	96 89       	ldd	r25, Z+22	; 0x16
    4fde:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4fe2:	89 17       	cp	r24, r25
    4fe4:	30 f4       	brcc	.+12     	; 0x4ff2 <vTaskRemoveFromUnorderedEventList+0x64>
    4fe6:	89 81       	ldd	r24, Y+1	; 0x01
    4fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fea:	fc 01       	movw	r30, r24
    4fec:	86 89       	ldd	r24, Z+22	; 0x16
    4fee:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    4ff2:	89 81       	ldd	r24, Y+1	; 0x01
    4ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ff6:	ac 01       	movw	r20, r24
    4ff8:	4e 5f       	subi	r20, 0xFE	; 254
    4ffa:	5f 4f       	sbci	r21, 0xFF	; 255
    4ffc:	89 81       	ldd	r24, Y+1	; 0x01
    4ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    5000:	fc 01       	movw	r30, r24
    5002:	86 89       	ldd	r24, Z+22	; 0x16
    5004:	28 2f       	mov	r18, r24
    5006:	30 e0       	ldi	r19, 0x00	; 0
    5008:	c9 01       	movw	r24, r18
    500a:	88 0f       	add	r24, r24
    500c:	99 1f       	adc	r25, r25
    500e:	88 0f       	add	r24, r24
    5010:	99 1f       	adc	r25, r25
    5012:	88 0f       	add	r24, r24
    5014:	99 1f       	adc	r25, r25
    5016:	82 0f       	add	r24, r18
    5018:	93 1f       	adc	r25, r19
    501a:	8f 55       	subi	r24, 0x5F	; 95
    501c:	99 4f       	sbci	r25, 0xF9	; 249
    501e:	ba 01       	movw	r22, r20
    5020:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5024:	89 81       	ldd	r24, Y+1	; 0x01
    5026:	9a 81       	ldd	r25, Y+2	; 0x02
    5028:	fc 01       	movw	r30, r24
    502a:	26 89       	ldd	r18, Z+22	; 0x16
    502c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5030:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5034:	fc 01       	movw	r30, r24
    5036:	86 89       	ldd	r24, Z+22	; 0x16
    5038:	82 17       	cp	r24, r18
    503a:	18 f4       	brcc	.+6      	; 0x5042 <vTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    503c:	81 e0       	ldi	r24, 0x01	; 1
    503e:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
	}
}
    5042:	00 00       	nop
    5044:	26 96       	adiw	r28, 0x06	; 6
    5046:	0f b6       	in	r0, 0x3f	; 63
    5048:	f8 94       	cli
    504a:	de bf       	out	0x3e, r29	; 62
    504c:	0f be       	out	0x3f, r0	; 63
    504e:	cd bf       	out	0x3d, r28	; 61
    5050:	df 91       	pop	r29
    5052:	cf 91       	pop	r28
    5054:	08 95       	ret

00005056 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5056:	cf 93       	push	r28
    5058:	df 93       	push	r29
    505a:	00 d0       	rcall	.+0      	; 0x505c <vTaskSetTimeOutState+0x6>
    505c:	cd b7       	in	r28, 0x3d	; 61
    505e:	de b7       	in	r29, 0x3e	; 62
    5060:	9a 83       	std	Y+2, r25	; 0x02
    5062:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5064:	0f b6       	in	r0, 0x3f	; 63
    5066:	f8 94       	cli
    5068:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    506a:	20 91 07 07 	lds	r18, 0x0707	; 0x800707 <xNumOfOverflows>
    506e:	89 81       	ldd	r24, Y+1	; 0x01
    5070:	9a 81       	ldd	r25, Y+2	; 0x02
    5072:	fc 01       	movw	r30, r24
    5074:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    5076:	20 91 01 07 	lds	r18, 0x0701	; 0x800701 <xTickCount>
    507a:	30 91 02 07 	lds	r19, 0x0702	; 0x800702 <xTickCount+0x1>
    507e:	89 81       	ldd	r24, Y+1	; 0x01
    5080:	9a 81       	ldd	r25, Y+2	; 0x02
    5082:	fc 01       	movw	r30, r24
    5084:	32 83       	std	Z+2, r19	; 0x02
    5086:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    5088:	0f 90       	pop	r0
    508a:	0f be       	out	0x3f, r0	; 63
}
    508c:	00 00       	nop
    508e:	0f 90       	pop	r0
    5090:	0f 90       	pop	r0
    5092:	df 91       	pop	r29
    5094:	cf 91       	pop	r28
    5096:	08 95       	ret

00005098 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5098:	cf 93       	push	r28
    509a:	df 93       	push	r29
    509c:	00 d0       	rcall	.+0      	; 0x509e <vTaskInternalSetTimeOutState+0x6>
    509e:	cd b7       	in	r28, 0x3d	; 61
    50a0:	de b7       	in	r29, 0x3e	; 62
    50a2:	9a 83       	std	Y+2, r25	; 0x02
    50a4:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    50a6:	20 91 07 07 	lds	r18, 0x0707	; 0x800707 <xNumOfOverflows>
    50aa:	89 81       	ldd	r24, Y+1	; 0x01
    50ac:	9a 81       	ldd	r25, Y+2	; 0x02
    50ae:	fc 01       	movw	r30, r24
    50b0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    50b2:	20 91 01 07 	lds	r18, 0x0701	; 0x800701 <xTickCount>
    50b6:	30 91 02 07 	lds	r19, 0x0702	; 0x800702 <xTickCount+0x1>
    50ba:	89 81       	ldd	r24, Y+1	; 0x01
    50bc:	9a 81       	ldd	r25, Y+2	; 0x02
    50be:	fc 01       	movw	r30, r24
    50c0:	32 83       	std	Z+2, r19	; 0x02
    50c2:	21 83       	std	Z+1, r18	; 0x01
}
    50c4:	00 00       	nop
    50c6:	0f 90       	pop	r0
    50c8:	0f 90       	pop	r0
    50ca:	df 91       	pop	r29
    50cc:	cf 91       	pop	r28
    50ce:	08 95       	ret

000050d0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    50d0:	cf 93       	push	r28
    50d2:	df 93       	push	r29
    50d4:	cd b7       	in	r28, 0x3d	; 61
    50d6:	de b7       	in	r29, 0x3e	; 62
    50d8:	29 97       	sbiw	r28, 0x09	; 9
    50da:	0f b6       	in	r0, 0x3f	; 63
    50dc:	f8 94       	cli
    50de:	de bf       	out	0x3e, r29	; 62
    50e0:	0f be       	out	0x3f, r0	; 63
    50e2:	cd bf       	out	0x3d, r28	; 61
    50e4:	9f 83       	std	Y+7, r25	; 0x07
    50e6:	8e 83       	std	Y+6, r24	; 0x06
    50e8:	79 87       	std	Y+9, r23	; 0x09
    50ea:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    50ec:	0f b6       	in	r0, 0x3f	; 63
    50ee:	f8 94       	cli
    50f0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    50f2:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    50f6:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    50fa:	9b 83       	std	Y+3, r25	; 0x03
    50fc:	8a 83       	std	Y+2, r24	; 0x02
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    50fe:	8e 81       	ldd	r24, Y+6	; 0x06
    5100:	9f 81       	ldd	r25, Y+7	; 0x07
    5102:	fc 01       	movw	r30, r24
    5104:	81 81       	ldd	r24, Z+1	; 0x01
    5106:	92 81       	ldd	r25, Z+2	; 0x02
    5108:	2a 81       	ldd	r18, Y+2	; 0x02
    510a:	3b 81       	ldd	r19, Y+3	; 0x03
    510c:	a9 01       	movw	r20, r18
    510e:	48 1b       	sub	r20, r24
    5110:	59 0b       	sbc	r21, r25
    5112:	ca 01       	movw	r24, r20
    5114:	9d 83       	std	Y+5, r25	; 0x05
    5116:	8c 83       	std	Y+4, r24	; 0x04
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5118:	88 85       	ldd	r24, Y+8	; 0x08
    511a:	99 85       	ldd	r25, Y+9	; 0x09
    511c:	fc 01       	movw	r30, r24
    511e:	80 81       	ld	r24, Z
    5120:	91 81       	ldd	r25, Z+1	; 0x01
    5122:	01 96       	adiw	r24, 0x01	; 1
    5124:	11 f4       	brne	.+4      	; 0x512a <xTaskCheckForTimeOut+0x5a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5126:	19 82       	std	Y+1, r1	; 0x01
    5128:	3a c0       	rjmp	.+116    	; 0x519e <xTaskCheckForTimeOut+0xce>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    512a:	8e 81       	ldd	r24, Y+6	; 0x06
    512c:	9f 81       	ldd	r25, Y+7	; 0x07
    512e:	fc 01       	movw	r30, r24
    5130:	90 81       	ld	r25, Z
    5132:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xNumOfOverflows>
    5136:	98 17       	cp	r25, r24
    5138:	69 f0       	breq	.+26     	; 0x5154 <xTaskCheckForTimeOut+0x84>
    513a:	8e 81       	ldd	r24, Y+6	; 0x06
    513c:	9f 81       	ldd	r25, Y+7	; 0x07
    513e:	fc 01       	movw	r30, r24
    5140:	21 81       	ldd	r18, Z+1	; 0x01
    5142:	32 81       	ldd	r19, Z+2	; 0x02
    5144:	8a 81       	ldd	r24, Y+2	; 0x02
    5146:	9b 81       	ldd	r25, Y+3	; 0x03
    5148:	82 17       	cp	r24, r18
    514a:	93 07       	cpc	r25, r19
    514c:	18 f0       	brcs	.+6      	; 0x5154 <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    514e:	81 e0       	ldi	r24, 0x01	; 1
    5150:	89 83       	std	Y+1, r24	; 0x01
    5152:	25 c0       	rjmp	.+74     	; 0x519e <xTaskCheckForTimeOut+0xce>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5154:	88 85       	ldd	r24, Y+8	; 0x08
    5156:	99 85       	ldd	r25, Y+9	; 0x09
    5158:	fc 01       	movw	r30, r24
    515a:	20 81       	ld	r18, Z
    515c:	31 81       	ldd	r19, Z+1	; 0x01
    515e:	8c 81       	ldd	r24, Y+4	; 0x04
    5160:	9d 81       	ldd	r25, Y+5	; 0x05
    5162:	82 17       	cp	r24, r18
    5164:	93 07       	cpc	r25, r19
    5166:	a0 f4       	brcc	.+40     	; 0x5190 <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    5168:	88 85       	ldd	r24, Y+8	; 0x08
    516a:	99 85       	ldd	r25, Y+9	; 0x09
    516c:	fc 01       	movw	r30, r24
    516e:	20 81       	ld	r18, Z
    5170:	31 81       	ldd	r19, Z+1	; 0x01
    5172:	8c 81       	ldd	r24, Y+4	; 0x04
    5174:	9d 81       	ldd	r25, Y+5	; 0x05
    5176:	28 1b       	sub	r18, r24
    5178:	39 0b       	sbc	r19, r25
    517a:	88 85       	ldd	r24, Y+8	; 0x08
    517c:	99 85       	ldd	r25, Y+9	; 0x09
    517e:	fc 01       	movw	r30, r24
    5180:	31 83       	std	Z+1, r19	; 0x01
    5182:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    5184:	8e 81       	ldd	r24, Y+6	; 0x06
    5186:	9f 81       	ldd	r25, Y+7	; 0x07
    5188:	0e 94 4c 28 	call	0x5098	; 0x5098 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    518c:	19 82       	std	Y+1, r1	; 0x01
    518e:	07 c0       	rjmp	.+14     	; 0x519e <xTaskCheckForTimeOut+0xce>
		}
		else
		{
			*pxTicksToWait = 0;
    5190:	88 85       	ldd	r24, Y+8	; 0x08
    5192:	99 85       	ldd	r25, Y+9	; 0x09
    5194:	fc 01       	movw	r30, r24
    5196:	11 82       	std	Z+1, r1	; 0x01
    5198:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    519a:	81 e0       	ldi	r24, 0x01	; 1
    519c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    519e:	0f 90       	pop	r0
    51a0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    51a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    51a4:	29 96       	adiw	r28, 0x09	; 9
    51a6:	0f b6       	in	r0, 0x3f	; 63
    51a8:	f8 94       	cli
    51aa:	de bf       	out	0x3e, r29	; 62
    51ac:	0f be       	out	0x3f, r0	; 63
    51ae:	cd bf       	out	0x3d, r28	; 61
    51b0:	df 91       	pop	r29
    51b2:	cf 91       	pop	r28
    51b4:	08 95       	ret

000051b6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    51b6:	cf 93       	push	r28
    51b8:	df 93       	push	r29
    51ba:	cd b7       	in	r28, 0x3d	; 61
    51bc:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    51be:	81 e0       	ldi	r24, 0x01	; 1
    51c0:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
}
    51c4:	00 00       	nop
    51c6:	df 91       	pop	r29
    51c8:	cf 91       	pop	r28
    51ca:	08 95       	ret

000051cc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    51cc:	cf 93       	push	r28
    51ce:	df 93       	push	r29
    51d0:	00 d0       	rcall	.+0      	; 0x51d2 <prvIdleTask+0x6>
    51d2:	cd b7       	in	r28, 0x3d	; 61
    51d4:	de b7       	in	r29, 0x3e	; 62
    51d6:	9a 83       	std	Y+2, r25	; 0x02
    51d8:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    51da:	0e 94 38 29 	call	0x5270	; 0x5270 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    51de:	80 91 a1 06 	lds	r24, 0x06A1	; 0x8006a1 <pxReadyTasksLists>
    51e2:	82 30       	cpi	r24, 0x02	; 2
    51e4:	d0 f3       	brcs	.-12     	; 0x51da <prvIdleTask+0xe>
			{
				taskYIELD();
    51e6:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    51ea:	f7 cf       	rjmp	.-18     	; 0x51da <prvIdleTask+0xe>

000051ec <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    51ec:	cf 93       	push	r28
    51ee:	df 93       	push	r29
    51f0:	1f 92       	push	r1
    51f2:	cd b7       	in	r28, 0x3d	; 61
    51f4:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    51f6:	19 82       	std	Y+1, r1	; 0x01
    51f8:	13 c0       	rjmp	.+38     	; 0x5220 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    51fa:	89 81       	ldd	r24, Y+1	; 0x01
    51fc:	28 2f       	mov	r18, r24
    51fe:	30 e0       	ldi	r19, 0x00	; 0
    5200:	c9 01       	movw	r24, r18
    5202:	88 0f       	add	r24, r24
    5204:	99 1f       	adc	r25, r25
    5206:	88 0f       	add	r24, r24
    5208:	99 1f       	adc	r25, r25
    520a:	88 0f       	add	r24, r24
    520c:	99 1f       	adc	r25, r25
    520e:	82 0f       	add	r24, r18
    5210:	93 1f       	adc	r25, r19
    5212:	8f 55       	subi	r24, 0x5F	; 95
    5214:	99 4f       	sbci	r25, 0xF9	; 249
    5216:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    521a:	89 81       	ldd	r24, Y+1	; 0x01
    521c:	8f 5f       	subi	r24, 0xFF	; 255
    521e:	89 83       	std	Y+1, r24	; 0x01
    5220:	89 81       	ldd	r24, Y+1	; 0x01
    5222:	85 30       	cpi	r24, 0x05	; 5
    5224:	50 f3       	brcs	.-44     	; 0x51fa <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5226:	8e ec       	ldi	r24, 0xCE	; 206
    5228:	96 e0       	ldi	r25, 0x06	; 6
    522a:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    522e:	87 ed       	ldi	r24, 0xD7	; 215
    5230:	96 e0       	ldi	r25, 0x06	; 6
    5232:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5236:	84 ee       	ldi	r24, 0xE4	; 228
    5238:	96 e0       	ldi	r25, 0x06	; 6
    523a:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    523e:	8d ee       	ldi	r24, 0xED	; 237
    5240:	96 e0       	ldi	r25, 0x06	; 6
    5242:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5246:	87 ef       	ldi	r24, 0xF7	; 247
    5248:	96 e0       	ldi	r25, 0x06	; 6
    524a:	0e 94 18 13 	call	0x2630	; 0x2630 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    524e:	8e ec       	ldi	r24, 0xCE	; 206
    5250:	96 e0       	ldi	r25, 0x06	; 6
    5252:	90 93 e1 06 	sts	0x06E1, r25	; 0x8006e1 <pxDelayedTaskList+0x1>
    5256:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    525a:	87 ed       	ldi	r24, 0xD7	; 215
    525c:	96 e0       	ldi	r25, 0x06	; 6
    525e:	90 93 e3 06 	sts	0x06E3, r25	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    5262:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <pxOverflowDelayedTaskList>
}
    5266:	00 00       	nop
    5268:	0f 90       	pop	r0
    526a:	df 91       	pop	r29
    526c:	cf 91       	pop	r28
    526e:	08 95       	ret

00005270 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5270:	cf 93       	push	r28
    5272:	df 93       	push	r29
    5274:	00 d0       	rcall	.+0      	; 0x5276 <prvCheckTasksWaitingTermination+0x6>
    5276:	cd b7       	in	r28, 0x3d	; 61
    5278:	de b7       	in	r29, 0x3e	; 62
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    527a:	21 c0       	rjmp	.+66     	; 0x52be <prvCheckTasksWaitingTermination+0x4e>
		{
			taskENTER_CRITICAL();
    527c:	0f b6       	in	r0, 0x3f	; 63
    527e:	f8 94       	cli
    5280:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5282:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xTasksWaitingTermination+0x5>
    5286:	90 91 f3 06 	lds	r25, 0x06F3	; 0x8006f3 <xTasksWaitingTermination+0x6>
    528a:	fc 01       	movw	r30, r24
    528c:	86 81       	ldd	r24, Z+6	; 0x06
    528e:	97 81       	ldd	r25, Z+7	; 0x07
    5290:	9a 83       	std	Y+2, r25	; 0x02
    5292:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5294:	89 81       	ldd	r24, Y+1	; 0x01
    5296:	9a 81       	ldd	r25, Y+2	; 0x02
    5298:	02 96       	adiw	r24, 0x02	; 2
    529a:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
				--uxCurrentNumberOfTasks;
    529e:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    52a2:	81 50       	subi	r24, 0x01	; 1
    52a4:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
    52a8:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    52ac:	81 50       	subi	r24, 0x01	; 1
    52ae:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
    52b2:	0f 90       	pop	r0
    52b4:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    52b6:	89 81       	ldd	r24, Y+1	; 0x01
    52b8:	9a 81       	ldd	r25, Y+2	; 0x02
    52ba:	0e 94 69 29 	call	0x52d2	; 0x52d2 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    52be:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    52c2:	88 23       	and	r24, r24
    52c4:	d9 f6       	brne	.-74     	; 0x527c <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    52c6:	00 00       	nop
    52c8:	0f 90       	pop	r0
    52ca:	0f 90       	pop	r0
    52cc:	df 91       	pop	r29
    52ce:	cf 91       	pop	r28
    52d0:	08 95       	ret

000052d2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    52d2:	cf 93       	push	r28
    52d4:	df 93       	push	r29
    52d6:	00 d0       	rcall	.+0      	; 0x52d8 <prvDeleteTCB+0x6>
    52d8:	cd b7       	in	r28, 0x3d	; 61
    52da:	de b7       	in	r29, 0x3e	; 62
    52dc:	9a 83       	std	Y+2, r25	; 0x02
    52de:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    52e0:	89 81       	ldd	r24, Y+1	; 0x01
    52e2:	9a 81       	ldd	r25, Y+2	; 0x02
    52e4:	fc 01       	movw	r30, r24
    52e6:	87 89       	ldd	r24, Z+23	; 0x17
    52e8:	90 8d       	ldd	r25, Z+24	; 0x18
    52ea:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vPortFree>
			vPortFree( pxTCB );
    52ee:	89 81       	ldd	r24, Y+1	; 0x01
    52f0:	9a 81       	ldd	r25, Y+2	; 0x02
    52f2:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    52f6:	00 00       	nop
    52f8:	0f 90       	pop	r0
    52fa:	0f 90       	pop	r0
    52fc:	df 91       	pop	r29
    52fe:	cf 91       	pop	r28
    5300:	08 95       	ret

00005302 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5302:	cf 93       	push	r28
    5304:	df 93       	push	r29
    5306:	00 d0       	rcall	.+0      	; 0x5308 <prvResetNextTaskUnblockTime+0x6>
    5308:	cd b7       	in	r28, 0x3d	; 61
    530a:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    530c:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    5310:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    5314:	fc 01       	movw	r30, r24
    5316:	80 81       	ld	r24, Z
    5318:	88 23       	and	r24, r24
    531a:	39 f4       	brne	.+14     	; 0x532a <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    531c:	8f ef       	ldi	r24, 0xFF	; 255
    531e:	9f ef       	ldi	r25, 0xFF	; 255
    5320:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    5324:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
    5328:	15 c0       	rjmp	.+42     	; 0x5354 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    532a:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    532e:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    5332:	fc 01       	movw	r30, r24
    5334:	85 81       	ldd	r24, Z+5	; 0x05
    5336:	96 81       	ldd	r25, Z+6	; 0x06
    5338:	fc 01       	movw	r30, r24
    533a:	86 81       	ldd	r24, Z+6	; 0x06
    533c:	97 81       	ldd	r25, Z+7	; 0x07
    533e:	9a 83       	std	Y+2, r25	; 0x02
    5340:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5342:	89 81       	ldd	r24, Y+1	; 0x01
    5344:	9a 81       	ldd	r25, Y+2	; 0x02
    5346:	fc 01       	movw	r30, r24
    5348:	82 81       	ldd	r24, Z+2	; 0x02
    534a:	93 81       	ldd	r25, Z+3	; 0x03
    534c:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    5350:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
	}
}
    5354:	00 00       	nop
    5356:	0f 90       	pop	r0
    5358:	0f 90       	pop	r0
    535a:	df 91       	pop	r29
    535c:	cf 91       	pop	r28
    535e:	08 95       	ret

00005360 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5360:	cf 93       	push	r28
    5362:	df 93       	push	r29
    5364:	00 d0       	rcall	.+0      	; 0x5366 <xTaskGetCurrentTaskHandle+0x6>
    5366:	cd b7       	in	r28, 0x3d	; 61
    5368:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    536a:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    536e:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5372:	9a 83       	std	Y+2, r25	; 0x02
    5374:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5376:	89 81       	ldd	r24, Y+1	; 0x01
    5378:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    537a:	0f 90       	pop	r0
    537c:	0f 90       	pop	r0
    537e:	df 91       	pop	r29
    5380:	cf 91       	pop	r28
    5382:	08 95       	ret

00005384 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    5384:	cf 93       	push	r28
    5386:	df 93       	push	r29
    5388:	00 d0       	rcall	.+0      	; 0x538a <xTaskPriorityInherit+0x6>
    538a:	00 d0       	rcall	.+0      	; 0x538c <xTaskPriorityInherit+0x8>
    538c:	1f 92       	push	r1
    538e:	cd b7       	in	r28, 0x3d	; 61
    5390:	de b7       	in	r29, 0x3e	; 62
    5392:	9d 83       	std	Y+5, r25	; 0x05
    5394:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    5396:	8c 81       	ldd	r24, Y+4	; 0x04
    5398:	9d 81       	ldd	r25, Y+5	; 0x05
    539a:	9b 83       	std	Y+3, r25	; 0x03
    539c:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    539e:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    53a0:	8c 81       	ldd	r24, Y+4	; 0x04
    53a2:	9d 81       	ldd	r25, Y+5	; 0x05
    53a4:	89 2b       	or	r24, r25
    53a6:	09 f4       	brne	.+2      	; 0x53aa <xTaskPriorityInherit+0x26>
    53a8:	90 c0       	rjmp	.+288    	; 0x54ca <xTaskPriorityInherit+0x146>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    53aa:	8a 81       	ldd	r24, Y+2	; 0x02
    53ac:	9b 81       	ldd	r25, Y+3	; 0x03
    53ae:	fc 01       	movw	r30, r24
    53b0:	26 89       	ldd	r18, Z+22	; 0x16
    53b2:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    53b6:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    53ba:	fc 01       	movw	r30, r24
    53bc:	86 89       	ldd	r24, Z+22	; 0x16
    53be:	28 17       	cp	r18, r24
    53c0:	08 f0       	brcs	.+2      	; 0x53c4 <xTaskPriorityInherit+0x40>
    53c2:	75 c0       	rjmp	.+234    	; 0x54ae <xTaskPriorityInherit+0x12a>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    53c4:	8a 81       	ldd	r24, Y+2	; 0x02
    53c6:	9b 81       	ldd	r25, Y+3	; 0x03
    53c8:	fc 01       	movw	r30, r24
    53ca:	84 85       	ldd	r24, Z+12	; 0x0c
    53cc:	95 85       	ldd	r25, Z+13	; 0x0d
    53ce:	99 23       	and	r25, r25
    53d0:	8c f0       	brlt	.+34     	; 0x53f4 <xTaskPriorityInherit+0x70>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    53d2:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    53d6:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    53da:	fc 01       	movw	r30, r24
    53dc:	86 89       	ldd	r24, Z+22	; 0x16
    53de:	88 2f       	mov	r24, r24
    53e0:	90 e0       	ldi	r25, 0x00	; 0
    53e2:	25 e0       	ldi	r18, 0x05	; 5
    53e4:	30 e0       	ldi	r19, 0x00	; 0
    53e6:	28 1b       	sub	r18, r24
    53e8:	39 0b       	sbc	r19, r25
    53ea:	8a 81       	ldd	r24, Y+2	; 0x02
    53ec:	9b 81       	ldd	r25, Y+3	; 0x03
    53ee:	fc 01       	movw	r30, r24
    53f0:	35 87       	std	Z+13, r19	; 0x0d
    53f2:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    53f4:	8a 81       	ldd	r24, Y+2	; 0x02
    53f6:	9b 81       	ldd	r25, Y+3	; 0x03
    53f8:	fc 01       	movw	r30, r24
    53fa:	42 85       	ldd	r20, Z+10	; 0x0a
    53fc:	53 85       	ldd	r21, Z+11	; 0x0b
    53fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5400:	9b 81       	ldd	r25, Y+3	; 0x03
    5402:	fc 01       	movw	r30, r24
    5404:	86 89       	ldd	r24, Z+22	; 0x16
    5406:	28 2f       	mov	r18, r24
    5408:	30 e0       	ldi	r19, 0x00	; 0
    540a:	c9 01       	movw	r24, r18
    540c:	88 0f       	add	r24, r24
    540e:	99 1f       	adc	r25, r25
    5410:	88 0f       	add	r24, r24
    5412:	99 1f       	adc	r25, r25
    5414:	88 0f       	add	r24, r24
    5416:	99 1f       	adc	r25, r25
    5418:	82 0f       	add	r24, r18
    541a:	93 1f       	adc	r25, r19
    541c:	8f 55       	subi	r24, 0x5F	; 95
    541e:	99 4f       	sbci	r25, 0xF9	; 249
    5420:	48 17       	cp	r20, r24
    5422:	59 07       	cpc	r21, r25
    5424:	b9 f5       	brne	.+110    	; 0x5494 <xTaskPriorityInherit+0x110>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5426:	8a 81       	ldd	r24, Y+2	; 0x02
    5428:	9b 81       	ldd	r25, Y+3	; 0x03
    542a:	02 96       	adiw	r24, 0x02	; 2
    542c:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    5430:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5434:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5438:	fc 01       	movw	r30, r24
    543a:	26 89       	ldd	r18, Z+22	; 0x16
    543c:	8a 81       	ldd	r24, Y+2	; 0x02
    543e:	9b 81       	ldd	r25, Y+3	; 0x03
    5440:	fc 01       	movw	r30, r24
    5442:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    5444:	8a 81       	ldd	r24, Y+2	; 0x02
    5446:	9b 81       	ldd	r25, Y+3	; 0x03
    5448:	fc 01       	movw	r30, r24
    544a:	96 89       	ldd	r25, Z+22	; 0x16
    544c:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5450:	89 17       	cp	r24, r25
    5452:	30 f4       	brcc	.+12     	; 0x5460 <xTaskPriorityInherit+0xdc>
    5454:	8a 81       	ldd	r24, Y+2	; 0x02
    5456:	9b 81       	ldd	r25, Y+3	; 0x03
    5458:	fc 01       	movw	r30, r24
    545a:	86 89       	ldd	r24, Z+22	; 0x16
    545c:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5460:	8a 81       	ldd	r24, Y+2	; 0x02
    5462:	9b 81       	ldd	r25, Y+3	; 0x03
    5464:	ac 01       	movw	r20, r24
    5466:	4e 5f       	subi	r20, 0xFE	; 254
    5468:	5f 4f       	sbci	r21, 0xFF	; 255
    546a:	8a 81       	ldd	r24, Y+2	; 0x02
    546c:	9b 81       	ldd	r25, Y+3	; 0x03
    546e:	fc 01       	movw	r30, r24
    5470:	86 89       	ldd	r24, Z+22	; 0x16
    5472:	28 2f       	mov	r18, r24
    5474:	30 e0       	ldi	r19, 0x00	; 0
    5476:	c9 01       	movw	r24, r18
    5478:	88 0f       	add	r24, r24
    547a:	99 1f       	adc	r25, r25
    547c:	88 0f       	add	r24, r24
    547e:	99 1f       	adc	r25, r25
    5480:	88 0f       	add	r24, r24
    5482:	99 1f       	adc	r25, r25
    5484:	82 0f       	add	r24, r18
    5486:	93 1f       	adc	r25, r19
    5488:	8f 55       	subi	r24, 0x5F	; 95
    548a:	99 4f       	sbci	r25, 0xF9	; 249
    548c:	ba 01       	movw	r22, r20
    548e:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
    5492:	0a c0       	rjmp	.+20     	; 0x54a8 <xTaskPriorityInherit+0x124>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    5494:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5498:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    549c:	fc 01       	movw	r30, r24
    549e:	26 89       	ldd	r18, Z+22	; 0x16
    54a0:	8a 81       	ldd	r24, Y+2	; 0x02
    54a2:	9b 81       	ldd	r25, Y+3	; 0x03
    54a4:	fc 01       	movw	r30, r24
    54a6:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    54a8:	81 e0       	ldi	r24, 0x01	; 1
    54aa:	89 83       	std	Y+1, r24	; 0x01
    54ac:	0e c0       	rjmp	.+28     	; 0x54ca <xTaskPriorityInherit+0x146>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    54ae:	8a 81       	ldd	r24, Y+2	; 0x02
    54b0:	9b 81       	ldd	r25, Y+3	; 0x03
    54b2:	fc 01       	movw	r30, r24
    54b4:	21 a1       	ldd	r18, Z+33	; 0x21
    54b6:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    54ba:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    54be:	fc 01       	movw	r30, r24
    54c0:	86 89       	ldd	r24, Z+22	; 0x16
    54c2:	28 17       	cp	r18, r24
    54c4:	10 f4       	brcc	.+4      	; 0x54ca <xTaskPriorityInherit+0x146>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    54c6:	81 e0       	ldi	r24, 0x01	; 1
    54c8:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    54ca:	89 81       	ldd	r24, Y+1	; 0x01
	}
    54cc:	0f 90       	pop	r0
    54ce:	0f 90       	pop	r0
    54d0:	0f 90       	pop	r0
    54d2:	0f 90       	pop	r0
    54d4:	0f 90       	pop	r0
    54d6:	df 91       	pop	r29
    54d8:	cf 91       	pop	r28
    54da:	08 95       	ret

000054dc <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    54dc:	cf 93       	push	r28
    54de:	df 93       	push	r29
    54e0:	00 d0       	rcall	.+0      	; 0x54e2 <xTaskPriorityDisinherit+0x6>
    54e2:	00 d0       	rcall	.+0      	; 0x54e4 <xTaskPriorityDisinherit+0x8>
    54e4:	1f 92       	push	r1
    54e6:	cd b7       	in	r28, 0x3d	; 61
    54e8:	de b7       	in	r29, 0x3e	; 62
    54ea:	9d 83       	std	Y+5, r25	; 0x05
    54ec:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    54ee:	8c 81       	ldd	r24, Y+4	; 0x04
    54f0:	9d 81       	ldd	r25, Y+5	; 0x05
    54f2:	9b 83       	std	Y+3, r25	; 0x03
    54f4:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    54f6:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    54f8:	8c 81       	ldd	r24, Y+4	; 0x04
    54fa:	9d 81       	ldd	r25, Y+5	; 0x05
    54fc:	89 2b       	or	r24, r25
    54fe:	09 f4       	brne	.+2      	; 0x5502 <xTaskPriorityDisinherit+0x26>
    5500:	61 c0       	rjmp	.+194    	; 0x55c4 <xTaskPriorityDisinherit+0xe8>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    5502:	8a 81       	ldd	r24, Y+2	; 0x02
    5504:	9b 81       	ldd	r25, Y+3	; 0x03
    5506:	fc 01       	movw	r30, r24
    5508:	82 a1       	ldd	r24, Z+34	; 0x22
    550a:	2f ef       	ldi	r18, 0xFF	; 255
    550c:	28 0f       	add	r18, r24
    550e:	8a 81       	ldd	r24, Y+2	; 0x02
    5510:	9b 81       	ldd	r25, Y+3	; 0x03
    5512:	fc 01       	movw	r30, r24
    5514:	22 a3       	std	Z+34, r18	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    5516:	8a 81       	ldd	r24, Y+2	; 0x02
    5518:	9b 81       	ldd	r25, Y+3	; 0x03
    551a:	fc 01       	movw	r30, r24
    551c:	26 89       	ldd	r18, Z+22	; 0x16
    551e:	8a 81       	ldd	r24, Y+2	; 0x02
    5520:	9b 81       	ldd	r25, Y+3	; 0x03
    5522:	fc 01       	movw	r30, r24
    5524:	81 a1       	ldd	r24, Z+33	; 0x21
    5526:	28 17       	cp	r18, r24
    5528:	09 f4       	brne	.+2      	; 0x552c <xTaskPriorityDisinherit+0x50>
    552a:	4c c0       	rjmp	.+152    	; 0x55c4 <xTaskPriorityDisinherit+0xe8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    552c:	8a 81       	ldd	r24, Y+2	; 0x02
    552e:	9b 81       	ldd	r25, Y+3	; 0x03
    5530:	fc 01       	movw	r30, r24
    5532:	82 a1       	ldd	r24, Z+34	; 0x22
    5534:	88 23       	and	r24, r24
    5536:	09 f0       	breq	.+2      	; 0x553a <xTaskPriorityDisinherit+0x5e>
    5538:	45 c0       	rjmp	.+138    	; 0x55c4 <xTaskPriorityDisinherit+0xe8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    553a:	8a 81       	ldd	r24, Y+2	; 0x02
    553c:	9b 81       	ldd	r25, Y+3	; 0x03
    553e:	02 96       	adiw	r24, 0x02	; 2
    5540:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    5544:	8a 81       	ldd	r24, Y+2	; 0x02
    5546:	9b 81       	ldd	r25, Y+3	; 0x03
    5548:	fc 01       	movw	r30, r24
    554a:	21 a1       	ldd	r18, Z+33	; 0x21
    554c:	8a 81       	ldd	r24, Y+2	; 0x02
    554e:	9b 81       	ldd	r25, Y+3	; 0x03
    5550:	fc 01       	movw	r30, r24
    5552:	26 8b       	std	Z+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5554:	8a 81       	ldd	r24, Y+2	; 0x02
    5556:	9b 81       	ldd	r25, Y+3	; 0x03
    5558:	fc 01       	movw	r30, r24
    555a:	86 89       	ldd	r24, Z+22	; 0x16
    555c:	88 2f       	mov	r24, r24
    555e:	90 e0       	ldi	r25, 0x00	; 0
    5560:	25 e0       	ldi	r18, 0x05	; 5
    5562:	30 e0       	ldi	r19, 0x00	; 0
    5564:	28 1b       	sub	r18, r24
    5566:	39 0b       	sbc	r19, r25
    5568:	8a 81       	ldd	r24, Y+2	; 0x02
    556a:	9b 81       	ldd	r25, Y+3	; 0x03
    556c:	fc 01       	movw	r30, r24
    556e:	35 87       	std	Z+13, r19	; 0x0d
    5570:	24 87       	std	Z+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    5572:	8a 81       	ldd	r24, Y+2	; 0x02
    5574:	9b 81       	ldd	r25, Y+3	; 0x03
    5576:	fc 01       	movw	r30, r24
    5578:	96 89       	ldd	r25, Z+22	; 0x16
    557a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    557e:	89 17       	cp	r24, r25
    5580:	30 f4       	brcc	.+12     	; 0x558e <xTaskPriorityDisinherit+0xb2>
    5582:	8a 81       	ldd	r24, Y+2	; 0x02
    5584:	9b 81       	ldd	r25, Y+3	; 0x03
    5586:	fc 01       	movw	r30, r24
    5588:	86 89       	ldd	r24, Z+22	; 0x16
    558a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    558e:	8a 81       	ldd	r24, Y+2	; 0x02
    5590:	9b 81       	ldd	r25, Y+3	; 0x03
    5592:	ac 01       	movw	r20, r24
    5594:	4e 5f       	subi	r20, 0xFE	; 254
    5596:	5f 4f       	sbci	r21, 0xFF	; 255
    5598:	8a 81       	ldd	r24, Y+2	; 0x02
    559a:	9b 81       	ldd	r25, Y+3	; 0x03
    559c:	fc 01       	movw	r30, r24
    559e:	86 89       	ldd	r24, Z+22	; 0x16
    55a0:	28 2f       	mov	r18, r24
    55a2:	30 e0       	ldi	r19, 0x00	; 0
    55a4:	c9 01       	movw	r24, r18
    55a6:	88 0f       	add	r24, r24
    55a8:	99 1f       	adc	r25, r25
    55aa:	88 0f       	add	r24, r24
    55ac:	99 1f       	adc	r25, r25
    55ae:	88 0f       	add	r24, r24
    55b0:	99 1f       	adc	r25, r25
    55b2:	82 0f       	add	r24, r18
    55b4:	93 1f       	adc	r25, r19
    55b6:	8f 55       	subi	r24, 0x5F	; 95
    55b8:	99 4f       	sbci	r25, 0xF9	; 249
    55ba:	ba 01       	movw	r22, r20
    55bc:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    55c0:	81 e0       	ldi	r24, 0x01	; 1
    55c2:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    55c4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    55c6:	0f 90       	pop	r0
    55c8:	0f 90       	pop	r0
    55ca:	0f 90       	pop	r0
    55cc:	0f 90       	pop	r0
    55ce:	0f 90       	pop	r0
    55d0:	df 91       	pop	r29
    55d2:	cf 91       	pop	r28
    55d4:	08 95       	ret

000055d6 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    55d6:	cf 93       	push	r28
    55d8:	df 93       	push	r29
    55da:	cd b7       	in	r28, 0x3d	; 61
    55dc:	de b7       	in	r29, 0x3e	; 62
    55de:	28 97       	sbiw	r28, 0x08	; 8
    55e0:	0f b6       	in	r0, 0x3f	; 63
    55e2:	f8 94       	cli
    55e4:	de bf       	out	0x3e, r29	; 62
    55e6:	0f be       	out	0x3f, r0	; 63
    55e8:	cd bf       	out	0x3d, r28	; 61
    55ea:	9f 83       	std	Y+7, r25	; 0x07
    55ec:	8e 83       	std	Y+6, r24	; 0x06
    55ee:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    55f0:	8e 81       	ldd	r24, Y+6	; 0x06
    55f2:	9f 81       	ldd	r25, Y+7	; 0x07
    55f4:	9b 83       	std	Y+3, r25	; 0x03
    55f6:	8a 83       	std	Y+2, r24	; 0x02
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    55f8:	81 e0       	ldi	r24, 0x01	; 1
    55fa:	8c 83       	std	Y+4, r24	; 0x04

		if( pxMutexHolder != NULL )
    55fc:	8e 81       	ldd	r24, Y+6	; 0x06
    55fe:	9f 81       	ldd	r25, Y+7	; 0x07
    5600:	89 2b       	or	r24, r25
    5602:	09 f4       	brne	.+2      	; 0x5606 <vTaskPriorityDisinheritAfterTimeout+0x30>
    5604:	7e c0       	rjmp	.+252    	; 0x5702 <vTaskPriorityDisinheritAfterTimeout+0x12c>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    5606:	8a 81       	ldd	r24, Y+2	; 0x02
    5608:	9b 81       	ldd	r25, Y+3	; 0x03
    560a:	fc 01       	movw	r30, r24
    560c:	91 a1       	ldd	r25, Z+33	; 0x21
    560e:	88 85       	ldd	r24, Y+8	; 0x08
    5610:	98 17       	cp	r25, r24
    5612:	18 f4       	brcc	.+6      	; 0x561a <vTaskPriorityDisinheritAfterTimeout+0x44>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    5614:	88 85       	ldd	r24, Y+8	; 0x08
    5616:	89 83       	std	Y+1, r24	; 0x01
    5618:	05 c0       	rjmp	.+10     	; 0x5624 <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    561a:	8a 81       	ldd	r24, Y+2	; 0x02
    561c:	9b 81       	ldd	r25, Y+3	; 0x03
    561e:	fc 01       	movw	r30, r24
    5620:	81 a1       	ldd	r24, Z+33	; 0x21
    5622:	89 83       	std	Y+1, r24	; 0x01
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    5624:	8a 81       	ldd	r24, Y+2	; 0x02
    5626:	9b 81       	ldd	r25, Y+3	; 0x03
    5628:	fc 01       	movw	r30, r24
    562a:	96 89       	ldd	r25, Z+22	; 0x16
    562c:	89 81       	ldd	r24, Y+1	; 0x01
    562e:	98 17       	cp	r25, r24
    5630:	09 f4       	brne	.+2      	; 0x5634 <vTaskPriorityDisinheritAfterTimeout+0x5e>
    5632:	67 c0       	rjmp	.+206    	; 0x5702 <vTaskPriorityDisinheritAfterTimeout+0x12c>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    5634:	8a 81       	ldd	r24, Y+2	; 0x02
    5636:	9b 81       	ldd	r25, Y+3	; 0x03
    5638:	fc 01       	movw	r30, r24
    563a:	92 a1       	ldd	r25, Z+34	; 0x22
    563c:	8c 81       	ldd	r24, Y+4	; 0x04
    563e:	98 17       	cp	r25, r24
    5640:	09 f0       	breq	.+2      	; 0x5644 <vTaskPriorityDisinheritAfterTimeout+0x6e>
    5642:	5f c0       	rjmp	.+190    	; 0x5702 <vTaskPriorityDisinheritAfterTimeout+0x12c>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    5644:	8a 81       	ldd	r24, Y+2	; 0x02
    5646:	9b 81       	ldd	r25, Y+3	; 0x03
    5648:	fc 01       	movw	r30, r24
    564a:	86 89       	ldd	r24, Z+22	; 0x16
    564c:	8d 83       	std	Y+5, r24	; 0x05
					pxTCB->uxPriority = uxPriorityToUse;
    564e:	8a 81       	ldd	r24, Y+2	; 0x02
    5650:	9b 81       	ldd	r25, Y+3	; 0x03
    5652:	29 81       	ldd	r18, Y+1	; 0x01
    5654:	fc 01       	movw	r30, r24
    5656:	26 8b       	std	Z+22, r18	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    5658:	8a 81       	ldd	r24, Y+2	; 0x02
    565a:	9b 81       	ldd	r25, Y+3	; 0x03
    565c:	fc 01       	movw	r30, r24
    565e:	84 85       	ldd	r24, Z+12	; 0x0c
    5660:	95 85       	ldd	r25, Z+13	; 0x0d
    5662:	99 23       	and	r25, r25
    5664:	64 f0       	brlt	.+24     	; 0x567e <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5666:	89 81       	ldd	r24, Y+1	; 0x01
    5668:	88 2f       	mov	r24, r24
    566a:	90 e0       	ldi	r25, 0x00	; 0
    566c:	25 e0       	ldi	r18, 0x05	; 5
    566e:	30 e0       	ldi	r19, 0x00	; 0
    5670:	28 1b       	sub	r18, r24
    5672:	39 0b       	sbc	r19, r25
    5674:	8a 81       	ldd	r24, Y+2	; 0x02
    5676:	9b 81       	ldd	r25, Y+3	; 0x03
    5678:	fc 01       	movw	r30, r24
    567a:	35 87       	std	Z+13, r19	; 0x0d
    567c:	24 87       	std	Z+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    567e:	8a 81       	ldd	r24, Y+2	; 0x02
    5680:	9b 81       	ldd	r25, Y+3	; 0x03
    5682:	fc 01       	movw	r30, r24
    5684:	42 85       	ldd	r20, Z+10	; 0x0a
    5686:	53 85       	ldd	r21, Z+11	; 0x0b
    5688:	8d 81       	ldd	r24, Y+5	; 0x05
    568a:	28 2f       	mov	r18, r24
    568c:	30 e0       	ldi	r19, 0x00	; 0
    568e:	c9 01       	movw	r24, r18
    5690:	88 0f       	add	r24, r24
    5692:	99 1f       	adc	r25, r25
    5694:	88 0f       	add	r24, r24
    5696:	99 1f       	adc	r25, r25
    5698:	88 0f       	add	r24, r24
    569a:	99 1f       	adc	r25, r25
    569c:	82 0f       	add	r24, r18
    569e:	93 1f       	adc	r25, r19
    56a0:	8f 55       	subi	r24, 0x5F	; 95
    56a2:	99 4f       	sbci	r25, 0xF9	; 249
    56a4:	48 17       	cp	r20, r24
    56a6:	59 07       	cpc	r21, r25
    56a8:	61 f5       	brne	.+88     	; 0x5702 <vTaskPriorityDisinheritAfterTimeout+0x12c>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    56aa:	8a 81       	ldd	r24, Y+2	; 0x02
    56ac:	9b 81       	ldd	r25, Y+3	; 0x03
    56ae:	02 96       	adiw	r24, 0x02	; 2
    56b0:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    56b4:	8a 81       	ldd	r24, Y+2	; 0x02
    56b6:	9b 81       	ldd	r25, Y+3	; 0x03
    56b8:	fc 01       	movw	r30, r24
    56ba:	96 89       	ldd	r25, Z+22	; 0x16
    56bc:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    56c0:	89 17       	cp	r24, r25
    56c2:	30 f4       	brcc	.+12     	; 0x56d0 <vTaskPriorityDisinheritAfterTimeout+0xfa>
    56c4:	8a 81       	ldd	r24, Y+2	; 0x02
    56c6:	9b 81       	ldd	r25, Y+3	; 0x03
    56c8:	fc 01       	movw	r30, r24
    56ca:	86 89       	ldd	r24, Z+22	; 0x16
    56cc:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    56d0:	8a 81       	ldd	r24, Y+2	; 0x02
    56d2:	9b 81       	ldd	r25, Y+3	; 0x03
    56d4:	ac 01       	movw	r20, r24
    56d6:	4e 5f       	subi	r20, 0xFE	; 254
    56d8:	5f 4f       	sbci	r21, 0xFF	; 255
    56da:	8a 81       	ldd	r24, Y+2	; 0x02
    56dc:	9b 81       	ldd	r25, Y+3	; 0x03
    56de:	fc 01       	movw	r30, r24
    56e0:	86 89       	ldd	r24, Z+22	; 0x16
    56e2:	28 2f       	mov	r18, r24
    56e4:	30 e0       	ldi	r19, 0x00	; 0
    56e6:	c9 01       	movw	r24, r18
    56e8:	88 0f       	add	r24, r24
    56ea:	99 1f       	adc	r25, r25
    56ec:	88 0f       	add	r24, r24
    56ee:	99 1f       	adc	r25, r25
    56f0:	88 0f       	add	r24, r24
    56f2:	99 1f       	adc	r25, r25
    56f4:	82 0f       	add	r24, r18
    56f6:	93 1f       	adc	r25, r19
    56f8:	8f 55       	subi	r24, 0x5F	; 95
    56fa:	99 4f       	sbci	r25, 0xF9	; 249
    56fc:	ba 01       	movw	r22, r20
    56fe:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5702:	00 00       	nop
    5704:	28 96       	adiw	r28, 0x08	; 8
    5706:	0f b6       	in	r0, 0x3f	; 63
    5708:	f8 94       	cli
    570a:	de bf       	out	0x3e, r29	; 62
    570c:	0f be       	out	0x3f, r0	; 63
    570e:	cd bf       	out	0x3d, r28	; 61
    5710:	df 91       	pop	r29
    5712:	cf 91       	pop	r28
    5714:	08 95       	ret

00005716 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5716:	cf 93       	push	r28
    5718:	df 93       	push	r29
    571a:	00 d0       	rcall	.+0      	; 0x571c <uxTaskResetEventItemValue+0x6>
    571c:	cd b7       	in	r28, 0x3d	; 61
    571e:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5720:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5724:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5728:	fc 01       	movw	r30, r24
    572a:	84 85       	ldd	r24, Z+12	; 0x0c
    572c:	95 85       	ldd	r25, Z+13	; 0x0d
    572e:	9a 83       	std	Y+2, r25	; 0x02
    5730:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5732:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5736:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    573a:	20 91 9f 06 	lds	r18, 0x069F	; 0x80069f <pxCurrentTCB>
    573e:	30 91 a0 06 	lds	r19, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5742:	f9 01       	movw	r30, r18
    5744:	26 89       	ldd	r18, Z+22	; 0x16
    5746:	22 2f       	mov	r18, r18
    5748:	30 e0       	ldi	r19, 0x00	; 0
    574a:	45 e0       	ldi	r20, 0x05	; 5
    574c:	50 e0       	ldi	r21, 0x00	; 0
    574e:	ba 01       	movw	r22, r20
    5750:	62 1b       	sub	r22, r18
    5752:	73 0b       	sbc	r23, r19
    5754:	9b 01       	movw	r18, r22
    5756:	fc 01       	movw	r30, r24
    5758:	35 87       	std	Z+13, r19	; 0x0d
    575a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    575c:	89 81       	ldd	r24, Y+1	; 0x01
    575e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5760:	0f 90       	pop	r0
    5762:	0f 90       	pop	r0
    5764:	df 91       	pop	r29
    5766:	cf 91       	pop	r28
    5768:	08 95       	ret

0000576a <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    576a:	cf 93       	push	r28
    576c:	df 93       	push	r29
    576e:	cd b7       	in	r28, 0x3d	; 61
    5770:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    5772:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5776:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    577a:	89 2b       	or	r24, r25
    577c:	49 f0       	breq	.+18     	; 0x5790 <pvTaskIncrementMutexHeldCount+0x26>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    577e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5782:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5786:	fc 01       	movw	r30, r24
    5788:	22 a1       	ldd	r18, Z+34	; 0x22
    578a:	2f 5f       	subi	r18, 0xFF	; 255
    578c:	fc 01       	movw	r30, r24
    578e:	22 a3       	std	Z+34, r18	; 0x22
		}

		return pxCurrentTCB;
    5790:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5794:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
	}
    5798:	df 91       	pop	r29
    579a:	cf 91       	pop	r28
    579c:	08 95       	ret

0000579e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    579e:	cf 93       	push	r28
    57a0:	df 93       	push	r29
    57a2:	cd b7       	in	r28, 0x3d	; 61
    57a4:	de b7       	in	r29, 0x3e	; 62
    57a6:	27 97       	sbiw	r28, 0x07	; 7
    57a8:	0f b6       	in	r0, 0x3f	; 63
    57aa:	f8 94       	cli
    57ac:	de bf       	out	0x3e, r29	; 62
    57ae:	0f be       	out	0x3f, r0	; 63
    57b0:	cd bf       	out	0x3d, r28	; 61
    57b2:	8d 83       	std	Y+5, r24	; 0x05
    57b4:	7f 83       	std	Y+7, r23	; 0x07
    57b6:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    57b8:	0f b6       	in	r0, 0x3f	; 63
    57ba:	f8 94       	cli
    57bc:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    57be:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    57c2:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    57c6:	fc 01       	movw	r30, r24
    57c8:	83 a1       	ldd	r24, Z+35	; 0x23
    57ca:	94 a1       	ldd	r25, Z+36	; 0x24
    57cc:	a5 a1       	ldd	r26, Z+37	; 0x25
    57ce:	b6 a1       	ldd	r27, Z+38	; 0x26
    57d0:	89 2b       	or	r24, r25
    57d2:	8a 2b       	or	r24, r26
    57d4:	8b 2b       	or	r24, r27
    57d6:	91 f4       	brne	.+36     	; 0x57fc <ulTaskNotifyTake+0x5e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    57d8:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    57dc:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    57e0:	21 e0       	ldi	r18, 0x01	; 1
    57e2:	fc 01       	movw	r30, r24
    57e4:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    57e6:	8e 81       	ldd	r24, Y+6	; 0x06
    57e8:	9f 81       	ldd	r25, Y+7	; 0x07
    57ea:	89 2b       	or	r24, r25
    57ec:	39 f0       	breq	.+14     	; 0x57fc <ulTaskNotifyTake+0x5e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    57ee:	8e 81       	ldd	r24, Y+6	; 0x06
    57f0:	9f 81       	ldd	r25, Y+7	; 0x07
    57f2:	61 e0       	ldi	r22, 0x01	; 1
    57f4:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    57f8:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    57fc:	0f 90       	pop	r0
    57fe:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5800:	0f b6       	in	r0, 0x3f	; 63
    5802:	f8 94       	cli
    5804:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5806:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    580a:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    580e:	fc 01       	movw	r30, r24
    5810:	83 a1       	ldd	r24, Z+35	; 0x23
    5812:	94 a1       	ldd	r25, Z+36	; 0x24
    5814:	a5 a1       	ldd	r26, Z+37	; 0x25
    5816:	b6 a1       	ldd	r27, Z+38	; 0x26
    5818:	89 83       	std	Y+1, r24	; 0x01
    581a:	9a 83       	std	Y+2, r25	; 0x02
    581c:	ab 83       	std	Y+3, r26	; 0x03
    581e:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5820:	89 81       	ldd	r24, Y+1	; 0x01
    5822:	9a 81       	ldd	r25, Y+2	; 0x02
    5824:	ab 81       	ldd	r26, Y+3	; 0x03
    5826:	bc 81       	ldd	r27, Y+4	; 0x04
    5828:	89 2b       	or	r24, r25
    582a:	8a 2b       	or	r24, r26
    582c:	8b 2b       	or	r24, r27
    582e:	e9 f0       	breq	.+58     	; 0x586a <ulTaskNotifyTake+0xcc>
			{
				if( xClearCountOnExit != pdFALSE )
    5830:	8d 81       	ldd	r24, Y+5	; 0x05
    5832:	88 23       	and	r24, r24
    5834:	51 f0       	breq	.+20     	; 0x584a <ulTaskNotifyTake+0xac>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5836:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    583a:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    583e:	fc 01       	movw	r30, r24
    5840:	13 a2       	std	Z+35, r1	; 0x23
    5842:	14 a2       	std	Z+36, r1	; 0x24
    5844:	15 a2       	std	Z+37, r1	; 0x25
    5846:	16 a2       	std	Z+38, r1	; 0x26
    5848:	10 c0       	rjmp	.+32     	; 0x586a <ulTaskNotifyTake+0xcc>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    584a:	20 91 9f 06 	lds	r18, 0x069F	; 0x80069f <pxCurrentTCB>
    584e:	30 91 a0 06 	lds	r19, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5852:	89 81       	ldd	r24, Y+1	; 0x01
    5854:	9a 81       	ldd	r25, Y+2	; 0x02
    5856:	ab 81       	ldd	r26, Y+3	; 0x03
    5858:	bc 81       	ldd	r27, Y+4	; 0x04
    585a:	01 97       	sbiw	r24, 0x01	; 1
    585c:	a1 09       	sbc	r26, r1
    585e:	b1 09       	sbc	r27, r1
    5860:	f9 01       	movw	r30, r18
    5862:	83 a3       	std	Z+35, r24	; 0x23
    5864:	94 a3       	std	Z+36, r25	; 0x24
    5866:	a5 a3       	std	Z+37, r26	; 0x25
    5868:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    586a:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    586e:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5872:	fc 01       	movw	r30, r24
    5874:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5876:	0f 90       	pop	r0
    5878:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    587a:	89 81       	ldd	r24, Y+1	; 0x01
    587c:	9a 81       	ldd	r25, Y+2	; 0x02
    587e:	ab 81       	ldd	r26, Y+3	; 0x03
    5880:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5882:	bc 01       	movw	r22, r24
    5884:	cd 01       	movw	r24, r26
    5886:	27 96       	adiw	r28, 0x07	; 7
    5888:	0f b6       	in	r0, 0x3f	; 63
    588a:	f8 94       	cli
    588c:	de bf       	out	0x3e, r29	; 62
    588e:	0f be       	out	0x3f, r0	; 63
    5890:	cd bf       	out	0x3d, r28	; 61
    5892:	df 91       	pop	r29
    5894:	cf 91       	pop	r28
    5896:	08 95       	ret

00005898 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5898:	ef 92       	push	r14
    589a:	ff 92       	push	r15
    589c:	0f 93       	push	r16
    589e:	1f 93       	push	r17
    58a0:	cf 93       	push	r28
    58a2:	df 93       	push	r29
    58a4:	cd b7       	in	r28, 0x3d	; 61
    58a6:	de b7       	in	r29, 0x3e	; 62
    58a8:	2d 97       	sbiw	r28, 0x0d	; 13
    58aa:	0f b6       	in	r0, 0x3f	; 63
    58ac:	f8 94       	cli
    58ae:	de bf       	out	0x3e, r29	; 62
    58b0:	0f be       	out	0x3f, r0	; 63
    58b2:	cd bf       	out	0x3d, r28	; 61
    58b4:	6a 83       	std	Y+2, r22	; 0x02
    58b6:	7b 83       	std	Y+3, r23	; 0x03
    58b8:	8c 83       	std	Y+4, r24	; 0x04
    58ba:	9d 83       	std	Y+5, r25	; 0x05
    58bc:	2e 83       	std	Y+6, r18	; 0x06
    58be:	3f 83       	std	Y+7, r19	; 0x07
    58c0:	48 87       	std	Y+8, r20	; 0x08
    58c2:	59 87       	std	Y+9, r21	; 0x09
    58c4:	1b 87       	std	Y+11, r17	; 0x0b
    58c6:	0a 87       	std	Y+10, r16	; 0x0a
    58c8:	fd 86       	std	Y+13, r15	; 0x0d
    58ca:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    58cc:	0f b6       	in	r0, 0x3f	; 63
    58ce:	f8 94       	cli
    58d0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    58d2:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    58d6:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    58da:	fc 01       	movw	r30, r24
    58dc:	87 a1       	ldd	r24, Z+39	; 0x27
    58de:	82 30       	cpi	r24, 0x02	; 2
    58e0:	61 f1       	breq	.+88     	; 0x593a <xTaskNotifyWait+0xa2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    58e2:	60 91 9f 06 	lds	r22, 0x069F	; 0x80069f <pxCurrentTCB>
    58e6:	70 91 a0 06 	lds	r23, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    58ea:	fb 01       	movw	r30, r22
    58ec:	23 a1       	ldd	r18, Z+35	; 0x23
    58ee:	34 a1       	ldd	r19, Z+36	; 0x24
    58f0:	45 a1       	ldd	r20, Z+37	; 0x25
    58f2:	56 a1       	ldd	r21, Z+38	; 0x26
    58f4:	8a 81       	ldd	r24, Y+2	; 0x02
    58f6:	9b 81       	ldd	r25, Y+3	; 0x03
    58f8:	ac 81       	ldd	r26, Y+4	; 0x04
    58fa:	bd 81       	ldd	r27, Y+5	; 0x05
    58fc:	80 95       	com	r24
    58fe:	90 95       	com	r25
    5900:	a0 95       	com	r26
    5902:	b0 95       	com	r27
    5904:	82 23       	and	r24, r18
    5906:	93 23       	and	r25, r19
    5908:	a4 23       	and	r26, r20
    590a:	b5 23       	and	r27, r21
    590c:	fb 01       	movw	r30, r22
    590e:	83 a3       	std	Z+35, r24	; 0x23
    5910:	94 a3       	std	Z+36, r25	; 0x24
    5912:	a5 a3       	std	Z+37, r26	; 0x25
    5914:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5916:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    591a:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    591e:	21 e0       	ldi	r18, 0x01	; 1
    5920:	fc 01       	movw	r30, r24
    5922:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5924:	8c 85       	ldd	r24, Y+12	; 0x0c
    5926:	9d 85       	ldd	r25, Y+13	; 0x0d
    5928:	89 2b       	or	r24, r25
    592a:	39 f0       	breq	.+14     	; 0x593a <xTaskNotifyWait+0xa2>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    592c:	8c 85       	ldd	r24, Y+12	; 0x0c
    592e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5930:	61 e0       	ldi	r22, 0x01	; 1
    5932:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5936:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    593a:	0f 90       	pop	r0
    593c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    593e:	0f b6       	in	r0, 0x3f	; 63
    5940:	f8 94       	cli
    5942:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5944:	8a 85       	ldd	r24, Y+10	; 0x0a
    5946:	9b 85       	ldd	r25, Y+11	; 0x0b
    5948:	89 2b       	or	r24, r25
    594a:	81 f0       	breq	.+32     	; 0x596c <xTaskNotifyWait+0xd4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    594c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5950:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5954:	fc 01       	movw	r30, r24
    5956:	83 a1       	ldd	r24, Z+35	; 0x23
    5958:	94 a1       	ldd	r25, Z+36	; 0x24
    595a:	a5 a1       	ldd	r26, Z+37	; 0x25
    595c:	b6 a1       	ldd	r27, Z+38	; 0x26
    595e:	2a 85       	ldd	r18, Y+10	; 0x0a
    5960:	3b 85       	ldd	r19, Y+11	; 0x0b
    5962:	f9 01       	movw	r30, r18
    5964:	80 83       	st	Z, r24
    5966:	91 83       	std	Z+1, r25	; 0x01
    5968:	a2 83       	std	Z+2, r26	; 0x02
    596a:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    596c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5970:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5974:	fc 01       	movw	r30, r24
    5976:	87 a1       	ldd	r24, Z+39	; 0x27
    5978:	82 30       	cpi	r24, 0x02	; 2
    597a:	11 f0       	breq	.+4      	; 0x5980 <xTaskNotifyWait+0xe8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    597c:	19 82       	std	Y+1, r1	; 0x01
    597e:	1c c0       	rjmp	.+56     	; 0x59b8 <xTaskNotifyWait+0x120>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5980:	60 91 9f 06 	lds	r22, 0x069F	; 0x80069f <pxCurrentTCB>
    5984:	70 91 a0 06 	lds	r23, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5988:	fb 01       	movw	r30, r22
    598a:	23 a1       	ldd	r18, Z+35	; 0x23
    598c:	34 a1       	ldd	r19, Z+36	; 0x24
    598e:	45 a1       	ldd	r20, Z+37	; 0x25
    5990:	56 a1       	ldd	r21, Z+38	; 0x26
    5992:	8e 81       	ldd	r24, Y+6	; 0x06
    5994:	9f 81       	ldd	r25, Y+7	; 0x07
    5996:	a8 85       	ldd	r26, Y+8	; 0x08
    5998:	b9 85       	ldd	r27, Y+9	; 0x09
    599a:	80 95       	com	r24
    599c:	90 95       	com	r25
    599e:	a0 95       	com	r26
    59a0:	b0 95       	com	r27
    59a2:	82 23       	and	r24, r18
    59a4:	93 23       	and	r25, r19
    59a6:	a4 23       	and	r26, r20
    59a8:	b5 23       	and	r27, r21
    59aa:	fb 01       	movw	r30, r22
    59ac:	83 a3       	std	Z+35, r24	; 0x23
    59ae:	94 a3       	std	Z+36, r25	; 0x24
    59b0:	a5 a3       	std	Z+37, r26	; 0x25
    59b2:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    59b4:	81 e0       	ldi	r24, 0x01	; 1
    59b6:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    59b8:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    59bc:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    59c0:	fc 01       	movw	r30, r24
    59c2:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    59c4:	0f 90       	pop	r0
    59c6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    59c8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    59ca:	2d 96       	adiw	r28, 0x0d	; 13
    59cc:	0f b6       	in	r0, 0x3f	; 63
    59ce:	f8 94       	cli
    59d0:	de bf       	out	0x3e, r29	; 62
    59d2:	0f be       	out	0x3f, r0	; 63
    59d4:	cd bf       	out	0x3d, r28	; 61
    59d6:	df 91       	pop	r29
    59d8:	cf 91       	pop	r28
    59da:	1f 91       	pop	r17
    59dc:	0f 91       	pop	r16
    59de:	ff 90       	pop	r15
    59e0:	ef 90       	pop	r14
    59e2:	08 95       	ret

000059e4 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    59e4:	0f 93       	push	r16
    59e6:	1f 93       	push	r17
    59e8:	cf 93       	push	r28
    59ea:	df 93       	push	r29
    59ec:	cd b7       	in	r28, 0x3d	; 61
    59ee:	de b7       	in	r29, 0x3e	; 62
    59f0:	2d 97       	sbiw	r28, 0x0d	; 13
    59f2:	0f b6       	in	r0, 0x3f	; 63
    59f4:	f8 94       	cli
    59f6:	de bf       	out	0x3e, r29	; 62
    59f8:	0f be       	out	0x3f, r0	; 63
    59fa:	cd bf       	out	0x3d, r28	; 61
    59fc:	9e 83       	std	Y+6, r25	; 0x06
    59fe:	8d 83       	std	Y+5, r24	; 0x05
    5a00:	4f 83       	std	Y+7, r20	; 0x07
    5a02:	58 87       	std	Y+8, r21	; 0x08
    5a04:	69 87       	std	Y+9, r22	; 0x09
    5a06:	7a 87       	std	Y+10, r23	; 0x0a
    5a08:	2b 87       	std	Y+11, r18	; 0x0b
    5a0a:	1d 87       	std	Y+13, r17	; 0x0d
    5a0c:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5a0e:	81 e0       	ldi	r24, 0x01	; 1
    5a10:	89 83       	std	Y+1, r24	; 0x01
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5a12:	8d 81       	ldd	r24, Y+5	; 0x05
    5a14:	9e 81       	ldd	r25, Y+6	; 0x06
    5a16:	9b 83       	std	Y+3, r25	; 0x03
    5a18:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5a1a:	0f b6       	in	r0, 0x3f	; 63
    5a1c:	f8 94       	cli
    5a1e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5a20:	8c 85       	ldd	r24, Y+12	; 0x0c
    5a22:	9d 85       	ldd	r25, Y+13	; 0x0d
    5a24:	89 2b       	or	r24, r25
    5a26:	71 f0       	breq	.+28     	; 0x5a44 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5a28:	8a 81       	ldd	r24, Y+2	; 0x02
    5a2a:	9b 81       	ldd	r25, Y+3	; 0x03
    5a2c:	fc 01       	movw	r30, r24
    5a2e:	83 a1       	ldd	r24, Z+35	; 0x23
    5a30:	94 a1       	ldd	r25, Z+36	; 0x24
    5a32:	a5 a1       	ldd	r26, Z+37	; 0x25
    5a34:	b6 a1       	ldd	r27, Z+38	; 0x26
    5a36:	2c 85       	ldd	r18, Y+12	; 0x0c
    5a38:	3d 85       	ldd	r19, Y+13	; 0x0d
    5a3a:	f9 01       	movw	r30, r18
    5a3c:	80 83       	st	Z, r24
    5a3e:	91 83       	std	Z+1, r25	; 0x01
    5a40:	a2 83       	std	Z+2, r26	; 0x02
    5a42:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5a44:	8a 81       	ldd	r24, Y+2	; 0x02
    5a46:	9b 81       	ldd	r25, Y+3	; 0x03
    5a48:	fc 01       	movw	r30, r24
    5a4a:	87 a1       	ldd	r24, Z+39	; 0x27
    5a4c:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5a4e:	8a 81       	ldd	r24, Y+2	; 0x02
    5a50:	9b 81       	ldd	r25, Y+3	; 0x03
    5a52:	22 e0       	ldi	r18, 0x02	; 2
    5a54:	fc 01       	movw	r30, r24
    5a56:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5a58:	8b 85       	ldd	r24, Y+11	; 0x0b
    5a5a:	88 2f       	mov	r24, r24
    5a5c:	90 e0       	ldi	r25, 0x00	; 0
    5a5e:	82 30       	cpi	r24, 0x02	; 2
    5a60:	91 05       	cpc	r25, r1
    5a62:	31 f1       	breq	.+76     	; 0x5ab0 <xTaskGenericNotify+0xcc>
    5a64:	83 30       	cpi	r24, 0x03	; 3
    5a66:	91 05       	cpc	r25, r1
    5a68:	34 f4       	brge	.+12     	; 0x5a76 <xTaskGenericNotify+0x92>
    5a6a:	00 97       	sbiw	r24, 0x00	; 0
    5a6c:	09 f4       	brne	.+2      	; 0x5a70 <xTaskGenericNotify+0x8c>
    5a6e:	4f c0       	rjmp	.+158    	; 0x5b0e <xTaskGenericNotify+0x12a>
    5a70:	01 97       	sbiw	r24, 0x01	; 1
    5a72:	39 f0       	breq	.+14     	; 0x5a82 <xTaskGenericNotify+0x9e>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a74:	4d c0       	rjmp	.+154    	; 0x5b10 <xTaskGenericNotify+0x12c>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5a76:	83 30       	cpi	r24, 0x03	; 3
    5a78:	91 05       	cpc	r25, r1
    5a7a:	61 f1       	breq	.+88     	; 0x5ad4 <xTaskGenericNotify+0xf0>
    5a7c:	04 97       	sbiw	r24, 0x04	; 4
    5a7e:	b1 f1       	breq	.+108    	; 0x5aec <xTaskGenericNotify+0x108>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a80:	47 c0       	rjmp	.+142    	; 0x5b10 <xTaskGenericNotify+0x12c>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5a82:	8a 81       	ldd	r24, Y+2	; 0x02
    5a84:	9b 81       	ldd	r25, Y+3	; 0x03
    5a86:	fc 01       	movw	r30, r24
    5a88:	23 a1       	ldd	r18, Z+35	; 0x23
    5a8a:	34 a1       	ldd	r19, Z+36	; 0x24
    5a8c:	45 a1       	ldd	r20, Z+37	; 0x25
    5a8e:	56 a1       	ldd	r21, Z+38	; 0x26
    5a90:	8f 81       	ldd	r24, Y+7	; 0x07
    5a92:	98 85       	ldd	r25, Y+8	; 0x08
    5a94:	a9 85       	ldd	r26, Y+9	; 0x09
    5a96:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a98:	82 2b       	or	r24, r18
    5a9a:	93 2b       	or	r25, r19
    5a9c:	a4 2b       	or	r26, r20
    5a9e:	b5 2b       	or	r27, r21
    5aa0:	2a 81       	ldd	r18, Y+2	; 0x02
    5aa2:	3b 81       	ldd	r19, Y+3	; 0x03
    5aa4:	f9 01       	movw	r30, r18
    5aa6:	83 a3       	std	Z+35, r24	; 0x23
    5aa8:	94 a3       	std	Z+36, r25	; 0x24
    5aaa:	a5 a3       	std	Z+37, r26	; 0x25
    5aac:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5aae:	30 c0       	rjmp	.+96     	; 0x5b10 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5ab0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ab2:	9b 81       	ldd	r25, Y+3	; 0x03
    5ab4:	fc 01       	movw	r30, r24
    5ab6:	83 a1       	ldd	r24, Z+35	; 0x23
    5ab8:	94 a1       	ldd	r25, Z+36	; 0x24
    5aba:	a5 a1       	ldd	r26, Z+37	; 0x25
    5abc:	b6 a1       	ldd	r27, Z+38	; 0x26
    5abe:	01 96       	adiw	r24, 0x01	; 1
    5ac0:	a1 1d       	adc	r26, r1
    5ac2:	b1 1d       	adc	r27, r1
    5ac4:	2a 81       	ldd	r18, Y+2	; 0x02
    5ac6:	3b 81       	ldd	r19, Y+3	; 0x03
    5ac8:	f9 01       	movw	r30, r18
    5aca:	83 a3       	std	Z+35, r24	; 0x23
    5acc:	94 a3       	std	Z+36, r25	; 0x24
    5ace:	a5 a3       	std	Z+37, r26	; 0x25
    5ad0:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5ad2:	1e c0       	rjmp	.+60     	; 0x5b10 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5ad4:	2a 81       	ldd	r18, Y+2	; 0x02
    5ad6:	3b 81       	ldd	r19, Y+3	; 0x03
    5ad8:	8f 81       	ldd	r24, Y+7	; 0x07
    5ada:	98 85       	ldd	r25, Y+8	; 0x08
    5adc:	a9 85       	ldd	r26, Y+9	; 0x09
    5ade:	ba 85       	ldd	r27, Y+10	; 0x0a
    5ae0:	f9 01       	movw	r30, r18
    5ae2:	83 a3       	std	Z+35, r24	; 0x23
    5ae4:	94 a3       	std	Z+36, r25	; 0x24
    5ae6:	a5 a3       	std	Z+37, r26	; 0x25
    5ae8:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5aea:	12 c0       	rjmp	.+36     	; 0x5b10 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5aec:	8c 81       	ldd	r24, Y+4	; 0x04
    5aee:	82 30       	cpi	r24, 0x02	; 2
    5af0:	61 f0       	breq	.+24     	; 0x5b0a <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5af2:	2a 81       	ldd	r18, Y+2	; 0x02
    5af4:	3b 81       	ldd	r19, Y+3	; 0x03
    5af6:	8f 81       	ldd	r24, Y+7	; 0x07
    5af8:	98 85       	ldd	r25, Y+8	; 0x08
    5afa:	a9 85       	ldd	r26, Y+9	; 0x09
    5afc:	ba 85       	ldd	r27, Y+10	; 0x0a
    5afe:	f9 01       	movw	r30, r18
    5b00:	83 a3       	std	Z+35, r24	; 0x23
    5b02:	94 a3       	std	Z+36, r25	; 0x24
    5b04:	a5 a3       	std	Z+37, r26	; 0x25
    5b06:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5b08:	03 c0       	rjmp	.+6      	; 0x5b10 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5b0a:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5b0c:	01 c0       	rjmp	.+2      	; 0x5b10 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    5b0e:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5b10:	8c 81       	ldd	r24, Y+4	; 0x04
    5b12:	81 30       	cpi	r24, 0x01	; 1
    5b14:	d1 f5       	brne	.+116    	; 0x5b8a <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5b16:	8a 81       	ldd	r24, Y+2	; 0x02
    5b18:	9b 81       	ldd	r25, Y+3	; 0x03
    5b1a:	02 96       	adiw	r24, 0x02	; 2
    5b1c:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5b20:	8a 81       	ldd	r24, Y+2	; 0x02
    5b22:	9b 81       	ldd	r25, Y+3	; 0x03
    5b24:	fc 01       	movw	r30, r24
    5b26:	96 89       	ldd	r25, Z+22	; 0x16
    5b28:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5b2c:	89 17       	cp	r24, r25
    5b2e:	30 f4       	brcc	.+12     	; 0x5b3c <xTaskGenericNotify+0x158>
    5b30:	8a 81       	ldd	r24, Y+2	; 0x02
    5b32:	9b 81       	ldd	r25, Y+3	; 0x03
    5b34:	fc 01       	movw	r30, r24
    5b36:	86 89       	ldd	r24, Z+22	; 0x16
    5b38:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    5b3e:	9b 81       	ldd	r25, Y+3	; 0x03
    5b40:	ac 01       	movw	r20, r24
    5b42:	4e 5f       	subi	r20, 0xFE	; 254
    5b44:	5f 4f       	sbci	r21, 0xFF	; 255
    5b46:	8a 81       	ldd	r24, Y+2	; 0x02
    5b48:	9b 81       	ldd	r25, Y+3	; 0x03
    5b4a:	fc 01       	movw	r30, r24
    5b4c:	86 89       	ldd	r24, Z+22	; 0x16
    5b4e:	28 2f       	mov	r18, r24
    5b50:	30 e0       	ldi	r19, 0x00	; 0
    5b52:	c9 01       	movw	r24, r18
    5b54:	88 0f       	add	r24, r24
    5b56:	99 1f       	adc	r25, r25
    5b58:	88 0f       	add	r24, r24
    5b5a:	99 1f       	adc	r25, r25
    5b5c:	88 0f       	add	r24, r24
    5b5e:	99 1f       	adc	r25, r25
    5b60:	82 0f       	add	r24, r18
    5b62:	93 1f       	adc	r25, r19
    5b64:	8f 55       	subi	r24, 0x5F	; 95
    5b66:	99 4f       	sbci	r25, 0xF9	; 249
    5b68:	ba 01       	movw	r22, r20
    5b6a:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5b6e:	8a 81       	ldd	r24, Y+2	; 0x02
    5b70:	9b 81       	ldd	r25, Y+3	; 0x03
    5b72:	fc 01       	movw	r30, r24
    5b74:	26 89       	ldd	r18, Z+22	; 0x16
    5b76:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5b7a:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5b7e:	fc 01       	movw	r30, r24
    5b80:	86 89       	ldd	r24, Z+22	; 0x16
    5b82:	82 17       	cp	r24, r18
    5b84:	10 f4       	brcc	.+4      	; 0x5b8a <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5b86:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5b8a:	0f 90       	pop	r0
    5b8c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5b8e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5b90:	2d 96       	adiw	r28, 0x0d	; 13
    5b92:	0f b6       	in	r0, 0x3f	; 63
    5b94:	f8 94       	cli
    5b96:	de bf       	out	0x3e, r29	; 62
    5b98:	0f be       	out	0x3f, r0	; 63
    5b9a:	cd bf       	out	0x3d, r28	; 61
    5b9c:	df 91       	pop	r29
    5b9e:	cf 91       	pop	r28
    5ba0:	1f 91       	pop	r17
    5ba2:	0f 91       	pop	r16
    5ba4:	08 95       	ret

00005ba6 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5ba6:	ef 92       	push	r14
    5ba8:	ff 92       	push	r15
    5baa:	0f 93       	push	r16
    5bac:	1f 93       	push	r17
    5bae:	cf 93       	push	r28
    5bb0:	df 93       	push	r29
    5bb2:	cd b7       	in	r28, 0x3d	; 61
    5bb4:	de b7       	in	r29, 0x3e	; 62
    5bb6:	60 97       	sbiw	r28, 0x10	; 16
    5bb8:	0f b6       	in	r0, 0x3f	; 63
    5bba:	f8 94       	cli
    5bbc:	de bf       	out	0x3e, r29	; 62
    5bbe:	0f be       	out	0x3f, r0	; 63
    5bc0:	cd bf       	out	0x3d, r28	; 61
    5bc2:	9f 83       	std	Y+7, r25	; 0x07
    5bc4:	8e 83       	std	Y+6, r24	; 0x06
    5bc6:	48 87       	std	Y+8, r20	; 0x08
    5bc8:	59 87       	std	Y+9, r21	; 0x09
    5bca:	6a 87       	std	Y+10, r22	; 0x0a
    5bcc:	7b 87       	std	Y+11, r23	; 0x0b
    5bce:	2c 87       	std	Y+12, r18	; 0x0c
    5bd0:	1e 87       	std	Y+14, r17	; 0x0e
    5bd2:	0d 87       	std	Y+13, r16	; 0x0d
    5bd4:	f8 8a       	std	Y+16, r15	; 0x10
    5bd6:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5bd8:	81 e0       	ldi	r24, 0x01	; 1
    5bda:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5bdc:	8e 81       	ldd	r24, Y+6	; 0x06
    5bde:	9f 81       	ldd	r25, Y+7	; 0x07
    5be0:	9b 83       	std	Y+3, r25	; 0x03
    5be2:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5be4:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    5be6:	8d 85       	ldd	r24, Y+13	; 0x0d
    5be8:	9e 85       	ldd	r25, Y+14	; 0x0e
    5bea:	89 2b       	or	r24, r25
    5bec:	71 f0       	breq	.+28     	; 0x5c0a <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5bee:	8a 81       	ldd	r24, Y+2	; 0x02
    5bf0:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf2:	fc 01       	movw	r30, r24
    5bf4:	83 a1       	ldd	r24, Z+35	; 0x23
    5bf6:	94 a1       	ldd	r25, Z+36	; 0x24
    5bf8:	a5 a1       	ldd	r26, Z+37	; 0x25
    5bfa:	b6 a1       	ldd	r27, Z+38	; 0x26
    5bfc:	2d 85       	ldd	r18, Y+13	; 0x0d
    5bfe:	3e 85       	ldd	r19, Y+14	; 0x0e
    5c00:	f9 01       	movw	r30, r18
    5c02:	80 83       	st	Z, r24
    5c04:	91 83       	std	Z+1, r25	; 0x01
    5c06:	a2 83       	std	Z+2, r26	; 0x02
    5c08:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5c0a:	8a 81       	ldd	r24, Y+2	; 0x02
    5c0c:	9b 81       	ldd	r25, Y+3	; 0x03
    5c0e:	fc 01       	movw	r30, r24
    5c10:	87 a1       	ldd	r24, Z+39	; 0x27
    5c12:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5c14:	8a 81       	ldd	r24, Y+2	; 0x02
    5c16:	9b 81       	ldd	r25, Y+3	; 0x03
    5c18:	22 e0       	ldi	r18, 0x02	; 2
    5c1a:	fc 01       	movw	r30, r24
    5c1c:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5c1e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5c20:	88 2f       	mov	r24, r24
    5c22:	90 e0       	ldi	r25, 0x00	; 0
    5c24:	82 30       	cpi	r24, 0x02	; 2
    5c26:	91 05       	cpc	r25, r1
    5c28:	31 f1       	breq	.+76     	; 0x5c76 <xTaskGenericNotifyFromISR+0xd0>
    5c2a:	83 30       	cpi	r24, 0x03	; 3
    5c2c:	91 05       	cpc	r25, r1
    5c2e:	34 f4       	brge	.+12     	; 0x5c3c <xTaskGenericNotifyFromISR+0x96>
    5c30:	00 97       	sbiw	r24, 0x00	; 0
    5c32:	09 f4       	brne	.+2      	; 0x5c36 <xTaskGenericNotifyFromISR+0x90>
    5c34:	4f c0       	rjmp	.+158    	; 0x5cd4 <xTaskGenericNotifyFromISR+0x12e>
    5c36:	01 97       	sbiw	r24, 0x01	; 1
    5c38:	39 f0       	breq	.+14     	; 0x5c48 <xTaskGenericNotifyFromISR+0xa2>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5c3a:	4d c0       	rjmp	.+154    	; 0x5cd6 <xTaskGenericNotifyFromISR+0x130>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5c3c:	83 30       	cpi	r24, 0x03	; 3
    5c3e:	91 05       	cpc	r25, r1
    5c40:	61 f1       	breq	.+88     	; 0x5c9a <xTaskGenericNotifyFromISR+0xf4>
    5c42:	04 97       	sbiw	r24, 0x04	; 4
    5c44:	b1 f1       	breq	.+108    	; 0x5cb2 <xTaskGenericNotifyFromISR+0x10c>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5c46:	47 c0       	rjmp	.+142    	; 0x5cd6 <xTaskGenericNotifyFromISR+0x130>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5c48:	8a 81       	ldd	r24, Y+2	; 0x02
    5c4a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c4c:	fc 01       	movw	r30, r24
    5c4e:	23 a1       	ldd	r18, Z+35	; 0x23
    5c50:	34 a1       	ldd	r19, Z+36	; 0x24
    5c52:	45 a1       	ldd	r20, Z+37	; 0x25
    5c54:	56 a1       	ldd	r21, Z+38	; 0x26
    5c56:	88 85       	ldd	r24, Y+8	; 0x08
    5c58:	99 85       	ldd	r25, Y+9	; 0x09
    5c5a:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c5c:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c5e:	82 2b       	or	r24, r18
    5c60:	93 2b       	or	r25, r19
    5c62:	a4 2b       	or	r26, r20
    5c64:	b5 2b       	or	r27, r21
    5c66:	2a 81       	ldd	r18, Y+2	; 0x02
    5c68:	3b 81       	ldd	r19, Y+3	; 0x03
    5c6a:	f9 01       	movw	r30, r18
    5c6c:	83 a3       	std	Z+35, r24	; 0x23
    5c6e:	94 a3       	std	Z+36, r25	; 0x24
    5c70:	a5 a3       	std	Z+37, r26	; 0x25
    5c72:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c74:	30 c0       	rjmp	.+96     	; 0x5cd6 <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5c76:	8a 81       	ldd	r24, Y+2	; 0x02
    5c78:	9b 81       	ldd	r25, Y+3	; 0x03
    5c7a:	fc 01       	movw	r30, r24
    5c7c:	83 a1       	ldd	r24, Z+35	; 0x23
    5c7e:	94 a1       	ldd	r25, Z+36	; 0x24
    5c80:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c82:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c84:	01 96       	adiw	r24, 0x01	; 1
    5c86:	a1 1d       	adc	r26, r1
    5c88:	b1 1d       	adc	r27, r1
    5c8a:	2a 81       	ldd	r18, Y+2	; 0x02
    5c8c:	3b 81       	ldd	r19, Y+3	; 0x03
    5c8e:	f9 01       	movw	r30, r18
    5c90:	83 a3       	std	Z+35, r24	; 0x23
    5c92:	94 a3       	std	Z+36, r25	; 0x24
    5c94:	a5 a3       	std	Z+37, r26	; 0x25
    5c96:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c98:	1e c0       	rjmp	.+60     	; 0x5cd6 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5c9a:	2a 81       	ldd	r18, Y+2	; 0x02
    5c9c:	3b 81       	ldd	r19, Y+3	; 0x03
    5c9e:	88 85       	ldd	r24, Y+8	; 0x08
    5ca0:	99 85       	ldd	r25, Y+9	; 0x09
    5ca2:	aa 85       	ldd	r26, Y+10	; 0x0a
    5ca4:	bb 85       	ldd	r27, Y+11	; 0x0b
    5ca6:	f9 01       	movw	r30, r18
    5ca8:	83 a3       	std	Z+35, r24	; 0x23
    5caa:	94 a3       	std	Z+36, r25	; 0x24
    5cac:	a5 a3       	std	Z+37, r26	; 0x25
    5cae:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5cb0:	12 c0       	rjmp	.+36     	; 0x5cd6 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5cb2:	8d 81       	ldd	r24, Y+5	; 0x05
    5cb4:	82 30       	cpi	r24, 0x02	; 2
    5cb6:	61 f0       	breq	.+24     	; 0x5cd0 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5cb8:	2a 81       	ldd	r18, Y+2	; 0x02
    5cba:	3b 81       	ldd	r19, Y+3	; 0x03
    5cbc:	88 85       	ldd	r24, Y+8	; 0x08
    5cbe:	99 85       	ldd	r25, Y+9	; 0x09
    5cc0:	aa 85       	ldd	r26, Y+10	; 0x0a
    5cc2:	bb 85       	ldd	r27, Y+11	; 0x0b
    5cc4:	f9 01       	movw	r30, r18
    5cc6:	83 a3       	std	Z+35, r24	; 0x23
    5cc8:	94 a3       	std	Z+36, r25	; 0x24
    5cca:	a5 a3       	std	Z+37, r26	; 0x25
    5ccc:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5cce:	03 c0       	rjmp	.+6      	; 0x5cd6 <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5cd0:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5cd2:	01 c0       	rjmp	.+2      	; 0x5cd6 <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    5cd4:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5cd6:	8d 81       	ldd	r24, Y+5	; 0x05
    5cd8:	81 30       	cpi	r24, 0x01	; 1
    5cda:	09 f0       	breq	.+2      	; 0x5cde <xTaskGenericNotifyFromISR+0x138>
    5cdc:	51 c0       	rjmp	.+162    	; 0x5d80 <xTaskGenericNotifyFromISR+0x1da>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5cde:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    5ce2:	88 23       	and	r24, r24
    5ce4:	69 f5       	brne	.+90     	; 0x5d40 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5ce6:	8a 81       	ldd	r24, Y+2	; 0x02
    5ce8:	9b 81       	ldd	r25, Y+3	; 0x03
    5cea:	02 96       	adiw	r24, 0x02	; 2
    5cec:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5cf0:	8a 81       	ldd	r24, Y+2	; 0x02
    5cf2:	9b 81       	ldd	r25, Y+3	; 0x03
    5cf4:	fc 01       	movw	r30, r24
    5cf6:	96 89       	ldd	r25, Z+22	; 0x16
    5cf8:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5cfc:	89 17       	cp	r24, r25
    5cfe:	30 f4       	brcc	.+12     	; 0x5d0c <xTaskGenericNotifyFromISR+0x166>
    5d00:	8a 81       	ldd	r24, Y+2	; 0x02
    5d02:	9b 81       	ldd	r25, Y+3	; 0x03
    5d04:	fc 01       	movw	r30, r24
    5d06:	86 89       	ldd	r24, Z+22	; 0x16
    5d08:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5d0c:	8a 81       	ldd	r24, Y+2	; 0x02
    5d0e:	9b 81       	ldd	r25, Y+3	; 0x03
    5d10:	ac 01       	movw	r20, r24
    5d12:	4e 5f       	subi	r20, 0xFE	; 254
    5d14:	5f 4f       	sbci	r21, 0xFF	; 255
    5d16:	8a 81       	ldd	r24, Y+2	; 0x02
    5d18:	9b 81       	ldd	r25, Y+3	; 0x03
    5d1a:	fc 01       	movw	r30, r24
    5d1c:	86 89       	ldd	r24, Z+22	; 0x16
    5d1e:	28 2f       	mov	r18, r24
    5d20:	30 e0       	ldi	r19, 0x00	; 0
    5d22:	c9 01       	movw	r24, r18
    5d24:	88 0f       	add	r24, r24
    5d26:	99 1f       	adc	r25, r25
    5d28:	88 0f       	add	r24, r24
    5d2a:	99 1f       	adc	r25, r25
    5d2c:	88 0f       	add	r24, r24
    5d2e:	99 1f       	adc	r25, r25
    5d30:	82 0f       	add	r24, r18
    5d32:	93 1f       	adc	r25, r19
    5d34:	8f 55       	subi	r24, 0x5F	; 95
    5d36:	99 4f       	sbci	r25, 0xF9	; 249
    5d38:	ba 01       	movw	r22, r20
    5d3a:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
    5d3e:	08 c0       	rjmp	.+16     	; 0x5d50 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5d40:	8a 81       	ldd	r24, Y+2	; 0x02
    5d42:	9b 81       	ldd	r25, Y+3	; 0x03
    5d44:	0c 96       	adiw	r24, 0x0c	; 12
    5d46:	bc 01       	movw	r22, r24
    5d48:	84 ee       	ldi	r24, 0xE4	; 228
    5d4a:	96 e0       	ldi	r25, 0x06	; 6
    5d4c:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5d50:	8a 81       	ldd	r24, Y+2	; 0x02
    5d52:	9b 81       	ldd	r25, Y+3	; 0x03
    5d54:	fc 01       	movw	r30, r24
    5d56:	26 89       	ldd	r18, Z+22	; 0x16
    5d58:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5d5c:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5d60:	fc 01       	movw	r30, r24
    5d62:	86 89       	ldd	r24, Z+22	; 0x16
    5d64:	82 17       	cp	r24, r18
    5d66:	60 f4       	brcc	.+24     	; 0x5d80 <xTaskGenericNotifyFromISR+0x1da>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5d68:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d6a:	98 89       	ldd	r25, Y+16	; 0x10
    5d6c:	89 2b       	or	r24, r25
    5d6e:	29 f0       	breq	.+10     	; 0x5d7a <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5d70:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d72:	98 89       	ldd	r25, Y+16	; 0x10
    5d74:	21 e0       	ldi	r18, 0x01	; 1
    5d76:	fc 01       	movw	r30, r24
    5d78:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5d7a:	81 e0       	ldi	r24, 0x01	; 1
    5d7c:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5d80:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5d82:	60 96       	adiw	r28, 0x10	; 16
    5d84:	0f b6       	in	r0, 0x3f	; 63
    5d86:	f8 94       	cli
    5d88:	de bf       	out	0x3e, r29	; 62
    5d8a:	0f be       	out	0x3f, r0	; 63
    5d8c:	cd bf       	out	0x3d, r28	; 61
    5d8e:	df 91       	pop	r29
    5d90:	cf 91       	pop	r28
    5d92:	1f 91       	pop	r17
    5d94:	0f 91       	pop	r16
    5d96:	ff 90       	pop	r15
    5d98:	ef 90       	pop	r14
    5d9a:	08 95       	ret

00005d9c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5d9c:	cf 93       	push	r28
    5d9e:	df 93       	push	r29
    5da0:	cd b7       	in	r28, 0x3d	; 61
    5da2:	de b7       	in	r29, 0x3e	; 62
    5da4:	28 97       	sbiw	r28, 0x08	; 8
    5da6:	0f b6       	in	r0, 0x3f	; 63
    5da8:	f8 94       	cli
    5daa:	de bf       	out	0x3e, r29	; 62
    5dac:	0f be       	out	0x3f, r0	; 63
    5dae:	cd bf       	out	0x3d, r28	; 61
    5db0:	9e 83       	std	Y+6, r25	; 0x06
    5db2:	8d 83       	std	Y+5, r24	; 0x05
    5db4:	78 87       	std	Y+8, r23	; 0x08
    5db6:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5db8:	8d 81       	ldd	r24, Y+5	; 0x05
    5dba:	9e 81       	ldd	r25, Y+6	; 0x06
    5dbc:	9a 83       	std	Y+2, r25	; 0x02
    5dbe:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5dc0:	1b 82       	std	Y+3, r1	; 0x03
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5dc2:	89 81       	ldd	r24, Y+1	; 0x01
    5dc4:	9a 81       	ldd	r25, Y+2	; 0x02
    5dc6:	fc 01       	movw	r30, r24
    5dc8:	87 a1       	ldd	r24, Z+39	; 0x27
    5dca:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5dcc:	89 81       	ldd	r24, Y+1	; 0x01
    5dce:	9a 81       	ldd	r25, Y+2	; 0x02
    5dd0:	22 e0       	ldi	r18, 0x02	; 2
    5dd2:	fc 01       	movw	r30, r24
    5dd4:	27 a3       	std	Z+39, r18	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5dd6:	89 81       	ldd	r24, Y+1	; 0x01
    5dd8:	9a 81       	ldd	r25, Y+2	; 0x02
    5dda:	fc 01       	movw	r30, r24
    5ddc:	83 a1       	ldd	r24, Z+35	; 0x23
    5dde:	94 a1       	ldd	r25, Z+36	; 0x24
    5de0:	a5 a1       	ldd	r26, Z+37	; 0x25
    5de2:	b6 a1       	ldd	r27, Z+38	; 0x26
    5de4:	01 96       	adiw	r24, 0x01	; 1
    5de6:	a1 1d       	adc	r26, r1
    5de8:	b1 1d       	adc	r27, r1
    5dea:	29 81       	ldd	r18, Y+1	; 0x01
    5dec:	3a 81       	ldd	r19, Y+2	; 0x02
    5dee:	f9 01       	movw	r30, r18
    5df0:	83 a3       	std	Z+35, r24	; 0x23
    5df2:	94 a3       	std	Z+36, r25	; 0x24
    5df4:	a5 a3       	std	Z+37, r26	; 0x25
    5df6:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5df8:	8c 81       	ldd	r24, Y+4	; 0x04
    5dfa:	81 30       	cpi	r24, 0x01	; 1
    5dfc:	09 f0       	breq	.+2      	; 0x5e00 <vTaskNotifyGiveFromISR+0x64>
    5dfe:	51 c0       	rjmp	.+162    	; 0x5ea2 <vTaskNotifyGiveFromISR+0x106>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5e00:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    5e04:	88 23       	and	r24, r24
    5e06:	69 f5       	brne	.+90     	; 0x5e62 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5e08:	89 81       	ldd	r24, Y+1	; 0x01
    5e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e0c:	02 96       	adiw	r24, 0x02	; 2
    5e0e:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5e12:	89 81       	ldd	r24, Y+1	; 0x01
    5e14:	9a 81       	ldd	r25, Y+2	; 0x02
    5e16:	fc 01       	movw	r30, r24
    5e18:	96 89       	ldd	r25, Z+22	; 0x16
    5e1a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5e1e:	89 17       	cp	r24, r25
    5e20:	30 f4       	brcc	.+12     	; 0x5e2e <vTaskNotifyGiveFromISR+0x92>
    5e22:	89 81       	ldd	r24, Y+1	; 0x01
    5e24:	9a 81       	ldd	r25, Y+2	; 0x02
    5e26:	fc 01       	movw	r30, r24
    5e28:	86 89       	ldd	r24, Z+22	; 0x16
    5e2a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5e2e:	89 81       	ldd	r24, Y+1	; 0x01
    5e30:	9a 81       	ldd	r25, Y+2	; 0x02
    5e32:	ac 01       	movw	r20, r24
    5e34:	4e 5f       	subi	r20, 0xFE	; 254
    5e36:	5f 4f       	sbci	r21, 0xFF	; 255
    5e38:	89 81       	ldd	r24, Y+1	; 0x01
    5e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e3c:	fc 01       	movw	r30, r24
    5e3e:	86 89       	ldd	r24, Z+22	; 0x16
    5e40:	28 2f       	mov	r18, r24
    5e42:	30 e0       	ldi	r19, 0x00	; 0
    5e44:	c9 01       	movw	r24, r18
    5e46:	88 0f       	add	r24, r24
    5e48:	99 1f       	adc	r25, r25
    5e4a:	88 0f       	add	r24, r24
    5e4c:	99 1f       	adc	r25, r25
    5e4e:	88 0f       	add	r24, r24
    5e50:	99 1f       	adc	r25, r25
    5e52:	82 0f       	add	r24, r18
    5e54:	93 1f       	adc	r25, r19
    5e56:	8f 55       	subi	r24, 0x5F	; 95
    5e58:	99 4f       	sbci	r25, 0xF9	; 249
    5e5a:	ba 01       	movw	r22, r20
    5e5c:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
    5e60:	08 c0       	rjmp	.+16     	; 0x5e72 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5e62:	89 81       	ldd	r24, Y+1	; 0x01
    5e64:	9a 81       	ldd	r25, Y+2	; 0x02
    5e66:	0c 96       	adiw	r24, 0x0c	; 12
    5e68:	bc 01       	movw	r22, r24
    5e6a:	84 ee       	ldi	r24, 0xE4	; 228
    5e6c:	96 e0       	ldi	r25, 0x06	; 6
    5e6e:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5e72:	89 81       	ldd	r24, Y+1	; 0x01
    5e74:	9a 81       	ldd	r25, Y+2	; 0x02
    5e76:	fc 01       	movw	r30, r24
    5e78:	26 89       	ldd	r18, Z+22	; 0x16
    5e7a:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5e7e:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5e82:	fc 01       	movw	r30, r24
    5e84:	86 89       	ldd	r24, Z+22	; 0x16
    5e86:	82 17       	cp	r24, r18
    5e88:	60 f4       	brcc	.+24     	; 0x5ea2 <vTaskNotifyGiveFromISR+0x106>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5e8a:	8f 81       	ldd	r24, Y+7	; 0x07
    5e8c:	98 85       	ldd	r25, Y+8	; 0x08
    5e8e:	89 2b       	or	r24, r25
    5e90:	29 f0       	breq	.+10     	; 0x5e9c <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5e92:	8f 81       	ldd	r24, Y+7	; 0x07
    5e94:	98 85       	ldd	r25, Y+8	; 0x08
    5e96:	21 e0       	ldi	r18, 0x01	; 1
    5e98:	fc 01       	movw	r30, r24
    5e9a:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5e9c:	81 e0       	ldi	r24, 0x01	; 1
    5e9e:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5ea2:	00 00       	nop
    5ea4:	28 96       	adiw	r28, 0x08	; 8
    5ea6:	0f b6       	in	r0, 0x3f	; 63
    5ea8:	f8 94       	cli
    5eaa:	de bf       	out	0x3e, r29	; 62
    5eac:	0f be       	out	0x3f, r0	; 63
    5eae:	cd bf       	out	0x3d, r28	; 61
    5eb0:	df 91       	pop	r29
    5eb2:	cf 91       	pop	r28
    5eb4:	08 95       	ret

00005eb6 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5eb6:	cf 93       	push	r28
    5eb8:	df 93       	push	r29
    5eba:	00 d0       	rcall	.+0      	; 0x5ebc <xTaskNotifyStateClear+0x6>
    5ebc:	00 d0       	rcall	.+0      	; 0x5ebe <xTaskNotifyStateClear+0x8>
    5ebe:	1f 92       	push	r1
    5ec0:	cd b7       	in	r28, 0x3d	; 61
    5ec2:	de b7       	in	r29, 0x3e	; 62
    5ec4:	9d 83       	std	Y+5, r25	; 0x05
    5ec6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5ec8:	8c 81       	ldd	r24, Y+4	; 0x04
    5eca:	9d 81       	ldd	r25, Y+5	; 0x05
    5ecc:	89 2b       	or	r24, r25
    5ece:	29 f4       	brne	.+10     	; 0x5eda <xTaskNotifyStateClear+0x24>
    5ed0:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5ed4:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5ed8:	02 c0       	rjmp	.+4      	; 0x5ede <xTaskNotifyStateClear+0x28>
    5eda:	8c 81       	ldd	r24, Y+4	; 0x04
    5edc:	9d 81       	ldd	r25, Y+5	; 0x05
    5ede:	9b 83       	std	Y+3, r25	; 0x03
    5ee0:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5ee2:	0f b6       	in	r0, 0x3f	; 63
    5ee4:	f8 94       	cli
    5ee6:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eea:	9b 81       	ldd	r25, Y+3	; 0x03
    5eec:	fc 01       	movw	r30, r24
    5eee:	87 a1       	ldd	r24, Z+39	; 0x27
    5ef0:	82 30       	cpi	r24, 0x02	; 2
    5ef2:	39 f4       	brne	.+14     	; 0x5f02 <xTaskNotifyStateClear+0x4c>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5ef4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ef6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ef8:	fc 01       	movw	r30, r24
    5efa:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5efc:	81 e0       	ldi	r24, 0x01	; 1
    5efe:	89 83       	std	Y+1, r24	; 0x01
    5f00:	01 c0       	rjmp	.+2      	; 0x5f04 <xTaskNotifyStateClear+0x4e>
			}
			else
			{
				xReturn = pdFAIL;
    5f02:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5f04:	0f 90       	pop	r0
    5f06:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5f08:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5f0a:	0f 90       	pop	r0
    5f0c:	0f 90       	pop	r0
    5f0e:	0f 90       	pop	r0
    5f10:	0f 90       	pop	r0
    5f12:	0f 90       	pop	r0
    5f14:	df 91       	pop	r29
    5f16:	cf 91       	pop	r28
    5f18:	08 95       	ret

00005f1a <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5f1a:	cf 93       	push	r28
    5f1c:	df 93       	push	r29
    5f1e:	cd b7       	in	r28, 0x3d	; 61
    5f20:	de b7       	in	r29, 0x3e	; 62
    5f22:	27 97       	sbiw	r28, 0x07	; 7
    5f24:	0f b6       	in	r0, 0x3f	; 63
    5f26:	f8 94       	cli
    5f28:	de bf       	out	0x3e, r29	; 62
    5f2a:	0f be       	out	0x3f, r0	; 63
    5f2c:	cd bf       	out	0x3d, r28	; 61
    5f2e:	9e 83       	std	Y+6, r25	; 0x06
    5f30:	8d 83       	std	Y+5, r24	; 0x05
    5f32:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5f34:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    5f38:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    5f3c:	9a 83       	std	Y+2, r25	; 0x02
    5f3e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5f40:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5f44:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5f48:	02 96       	adiw	r24, 0x02	; 2
    5f4a:	0e 94 27 14 	call	0x284e	; 0x284e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    5f50:	9e 81       	ldd	r25, Y+6	; 0x06
    5f52:	01 96       	adiw	r24, 0x01	; 1
    5f54:	71 f4       	brne	.+28     	; 0x5f72 <prvAddCurrentTaskToDelayedList+0x58>
    5f56:	8f 81       	ldd	r24, Y+7	; 0x07
    5f58:	88 23       	and	r24, r24
    5f5a:	59 f0       	breq	.+22     	; 0x5f72 <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5f5c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5f60:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5f64:	02 96       	adiw	r24, 0x02	; 2
    5f66:	bc 01       	movw	r22, r24
    5f68:	87 ef       	ldi	r24, 0xF7	; 247
    5f6a:	96 e0       	ldi	r25, 0x06	; 6
    5f6c:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f70:	44 c0       	rjmp	.+136    	; 0x5ffa <prvAddCurrentTaskToDelayedList+0xe0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    5f72:	29 81       	ldd	r18, Y+1	; 0x01
    5f74:	3a 81       	ldd	r19, Y+2	; 0x02
    5f76:	8d 81       	ldd	r24, Y+5	; 0x05
    5f78:	9e 81       	ldd	r25, Y+6	; 0x06
    5f7a:	82 0f       	add	r24, r18
    5f7c:	93 1f       	adc	r25, r19
    5f7e:	9c 83       	std	Y+4, r25	; 0x04
    5f80:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5f82:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5f86:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5f8a:	2b 81       	ldd	r18, Y+3	; 0x03
    5f8c:	3c 81       	ldd	r19, Y+4	; 0x04
    5f8e:	fc 01       	movw	r30, r24
    5f90:	33 83       	std	Z+3, r19	; 0x03
    5f92:	22 83       	std	Z+2, r18	; 0x02

			if( xTimeToWake < xConstTickCount )
    5f94:	2b 81       	ldd	r18, Y+3	; 0x03
    5f96:	3c 81       	ldd	r19, Y+4	; 0x04
    5f98:	89 81       	ldd	r24, Y+1	; 0x01
    5f9a:	9a 81       	ldd	r25, Y+2	; 0x02
    5f9c:	28 17       	cp	r18, r24
    5f9e:	39 07       	cpc	r19, r25
    5fa0:	78 f4       	brcc	.+30     	; 0x5fc0 <prvAddCurrentTaskToDelayedList+0xa6>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5fa2:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5fa6:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5faa:	9c 01       	movw	r18, r24
    5fac:	2e 5f       	subi	r18, 0xFE	; 254
    5fae:	3f 4f       	sbci	r19, 0xFF	; 255
    5fb0:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <pxOverflowDelayedTaskList>
    5fb4:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    5fb8:	b9 01       	movw	r22, r18
    5fba:	0e 94 af 13 	call	0x275e	; 0x275e <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5fbe:	1d c0       	rjmp	.+58     	; 0x5ffa <prvAddCurrentTaskToDelayedList+0xe0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5fc0:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5fc4:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5fc8:	9c 01       	movw	r18, r24
    5fca:	2e 5f       	subi	r18, 0xFE	; 254
    5fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    5fce:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    5fd2:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    5fd6:	b9 01       	movw	r22, r18
    5fd8:	0e 94 af 13 	call	0x275e	; 0x275e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5fdc:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xNextTaskUnblockTime>
    5fe0:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xNextTaskUnblockTime+0x1>
    5fe4:	2b 81       	ldd	r18, Y+3	; 0x03
    5fe6:	3c 81       	ldd	r19, Y+4	; 0x04
    5fe8:	28 17       	cp	r18, r24
    5fea:	39 07       	cpc	r19, r25
    5fec:	30 f4       	brcc	.+12     	; 0x5ffa <prvAddCurrentTaskToDelayedList+0xe0>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5fee:	8b 81       	ldd	r24, Y+3	; 0x03
    5ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    5ff2:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    5ff6:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5ffa:	00 00       	nop
    5ffc:	27 96       	adiw	r28, 0x07	; 7
    5ffe:	0f b6       	in	r0, 0x3f	; 63
    6000:	f8 94       	cli
    6002:	de bf       	out	0x3e, r29	; 62
    6004:	0f be       	out	0x3f, r0	; 63
    6006:	cd bf       	out	0x3d, r28	; 61
    6008:	df 91       	pop	r29
    600a:	cf 91       	pop	r28
    600c:	08 95       	ret

0000600e <__umulhisi3>:
    600e:	a2 9f       	mul	r26, r18
    6010:	b0 01       	movw	r22, r0
    6012:	b3 9f       	mul	r27, r19
    6014:	c0 01       	movw	r24, r0
    6016:	a3 9f       	mul	r26, r19
    6018:	70 0d       	add	r23, r0
    601a:	81 1d       	adc	r24, r1
    601c:	11 24       	eor	r1, r1
    601e:	91 1d       	adc	r25, r1
    6020:	b2 9f       	mul	r27, r18
    6022:	70 0d       	add	r23, r0
    6024:	81 1d       	adc	r24, r1
    6026:	11 24       	eor	r1, r1
    6028:	91 1d       	adc	r25, r1
    602a:	08 95       	ret

0000602c <__subsf3>:
    602c:	50 58       	subi	r21, 0x80	; 128

0000602e <__addsf3>:
    602e:	bb 27       	eor	r27, r27
    6030:	aa 27       	eor	r26, r26
    6032:	0e 94 2e 30 	call	0x605c	; 0x605c <__addsf3x>
    6036:	0c 94 64 31 	jmp	0x62c8	; 0x62c8 <__fp_round>
    603a:	0e 94 56 31 	call	0x62ac	; 0x62ac <__fp_pscA>
    603e:	38 f0       	brcs	.+14     	; 0x604e <__addsf3+0x20>
    6040:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__fp_pscB>
    6044:	20 f0       	brcs	.+8      	; 0x604e <__addsf3+0x20>
    6046:	39 f4       	brne	.+14     	; 0x6056 <__addsf3+0x28>
    6048:	9f 3f       	cpi	r25, 0xFF	; 255
    604a:	19 f4       	brne	.+6      	; 0x6052 <__addsf3+0x24>
    604c:	26 f4       	brtc	.+8      	; 0x6056 <__addsf3+0x28>
    604e:	0c 94 53 31 	jmp	0x62a6	; 0x62a6 <__fp_nan>
    6052:	0e f4       	brtc	.+2      	; 0x6056 <__addsf3+0x28>
    6054:	e0 95       	com	r30
    6056:	e7 fb       	bst	r30, 7
    6058:	0c 94 4d 31 	jmp	0x629a	; 0x629a <__fp_inf>

0000605c <__addsf3x>:
    605c:	e9 2f       	mov	r30, r25
    605e:	0e 94 75 31 	call	0x62ea	; 0x62ea <__fp_split3>
    6062:	58 f3       	brcs	.-42     	; 0x603a <__addsf3+0xc>
    6064:	ba 17       	cp	r27, r26
    6066:	62 07       	cpc	r22, r18
    6068:	73 07       	cpc	r23, r19
    606a:	84 07       	cpc	r24, r20
    606c:	95 07       	cpc	r25, r21
    606e:	20 f0       	brcs	.+8      	; 0x6078 <__addsf3x+0x1c>
    6070:	79 f4       	brne	.+30     	; 0x6090 <__addsf3x+0x34>
    6072:	a6 f5       	brtc	.+104    	; 0x60dc <__addsf3x+0x80>
    6074:	0c 94 97 31 	jmp	0x632e	; 0x632e <__fp_zero>
    6078:	0e f4       	brtc	.+2      	; 0x607c <__addsf3x+0x20>
    607a:	e0 95       	com	r30
    607c:	0b 2e       	mov	r0, r27
    607e:	ba 2f       	mov	r27, r26
    6080:	a0 2d       	mov	r26, r0
    6082:	0b 01       	movw	r0, r22
    6084:	b9 01       	movw	r22, r18
    6086:	90 01       	movw	r18, r0
    6088:	0c 01       	movw	r0, r24
    608a:	ca 01       	movw	r24, r20
    608c:	a0 01       	movw	r20, r0
    608e:	11 24       	eor	r1, r1
    6090:	ff 27       	eor	r31, r31
    6092:	59 1b       	sub	r21, r25
    6094:	99 f0       	breq	.+38     	; 0x60bc <__addsf3x+0x60>
    6096:	59 3f       	cpi	r21, 0xF9	; 249
    6098:	50 f4       	brcc	.+20     	; 0x60ae <__addsf3x+0x52>
    609a:	50 3e       	cpi	r21, 0xE0	; 224
    609c:	68 f1       	brcs	.+90     	; 0x60f8 <__addsf3x+0x9c>
    609e:	1a 16       	cp	r1, r26
    60a0:	f0 40       	sbci	r31, 0x00	; 0
    60a2:	a2 2f       	mov	r26, r18
    60a4:	23 2f       	mov	r18, r19
    60a6:	34 2f       	mov	r19, r20
    60a8:	44 27       	eor	r20, r20
    60aa:	58 5f       	subi	r21, 0xF8	; 248
    60ac:	f3 cf       	rjmp	.-26     	; 0x6094 <__addsf3x+0x38>
    60ae:	46 95       	lsr	r20
    60b0:	37 95       	ror	r19
    60b2:	27 95       	ror	r18
    60b4:	a7 95       	ror	r26
    60b6:	f0 40       	sbci	r31, 0x00	; 0
    60b8:	53 95       	inc	r21
    60ba:	c9 f7       	brne	.-14     	; 0x60ae <__addsf3x+0x52>
    60bc:	7e f4       	brtc	.+30     	; 0x60dc <__addsf3x+0x80>
    60be:	1f 16       	cp	r1, r31
    60c0:	ba 0b       	sbc	r27, r26
    60c2:	62 0b       	sbc	r22, r18
    60c4:	73 0b       	sbc	r23, r19
    60c6:	84 0b       	sbc	r24, r20
    60c8:	ba f0       	brmi	.+46     	; 0x60f8 <__addsf3x+0x9c>
    60ca:	91 50       	subi	r25, 0x01	; 1
    60cc:	a1 f0       	breq	.+40     	; 0x60f6 <__addsf3x+0x9a>
    60ce:	ff 0f       	add	r31, r31
    60d0:	bb 1f       	adc	r27, r27
    60d2:	66 1f       	adc	r22, r22
    60d4:	77 1f       	adc	r23, r23
    60d6:	88 1f       	adc	r24, r24
    60d8:	c2 f7       	brpl	.-16     	; 0x60ca <__addsf3x+0x6e>
    60da:	0e c0       	rjmp	.+28     	; 0x60f8 <__addsf3x+0x9c>
    60dc:	ba 0f       	add	r27, r26
    60de:	62 1f       	adc	r22, r18
    60e0:	73 1f       	adc	r23, r19
    60e2:	84 1f       	adc	r24, r20
    60e4:	48 f4       	brcc	.+18     	; 0x60f8 <__addsf3x+0x9c>
    60e6:	87 95       	ror	r24
    60e8:	77 95       	ror	r23
    60ea:	67 95       	ror	r22
    60ec:	b7 95       	ror	r27
    60ee:	f7 95       	ror	r31
    60f0:	9e 3f       	cpi	r25, 0xFE	; 254
    60f2:	08 f0       	brcs	.+2      	; 0x60f6 <__addsf3x+0x9a>
    60f4:	b0 cf       	rjmp	.-160    	; 0x6056 <__addsf3+0x28>
    60f6:	93 95       	inc	r25
    60f8:	88 0f       	add	r24, r24
    60fa:	08 f0       	brcs	.+2      	; 0x60fe <__addsf3x+0xa2>
    60fc:	99 27       	eor	r25, r25
    60fe:	ee 0f       	add	r30, r30
    6100:	97 95       	ror	r25
    6102:	87 95       	ror	r24
    6104:	08 95       	ret

00006106 <__cmpsf2>:
    6106:	0e 94 29 31 	call	0x6252	; 0x6252 <__fp_cmp>
    610a:	08 f4       	brcc	.+2      	; 0x610e <__cmpsf2+0x8>
    610c:	81 e0       	ldi	r24, 0x01	; 1
    610e:	08 95       	ret

00006110 <__divsf3>:
    6110:	0e 94 9c 30 	call	0x6138	; 0x6138 <__divsf3x>
    6114:	0c 94 64 31 	jmp	0x62c8	; 0x62c8 <__fp_round>
    6118:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__fp_pscB>
    611c:	58 f0       	brcs	.+22     	; 0x6134 <__divsf3+0x24>
    611e:	0e 94 56 31 	call	0x62ac	; 0x62ac <__fp_pscA>
    6122:	40 f0       	brcs	.+16     	; 0x6134 <__divsf3+0x24>
    6124:	29 f4       	brne	.+10     	; 0x6130 <__divsf3+0x20>
    6126:	5f 3f       	cpi	r21, 0xFF	; 255
    6128:	29 f0       	breq	.+10     	; 0x6134 <__divsf3+0x24>
    612a:	0c 94 4d 31 	jmp	0x629a	; 0x629a <__fp_inf>
    612e:	51 11       	cpse	r21, r1
    6130:	0c 94 98 31 	jmp	0x6330	; 0x6330 <__fp_szero>
    6134:	0c 94 53 31 	jmp	0x62a6	; 0x62a6 <__fp_nan>

00006138 <__divsf3x>:
    6138:	0e 94 75 31 	call	0x62ea	; 0x62ea <__fp_split3>
    613c:	68 f3       	brcs	.-38     	; 0x6118 <__divsf3+0x8>

0000613e <__divsf3_pse>:
    613e:	99 23       	and	r25, r25
    6140:	b1 f3       	breq	.-20     	; 0x612e <__divsf3+0x1e>
    6142:	55 23       	and	r21, r21
    6144:	91 f3       	breq	.-28     	; 0x612a <__divsf3+0x1a>
    6146:	95 1b       	sub	r25, r21
    6148:	55 0b       	sbc	r21, r21
    614a:	bb 27       	eor	r27, r27
    614c:	aa 27       	eor	r26, r26
    614e:	62 17       	cp	r22, r18
    6150:	73 07       	cpc	r23, r19
    6152:	84 07       	cpc	r24, r20
    6154:	38 f0       	brcs	.+14     	; 0x6164 <__divsf3_pse+0x26>
    6156:	9f 5f       	subi	r25, 0xFF	; 255
    6158:	5f 4f       	sbci	r21, 0xFF	; 255
    615a:	22 0f       	add	r18, r18
    615c:	33 1f       	adc	r19, r19
    615e:	44 1f       	adc	r20, r20
    6160:	aa 1f       	adc	r26, r26
    6162:	a9 f3       	breq	.-22     	; 0x614e <__divsf3_pse+0x10>
    6164:	35 d0       	rcall	.+106    	; 0x61d0 <__divsf3_pse+0x92>
    6166:	0e 2e       	mov	r0, r30
    6168:	3a f0       	brmi	.+14     	; 0x6178 <__divsf3_pse+0x3a>
    616a:	e0 e8       	ldi	r30, 0x80	; 128
    616c:	32 d0       	rcall	.+100    	; 0x61d2 <__divsf3_pse+0x94>
    616e:	91 50       	subi	r25, 0x01	; 1
    6170:	50 40       	sbci	r21, 0x00	; 0
    6172:	e6 95       	lsr	r30
    6174:	00 1c       	adc	r0, r0
    6176:	ca f7       	brpl	.-14     	; 0x616a <__divsf3_pse+0x2c>
    6178:	2b d0       	rcall	.+86     	; 0x61d0 <__divsf3_pse+0x92>
    617a:	fe 2f       	mov	r31, r30
    617c:	29 d0       	rcall	.+82     	; 0x61d0 <__divsf3_pse+0x92>
    617e:	66 0f       	add	r22, r22
    6180:	77 1f       	adc	r23, r23
    6182:	88 1f       	adc	r24, r24
    6184:	bb 1f       	adc	r27, r27
    6186:	26 17       	cp	r18, r22
    6188:	37 07       	cpc	r19, r23
    618a:	48 07       	cpc	r20, r24
    618c:	ab 07       	cpc	r26, r27
    618e:	b0 e8       	ldi	r27, 0x80	; 128
    6190:	09 f0       	breq	.+2      	; 0x6194 <__divsf3_pse+0x56>
    6192:	bb 0b       	sbc	r27, r27
    6194:	80 2d       	mov	r24, r0
    6196:	bf 01       	movw	r22, r30
    6198:	ff 27       	eor	r31, r31
    619a:	93 58       	subi	r25, 0x83	; 131
    619c:	5f 4f       	sbci	r21, 0xFF	; 255
    619e:	3a f0       	brmi	.+14     	; 0x61ae <__divsf3_pse+0x70>
    61a0:	9e 3f       	cpi	r25, 0xFE	; 254
    61a2:	51 05       	cpc	r21, r1
    61a4:	78 f0       	brcs	.+30     	; 0x61c4 <__divsf3_pse+0x86>
    61a6:	0c 94 4d 31 	jmp	0x629a	; 0x629a <__fp_inf>
    61aa:	0c 94 98 31 	jmp	0x6330	; 0x6330 <__fp_szero>
    61ae:	5f 3f       	cpi	r21, 0xFF	; 255
    61b0:	e4 f3       	brlt	.-8      	; 0x61aa <__divsf3_pse+0x6c>
    61b2:	98 3e       	cpi	r25, 0xE8	; 232
    61b4:	d4 f3       	brlt	.-12     	; 0x61aa <__divsf3_pse+0x6c>
    61b6:	86 95       	lsr	r24
    61b8:	77 95       	ror	r23
    61ba:	67 95       	ror	r22
    61bc:	b7 95       	ror	r27
    61be:	f7 95       	ror	r31
    61c0:	9f 5f       	subi	r25, 0xFF	; 255
    61c2:	c9 f7       	brne	.-14     	; 0x61b6 <__divsf3_pse+0x78>
    61c4:	88 0f       	add	r24, r24
    61c6:	91 1d       	adc	r25, r1
    61c8:	96 95       	lsr	r25
    61ca:	87 95       	ror	r24
    61cc:	97 f9       	bld	r25, 7
    61ce:	08 95       	ret
    61d0:	e1 e0       	ldi	r30, 0x01	; 1
    61d2:	66 0f       	add	r22, r22
    61d4:	77 1f       	adc	r23, r23
    61d6:	88 1f       	adc	r24, r24
    61d8:	bb 1f       	adc	r27, r27
    61da:	62 17       	cp	r22, r18
    61dc:	73 07       	cpc	r23, r19
    61de:	84 07       	cpc	r24, r20
    61e0:	ba 07       	cpc	r27, r26
    61e2:	20 f0       	brcs	.+8      	; 0x61ec <__divsf3_pse+0xae>
    61e4:	62 1b       	sub	r22, r18
    61e6:	73 0b       	sbc	r23, r19
    61e8:	84 0b       	sbc	r24, r20
    61ea:	ba 0b       	sbc	r27, r26
    61ec:	ee 1f       	adc	r30, r30
    61ee:	88 f7       	brcc	.-30     	; 0x61d2 <__divsf3_pse+0x94>
    61f0:	e0 95       	com	r30
    61f2:	08 95       	ret

000061f4 <__fixunssfsi>:
    61f4:	0e 94 7d 31 	call	0x62fa	; 0x62fa <__fp_splitA>
    61f8:	88 f0       	brcs	.+34     	; 0x621c <__fixunssfsi+0x28>
    61fa:	9f 57       	subi	r25, 0x7F	; 127
    61fc:	98 f0       	brcs	.+38     	; 0x6224 <__fixunssfsi+0x30>
    61fe:	b9 2f       	mov	r27, r25
    6200:	99 27       	eor	r25, r25
    6202:	b7 51       	subi	r27, 0x17	; 23
    6204:	b0 f0       	brcs	.+44     	; 0x6232 <__fixunssfsi+0x3e>
    6206:	e1 f0       	breq	.+56     	; 0x6240 <__fixunssfsi+0x4c>
    6208:	66 0f       	add	r22, r22
    620a:	77 1f       	adc	r23, r23
    620c:	88 1f       	adc	r24, r24
    620e:	99 1f       	adc	r25, r25
    6210:	1a f0       	brmi	.+6      	; 0x6218 <__fixunssfsi+0x24>
    6212:	ba 95       	dec	r27
    6214:	c9 f7       	brne	.-14     	; 0x6208 <__fixunssfsi+0x14>
    6216:	14 c0       	rjmp	.+40     	; 0x6240 <__fixunssfsi+0x4c>
    6218:	b1 30       	cpi	r27, 0x01	; 1
    621a:	91 f0       	breq	.+36     	; 0x6240 <__fixunssfsi+0x4c>
    621c:	0e 94 97 31 	call	0x632e	; 0x632e <__fp_zero>
    6220:	b1 e0       	ldi	r27, 0x01	; 1
    6222:	08 95       	ret
    6224:	0c 94 97 31 	jmp	0x632e	; 0x632e <__fp_zero>
    6228:	67 2f       	mov	r22, r23
    622a:	78 2f       	mov	r23, r24
    622c:	88 27       	eor	r24, r24
    622e:	b8 5f       	subi	r27, 0xF8	; 248
    6230:	39 f0       	breq	.+14     	; 0x6240 <__fixunssfsi+0x4c>
    6232:	b9 3f       	cpi	r27, 0xF9	; 249
    6234:	cc f3       	brlt	.-14     	; 0x6228 <__fixunssfsi+0x34>
    6236:	86 95       	lsr	r24
    6238:	77 95       	ror	r23
    623a:	67 95       	ror	r22
    623c:	b3 95       	inc	r27
    623e:	d9 f7       	brne	.-10     	; 0x6236 <__fixunssfsi+0x42>
    6240:	3e f4       	brtc	.+14     	; 0x6250 <__fixunssfsi+0x5c>
    6242:	90 95       	com	r25
    6244:	80 95       	com	r24
    6246:	70 95       	com	r23
    6248:	61 95       	neg	r22
    624a:	7f 4f       	sbci	r23, 0xFF	; 255
    624c:	8f 4f       	sbci	r24, 0xFF	; 255
    624e:	9f 4f       	sbci	r25, 0xFF	; 255
    6250:	08 95       	ret

00006252 <__fp_cmp>:
    6252:	99 0f       	add	r25, r25
    6254:	00 08       	sbc	r0, r0
    6256:	55 0f       	add	r21, r21
    6258:	aa 0b       	sbc	r26, r26
    625a:	e0 e8       	ldi	r30, 0x80	; 128
    625c:	fe ef       	ldi	r31, 0xFE	; 254
    625e:	16 16       	cp	r1, r22
    6260:	17 06       	cpc	r1, r23
    6262:	e8 07       	cpc	r30, r24
    6264:	f9 07       	cpc	r31, r25
    6266:	c0 f0       	brcs	.+48     	; 0x6298 <__fp_cmp+0x46>
    6268:	12 16       	cp	r1, r18
    626a:	13 06       	cpc	r1, r19
    626c:	e4 07       	cpc	r30, r20
    626e:	f5 07       	cpc	r31, r21
    6270:	98 f0       	brcs	.+38     	; 0x6298 <__fp_cmp+0x46>
    6272:	62 1b       	sub	r22, r18
    6274:	73 0b       	sbc	r23, r19
    6276:	84 0b       	sbc	r24, r20
    6278:	95 0b       	sbc	r25, r21
    627a:	39 f4       	brne	.+14     	; 0x628a <__fp_cmp+0x38>
    627c:	0a 26       	eor	r0, r26
    627e:	61 f0       	breq	.+24     	; 0x6298 <__fp_cmp+0x46>
    6280:	23 2b       	or	r18, r19
    6282:	24 2b       	or	r18, r20
    6284:	25 2b       	or	r18, r21
    6286:	21 f4       	brne	.+8      	; 0x6290 <__fp_cmp+0x3e>
    6288:	08 95       	ret
    628a:	0a 26       	eor	r0, r26
    628c:	09 f4       	brne	.+2      	; 0x6290 <__fp_cmp+0x3e>
    628e:	a1 40       	sbci	r26, 0x01	; 1
    6290:	a6 95       	lsr	r26
    6292:	8f ef       	ldi	r24, 0xFF	; 255
    6294:	81 1d       	adc	r24, r1
    6296:	81 1d       	adc	r24, r1
    6298:	08 95       	ret

0000629a <__fp_inf>:
    629a:	97 f9       	bld	r25, 7
    629c:	9f 67       	ori	r25, 0x7F	; 127
    629e:	80 e8       	ldi	r24, 0x80	; 128
    62a0:	70 e0       	ldi	r23, 0x00	; 0
    62a2:	60 e0       	ldi	r22, 0x00	; 0
    62a4:	08 95       	ret

000062a6 <__fp_nan>:
    62a6:	9f ef       	ldi	r25, 0xFF	; 255
    62a8:	80 ec       	ldi	r24, 0xC0	; 192
    62aa:	08 95       	ret

000062ac <__fp_pscA>:
    62ac:	00 24       	eor	r0, r0
    62ae:	0a 94       	dec	r0
    62b0:	16 16       	cp	r1, r22
    62b2:	17 06       	cpc	r1, r23
    62b4:	18 06       	cpc	r1, r24
    62b6:	09 06       	cpc	r0, r25
    62b8:	08 95       	ret

000062ba <__fp_pscB>:
    62ba:	00 24       	eor	r0, r0
    62bc:	0a 94       	dec	r0
    62be:	12 16       	cp	r1, r18
    62c0:	13 06       	cpc	r1, r19
    62c2:	14 06       	cpc	r1, r20
    62c4:	05 06       	cpc	r0, r21
    62c6:	08 95       	ret

000062c8 <__fp_round>:
    62c8:	09 2e       	mov	r0, r25
    62ca:	03 94       	inc	r0
    62cc:	00 0c       	add	r0, r0
    62ce:	11 f4       	brne	.+4      	; 0x62d4 <__fp_round+0xc>
    62d0:	88 23       	and	r24, r24
    62d2:	52 f0       	brmi	.+20     	; 0x62e8 <__fp_round+0x20>
    62d4:	bb 0f       	add	r27, r27
    62d6:	40 f4       	brcc	.+16     	; 0x62e8 <__fp_round+0x20>
    62d8:	bf 2b       	or	r27, r31
    62da:	11 f4       	brne	.+4      	; 0x62e0 <__fp_round+0x18>
    62dc:	60 ff       	sbrs	r22, 0
    62de:	04 c0       	rjmp	.+8      	; 0x62e8 <__fp_round+0x20>
    62e0:	6f 5f       	subi	r22, 0xFF	; 255
    62e2:	7f 4f       	sbci	r23, 0xFF	; 255
    62e4:	8f 4f       	sbci	r24, 0xFF	; 255
    62e6:	9f 4f       	sbci	r25, 0xFF	; 255
    62e8:	08 95       	ret

000062ea <__fp_split3>:
    62ea:	57 fd       	sbrc	r21, 7
    62ec:	90 58       	subi	r25, 0x80	; 128
    62ee:	44 0f       	add	r20, r20
    62f0:	55 1f       	adc	r21, r21
    62f2:	59 f0       	breq	.+22     	; 0x630a <__fp_splitA+0x10>
    62f4:	5f 3f       	cpi	r21, 0xFF	; 255
    62f6:	71 f0       	breq	.+28     	; 0x6314 <__fp_splitA+0x1a>
    62f8:	47 95       	ror	r20

000062fa <__fp_splitA>:
    62fa:	88 0f       	add	r24, r24
    62fc:	97 fb       	bst	r25, 7
    62fe:	99 1f       	adc	r25, r25
    6300:	61 f0       	breq	.+24     	; 0x631a <__fp_splitA+0x20>
    6302:	9f 3f       	cpi	r25, 0xFF	; 255
    6304:	79 f0       	breq	.+30     	; 0x6324 <__fp_splitA+0x2a>
    6306:	87 95       	ror	r24
    6308:	08 95       	ret
    630a:	12 16       	cp	r1, r18
    630c:	13 06       	cpc	r1, r19
    630e:	14 06       	cpc	r1, r20
    6310:	55 1f       	adc	r21, r21
    6312:	f2 cf       	rjmp	.-28     	; 0x62f8 <__fp_split3+0xe>
    6314:	46 95       	lsr	r20
    6316:	f1 df       	rcall	.-30     	; 0x62fa <__fp_splitA>
    6318:	08 c0       	rjmp	.+16     	; 0x632a <__fp_splitA+0x30>
    631a:	16 16       	cp	r1, r22
    631c:	17 06       	cpc	r1, r23
    631e:	18 06       	cpc	r1, r24
    6320:	99 1f       	adc	r25, r25
    6322:	f1 cf       	rjmp	.-30     	; 0x6306 <__fp_splitA+0xc>
    6324:	86 95       	lsr	r24
    6326:	71 05       	cpc	r23, r1
    6328:	61 05       	cpc	r22, r1
    632a:	08 94       	sec
    632c:	08 95       	ret

0000632e <__fp_zero>:
    632e:	e8 94       	clt

00006330 <__fp_szero>:
    6330:	bb 27       	eor	r27, r27
    6332:	66 27       	eor	r22, r22
    6334:	77 27       	eor	r23, r23
    6336:	cb 01       	movw	r24, r22
    6338:	97 f9       	bld	r25, 7
    633a:	08 95       	ret

0000633c <__gesf2>:
    633c:	0e 94 29 31 	call	0x6252	; 0x6252 <__fp_cmp>
    6340:	08 f4       	brcc	.+2      	; 0x6344 <__gesf2+0x8>
    6342:	8f ef       	ldi	r24, 0xFF	; 255
    6344:	08 95       	ret

00006346 <__mulsf3>:
    6346:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3x>
    634a:	0c 94 64 31 	jmp	0x62c8	; 0x62c8 <__fp_round>
    634e:	0e 94 56 31 	call	0x62ac	; 0x62ac <__fp_pscA>
    6352:	38 f0       	brcs	.+14     	; 0x6362 <__mulsf3+0x1c>
    6354:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__fp_pscB>
    6358:	20 f0       	brcs	.+8      	; 0x6362 <__mulsf3+0x1c>
    635a:	95 23       	and	r25, r21
    635c:	11 f0       	breq	.+4      	; 0x6362 <__mulsf3+0x1c>
    635e:	0c 94 4d 31 	jmp	0x629a	; 0x629a <__fp_inf>
    6362:	0c 94 53 31 	jmp	0x62a6	; 0x62a6 <__fp_nan>
    6366:	11 24       	eor	r1, r1
    6368:	0c 94 98 31 	jmp	0x6330	; 0x6330 <__fp_szero>

0000636c <__mulsf3x>:
    636c:	0e 94 75 31 	call	0x62ea	; 0x62ea <__fp_split3>
    6370:	70 f3       	brcs	.-36     	; 0x634e <__mulsf3+0x8>

00006372 <__mulsf3_pse>:
    6372:	95 9f       	mul	r25, r21
    6374:	c1 f3       	breq	.-16     	; 0x6366 <__mulsf3+0x20>
    6376:	95 0f       	add	r25, r21
    6378:	50 e0       	ldi	r21, 0x00	; 0
    637a:	55 1f       	adc	r21, r21
    637c:	62 9f       	mul	r22, r18
    637e:	f0 01       	movw	r30, r0
    6380:	72 9f       	mul	r23, r18
    6382:	bb 27       	eor	r27, r27
    6384:	f0 0d       	add	r31, r0
    6386:	b1 1d       	adc	r27, r1
    6388:	63 9f       	mul	r22, r19
    638a:	aa 27       	eor	r26, r26
    638c:	f0 0d       	add	r31, r0
    638e:	b1 1d       	adc	r27, r1
    6390:	aa 1f       	adc	r26, r26
    6392:	64 9f       	mul	r22, r20
    6394:	66 27       	eor	r22, r22
    6396:	b0 0d       	add	r27, r0
    6398:	a1 1d       	adc	r26, r1
    639a:	66 1f       	adc	r22, r22
    639c:	82 9f       	mul	r24, r18
    639e:	22 27       	eor	r18, r18
    63a0:	b0 0d       	add	r27, r0
    63a2:	a1 1d       	adc	r26, r1
    63a4:	62 1f       	adc	r22, r18
    63a6:	73 9f       	mul	r23, r19
    63a8:	b0 0d       	add	r27, r0
    63aa:	a1 1d       	adc	r26, r1
    63ac:	62 1f       	adc	r22, r18
    63ae:	83 9f       	mul	r24, r19
    63b0:	a0 0d       	add	r26, r0
    63b2:	61 1d       	adc	r22, r1
    63b4:	22 1f       	adc	r18, r18
    63b6:	74 9f       	mul	r23, r20
    63b8:	33 27       	eor	r19, r19
    63ba:	a0 0d       	add	r26, r0
    63bc:	61 1d       	adc	r22, r1
    63be:	23 1f       	adc	r18, r19
    63c0:	84 9f       	mul	r24, r20
    63c2:	60 0d       	add	r22, r0
    63c4:	21 1d       	adc	r18, r1
    63c6:	82 2f       	mov	r24, r18
    63c8:	76 2f       	mov	r23, r22
    63ca:	6a 2f       	mov	r22, r26
    63cc:	11 24       	eor	r1, r1
    63ce:	9f 57       	subi	r25, 0x7F	; 127
    63d0:	50 40       	sbci	r21, 0x00	; 0
    63d2:	9a f0       	brmi	.+38     	; 0x63fa <__mulsf3_pse+0x88>
    63d4:	f1 f0       	breq	.+60     	; 0x6412 <__mulsf3_pse+0xa0>
    63d6:	88 23       	and	r24, r24
    63d8:	4a f0       	brmi	.+18     	; 0x63ec <__mulsf3_pse+0x7a>
    63da:	ee 0f       	add	r30, r30
    63dc:	ff 1f       	adc	r31, r31
    63de:	bb 1f       	adc	r27, r27
    63e0:	66 1f       	adc	r22, r22
    63e2:	77 1f       	adc	r23, r23
    63e4:	88 1f       	adc	r24, r24
    63e6:	91 50       	subi	r25, 0x01	; 1
    63e8:	50 40       	sbci	r21, 0x00	; 0
    63ea:	a9 f7       	brne	.-22     	; 0x63d6 <__mulsf3_pse+0x64>
    63ec:	9e 3f       	cpi	r25, 0xFE	; 254
    63ee:	51 05       	cpc	r21, r1
    63f0:	80 f0       	brcs	.+32     	; 0x6412 <__mulsf3_pse+0xa0>
    63f2:	0c 94 4d 31 	jmp	0x629a	; 0x629a <__fp_inf>
    63f6:	0c 94 98 31 	jmp	0x6330	; 0x6330 <__fp_szero>
    63fa:	5f 3f       	cpi	r21, 0xFF	; 255
    63fc:	e4 f3       	brlt	.-8      	; 0x63f6 <__mulsf3_pse+0x84>
    63fe:	98 3e       	cpi	r25, 0xE8	; 232
    6400:	d4 f3       	brlt	.-12     	; 0x63f6 <__mulsf3_pse+0x84>
    6402:	86 95       	lsr	r24
    6404:	77 95       	ror	r23
    6406:	67 95       	ror	r22
    6408:	b7 95       	ror	r27
    640a:	f7 95       	ror	r31
    640c:	e7 95       	ror	r30
    640e:	9f 5f       	subi	r25, 0xFF	; 255
    6410:	c1 f7       	brne	.-16     	; 0x6402 <__mulsf3_pse+0x90>
    6412:	fe 2b       	or	r31, r30
    6414:	88 0f       	add	r24, r24
    6416:	91 1d       	adc	r25, r1
    6418:	96 95       	lsr	r25
    641a:	87 95       	ror	r24
    641c:	97 f9       	bld	r25, 7
    641e:	08 95       	ret

00006420 <memcpy>:
    6420:	fb 01       	movw	r30, r22
    6422:	dc 01       	movw	r26, r24
    6424:	02 c0       	rjmp	.+4      	; 0x642a <memcpy+0xa>
    6426:	01 90       	ld	r0, Z+
    6428:	0d 92       	st	X+, r0
    642a:	41 50       	subi	r20, 0x01	; 1
    642c:	50 40       	sbci	r21, 0x00	; 0
    642e:	d8 f7       	brcc	.-10     	; 0x6426 <memcpy+0x6>
    6430:	08 95       	ret

00006432 <_exit>:
    6432:	f8 94       	cli

00006434 <__stop_program>:
    6434:	ff cf       	rjmp	.-2      	; 0x6434 <__stop_program>

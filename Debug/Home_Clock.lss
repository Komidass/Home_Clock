
Home_Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006468  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  00006468  000064fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000065e  008000a8  008000a8  00006544  2**0
                  ALLOC
  3 .stab         0000af08  00000000  00000000  00006544  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004dc6  00000000  00000000  0001144c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00016212  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00016224  2**2
                  CONTENTS, READONLY
  7 .debug_info   000004e6  00000000  00000000  00016260  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004a3  00000000  00000000  00016746  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00016be9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000196  00000000  00000000  00016c03  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 eb 17 	jmp	0x2fd6	; 0x2fd6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e6       	ldi	r30, 0x68	; 104
      68:	f4 e6       	ldi	r31, 0x64	; 100
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 3a       	cpi	r26, 0xA8	; 168
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a8 ea       	ldi	r26, 0xA8	; 168
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 30       	cpi	r26, 0x06	; 6
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 97 14 	call	0x292e	; 0x292e <main>
      8a:	0c 94 32 32 	jmp	0x6464	; 0x6464 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Clock_Print_Default_Interface>:
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	80 e0       	ldi	r24, 0x00	; 0
      9c:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
      a0:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <Hours>
      a4:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <LCD_Void_Write_Number_2>
      a8:	82 e0       	ldi	r24, 0x02	; 2
      aa:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
      ae:	8a e3       	ldi	r24, 0x3A	; 58
      b0:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
      b4:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <Minutes>
      b8:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <LCD_Void_Write_Number_2>
      bc:	85 e0       	ldi	r24, 0x05	; 5
      be:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
      c2:	8a e3       	ldi	r24, 0x3A	; 58
      c4:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
      c8:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <__data_end>
      cc:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <LCD_Void_Write_Number_2>
      d0:	00 00       	nop
      d2:	df 91       	pop	r29
      d4:	cf 91       	pop	r28
      d6:	08 95       	ret

000000d8 <Clock_Second>:
	LCD_Void_Write_Number_2(Seconds);

}

void Clock_Second(void *pvParameters)
{
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	00 d0       	rcall	.+0      	; 0xde <Clock_Second+0x6>
      de:	00 d0       	rcall	.+0      	; 0xe0 <Clock_Second+0x8>
      e0:	cd b7       	in	r28, 0x3d	; 61
      e2:	de b7       	in	r29, 0x3e	; 62
      e4:	9c 83       	std	Y+4, r25	; 0x04
      e6:	8b 83       	std	Y+3, r24	; 0x03
	LCD = xSemaphoreCreateMutex();
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	0e 94 3a 19 	call	0x3274	; 0x3274 <xQueueCreateMutex>
      ee:	90 93 fd 06 	sts	0x06FD, r25	; 0x8006fd <LCD+0x1>
      f2:	80 93 fc 06 	sts	0x06FC, r24	; 0x8006fc <LCD>
	TickType_t MyLastUnblockS;
	MyLastUnblockS = xTaskGetTickCount();
      f6:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGetTickCount>
      fa:	9a 83       	std	Y+2, r25	; 0x02
      fc:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(seconds_position-1);
      fe:	85 e0       	ldi	r24, 0x05	; 5
     100:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     104:	8a e3       	ldi	r24, 0x3A	; 58
     106:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     10a:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     10e:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     112:	6a e0       	ldi	r22, 0x0A	; 10
     114:	70 e0       	ldi	r23, 0x00	; 0
     116:	0e 94 75 1b 	call	0x36ea	; 0x36ea <xQueueSemaphoreTake>
     11a:	88 23       	and	r24, r24
     11c:	91 f0       	breq	.+36     	; 0x142 <Clock_Second+0x6a>
		{
			LCD_Set_Block(seconds_position);
     11e:	86 e0       	ldi	r24, 0x06	; 6
     120:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
			LCD_Void_Write_Number_2(Seconds);
     124:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <__data_end>
     128:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     12c:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     130:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     134:	20 e0       	ldi	r18, 0x00	; 0
     136:	40 e0       	ldi	r20, 0x00	; 0
     138:	50 e0       	ldi	r21, 0x00	; 0
     13a:	60 e0       	ldi	r22, 0x00	; 0
     13c:	70 e0       	ldi	r23, 0x00	; 0
     13e:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <xQueueGenericSend>
		}
		vTaskDelayUntil(&MyLastUnblockS,seconds_frequency);
     142:	65 e0       	ldi	r22, 0x05	; 5
     144:	70 e0       	ldi	r23, 0x00	; 0
     146:	ce 01       	movw	r24, r28
     148:	01 96       	adiw	r24, 0x01	; 1
     14a:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskDelayUntil>
		Seconds++;
     14e:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <__data_end>
     152:	8f 5f       	subi	r24, 0xFF	; 255
     154:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__data_end>
		Seconds %= 60;
     158:	90 91 a8 00 	lds	r25, 0x00A8	; 0x8000a8 <__data_end>
     15c:	89 e8       	ldi	r24, 0x89	; 137
     15e:	98 9f       	mul	r25, r24
     160:	81 2d       	mov	r24, r1
     162:	11 24       	eor	r1, r1
     164:	82 95       	swap	r24
     166:	86 95       	lsr	r24
     168:	87 70       	andi	r24, 0x07	; 7
     16a:	2c e3       	ldi	r18, 0x3C	; 60
     16c:	82 9f       	mul	r24, r18
     16e:	80 2d       	mov	r24, r0
     170:	11 24       	eor	r1, r1
     172:	29 2f       	mov	r18, r25
     174:	28 1b       	sub	r18, r24
     176:	82 2f       	mov	r24, r18
     178:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__data_end>
	}
     17c:	c6 cf       	rjmp	.-116    	; 0x10a <Clock_Second+0x32>

0000017e <Clock_Minute>:
}

void Clock_Minute(void *pvParameters)
{
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
     182:	00 d0       	rcall	.+0      	; 0x184 <Clock_Minute+0x6>
     184:	00 d0       	rcall	.+0      	; 0x186 <Clock_Minute+0x8>
     186:	cd b7       	in	r28, 0x3d	; 61
     188:	de b7       	in	r29, 0x3e	; 62
     18a:	9c 83       	std	Y+4, r25	; 0x04
     18c:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockM;
	MyLastUnblockM = xTaskGetTickCount();
     18e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGetTickCount>
     192:	9a 83       	std	Y+2, r25	; 0x02
     194:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     196:	82 e0       	ldi	r24, 0x02	; 2
     198:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     19c:	8a e3       	ldi	r24, 0x3A	; 58
     19e:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     1a2:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     1a6:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     1aa:	6a e0       	ldi	r22, 0x0A	; 10
     1ac:	70 e0       	ldi	r23, 0x00	; 0
     1ae:	0e 94 75 1b 	call	0x36ea	; 0x36ea <xQueueSemaphoreTake>
     1b2:	88 23       	and	r24, r24
     1b4:	91 f0       	breq	.+36     	; 0x1da <Clock_Minute+0x5c>
		{
			LCD_Set_Block(minutes_position);
     1b6:	83 e0       	ldi	r24, 0x03	; 3
     1b8:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
			LCD_Void_Write_Number_2(Minutes);
     1bc:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <Minutes>
     1c0:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     1c4:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     1c8:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     1cc:	20 e0       	ldi	r18, 0x00	; 0
     1ce:	40 e0       	ldi	r20, 0x00	; 0
     1d0:	50 e0       	ldi	r21, 0x00	; 0
     1d2:	60 e0       	ldi	r22, 0x00	; 0
     1d4:	70 e0       	ldi	r23, 0x00	; 0
     1d6:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockM,minutes_frequency);
     1da:	6c e2       	ldi	r22, 0x2C	; 44
     1dc:	71 e0       	ldi	r23, 0x01	; 1
     1de:	ce 01       	movw	r24, r28
     1e0:	01 96       	adiw	r24, 0x01	; 1
     1e2:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskDelayUntil>
		Minutes++;
     1e6:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <Minutes>
     1ea:	8f 5f       	subi	r24, 0xFF	; 255
     1ec:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <Minutes>
		Minutes %= 60;
     1f0:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <Minutes>
     1f4:	89 e8       	ldi	r24, 0x89	; 137
     1f6:	98 9f       	mul	r25, r24
     1f8:	81 2d       	mov	r24, r1
     1fa:	11 24       	eor	r1, r1
     1fc:	82 95       	swap	r24
     1fe:	86 95       	lsr	r24
     200:	87 70       	andi	r24, 0x07	; 7
     202:	2c e3       	ldi	r18, 0x3C	; 60
     204:	82 9f       	mul	r24, r18
     206:	80 2d       	mov	r24, r0
     208:	11 24       	eor	r1, r1
     20a:	29 2f       	mov	r18, r25
     20c:	28 1b       	sub	r18, r24
     20e:	82 2f       	mov	r24, r18
     210:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <Minutes>
	}
     214:	c6 cf       	rjmp	.-116    	; 0x1a2 <Clock_Minute+0x24>

00000216 <Clock_Hours>:
}
void Clock_Hours(void *pvParameters)
{
     216:	cf 93       	push	r28
     218:	df 93       	push	r29
     21a:	00 d0       	rcall	.+0      	; 0x21c <Clock_Hours+0x6>
     21c:	00 d0       	rcall	.+0      	; 0x21e <Clock_Hours+0x8>
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
     222:	9c 83       	std	Y+4, r25	; 0x04
     224:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockH;
	MyLastUnblockH = xTaskGetTickCount();
     226:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGetTickCount>
     22a:	9a 83       	std	Y+2, r25	; 0x02
     22c:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     22e:	82 e0       	ldi	r24, 0x02	; 2
     230:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     234:	8a e3       	ldi	r24, 0x3A	; 58
     236:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     23a:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     23e:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     242:	6a e0       	ldi	r22, 0x0A	; 10
     244:	70 e0       	ldi	r23, 0x00	; 0
     246:	0e 94 75 1b 	call	0x36ea	; 0x36ea <xQueueSemaphoreTake>
     24a:	88 23       	and	r24, r24
     24c:	19 f1       	breq	.+70     	; 0x294 <Clock_Hours+0x7e>
		{
			LCD_Set_Block(hours_position);
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
			LCD_Void_Write_Number_2((Hours%12)+1);
     254:	20 91 aa 00 	lds	r18, 0x00AA	; 0x8000aa <Hours>
     258:	8b ea       	ldi	r24, 0xAB	; 171
     25a:	28 9f       	mul	r18, r24
     25c:	81 2d       	mov	r24, r1
     25e:	11 24       	eor	r1, r1
     260:	98 2f       	mov	r25, r24
     262:	96 95       	lsr	r25
     264:	96 95       	lsr	r25
     266:	96 95       	lsr	r25
     268:	89 2f       	mov	r24, r25
     26a:	88 0f       	add	r24, r24
     26c:	89 0f       	add	r24, r25
     26e:	88 0f       	add	r24, r24
     270:	88 0f       	add	r24, r24
     272:	92 2f       	mov	r25, r18
     274:	98 1b       	sub	r25, r24
     276:	81 e0       	ldi	r24, 0x01	; 1
     278:	89 0f       	add	r24, r25
     27a:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     27e:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     282:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     286:	20 e0       	ldi	r18, 0x00	; 0
     288:	40 e0       	ldi	r20, 0x00	; 0
     28a:	50 e0       	ldi	r21, 0x00	; 0
     28c:	60 e0       	ldi	r22, 0x00	; 0
     28e:	70 e0       	ldi	r23, 0x00	; 0
     290:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockH,hours_frequency);
     294:	60 e5       	ldi	r22, 0x50	; 80
     296:	76 e4       	ldi	r23, 0x46	; 70
     298:	ce 01       	movw	r24, r28
     29a:	01 96       	adiw	r24, 0x01	; 1
     29c:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskDelayUntil>
		Hours++;
     2a0:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <Hours>
     2a4:	8f 5f       	subi	r24, 0xFF	; 255
     2a6:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <Hours>
		Hours %= 24;
     2aa:	90 91 aa 00 	lds	r25, 0x00AA	; 0x8000aa <Hours>
     2ae:	8b ea       	ldi	r24, 0xAB	; 171
     2b0:	98 9f       	mul	r25, r24
     2b2:	81 2d       	mov	r24, r1
     2b4:	11 24       	eor	r1, r1
     2b6:	82 95       	swap	r24
     2b8:	8f 70       	andi	r24, 0x0F	; 15
     2ba:	28 e1       	ldi	r18, 0x18	; 24
     2bc:	82 9f       	mul	r24, r18
     2be:	80 2d       	mov	r24, r0
     2c0:	11 24       	eor	r1, r1
     2c2:	29 2f       	mov	r18, r25
     2c4:	28 1b       	sub	r18, r24
     2c6:	82 2f       	mov	r24, r18
     2c8:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <Hours>
	}
     2cc:	b6 cf       	rjmp	.-148    	; 0x23a <Clock_Hours+0x24>

000002ce <Clock_Check_KPD>:
}

void Clock_Check_KPD(void *pvParameters)
{
     2ce:	cf 93       	push	r28
     2d0:	df 93       	push	r29
     2d2:	cd b7       	in	r28, 0x3d	; 61
     2d4:	de b7       	in	r29, 0x3e	; 62
     2d6:	65 97       	sbiw	r28, 0x15	; 21
     2d8:	0f b6       	in	r0, 0x3f	; 63
     2da:	f8 94       	cli
     2dc:	de bf       	out	0x3e, r29	; 62
     2de:	0f be       	out	0x3f, r0	; 63
     2e0:	cd bf       	out	0x3d, r28	; 61
     2e2:	9d 8b       	std	Y+21, r25	; 0x15
     2e4:	8c 8b       	std	Y+20, r24	; 0x14
	KPD_input = xQueueCreate(1,sizeof(u8));
     2e6:	40 e0       	ldi	r20, 0x00	; 0
     2e8:	61 e0       	ldi	r22, 0x01	; 1
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	0e 94 82 18 	call	0x3104	; 0x3104 <xQueueGenericCreate>
     2f0:	90 93 ac 00 	sts	0x00AC, r25	; 0x8000ac <KPD_input+0x1>
     2f4:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <KPD_input>
	TickType_t MyLastUnblockKPD;
	MyLastUnblockKPD = xTaskGetTickCount();
     2f8:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGetTickCount>
     2fc:	9a 83       	std	Y+2, r25	; 0x02
     2fe:	89 83       	std	Y+1, r24	; 0x01
	u8 keys[16];
	u8 pressed;
	while(1)
	{	pressed = KBD_u8GetKeyPadState(keys);
     300:	ce 01       	movw	r24, r28
     302:	03 96       	adiw	r24, 0x03	; 3
     304:	0e 94 7d 05 	call	0xafa	; 0xafa <KBD_u8GetKeyPadState>
     308:	8b 8b       	std	Y+19, r24	; 0x13
		if(pressed != 0xff)
     30a:	8b 89       	ldd	r24, Y+19	; 0x13
     30c:	8f 3f       	cpi	r24, 0xFF	; 255
     30e:	61 f0       	breq	.+24     	; 0x328 <Clock_Check_KPD+0x5a>
		{
			xQueueSend(KPD_input,&pressed,10);
     310:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <KPD_input>
     314:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <KPD_input+0x1>
     318:	be 01       	movw	r22, r28
     31a:	6d 5e       	subi	r22, 0xED	; 237
     31c:	7f 4f       	sbci	r23, 0xFF	; 255
     31e:	20 e0       	ldi	r18, 0x00	; 0
     320:	4a e0       	ldi	r20, 0x0A	; 10
     322:	50 e0       	ldi	r21, 0x00	; 0
     324:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockKPD,KPD_Check_frequency);
     328:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <KPD_Check_frequency>
     32c:	88 2f       	mov	r24, r24
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	bc 01       	movw	r22, r24
     332:	ce 01       	movw	r24, r28
     334:	01 96       	adiw	r24, 0x01	; 1
     336:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskDelayUntil>
	}
     33a:	e2 cf       	rjmp	.-60     	; 0x300 <Clock_Check_KPD+0x32>

0000033c <Clock_Enter_Typing_Mode>:
}

void Clock_Enter_Typing_Mode(void *pvParameters)
{
     33c:	cf 93       	push	r28
     33e:	df 93       	push	r29
     340:	00 d0       	rcall	.+0      	; 0x342 <Clock_Enter_Typing_Mode+0x6>
     342:	00 d0       	rcall	.+0      	; 0x344 <Clock_Enter_Typing_Mode+0x8>
     344:	00 d0       	rcall	.+0      	; 0x346 <Clock_Enter_Typing_Mode+0xa>
     346:	cd b7       	in	r28, 0x3d	; 61
     348:	de b7       	in	r29, 0x3e	; 62
     34a:	9e 83       	std	Y+6, r25	; 0x06
     34c:	8d 83       	std	Y+5, r24	; 0x05
	u8 pressed  = 0xff;
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	8c 83       	std	Y+4, r24	; 0x04
	u8 take_lach = 0;
     352:	19 82       	std	Y+1, r1	; 0x01
	u8 current_block = 26;
     354:	8a e1       	ldi	r24, 0x1A	; 26
     356:	8a 83       	std	Y+2, r24	; 0x02
	u8 take_lcd = 0;
     358:	1b 82       	std	Y+3, r1	; 0x03
	while(1)
	{
		if(xQueueReceive(KPD_input,&pressed,10))
     35a:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <KPD_input>
     35e:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <KPD_input+0x1>
     362:	9e 01       	movw	r18, r28
     364:	2c 5f       	subi	r18, 0xFC	; 252
     366:	3f 4f       	sbci	r19, 0xFF	; 255
     368:	4a e0       	ldi	r20, 0x0A	; 10
     36a:	50 e0       	ldi	r21, 0x00	; 0
     36c:	b9 01       	movw	r22, r18
     36e:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xQueueReceive>
     372:	88 23       	and	r24, r24
     374:	91 f3       	breq	.-28     	; 0x35a <Clock_Enter_Typing_Mode+0x1e>
		{

			switch (pressed)
     376:	8c 81       	ldd	r24, Y+4	; 0x04
     378:	88 2f       	mov	r24, r24
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	8a 97       	sbiw	r24, 0x2a	; 42
     37e:	b9 f0       	breq	.+46     	; 0x3ae <Clock_Enter_Typing_Mode+0x72>
			{
			default:
				if((take_lach))
     380:	89 81       	ldd	r24, Y+1	; 0x01
     382:	88 23       	and	r24, r24
     384:	09 f4       	brne	.+2      	; 0x388 <Clock_Enter_Typing_Mode+0x4c>
     386:	59 c0       	rjmp	.+178    	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
				{
					LCD_Set_Block(current_block);
     388:	8a 81       	ldd	r24, Y+2	; 0x02
     38a:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
					LCD_Void_Write_Data(' ');
     38e:	80 e2       	ldi	r24, 0x20	; 32
     390:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
					switch (pressed)
     394:	8c 81       	ldd	r24, Y+4	; 0x04
     396:	88 2f       	mov	r24, r24
     398:	90 e0       	ldi	r25, 0x00	; 0
     39a:	ce 97       	sbiw	r24, 0x3e	; 62
     39c:	09 f0       	breq	.+2      	; 0x3a0 <Clock_Enter_Typing_Mode+0x64>
					{
					case '>':
						current_block++;
						LCD_Void_Write_Data(Up_Arrow);
					}
					continue;
     39e:	50 c0       	rjmp	.+160    	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
					LCD_Set_Block(current_block);
					LCD_Void_Write_Data(' ');
					switch (pressed)
					{
					case '>':
						current_block++;
     3a0:	8a 81       	ldd	r24, Y+2	; 0x02
     3a2:	8f 5f       	subi	r24, 0xFF	; 255
     3a4:	8a 83       	std	Y+2, r24	; 0x02
						LCD_Void_Write_Data(Up_Arrow);
     3a6:	8e e5       	ldi	r24, 0x5E	; 94
     3a8:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
					}
					continue;
     3ac:	49 c0       	rjmp	.+146    	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
				}
				break;


			case '*':
				if((take_lcd%2)==0)
     3ae:	8b 81       	ldd	r24, Y+3	; 0x03
     3b0:	81 70       	andi	r24, 0x01	; 1
     3b2:	88 23       	and	r24, r24
     3b4:	01 f5       	brne	.+64     	; 0x3f6 <Clock_Enter_Typing_Mode+0xba>
				{
					if(xSemaphoreTake(LCD,10))
     3b6:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     3ba:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     3be:	6a e0       	ldi	r22, 0x0A	; 10
     3c0:	70 e0       	ldi	r23, 0x00	; 0
     3c2:	0e 94 75 1b 	call	0x36ea	; 0x36ea <xQueueSemaphoreTake>
     3c6:	88 23       	and	r24, r24
     3c8:	d1 f1       	breq	.+116    	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
					{
						LCD_Set_Block(16);
     3ca:	80 e1       	ldi	r24, 0x10	; 16
     3cc:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
					//	LCD_Void_Write_String("taken  ");
						take_lach = 1;
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	89 83       	std	Y+1, r24	; 0x01
						vTaskDelay(configTICK_RATE_HZ);
     3d4:	85 e0       	ldi	r24, 0x05	; 5
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	0e 94 f4 22 	call	0x45e8	; 0x45e8 <vTaskDelay>
						LCD_Set_Block(current_block);
     3dc:	8a 81       	ldd	r24, Y+2	; 0x02
     3de:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
						LCD_Void_Write_Data(Up_Arrow);
     3e2:	8e e5       	ldi	r24, 0x5E	; 94
     3e4:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
						take_lcd++;
     3e8:	8b 81       	ldd	r24, Y+3	; 0x03
     3ea:	8f 5f       	subi	r24, 0xFF	; 255
     3ec:	8b 83       	std	Y+3, r24	; 0x03
						KPD_Check_frequency = 1;
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
					LCD_Void_Write_Data(' ');
					vTaskDelay(configTICK_RATE_HZ);
					take_lcd++;

				}
				break;
     3f4:	24 c0       	rjmp	.+72     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>

					}
				}
				else
				{
					xSemaphoreGive(LCD);
     3f6:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <LCD>
     3fa:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <LCD+0x1>
     3fe:	20 e0       	ldi	r18, 0x00	; 0
     400:	40 e0       	ldi	r20, 0x00	; 0
     402:	50 e0       	ldi	r21, 0x00	; 0
     404:	60 e0       	ldi	r22, 0x00	; 0
     406:	70 e0       	ldi	r23, 0x00	; 0
     408:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <xQueueGenericSend>
					LCD_Set_Block(16);
     40c:	80 e1       	ldi	r24, 0x10	; 16
     40e:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
					//LCD_Void_Write_String("released");
					take_lach = 0;
     412:	19 82       	std	Y+1, r1	; 0x01
					Clock_Print_Default_Interface();
     414:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
					KPD_Check_frequency = configTICK_RATE_HZ*2;
     418:	8a e0       	ldi	r24, 0x0A	; 10
     41a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
					LCD_Set_Block(current_block);
     41e:	8a 81       	ldd	r24, Y+2	; 0x02
     420:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
					LCD_Void_Write_Data(' ');
     424:	80 e2       	ldi	r24, 0x20	; 32
     426:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
					vTaskDelay(configTICK_RATE_HZ);
     42a:	85 e0       	ldi	r24, 0x05	; 5
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	0e 94 f4 22 	call	0x45e8	; 0x45e8 <vTaskDelay>
					take_lcd++;
     432:	8b 81       	ldd	r24, Y+3	; 0x03
     434:	8f 5f       	subi	r24, 0xFF	; 255
     436:	8b 83       	std	Y+3, r24	; 0x03

				}
				break;
     438:	02 c0       	rjmp	.+4      	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
						current_block++;
						LCD_Void_Write_Data(Up_Arrow);
					}
					continue;
				}
				break;
     43a:	00 00       	nop
     43c:	8e cf       	rjmp	.-228    	; 0x35a <Clock_Enter_Typing_Mode+0x1e>
					LCD_Void_Write_Data(' ');
					vTaskDelay(configTICK_RATE_HZ);
					take_lcd++;

				}
				break;
     43e:	00 00       	nop
			}

		}

	}
     440:	8c cf       	rjmp	.-232    	; 0x35a <Clock_Enter_Typing_Mode+0x1e>

00000442 <DIO_voidInitialize>:

/* Description: This function shall initialize the     */
/*              direction and initial value for DIO    */
/*              pins                                   */
void DIO_voidInitialize(void)
{
     442:	cf 93       	push	r28
     444:	df 93       	push	r29
     446:	cd b7       	in	r28, 0x3d	; 61
     448:	de b7       	in	r29, 0x3e	; 62
	DIO_u8_DDRA->ByteAccess = CONC_8BIT(DIO_u8_PIN0_DIR,
     44a:	8a e3       	ldi	r24, 0x3A	; 58
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	fc 01       	movw	r30, r24
     450:	10 82       	st	Z, r1
										DIO_u8_PIN4_DIR,
										DIO_u8_PIN5_DIR,
										DIO_u8_PIN6_DIR,
										DIO_u8_PIN7_DIR);

	DIO_u8_DDRB->ByteAccess = CONC_8BIT(DIO_u8_PIN8_DIR,
     452:	87 e3       	ldi	r24, 0x37	; 55
     454:	90 e0       	ldi	r25, 0x00	; 0
     456:	fc 01       	movw	r30, r24
     458:	10 82       	st	Z, r1
										DIO_u8_PIN12_DIR,
										DIO_u8_PIN13_DIR,
										DIO_u8_PIN14_DIR,
										DIO_u8_PIN15_DIR);

	DIO_u8_DDRC->ByteAccess = CONC_8BIT(DIO_u8_PIN16_DIR,
     45a:	84 e3       	ldi	r24, 0x34	; 52
     45c:	90 e0       	ldi	r25, 0x00	; 0
     45e:	fc 01       	movw	r30, r24
     460:	10 82       	st	Z, r1
										DIO_u8_PIN20_DIR,
										DIO_u8_PIN21_DIR,
										DIO_u8_PIN22_DIR,
										DIO_u8_PIN23_DIR);

	DIO_u8_DDRD->ByteAccess = CONC_8BIT(DIO_u8_PIN24_DIR,
     462:	81 e3       	ldi	r24, 0x31	; 49
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	fc 01       	movw	r30, r24
     468:	10 82       	st	Z, r1
										DIO_u8_PIN27_DIR,
										DIO_u8_PIN28_DIR,
										DIO_u8_PIN29_DIR,
										DIO_u8_PIN30_DIR,
										DIO_u8_PIN31_DIR);
}
     46a:	00 00       	nop
     46c:	df 91       	pop	r29
     46e:	cf 91       	pop	r28
     470:	08 95       	ret

00000472 <DIO_u8SetPinDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_pin           */
u8 DIO_u8SetPinDirection(u8 Copy_u8PinNB, u8 Copy_u8PinDirection)
{
     472:	cf 93       	push	r28
     474:	df 93       	push	r29
     476:	00 d0       	rcall	.+0      	; 0x478 <DIO_u8SetPinDirection+0x6>
     478:	00 d0       	rcall	.+0      	; 0x47a <DIO_u8SetPinDirection+0x8>
     47a:	1f 92       	push	r1
     47c:	cd b7       	in	r28, 0x3d	; 61
     47e:	de b7       	in	r29, 0x3e	; 62
     480:	8c 83       	std	Y+4, r24	; 0x04
     482:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     484:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     486:	8c 81       	ldd	r24, Y+4	; 0x04
     488:	80 32       	cpi	r24, 0x20	; 32
     48a:	18 f0       	brcs	.+6      	; 0x492 <DIO_u8SetPinDirection+0x20>
	{
		u8ErrorState = 1;
     48c:	81 e0       	ldi	r24, 0x01	; 1
     48e:	89 83       	std	Y+1, r24	; 0x01
     490:	dd c0       	rjmp	.+442    	; 0x64c <DIO_u8SetPinDirection+0x1da>
	}else if ((Copy_u8PinDirection != DIO_u8_INPUT) && (Copy_u8PinDirection != DIO_u8_OUTPUT))
     492:	8d 81       	ldd	r24, Y+5	; 0x05
     494:	88 23       	and	r24, r24
     496:	31 f0       	breq	.+12     	; 0x4a4 <DIO_u8SetPinDirection+0x32>
     498:	8d 81       	ldd	r24, Y+5	; 0x05
     49a:	81 30       	cpi	r24, 0x01	; 1
     49c:	19 f0       	breq	.+6      	; 0x4a4 <DIO_u8SetPinDirection+0x32>
	{
		u8ErrorState = 1;
     49e:	81 e0       	ldi	r24, 0x01	; 1
     4a0:	89 83       	std	Y+1, r24	; 0x01
     4a2:	d4 c0       	rjmp	.+424    	; 0x64c <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     4a4:	8c 81       	ldd	r24, Y+4	; 0x04
     4a6:	86 95       	lsr	r24
     4a8:	86 95       	lsr	r24
     4aa:	86 95       	lsr	r24
     4ac:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     4ae:	8c 81       	ldd	r24, Y+4	; 0x04
     4b0:	87 70       	andi	r24, 0x07	; 7
     4b2:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     4b4:	8a 81       	ldd	r24, Y+2	; 0x02
     4b6:	88 2f       	mov	r24, r24
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	81 30       	cpi	r24, 0x01	; 1
     4bc:	91 05       	cpc	r25, r1
     4be:	e1 f1       	breq	.+120    	; 0x538 <DIO_u8SetPinDirection+0xc6>
     4c0:	82 30       	cpi	r24, 0x02	; 2
     4c2:	91 05       	cpc	r25, r1
     4c4:	1c f4       	brge	.+6      	; 0x4cc <DIO_u8SetPinDirection+0x5a>
     4c6:	89 2b       	or	r24, r25
     4c8:	49 f0       	breq	.+18     	; 0x4dc <DIO_u8SetPinDirection+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     4ca:	c0 c0       	rjmp	.+384    	; 0x64c <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     4cc:	82 30       	cpi	r24, 0x02	; 2
     4ce:	91 05       	cpc	r25, r1
     4d0:	09 f4       	brne	.+2      	; 0x4d4 <DIO_u8SetPinDirection+0x62>
     4d2:	60 c0       	rjmp	.+192    	; 0x594 <DIO_u8SetPinDirection+0x122>
     4d4:	03 97       	sbiw	r24, 0x03	; 3
     4d6:	09 f4       	brne	.+2      	; 0x4da <DIO_u8SetPinDirection+0x68>
     4d8:	8b c0       	rjmp	.+278    	; 0x5f0 <DIO_u8SetPinDirection+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     4da:	b8 c0       	rjmp	.+368    	; 0x64c <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     4dc:	8d 81       	ldd	r24, Y+5	; 0x05
     4de:	81 30       	cpi	r24, 0x01	; 1
     4e0:	a9 f4       	brne	.+42     	; 0x50c <DIO_u8SetPinDirection+0x9a>
     4e2:	8a e3       	ldi	r24, 0x3A	; 58
     4e4:	90 e0       	ldi	r25, 0x00	; 0
     4e6:	2a e3       	ldi	r18, 0x3A	; 58
     4e8:	30 e0       	ldi	r19, 0x00	; 0
     4ea:	f9 01       	movw	r30, r18
     4ec:	20 81       	ld	r18, Z
     4ee:	62 2f       	mov	r22, r18
     4f0:	2b 81       	ldd	r18, Y+3	; 0x03
     4f2:	42 2f       	mov	r20, r18
     4f4:	50 e0       	ldi	r21, 0x00	; 0
     4f6:	21 e0       	ldi	r18, 0x01	; 1
     4f8:	30 e0       	ldi	r19, 0x00	; 0
     4fa:	02 c0       	rjmp	.+4      	; 0x500 <DIO_u8SetPinDirection+0x8e>
     4fc:	22 0f       	add	r18, r18
     4fe:	33 1f       	adc	r19, r19
     500:	4a 95       	dec	r20
     502:	e2 f7       	brpl	.-8      	; 0x4fc <DIO_u8SetPinDirection+0x8a>
     504:	26 2b       	or	r18, r22
     506:	fc 01       	movw	r30, r24
     508:	20 83       	st	Z, r18
			break;
     50a:	a0 c0       	rjmp	.+320    	; 0x64c <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     50c:	8a e3       	ldi	r24, 0x3A	; 58
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	2a e3       	ldi	r18, 0x3A	; 58
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	f9 01       	movw	r30, r18
     516:	20 81       	ld	r18, Z
     518:	62 2f       	mov	r22, r18
     51a:	2b 81       	ldd	r18, Y+3	; 0x03
     51c:	42 2f       	mov	r20, r18
     51e:	50 e0       	ldi	r21, 0x00	; 0
     520:	21 e0       	ldi	r18, 0x01	; 1
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	02 c0       	rjmp	.+4      	; 0x52a <DIO_u8SetPinDirection+0xb8>
     526:	22 0f       	add	r18, r18
     528:	33 1f       	adc	r19, r19
     52a:	4a 95       	dec	r20
     52c:	e2 f7       	brpl	.-8      	; 0x526 <DIO_u8SetPinDirection+0xb4>
     52e:	20 95       	com	r18
     530:	26 23       	and	r18, r22
     532:	fc 01       	movw	r30, r24
     534:	20 83       	st	Z, r18
			break;
     536:	8a c0       	rjmp	.+276    	; 0x64c <DIO_u8SetPinDirection+0x1da>
		case GROUP_B :
			if(Copy_u8PinDirection == DIO_u8_INPUT)
     538:	8d 81       	ldd	r24, Y+5	; 0x05
     53a:	88 23       	and	r24, r24
     53c:	b1 f4       	brne	.+44     	; 0x56a <DIO_u8SetPinDirection+0xf8>
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     53e:	87 e3       	ldi	r24, 0x37	; 55
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	27 e3       	ldi	r18, 0x37	; 55
     544:	30 e0       	ldi	r19, 0x00	; 0
     546:	f9 01       	movw	r30, r18
     548:	20 81       	ld	r18, Z
     54a:	62 2f       	mov	r22, r18
     54c:	2b 81       	ldd	r18, Y+3	; 0x03
     54e:	42 2f       	mov	r20, r18
     550:	50 e0       	ldi	r21, 0x00	; 0
     552:	21 e0       	ldi	r18, 0x01	; 1
     554:	30 e0       	ldi	r19, 0x00	; 0
     556:	02 c0       	rjmp	.+4      	; 0x55c <DIO_u8SetPinDirection+0xea>
     558:	22 0f       	add	r18, r18
     55a:	33 1f       	adc	r19, r19
     55c:	4a 95       	dec	r20
     55e:	e2 f7       	brpl	.-8      	; 0x558 <DIO_u8SetPinDirection+0xe6>
     560:	20 95       	com	r18
     562:	26 23       	and	r18, r22
     564:	fc 01       	movw	r30, r24
     566:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
     568:	71 c0       	rjmp	.+226    	; 0x64c <DIO_u8SetPinDirection+0x1da>
			if(Copy_u8PinDirection == DIO_u8_INPUT)
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     56a:	87 e3       	ldi	r24, 0x37	; 55
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	27 e3       	ldi	r18, 0x37	; 55
     570:	30 e0       	ldi	r19, 0x00	; 0
     572:	f9 01       	movw	r30, r18
     574:	20 81       	ld	r18, Z
     576:	62 2f       	mov	r22, r18
     578:	2b 81       	ldd	r18, Y+3	; 0x03
     57a:	42 2f       	mov	r20, r18
     57c:	50 e0       	ldi	r21, 0x00	; 0
     57e:	21 e0       	ldi	r18, 0x01	; 1
     580:	30 e0       	ldi	r19, 0x00	; 0
     582:	02 c0       	rjmp	.+4      	; 0x588 <DIO_u8SetPinDirection+0x116>
     584:	22 0f       	add	r18, r18
     586:	33 1f       	adc	r19, r19
     588:	4a 95       	dec	r20
     58a:	e2 f7       	brpl	.-8      	; 0x584 <DIO_u8SetPinDirection+0x112>
     58c:	26 2b       	or	r18, r22
     58e:	fc 01       	movw	r30, r24
     590:	20 83       	st	Z, r18
			}
			break;
     592:	5c c0       	rjmp	.+184    	; 0x64c <DIO_u8SetPinDirection+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     594:	8d 81       	ldd	r24, Y+5	; 0x05
     596:	81 30       	cpi	r24, 0x01	; 1
     598:	a9 f4       	brne	.+42     	; 0x5c4 <DIO_u8SetPinDirection+0x152>
     59a:	84 e3       	ldi	r24, 0x34	; 52
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	24 e3       	ldi	r18, 0x34	; 52
     5a0:	30 e0       	ldi	r19, 0x00	; 0
     5a2:	f9 01       	movw	r30, r18
     5a4:	20 81       	ld	r18, Z
     5a6:	62 2f       	mov	r22, r18
     5a8:	2b 81       	ldd	r18, Y+3	; 0x03
     5aa:	42 2f       	mov	r20, r18
     5ac:	50 e0       	ldi	r21, 0x00	; 0
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	30 e0       	ldi	r19, 0x00	; 0
     5b2:	02 c0       	rjmp	.+4      	; 0x5b8 <DIO_u8SetPinDirection+0x146>
     5b4:	22 0f       	add	r18, r18
     5b6:	33 1f       	adc	r19, r19
     5b8:	4a 95       	dec	r20
     5ba:	e2 f7       	brpl	.-8      	; 0x5b4 <DIO_u8SetPinDirection+0x142>
     5bc:	26 2b       	or	r18, r22
     5be:	fc 01       	movw	r30, r24
     5c0:	20 83       	st	Z, r18
			break;
     5c2:	44 c0       	rjmp	.+136    	; 0x64c <DIO_u8SetPinDirection+0x1da>
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     5c4:	84 e3       	ldi	r24, 0x34	; 52
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	24 e3       	ldi	r18, 0x34	; 52
     5ca:	30 e0       	ldi	r19, 0x00	; 0
     5cc:	f9 01       	movw	r30, r18
     5ce:	20 81       	ld	r18, Z
     5d0:	62 2f       	mov	r22, r18
     5d2:	2b 81       	ldd	r18, Y+3	; 0x03
     5d4:	42 2f       	mov	r20, r18
     5d6:	50 e0       	ldi	r21, 0x00	; 0
     5d8:	21 e0       	ldi	r18, 0x01	; 1
     5da:	30 e0       	ldi	r19, 0x00	; 0
     5dc:	02 c0       	rjmp	.+4      	; 0x5e2 <DIO_u8SetPinDirection+0x170>
     5de:	22 0f       	add	r18, r18
     5e0:	33 1f       	adc	r19, r19
     5e2:	4a 95       	dec	r20
     5e4:	e2 f7       	brpl	.-8      	; 0x5de <DIO_u8SetPinDirection+0x16c>
     5e6:	20 95       	com	r18
     5e8:	26 23       	and	r18, r22
     5ea:	fc 01       	movw	r30, r24
     5ec:	20 83       	st	Z, r18
			break;
     5ee:	2e c0       	rjmp	.+92     	; 0x64c <DIO_u8SetPinDirection+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     5f0:	8d 81       	ldd	r24, Y+5	; 0x05
     5f2:	81 30       	cpi	r24, 0x01	; 1
     5f4:	a9 f4       	brne	.+42     	; 0x620 <DIO_u8SetPinDirection+0x1ae>
     5f6:	81 e3       	ldi	r24, 0x31	; 49
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	21 e3       	ldi	r18, 0x31	; 49
     5fc:	30 e0       	ldi	r19, 0x00	; 0
     5fe:	f9 01       	movw	r30, r18
     600:	20 81       	ld	r18, Z
     602:	62 2f       	mov	r22, r18
     604:	2b 81       	ldd	r18, Y+3	; 0x03
     606:	42 2f       	mov	r20, r18
     608:	50 e0       	ldi	r21, 0x00	; 0
     60a:	21 e0       	ldi	r18, 0x01	; 1
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	02 c0       	rjmp	.+4      	; 0x614 <DIO_u8SetPinDirection+0x1a2>
     610:	22 0f       	add	r18, r18
     612:	33 1f       	adc	r19, r19
     614:	4a 95       	dec	r20
     616:	e2 f7       	brpl	.-8      	; 0x610 <DIO_u8SetPinDirection+0x19e>
     618:	26 2b       	or	r18, r22
     61a:	fc 01       	movw	r30, r24
     61c:	20 83       	st	Z, r18
			break;
     61e:	15 c0       	rjmp	.+42     	; 0x64a <DIO_u8SetPinDirection+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     620:	81 e3       	ldi	r24, 0x31	; 49
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	21 e3       	ldi	r18, 0x31	; 49
     626:	30 e0       	ldi	r19, 0x00	; 0
     628:	f9 01       	movw	r30, r18
     62a:	20 81       	ld	r18, Z
     62c:	62 2f       	mov	r22, r18
     62e:	2b 81       	ldd	r18, Y+3	; 0x03
     630:	42 2f       	mov	r20, r18
     632:	50 e0       	ldi	r21, 0x00	; 0
     634:	21 e0       	ldi	r18, 0x01	; 1
     636:	30 e0       	ldi	r19, 0x00	; 0
     638:	02 c0       	rjmp	.+4      	; 0x63e <DIO_u8SetPinDirection+0x1cc>
     63a:	22 0f       	add	r18, r18
     63c:	33 1f       	adc	r19, r19
     63e:	4a 95       	dec	r20
     640:	e2 f7       	brpl	.-8      	; 0x63a <DIO_u8SetPinDirection+0x1c8>
     642:	20 95       	com	r18
     644:	26 23       	and	r18, r22
     646:	fc 01       	movw	r30, r24
     648:	20 83       	st	Z, r18
			break;
     64a:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     64c:	89 81       	ldd	r24, Y+1	; 0x01
}
     64e:	0f 90       	pop	r0
     650:	0f 90       	pop	r0
     652:	0f 90       	pop	r0
     654:	0f 90       	pop	r0
     656:	0f 90       	pop	r0
     658:	df 91       	pop	r29
     65a:	cf 91       	pop	r28
     65c:	08 95       	ret

0000065e <DIO_u8SetPinValue>:
/* Description: This function shall set certain value  */
/*              to certain DIO pin                     */
u8 DIO_u8SetPinValue(u8 Copy_u8PinNB, u8 Copy_u8PinValue)
{
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
     662:	00 d0       	rcall	.+0      	; 0x664 <DIO_u8SetPinValue+0x6>
     664:	00 d0       	rcall	.+0      	; 0x666 <DIO_u8SetPinValue+0x8>
     666:	1f 92       	push	r1
     668:	cd b7       	in	r28, 0x3d	; 61
     66a:	de b7       	in	r29, 0x3e	; 62
     66c:	8c 83       	std	Y+4, r24	; 0x04
     66e:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     670:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     672:	8c 81       	ldd	r24, Y+4	; 0x04
     674:	80 32       	cpi	r24, 0x20	; 32
     676:	18 f0       	brcs	.+6      	; 0x67e <DIO_u8SetPinValue+0x20>
	{
		u8ErrorState = 1;
     678:	81 e0       	ldi	r24, 0x01	; 1
     67a:	89 83       	std	Y+1, r24	; 0x01
     67c:	dd c0       	rjmp	.+442    	; 0x838 <DIO_u8SetPinValue+0x1da>
	}else if ((Copy_u8PinValue != DIO_u8_HIGH) && (Copy_u8PinValue != DIO_u8_LOW))
     67e:	8d 81       	ldd	r24, Y+5	; 0x05
     680:	81 30       	cpi	r24, 0x01	; 1
     682:	31 f0       	breq	.+12     	; 0x690 <DIO_u8SetPinValue+0x32>
     684:	8d 81       	ldd	r24, Y+5	; 0x05
     686:	88 23       	and	r24, r24
     688:	19 f0       	breq	.+6      	; 0x690 <DIO_u8SetPinValue+0x32>
	{
		u8ErrorState = 1;
     68a:	81 e0       	ldi	r24, 0x01	; 1
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	d4 c0       	rjmp	.+424    	; 0x838 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     690:	8c 81       	ldd	r24, Y+4	; 0x04
     692:	86 95       	lsr	r24
     694:	86 95       	lsr	r24
     696:	86 95       	lsr	r24
     698:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     69a:	8c 81       	ldd	r24, Y+4	; 0x04
     69c:	87 70       	andi	r24, 0x07	; 7
     69e:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     6a0:	8a 81       	ldd	r24, Y+2	; 0x02
     6a2:	88 2f       	mov	r24, r24
     6a4:	90 e0       	ldi	r25, 0x00	; 0
     6a6:	81 30       	cpi	r24, 0x01	; 1
     6a8:	91 05       	cpc	r25, r1
     6aa:	e1 f1       	breq	.+120    	; 0x724 <DIO_u8SetPinValue+0xc6>
     6ac:	82 30       	cpi	r24, 0x02	; 2
     6ae:	91 05       	cpc	r25, r1
     6b0:	1c f4       	brge	.+6      	; 0x6b8 <DIO_u8SetPinValue+0x5a>
     6b2:	89 2b       	or	r24, r25
     6b4:	49 f0       	breq	.+18     	; 0x6c8 <DIO_u8SetPinValue+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     6b6:	c0 c0       	rjmp	.+384    	; 0x838 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     6b8:	82 30       	cpi	r24, 0x02	; 2
     6ba:	91 05       	cpc	r25, r1
     6bc:	09 f4       	brne	.+2      	; 0x6c0 <DIO_u8SetPinValue+0x62>
     6be:	60 c0       	rjmp	.+192    	; 0x780 <DIO_u8SetPinValue+0x122>
     6c0:	03 97       	sbiw	r24, 0x03	; 3
     6c2:	09 f4       	brne	.+2      	; 0x6c6 <DIO_u8SetPinValue+0x68>
     6c4:	8b c0       	rjmp	.+278    	; 0x7dc <DIO_u8SetPinValue+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     6c6:	b8 c0       	rjmp	.+368    	; 0x838 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     6c8:	8d 81       	ldd	r24, Y+5	; 0x05
     6ca:	81 30       	cpi	r24, 0x01	; 1
     6cc:	a9 f4       	brne	.+42     	; 0x6f8 <DIO_u8SetPinValue+0x9a>
     6ce:	8b e3       	ldi	r24, 0x3B	; 59
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	2b e3       	ldi	r18, 0x3B	; 59
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	f9 01       	movw	r30, r18
     6d8:	20 81       	ld	r18, Z
     6da:	62 2f       	mov	r22, r18
     6dc:	2b 81       	ldd	r18, Y+3	; 0x03
     6de:	42 2f       	mov	r20, r18
     6e0:	50 e0       	ldi	r21, 0x00	; 0
     6e2:	21 e0       	ldi	r18, 0x01	; 1
     6e4:	30 e0       	ldi	r19, 0x00	; 0
     6e6:	02 c0       	rjmp	.+4      	; 0x6ec <DIO_u8SetPinValue+0x8e>
     6e8:	22 0f       	add	r18, r18
     6ea:	33 1f       	adc	r19, r19
     6ec:	4a 95       	dec	r20
     6ee:	e2 f7       	brpl	.-8      	; 0x6e8 <DIO_u8SetPinValue+0x8a>
     6f0:	26 2b       	or	r18, r22
     6f2:	fc 01       	movw	r30, r24
     6f4:	20 83       	st	Z, r18
			break;
     6f6:	a0 c0       	rjmp	.+320    	; 0x838 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     6f8:	8b e3       	ldi	r24, 0x3B	; 59
     6fa:	90 e0       	ldi	r25, 0x00	; 0
     6fc:	2b e3       	ldi	r18, 0x3B	; 59
     6fe:	30 e0       	ldi	r19, 0x00	; 0
     700:	f9 01       	movw	r30, r18
     702:	20 81       	ld	r18, Z
     704:	62 2f       	mov	r22, r18
     706:	2b 81       	ldd	r18, Y+3	; 0x03
     708:	42 2f       	mov	r20, r18
     70a:	50 e0       	ldi	r21, 0x00	; 0
     70c:	21 e0       	ldi	r18, 0x01	; 1
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	02 c0       	rjmp	.+4      	; 0x716 <DIO_u8SetPinValue+0xb8>
     712:	22 0f       	add	r18, r18
     714:	33 1f       	adc	r19, r19
     716:	4a 95       	dec	r20
     718:	e2 f7       	brpl	.-8      	; 0x712 <DIO_u8SetPinValue+0xb4>
     71a:	20 95       	com	r18
     71c:	26 23       	and	r18, r22
     71e:	fc 01       	movw	r30, r24
     720:	20 83       	st	Z, r18
			break;
     722:	8a c0       	rjmp	.+276    	; 0x838 <DIO_u8SetPinValue+0x1da>
		case GROUP_B :
			if(Copy_u8PinValue == DIO_u8_LOW)
     724:	8d 81       	ldd	r24, Y+5	; 0x05
     726:	88 23       	and	r24, r24
     728:	b1 f4       	brne	.+44     	; 0x756 <DIO_u8SetPinValue+0xf8>
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     72a:	88 e3       	ldi	r24, 0x38	; 56
     72c:	90 e0       	ldi	r25, 0x00	; 0
     72e:	28 e3       	ldi	r18, 0x38	; 56
     730:	30 e0       	ldi	r19, 0x00	; 0
     732:	f9 01       	movw	r30, r18
     734:	20 81       	ld	r18, Z
     736:	62 2f       	mov	r22, r18
     738:	2b 81       	ldd	r18, Y+3	; 0x03
     73a:	42 2f       	mov	r20, r18
     73c:	50 e0       	ldi	r21, 0x00	; 0
     73e:	21 e0       	ldi	r18, 0x01	; 1
     740:	30 e0       	ldi	r19, 0x00	; 0
     742:	02 c0       	rjmp	.+4      	; 0x748 <DIO_u8SetPinValue+0xea>
     744:	22 0f       	add	r18, r18
     746:	33 1f       	adc	r19, r19
     748:	4a 95       	dec	r20
     74a:	e2 f7       	brpl	.-8      	; 0x744 <DIO_u8SetPinValue+0xe6>
     74c:	20 95       	com	r18
     74e:	26 23       	and	r18, r22
     750:	fc 01       	movw	r30, r24
     752:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
     754:	71 c0       	rjmp	.+226    	; 0x838 <DIO_u8SetPinValue+0x1da>
			if(Copy_u8PinValue == DIO_u8_LOW)
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     756:	88 e3       	ldi	r24, 0x38	; 56
     758:	90 e0       	ldi	r25, 0x00	; 0
     75a:	28 e3       	ldi	r18, 0x38	; 56
     75c:	30 e0       	ldi	r19, 0x00	; 0
     75e:	f9 01       	movw	r30, r18
     760:	20 81       	ld	r18, Z
     762:	62 2f       	mov	r22, r18
     764:	2b 81       	ldd	r18, Y+3	; 0x03
     766:	42 2f       	mov	r20, r18
     768:	50 e0       	ldi	r21, 0x00	; 0
     76a:	21 e0       	ldi	r18, 0x01	; 1
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	02 c0       	rjmp	.+4      	; 0x774 <DIO_u8SetPinValue+0x116>
     770:	22 0f       	add	r18, r18
     772:	33 1f       	adc	r19, r19
     774:	4a 95       	dec	r20
     776:	e2 f7       	brpl	.-8      	; 0x770 <DIO_u8SetPinValue+0x112>
     778:	26 2b       	or	r18, r22
     77a:	fc 01       	movw	r30, r24
     77c:	20 83       	st	Z, r18
			}
			break;
     77e:	5c c0       	rjmp	.+184    	; 0x838 <DIO_u8SetPinValue+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     780:	8d 81       	ldd	r24, Y+5	; 0x05
     782:	81 30       	cpi	r24, 0x01	; 1
     784:	a9 f4       	brne	.+42     	; 0x7b0 <DIO_u8SetPinValue+0x152>
     786:	85 e3       	ldi	r24, 0x35	; 53
     788:	90 e0       	ldi	r25, 0x00	; 0
     78a:	25 e3       	ldi	r18, 0x35	; 53
     78c:	30 e0       	ldi	r19, 0x00	; 0
     78e:	f9 01       	movw	r30, r18
     790:	20 81       	ld	r18, Z
     792:	62 2f       	mov	r22, r18
     794:	2b 81       	ldd	r18, Y+3	; 0x03
     796:	42 2f       	mov	r20, r18
     798:	50 e0       	ldi	r21, 0x00	; 0
     79a:	21 e0       	ldi	r18, 0x01	; 1
     79c:	30 e0       	ldi	r19, 0x00	; 0
     79e:	02 c0       	rjmp	.+4      	; 0x7a4 <DIO_u8SetPinValue+0x146>
     7a0:	22 0f       	add	r18, r18
     7a2:	33 1f       	adc	r19, r19
     7a4:	4a 95       	dec	r20
     7a6:	e2 f7       	brpl	.-8      	; 0x7a0 <DIO_u8SetPinValue+0x142>
     7a8:	26 2b       	or	r18, r22
     7aa:	fc 01       	movw	r30, r24
     7ac:	20 83       	st	Z, r18
			break;
     7ae:	44 c0       	rjmp	.+136    	; 0x838 <DIO_u8SetPinValue+0x1da>
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     7b0:	85 e3       	ldi	r24, 0x35	; 53
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	25 e3       	ldi	r18, 0x35	; 53
     7b6:	30 e0       	ldi	r19, 0x00	; 0
     7b8:	f9 01       	movw	r30, r18
     7ba:	20 81       	ld	r18, Z
     7bc:	62 2f       	mov	r22, r18
     7be:	2b 81       	ldd	r18, Y+3	; 0x03
     7c0:	42 2f       	mov	r20, r18
     7c2:	50 e0       	ldi	r21, 0x00	; 0
     7c4:	21 e0       	ldi	r18, 0x01	; 1
     7c6:	30 e0       	ldi	r19, 0x00	; 0
     7c8:	02 c0       	rjmp	.+4      	; 0x7ce <DIO_u8SetPinValue+0x170>
     7ca:	22 0f       	add	r18, r18
     7cc:	33 1f       	adc	r19, r19
     7ce:	4a 95       	dec	r20
     7d0:	e2 f7       	brpl	.-8      	; 0x7ca <DIO_u8SetPinValue+0x16c>
     7d2:	20 95       	com	r18
     7d4:	26 23       	and	r18, r22
     7d6:	fc 01       	movw	r30, r24
     7d8:	20 83       	st	Z, r18
			break;
     7da:	2e c0       	rjmp	.+92     	; 0x838 <DIO_u8SetPinValue+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     7dc:	8d 81       	ldd	r24, Y+5	; 0x05
     7de:	81 30       	cpi	r24, 0x01	; 1
     7e0:	a9 f4       	brne	.+42     	; 0x80c <DIO_u8SetPinValue+0x1ae>
     7e2:	82 e3       	ldi	r24, 0x32	; 50
     7e4:	90 e0       	ldi	r25, 0x00	; 0
     7e6:	22 e3       	ldi	r18, 0x32	; 50
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	f9 01       	movw	r30, r18
     7ec:	20 81       	ld	r18, Z
     7ee:	62 2f       	mov	r22, r18
     7f0:	2b 81       	ldd	r18, Y+3	; 0x03
     7f2:	42 2f       	mov	r20, r18
     7f4:	50 e0       	ldi	r21, 0x00	; 0
     7f6:	21 e0       	ldi	r18, 0x01	; 1
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	02 c0       	rjmp	.+4      	; 0x800 <DIO_u8SetPinValue+0x1a2>
     7fc:	22 0f       	add	r18, r18
     7fe:	33 1f       	adc	r19, r19
     800:	4a 95       	dec	r20
     802:	e2 f7       	brpl	.-8      	; 0x7fc <DIO_u8SetPinValue+0x19e>
     804:	26 2b       	or	r18, r22
     806:	fc 01       	movw	r30, r24
     808:	20 83       	st	Z, r18
			break;
     80a:	15 c0       	rjmp	.+42     	; 0x836 <DIO_u8SetPinValue+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     80c:	82 e3       	ldi	r24, 0x32	; 50
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	22 e3       	ldi	r18, 0x32	; 50
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	f9 01       	movw	r30, r18
     816:	20 81       	ld	r18, Z
     818:	62 2f       	mov	r22, r18
     81a:	2b 81       	ldd	r18, Y+3	; 0x03
     81c:	42 2f       	mov	r20, r18
     81e:	50 e0       	ldi	r21, 0x00	; 0
     820:	21 e0       	ldi	r18, 0x01	; 1
     822:	30 e0       	ldi	r19, 0x00	; 0
     824:	02 c0       	rjmp	.+4      	; 0x82a <DIO_u8SetPinValue+0x1cc>
     826:	22 0f       	add	r18, r18
     828:	33 1f       	adc	r19, r19
     82a:	4a 95       	dec	r20
     82c:	e2 f7       	brpl	.-8      	; 0x826 <DIO_u8SetPinValue+0x1c8>
     82e:	20 95       	com	r18
     830:	26 23       	and	r18, r22
     832:	fc 01       	movw	r30, r24
     834:	20 83       	st	Z, r18
			break;
     836:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     838:	89 81       	ldd	r24, Y+1	; 0x01
}
     83a:	0f 90       	pop	r0
     83c:	0f 90       	pop	r0
     83e:	0f 90       	pop	r0
     840:	0f 90       	pop	r0
     842:	0f 90       	pop	r0
     844:	df 91       	pop	r29
     846:	cf 91       	pop	r28
     848:	08 95       	ret

0000084a <DIO_u8SetPortDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_port          */
u8 DIO_u8SetPortDirection(u8 Copy_u8PortNB, u8 Copy_u8PortDirection)
{
     84a:	cf 93       	push	r28
     84c:	df 93       	push	r29
     84e:	00 d0       	rcall	.+0      	; 0x850 <DIO_u8SetPortDirection+0x6>
     850:	1f 92       	push	r1
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
     856:	8a 83       	std	Y+2, r24	; 0x02
     858:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     85a:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
		if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     85c:	8a 81       	ldd	r24, Y+2	; 0x02
     85e:	84 30       	cpi	r24, 0x04	; 4
     860:	18 f0       	brcs	.+6      	; 0x868 <__stack+0x9>
		{
			u8ErrorState = 1;
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	89 83       	std	Y+1, r24	; 0x01
     866:	2a c0       	rjmp	.+84     	; 0x8bc <__stack+0x5d>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     868:	8a 81       	ldd	r24, Y+2	; 0x02
     86a:	88 2f       	mov	r24, r24
     86c:	90 e0       	ldi	r25, 0x00	; 0
     86e:	81 30       	cpi	r24, 0x01	; 1
     870:	91 05       	cpc	r25, r1
     872:	91 f0       	breq	.+36     	; 0x898 <__stack+0x39>
     874:	82 30       	cpi	r24, 0x02	; 2
     876:	91 05       	cpc	r25, r1
     878:	1c f4       	brge	.+6      	; 0x880 <__stack+0x21>
     87a:	89 2b       	or	r24, r25
     87c:	39 f0       	breq	.+14     	; 0x88c <__stack+0x2d>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     87e:	1e c0       	rjmp	.+60     	; 0x8bc <__stack+0x5d>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     880:	82 30       	cpi	r24, 0x02	; 2
     882:	91 05       	cpc	r25, r1
     884:	79 f0       	breq	.+30     	; 0x8a4 <__stack+0x45>
     886:	03 97       	sbiw	r24, 0x03	; 3
     888:	99 f0       	breq	.+38     	; 0x8b0 <__stack+0x51>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     88a:	18 c0       	rjmp	.+48     	; 0x8bc <__stack+0x5d>
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
			{
			case GROUP_A :
				DIO_u8_DDRA->ByteAccess = Copy_u8PortDirection;
     88c:	8a e3       	ldi	r24, 0x3A	; 58
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	2b 81       	ldd	r18, Y+3	; 0x03
     892:	fc 01       	movw	r30, r24
     894:	20 83       	st	Z, r18
				break;
     896:	12 c0       	rjmp	.+36     	; 0x8bc <__stack+0x5d>
			case GROUP_B :
				DIO_u8_DDRB->ByteAccess = Copy_u8PortDirection;
     898:	87 e3       	ldi	r24, 0x37	; 55
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	2b 81       	ldd	r18, Y+3	; 0x03
     89e:	fc 01       	movw	r30, r24
     8a0:	20 83       	st	Z, r18
				break;
     8a2:	0c c0       	rjmp	.+24     	; 0x8bc <__stack+0x5d>
			case GROUP_C :
				DIO_u8_DDRC->ByteAccess = Copy_u8PortDirection;
     8a4:	84 e3       	ldi	r24, 0x34	; 52
     8a6:	90 e0       	ldi	r25, 0x00	; 0
     8a8:	2b 81       	ldd	r18, Y+3	; 0x03
     8aa:	fc 01       	movw	r30, r24
     8ac:	20 83       	st	Z, r18
				break;
     8ae:	06 c0       	rjmp	.+12     	; 0x8bc <__stack+0x5d>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
     8b0:	81 e3       	ldi	r24, 0x31	; 49
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	2b 81       	ldd	r18, Y+3	; 0x03
     8b6:	fc 01       	movw	r30, r24
     8b8:	20 83       	st	Z, r18
				break;
     8ba:	00 00       	nop

				break;
			}
		}
	/*Function return*/
	return u8ErrorState;
     8bc:	89 81       	ldd	r24, Y+1	; 0x01
}
     8be:	0f 90       	pop	r0
     8c0:	0f 90       	pop	r0
     8c2:	0f 90       	pop	r0
     8c4:	df 91       	pop	r29
     8c6:	cf 91       	pop	r28
     8c8:	08 95       	ret

000008ca <DIO_u8SetPortValue>:

/* Description: This function shall set certain        */
/*              value to certain DIO_port              */
u8 DIO_u8SetPortValue(u8 Copy_u8PortNB, u8 Copy_u8PortValue)
{
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
     8ce:	00 d0       	rcall	.+0      	; 0x8d0 <DIO_u8SetPortValue+0x6>
     8d0:	1f 92       	push	r1
     8d2:	cd b7       	in	r28, 0x3d	; 61
     8d4:	de b7       	in	r29, 0x3e	; 62
     8d6:	8a 83       	std	Y+2, r24	; 0x02
     8d8:	6b 83       	std	Y+3, r22	; 0x03
		/*Local variables*/
		u8 u8ErrorState = 0;
     8da:	19 82       	std	Y+1, r1	; 0x01

		/*validate inputs*/
			if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     8dc:	8a 81       	ldd	r24, Y+2	; 0x02
     8de:	84 30       	cpi	r24, 0x04	; 4
     8e0:	18 f0       	brcs	.+6      	; 0x8e8 <DIO_u8SetPortValue+0x1e>
			{
				u8ErrorState = 1;
     8e2:	81 e0       	ldi	r24, 0x01	; 1
     8e4:	89 83       	std	Y+1, r24	; 0x01
     8e6:	2a c0       	rjmp	.+84     	; 0x93c <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     8e8:	8a 81       	ldd	r24, Y+2	; 0x02
     8ea:	88 2f       	mov	r24, r24
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	81 30       	cpi	r24, 0x01	; 1
     8f0:	91 05       	cpc	r25, r1
     8f2:	91 f0       	breq	.+36     	; 0x918 <DIO_u8SetPortValue+0x4e>
     8f4:	82 30       	cpi	r24, 0x02	; 2
     8f6:	91 05       	cpc	r25, r1
     8f8:	1c f4       	brge	.+6      	; 0x900 <DIO_u8SetPortValue+0x36>
     8fa:	89 2b       	or	r24, r25
     8fc:	39 f0       	breq	.+14     	; 0x90c <DIO_u8SetPortValue+0x42>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     8fe:	1e c0       	rjmp	.+60     	; 0x93c <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     900:	82 30       	cpi	r24, 0x02	; 2
     902:	91 05       	cpc	r25, r1
     904:	79 f0       	breq	.+30     	; 0x924 <DIO_u8SetPortValue+0x5a>
     906:	03 97       	sbiw	r24, 0x03	; 3
     908:	99 f0       	breq	.+38     	; 0x930 <DIO_u8SetPortValue+0x66>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     90a:	18 c0       	rjmp	.+48     	; 0x93c <DIO_u8SetPortValue+0x72>
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
				{
				case GROUP_A :
					DIO_u8_PORTA->ByteAccess = Copy_u8PortValue;
     90c:	8b e3       	ldi	r24, 0x3B	; 59
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	2b 81       	ldd	r18, Y+3	; 0x03
     912:	fc 01       	movw	r30, r24
     914:	20 83       	st	Z, r18
					break;
     916:	12 c0       	rjmp	.+36     	; 0x93c <DIO_u8SetPortValue+0x72>
				case GROUP_B :
					DIO_u8_PORTB->ByteAccess = Copy_u8PortValue;
     918:	88 e3       	ldi	r24, 0x38	; 56
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	2b 81       	ldd	r18, Y+3	; 0x03
     91e:	fc 01       	movw	r30, r24
     920:	20 83       	st	Z, r18
					break;
     922:	0c c0       	rjmp	.+24     	; 0x93c <DIO_u8SetPortValue+0x72>
				case GROUP_C :
					DIO_u8_PORTC->ByteAccess = Copy_u8PortValue;
     924:	85 e3       	ldi	r24, 0x35	; 53
     926:	90 e0       	ldi	r25, 0x00	; 0
     928:	2b 81       	ldd	r18, Y+3	; 0x03
     92a:	fc 01       	movw	r30, r24
     92c:	20 83       	st	Z, r18
					break;
     92e:	06 c0       	rjmp	.+12     	; 0x93c <DIO_u8SetPortValue+0x72>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
     930:	82 e3       	ldi	r24, 0x32	; 50
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	2b 81       	ldd	r18, Y+3	; 0x03
     936:	fc 01       	movw	r30, r24
     938:	20 83       	st	Z, r18
					break;
     93a:	00 00       	nop

					break;
				}
			}
		/*Function return*/
		return u8ErrorState;
     93c:	89 81       	ldd	r24, Y+1	; 0x01
}
     93e:	0f 90       	pop	r0
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <DIO_u8GetPinValue>:

/* */
/* */
u8 DIO_u8GetPinValue(u8 Copy_u8PinNB, u8 *Copy_u8PinValue)
{
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <DIO_u8GetPinValue+0x6>
     950:	00 d0       	rcall	.+0      	; 0x952 <DIO_u8GetPinValue+0x8>
     952:	00 d0       	rcall	.+0      	; 0x954 <DIO_u8GetPinValue+0xa>
     954:	cd b7       	in	r28, 0x3d	; 61
     956:	de b7       	in	r29, 0x3e	; 62
     958:	8c 83       	std	Y+4, r24	; 0x04
     95a:	7e 83       	std	Y+6, r23	; 0x06
     95c:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     95e:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     960:	8c 81       	ldd	r24, Y+4	; 0x04
     962:	80 32       	cpi	r24, 0x20	; 32
     964:	18 f0       	brcs	.+6      	; 0x96c <DIO_u8GetPinValue+0x22>
	{
		u8ErrorState = 1;
     966:	81 e0       	ldi	r24, 0x01	; 1
     968:	89 83       	std	Y+1, r24	; 0x01
     96a:	6f c0       	rjmp	.+222    	; 0xa4a <DIO_u8GetPinValue+0x100>
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     96c:	8c 81       	ldd	r24, Y+4	; 0x04
     96e:	86 95       	lsr	r24
     970:	86 95       	lsr	r24
     972:	86 95       	lsr	r24
     974:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     976:	8c 81       	ldd	r24, Y+4	; 0x04
     978:	87 70       	andi	r24, 0x07	; 7
     97a:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     97c:	8a 81       	ldd	r24, Y+2	; 0x02
     97e:	88 2f       	mov	r24, r24
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	81 30       	cpi	r24, 0x01	; 1
     984:	91 05       	cpc	r25, r1
     986:	11 f1       	breq	.+68     	; 0x9cc <DIO_u8GetPinValue+0x82>
     988:	82 30       	cpi	r24, 0x02	; 2
     98a:	91 05       	cpc	r25, r1
     98c:	1c f4       	brge	.+6      	; 0x994 <DIO_u8GetPinValue+0x4a>
     98e:	89 2b       	or	r24, r25
     990:	41 f0       	breq	.+16     	; 0x9a2 <DIO_u8GetPinValue+0x58>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     992:	5b c0       	rjmp	.+182    	; 0xa4a <DIO_u8GetPinValue+0x100>
		u8ErrorState = 1;
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     994:	82 30       	cpi	r24, 0x02	; 2
     996:	91 05       	cpc	r25, r1
     998:	71 f1       	breq	.+92     	; 0x9f6 <DIO_u8GetPinValue+0xac>
     99a:	03 97       	sbiw	r24, 0x03	; 3
     99c:	09 f4       	brne	.+2      	; 0x9a0 <DIO_u8GetPinValue+0x56>
     99e:	40 c0       	rjmp	.+128    	; 0xa20 <DIO_u8GetPinValue+0xd6>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     9a0:	54 c0       	rjmp	.+168    	; 0xa4a <DIO_u8GetPinValue+0x100>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINA -> ByteAccess, u8PIN_ID);
     9a2:	89 e3       	ldi	r24, 0x39	; 57
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	fc 01       	movw	r30, r24
     9a8:	80 81       	ld	r24, Z
     9aa:	88 2f       	mov	r24, r24
     9ac:	90 e0       	ldi	r25, 0x00	; 0
     9ae:	2b 81       	ldd	r18, Y+3	; 0x03
     9b0:	22 2f       	mov	r18, r18
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	02 c0       	rjmp	.+4      	; 0x9ba <DIO_u8GetPinValue+0x70>
     9b6:	95 95       	asr	r25
     9b8:	87 95       	ror	r24
     9ba:	2a 95       	dec	r18
     9bc:	e2 f7       	brpl	.-8      	; 0x9b6 <DIO_u8GetPinValue+0x6c>
     9be:	28 2f       	mov	r18, r24
     9c0:	21 70       	andi	r18, 0x01	; 1
     9c2:	8d 81       	ldd	r24, Y+5	; 0x05
     9c4:	9e 81       	ldd	r25, Y+6	; 0x06
     9c6:	fc 01       	movw	r30, r24
     9c8:	20 83       	st	Z, r18
			break;
     9ca:	3f c0       	rjmp	.+126    	; 0xa4a <DIO_u8GetPinValue+0x100>
		case GROUP_B :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINB -> ByteAccess, u8PIN_ID);
     9cc:	86 e3       	ldi	r24, 0x36	; 54
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	fc 01       	movw	r30, r24
     9d2:	80 81       	ld	r24, Z
     9d4:	88 2f       	mov	r24, r24
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	2b 81       	ldd	r18, Y+3	; 0x03
     9da:	22 2f       	mov	r18, r18
     9dc:	30 e0       	ldi	r19, 0x00	; 0
     9de:	02 c0       	rjmp	.+4      	; 0x9e4 <DIO_u8GetPinValue+0x9a>
     9e0:	95 95       	asr	r25
     9e2:	87 95       	ror	r24
     9e4:	2a 95       	dec	r18
     9e6:	e2 f7       	brpl	.-8      	; 0x9e0 <DIO_u8GetPinValue+0x96>
     9e8:	28 2f       	mov	r18, r24
     9ea:	21 70       	andi	r18, 0x01	; 1
     9ec:	8d 81       	ldd	r24, Y+5	; 0x05
     9ee:	9e 81       	ldd	r25, Y+6	; 0x06
     9f0:	fc 01       	movw	r30, r24
     9f2:	20 83       	st	Z, r18
			break;
     9f4:	2a c0       	rjmp	.+84     	; 0xa4a <DIO_u8GetPinValue+0x100>
		case GROUP_C :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINC -> ByteAccess, u8PIN_ID);
     9f6:	83 e3       	ldi	r24, 0x33	; 51
     9f8:	90 e0       	ldi	r25, 0x00	; 0
     9fa:	fc 01       	movw	r30, r24
     9fc:	80 81       	ld	r24, Z
     9fe:	88 2f       	mov	r24, r24
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	2b 81       	ldd	r18, Y+3	; 0x03
     a04:	22 2f       	mov	r18, r18
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	02 c0       	rjmp	.+4      	; 0xa0e <DIO_u8GetPinValue+0xc4>
     a0a:	95 95       	asr	r25
     a0c:	87 95       	ror	r24
     a0e:	2a 95       	dec	r18
     a10:	e2 f7       	brpl	.-8      	; 0xa0a <DIO_u8GetPinValue+0xc0>
     a12:	28 2f       	mov	r18, r24
     a14:	21 70       	andi	r18, 0x01	; 1
     a16:	8d 81       	ldd	r24, Y+5	; 0x05
     a18:	9e 81       	ldd	r25, Y+6	; 0x06
     a1a:	fc 01       	movw	r30, r24
     a1c:	20 83       	st	Z, r18
			break;
     a1e:	15 c0       	rjmp	.+42     	; 0xa4a <DIO_u8GetPinValue+0x100>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
     a20:	80 e3       	ldi	r24, 0x30	; 48
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	fc 01       	movw	r30, r24
     a26:	80 81       	ld	r24, Z
     a28:	88 2f       	mov	r24, r24
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	2b 81       	ldd	r18, Y+3	; 0x03
     a2e:	22 2f       	mov	r18, r18
     a30:	30 e0       	ldi	r19, 0x00	; 0
     a32:	02 c0       	rjmp	.+4      	; 0xa38 <DIO_u8GetPinValue+0xee>
     a34:	95 95       	asr	r25
     a36:	87 95       	ror	r24
     a38:	2a 95       	dec	r18
     a3a:	e2 f7       	brpl	.-8      	; 0xa34 <DIO_u8GetPinValue+0xea>
     a3c:	28 2f       	mov	r18, r24
     a3e:	21 70       	andi	r18, 0x01	; 1
     a40:	8d 81       	ldd	r24, Y+5	; 0x05
     a42:	9e 81       	ldd	r25, Y+6	; 0x06
     a44:	fc 01       	movw	r30, r24
     a46:	20 83       	st	Z, r18
			break;
     a48:	00 00       	nop

			break;
		}
	}
	/*Function return*/
	return u8ErrorState;
     a4a:	89 81       	ldd	r24, Y+1	; 0x01
}
     a4c:	26 96       	adiw	r28, 0x06	; 6
     a4e:	0f b6       	in	r0, 0x3f	; 63
     a50:	f8 94       	cli
     a52:	de bf       	out	0x3e, r29	; 62
     a54:	0f be       	out	0x3f, r0	; 63
     a56:	cd bf       	out	0x3d, r28	; 61
     a58:	df 91       	pop	r29
     a5a:	cf 91       	pop	r28
     a5c:	08 95       	ret

00000a5e <DIO_u8GetPortValue>:

/* */
/* */
u8 DIO_u8GetPortValue(u8 Copy_u8PortNB, u8 *Copy_u8PortValue)
{
     a5e:	cf 93       	push	r28
     a60:	df 93       	push	r29
     a62:	00 d0       	rcall	.+0      	; 0xa64 <DIO_u8GetPortValue+0x6>
     a64:	00 d0       	rcall	.+0      	; 0xa66 <DIO_u8GetPortValue+0x8>
     a66:	cd b7       	in	r28, 0x3d	; 61
     a68:	de b7       	in	r29, 0x3e	; 62
     a6a:	8a 83       	std	Y+2, r24	; 0x02
     a6c:	7c 83       	std	Y+4, r23	; 0x04
     a6e:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     a70:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
	if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     a72:	8a 81       	ldd	r24, Y+2	; 0x02
     a74:	84 30       	cpi	r24, 0x04	; 4
     a76:	18 f0       	brcs	.+6      	; 0xa7e <DIO_u8GetPortValue+0x20>
	{
		u8ErrorState = 1;
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	89 83       	std	Y+1, r24	; 0x01
     a7c:	36 c0       	rjmp	.+108    	; 0xaea <DIO_u8GetPortValue+0x8c>
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a7e:	8a 81       	ldd	r24, Y+2	; 0x02
     a80:	88 2f       	mov	r24, r24
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	81 30       	cpi	r24, 0x01	; 1
     a86:	91 05       	cpc	r25, r1
     a88:	a9 f0       	breq	.+42     	; 0xab4 <DIO_u8GetPortValue+0x56>
     a8a:	82 30       	cpi	r24, 0x02	; 2
     a8c:	91 05       	cpc	r25, r1
     a8e:	1c f4       	brge	.+6      	; 0xa96 <DIO_u8GetPortValue+0x38>
     a90:	89 2b       	or	r24, r25
     a92:	39 f0       	breq	.+14     	; 0xaa2 <DIO_u8GetPortValue+0x44>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     a94:	2a c0       	rjmp	.+84     	; 0xaea <DIO_u8GetPortValue+0x8c>
		u8ErrorState = 1;
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a96:	82 30       	cpi	r24, 0x02	; 2
     a98:	91 05       	cpc	r25, r1
     a9a:	a9 f0       	breq	.+42     	; 0xac6 <DIO_u8GetPortValue+0x68>
     a9c:	03 97       	sbiw	r24, 0x03	; 3
     a9e:	e1 f0       	breq	.+56     	; 0xad8 <DIO_u8GetPortValue+0x7a>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     aa0:	24 c0       	rjmp	.+72     	; 0xaea <DIO_u8GetPortValue+0x8c>
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
		{
			case GROUP_A :
				*Copy_u8PortValue = DIO_u8_PINA->ByteAccess;
     aa2:	89 e3       	ldi	r24, 0x39	; 57
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	fc 01       	movw	r30, r24
     aa8:	20 81       	ld	r18, Z
     aaa:	8b 81       	ldd	r24, Y+3	; 0x03
     aac:	9c 81       	ldd	r25, Y+4	; 0x04
     aae:	fc 01       	movw	r30, r24
     ab0:	20 83       	st	Z, r18
				break;
     ab2:	1b c0       	rjmp	.+54     	; 0xaea <DIO_u8GetPortValue+0x8c>
			case GROUP_B :
				*Copy_u8PortValue = DIO_u8_PINB->ByteAccess;
     ab4:	86 e3       	ldi	r24, 0x36	; 54
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	fc 01       	movw	r30, r24
     aba:	20 81       	ld	r18, Z
     abc:	8b 81       	ldd	r24, Y+3	; 0x03
     abe:	9c 81       	ldd	r25, Y+4	; 0x04
     ac0:	fc 01       	movw	r30, r24
     ac2:	20 83       	st	Z, r18
				break;
     ac4:	12 c0       	rjmp	.+36     	; 0xaea <DIO_u8GetPortValue+0x8c>
			case GROUP_C :
				*Copy_u8PortValue = DIO_u8_PINC->ByteAccess;
     ac6:	83 e3       	ldi	r24, 0x33	; 51
     ac8:	90 e0       	ldi	r25, 0x00	; 0
     aca:	fc 01       	movw	r30, r24
     acc:	20 81       	ld	r18, Z
     ace:	8b 81       	ldd	r24, Y+3	; 0x03
     ad0:	9c 81       	ldd	r25, Y+4	; 0x04
     ad2:	fc 01       	movw	r30, r24
     ad4:	20 83       	st	Z, r18
				break;
     ad6:	09 c0       	rjmp	.+18     	; 0xaea <DIO_u8GetPortValue+0x8c>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
     ad8:	80 e3       	ldi	r24, 0x30	; 48
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	fc 01       	movw	r30, r24
     ade:	20 81       	ld	r18, Z
     ae0:	8b 81       	ldd	r24, Y+3	; 0x03
     ae2:	9c 81       	ldd	r25, Y+4	; 0x04
     ae4:	fc 01       	movw	r30, r24
     ae6:	20 83       	st	Z, r18
				break;
     ae8:	00 00       	nop
				break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     aea:	89 81       	ldd	r24, Y+1	; 0x01
}
     aec:	0f 90       	pop	r0
     aee:	0f 90       	pop	r0
     af0:	0f 90       	pop	r0
     af2:	0f 90       	pop	r0
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	08 95       	ret

00000afa <KBD_u8GetKeyPadState>:
#include "KBD_interface.h"
#include "KBD_private.h"


u8 KBD_u8GetKeyPadState(u8* Copy_Au8KeysState/*[KBD_u8_KEYS_NB]*/)
{
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	cd b7       	in	r28, 0x3d	; 61
     b00:	de b7       	in	r29, 0x3e	; 62
     b02:	27 97       	sbiw	r28, 0x07	; 7
     b04:	0f b6       	in	r0, 0x3f	; 63
     b06:	f8 94       	cli
     b08:	de bf       	out	0x3e, r29	; 62
     b0a:	0f be       	out	0x3f, r0	; 63
     b0c:	cd bf       	out	0x3d, r28	; 61
     b0e:	9f 83       	std	Y+7, r25	; 0x07
     b10:	8e 83       	std	Y+6, r24	; 0x06
	u8 LOCAL_u8ColIndex = 0;
     b12:	19 82       	std	Y+1, r1	; 0x01
	u8 LOCAL_u8RowIndex = 0;
     b14:	1a 82       	std	Y+2, r1	; 0x02
	
	u8 Local_u8CurrentPinValue=0;
     b16:	1d 82       	std	Y+5, r1	; 0x05
	u8 Local_u8KeyIndex=0;
     b18:	1c 82       	std	Y+4, r1	; 0x04
	u8 pressed = 0xff;
     b1a:	8f ef       	ldi	r24, 0xFF	; 255
     b1c:	8b 83       	std	Y+3, r24	; 0x03
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     b1e:	19 82       	std	Y+1, r1	; 0x01
     b20:	52 c0       	rjmp	.+164    	; 0xbc6 <KBD_u8GetKeyPadState+0xcc>
		{
			//activate current col
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
     b22:	89 81       	ldd	r24, Y+1	; 0x01
     b24:	88 2f       	mov	r24, r24
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	82 50       	subi	r24, 0x02	; 2
     b2a:	99 4f       	sbci	r25, 0xF9	; 249
     b2c:	fc 01       	movw	r30, r24
     b2e:	80 81       	ld	r24, Z
     b30:	60 e0       	ldi	r22, 0x00	; 0
     b32:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     b36:	1a 82       	std	Y+2, r1	; 0x02
     b38:	36 c0       	rjmp	.+108    	; 0xba6 <KBD_u8GetKeyPadState+0xac>
			{
				DIO_u8GetPinValue(KBD_Au8RowsPins[LOCAL_u8RowIndex], &Local_u8CurrentPinValue);
     b3a:	8a 81       	ldd	r24, Y+2	; 0x02
     b3c:	88 2f       	mov	r24, r24
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	8e 5f       	subi	r24, 0xFE	; 254
     b42:	98 4f       	sbci	r25, 0xF8	; 248
     b44:	fc 01       	movw	r30, r24
     b46:	20 81       	ld	r18, Z
     b48:	ce 01       	movw	r24, r28
     b4a:	05 96       	adiw	r24, 0x05	; 5
     b4c:	bc 01       	movw	r22, r24
     b4e:	82 2f       	mov	r24, r18
     b50:	0e 94 a5 04 	call	0x94a	; 0x94a <DIO_u8GetPinValue>
				
				Local_u8KeyIndex = LOCAL_u8ColIndex + (LOCAL_u8RowIndex*KBD_u8_COL);
     b54:	8a 81       	ldd	r24, Y+2	; 0x02
     b56:	98 2f       	mov	r25, r24
     b58:	99 0f       	add	r25, r25
     b5a:	99 0f       	add	r25, r25
     b5c:	89 81       	ldd	r24, Y+1	; 0x01
     b5e:	89 0f       	add	r24, r25
     b60:	8c 83       	std	Y+4, r24	; 0x04
				
				if(Local_u8CurrentPinValue == DIO_u8_HIGH)
     b62:	8d 81       	ldd	r24, Y+5	; 0x05
     b64:	81 30       	cpi	r24, 0x01	; 1
     b66:	51 f4       	brne	.+20     	; 0xb7c <KBD_u8GetKeyPadState+0x82>
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Not Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
     b68:	8c 81       	ldd	r24, Y+4	; 0x04
     b6a:	88 2f       	mov	r24, r24
     b6c:	90 e0       	ldi	r25, 0x00	; 0
     b6e:	2e 81       	ldd	r18, Y+6	; 0x06
     b70:	3f 81       	ldd	r19, Y+7	; 0x07
     b72:	82 0f       	add	r24, r18
     b74:	93 1f       	adc	r25, r19
     b76:	fc 01       	movw	r30, r24
     b78:	10 82       	st	Z, r1
     b7a:	12 c0       	rjmp	.+36     	; 0xba0 <KBD_u8GetKeyPadState+0xa6>
					#endif
				}else
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_PRESSED;
     b7c:	8c 81       	ldd	r24, Y+4	; 0x04
     b7e:	88 2f       	mov	r24, r24
     b80:	90 e0       	ldi	r25, 0x00	; 0
     b82:	2e 81       	ldd	r18, Y+6	; 0x06
     b84:	3f 81       	ldd	r19, Y+7	; 0x07
     b86:	82 0f       	add	r24, r18
     b88:	93 1f       	adc	r25, r19
     b8a:	21 e0       	ldi	r18, 0x01	; 1
     b8c:	fc 01       	movw	r30, r24
     b8e:	20 83       	st	Z, r18
						pressed = key_map[Local_u8KeyIndex];
     b90:	8c 81       	ldd	r24, Y+4	; 0x04
     b92:	88 2f       	mov	r24, r24
     b94:	90 e0       	ldi	r25, 0x00	; 0
     b96:	8f 59       	subi	r24, 0x9F	; 159
     b98:	9f 4f       	sbci	r25, 0xFF	; 255
     b9a:	fc 01       	movw	r30, r24
     b9c:	80 81       	ld	r24, Z
     b9e:	8b 83       	std	Y+3, r24	; 0x03
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     ba0:	8a 81       	ldd	r24, Y+2	; 0x02
     ba2:	8f 5f       	subi	r24, 0xFF	; 255
     ba4:	8a 83       	std	Y+2, r24	; 0x02
     ba6:	8a 81       	ldd	r24, Y+2	; 0x02
     ba8:	84 30       	cpi	r24, 0x04	; 4
     baa:	38 f2       	brcs	.-114    	; 0xb3a <KBD_u8GetKeyPadState+0x40>
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
					#endif
				}
			}
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
     bac:	89 81       	ldd	r24, Y+1	; 0x01
     bae:	88 2f       	mov	r24, r24
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	82 50       	subi	r24, 0x02	; 2
     bb4:	99 4f       	sbci	r25, 0xF9	; 249
     bb6:	fc 01       	movw	r30, r24
     bb8:	80 81       	ld	r24, Z
     bba:	61 e0       	ldi	r22, 0x01	; 1
     bbc:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	u8 Local_u8CurrentPinValue=0;
	u8 Local_u8KeyIndex=0;
	u8 pressed = 0xff;
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     bc0:	89 81       	ldd	r24, Y+1	; 0x01
     bc2:	8f 5f       	subi	r24, 0xFF	; 255
     bc4:	89 83       	std	Y+1, r24	; 0x01
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	84 30       	cpi	r24, 0x04	; 4
     bca:	08 f4       	brcc	.+2      	; 0xbce <KBD_u8GetKeyPadState+0xd4>
     bcc:	aa cf       	rjmp	.-172    	; 0xb22 <KBD_u8GetKeyPadState+0x28>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#else
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
			#endif
		}
		return pressed;
     bce:	8b 81       	ldd	r24, Y+3	; 0x03
			#endif
		}

	#endif

}
     bd0:	27 96       	adiw	r28, 0x07	; 7
     bd2:	0f b6       	in	r0, 0x3f	; 63
     bd4:	f8 94       	cli
     bd6:	de bf       	out	0x3e, r29	; 62
     bd8:	0f be       	out	0x3f, r0	; 63
     bda:	cd bf       	out	0x3d, r28	; 61
     bdc:	df 91       	pop	r29
     bde:	cf 91       	pop	r28
     be0:	08 95       	ret

00000be2 <KBD_u8Initialize>:
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
     be2:	cf 93       	push	r28
     be4:	df 93       	push	r29
     be6:	cd b7       	in	r28, 0x3d	; 61
     be8:	de b7       	in	r29, 0x3e	; 62
     bea:	29 97       	sbiw	r28, 0x09	; 9
     bec:	0f b6       	in	r0, 0x3f	; 63
     bee:	f8 94       	cli
     bf0:	de bf       	out	0x3e, r29	; 62
     bf2:	0f be       	out	0x3f, r0	; 63
     bf4:	cd bf       	out	0x3d, r28	; 61
     bf6:	89 87       	std	Y+9, r24	; 0x09
		switch (group_nb)
     bf8:	89 85       	ldd	r24, Y+9	; 0x09
     bfa:	88 2f       	mov	r24, r24
     bfc:	90 e0       	ldi	r25, 0x00	; 0
     bfe:	81 30       	cpi	r24, 0x01	; 1
     c00:	91 05       	cpc	r25, r1
     c02:	09 f4       	brne	.+2      	; 0xc06 <KBD_u8Initialize+0x24>
     c04:	42 c0       	rjmp	.+132    	; 0xc8a <KBD_u8Initialize+0xa8>
     c06:	82 30       	cpi	r24, 0x02	; 2
     c08:	91 05       	cpc	r25, r1
     c0a:	1c f4       	brge	.+6      	; 0xc12 <KBD_u8Initialize+0x30>
     c0c:	89 2b       	or	r24, r25
     c0e:	49 f0       	breq	.+18     	; 0xc22 <KBD_u8Initialize+0x40>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     c10:	d8 c0       	rjmp	.+432    	; 0xdc2 <KBD_u8Initialize+0x1e0>
	#endif

}
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
     c12:	82 30       	cpi	r24, 0x02	; 2
     c14:	91 05       	cpc	r25, r1
     c16:	09 f4       	brne	.+2      	; 0xc1a <KBD_u8Initialize+0x38>
     c18:	6c c0       	rjmp	.+216    	; 0xcf2 <KBD_u8Initialize+0x110>
     c1a:	03 97       	sbiw	r24, 0x03	; 3
     c1c:	09 f4       	brne	.+2      	; 0xc20 <KBD_u8Initialize+0x3e>
     c1e:	9d c0       	rjmp	.+314    	; 0xd5a <KBD_u8Initialize+0x178>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     c20:	d0 c0       	rjmp	.+416    	; 0xdc2 <KBD_u8Initialize+0x1e0>
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
		{
		case 0:
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
     c22:	6f e0       	ldi	r22, 0x0F	; 15
     c24:	80 e0       	ldi	r24, 0x00	; 0
     c26:	0e 94 25 04 	call	0x84a	; 0x84a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(A4,1);
     c2a:	61 e0       	ldi	r22, 0x01	; 1
     c2c:	84 e0       	ldi	r24, 0x04	; 4
     c2e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A5,1);
     c32:	61 e0       	ldi	r22, 0x01	; 1
     c34:	85 e0       	ldi	r24, 0x05	; 5
     c36:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A6,1);
     c3a:	61 e0       	ldi	r22, 0x01	; 1
     c3c:	86 e0       	ldi	r24, 0x06	; 6
     c3e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A7,1);
     c42:	61 e0       	ldi	r22, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c4a:	1a 82       	std	Y+2, r1	; 0x02
     c4c:	19 82       	std	Y+1, r1	; 0x01
     c4e:	18 c0       	rjmp	.+48     	; 0xc80 <KBD_u8Initialize+0x9e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
     c50:	89 81       	ldd	r24, Y+1	; 0x01
     c52:	24 e0       	ldi	r18, 0x04	; 4
     c54:	28 0f       	add	r18, r24
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	9a 81       	ldd	r25, Y+2	; 0x02
     c5a:	8e 5f       	subi	r24, 0xFE	; 254
     c5c:	98 4f       	sbci	r25, 0xF8	; 248
     c5e:	fc 01       	movw	r30, r24
     c60:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = A3 - i;
     c62:	89 81       	ldd	r24, Y+1	; 0x01
     c64:	93 e0       	ldi	r25, 0x03	; 3
     c66:	29 2f       	mov	r18, r25
     c68:	28 1b       	sub	r18, r24
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
     c6c:	9a 81       	ldd	r25, Y+2	; 0x02
     c6e:	82 50       	subi	r24, 0x02	; 2
     c70:	99 4f       	sbci	r25, 0xF9	; 249
     c72:	fc 01       	movw	r30, r24
     c74:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
			DIO_u8SetPinValue(A4,1);
			DIO_u8SetPinValue(A5,1);
			DIO_u8SetPinValue(A6,1);
			DIO_u8SetPinValue(A7,1);
			for (int i=0;i<4;i++)
     c76:	89 81       	ldd	r24, Y+1	; 0x01
     c78:	9a 81       	ldd	r25, Y+2	; 0x02
     c7a:	01 96       	adiw	r24, 0x01	; 1
     c7c:	9a 83       	std	Y+2, r25	; 0x02
     c7e:	89 83       	std	Y+1, r24	; 0x01
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	9a 81       	ldd	r25, Y+2	; 0x02
     c84:	04 97       	sbiw	r24, 0x04	; 4
     c86:	24 f3       	brlt	.-56     	; 0xc50 <KBD_u8Initialize+0x6e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
				KBD_Au8ColsPins[i] = A3 - i;
			}
			break;
     c88:	9c c0       	rjmp	.+312    	; 0xdc2 <KBD_u8Initialize+0x1e0>
		case 1:
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
     c8a:	6f e0       	ldi	r22, 0x0F	; 15
     c8c:	81 e0       	ldi	r24, 0x01	; 1
     c8e:	0e 94 25 04 	call	0x84a	; 0x84a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(B4,1);
     c92:	61 e0       	ldi	r22, 0x01	; 1
     c94:	8c e0       	ldi	r24, 0x0C	; 12
     c96:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B5,1);
     c9a:	61 e0       	ldi	r22, 0x01	; 1
     c9c:	8d e0       	ldi	r24, 0x0D	; 13
     c9e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B6,1);
     ca2:	61 e0       	ldi	r22, 0x01	; 1
     ca4:	8e e0       	ldi	r24, 0x0E	; 14
     ca6:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B7,1);
     caa:	61 e0       	ldi	r22, 0x01	; 1
     cac:	8f e0       	ldi	r24, 0x0F	; 15
     cae:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     cb2:	1c 82       	std	Y+4, r1	; 0x04
     cb4:	1b 82       	std	Y+3, r1	; 0x03
     cb6:	18 c0       	rjmp	.+48     	; 0xce8 <KBD_u8Initialize+0x106>
			{
				KBD_Au8RowsPins[i] = B4 + i;
     cb8:	8b 81       	ldd	r24, Y+3	; 0x03
     cba:	2c e0       	ldi	r18, 0x0C	; 12
     cbc:	28 0f       	add	r18, r24
     cbe:	8b 81       	ldd	r24, Y+3	; 0x03
     cc0:	9c 81       	ldd	r25, Y+4	; 0x04
     cc2:	8e 5f       	subi	r24, 0xFE	; 254
     cc4:	98 4f       	sbci	r25, 0xF8	; 248
     cc6:	fc 01       	movw	r30, r24
     cc8:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = B3 - i;
     cca:	8b 81       	ldd	r24, Y+3	; 0x03
     ccc:	9b e0       	ldi	r25, 0x0B	; 11
     cce:	29 2f       	mov	r18, r25
     cd0:	28 1b       	sub	r18, r24
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	9c 81       	ldd	r25, Y+4	; 0x04
     cd6:	82 50       	subi	r24, 0x02	; 2
     cd8:	99 4f       	sbci	r25, 0xF9	; 249
     cda:	fc 01       	movw	r30, r24
     cdc:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
			DIO_u8SetPinValue(B4,1);
			DIO_u8SetPinValue(B5,1);
			DIO_u8SetPinValue(B6,1);
			DIO_u8SetPinValue(B7,1);
			for (int i=0;i<4;i++)
     cde:	8b 81       	ldd	r24, Y+3	; 0x03
     ce0:	9c 81       	ldd	r25, Y+4	; 0x04
     ce2:	01 96       	adiw	r24, 0x01	; 1
     ce4:	9c 83       	std	Y+4, r25	; 0x04
     ce6:	8b 83       	std	Y+3, r24	; 0x03
     ce8:	8b 81       	ldd	r24, Y+3	; 0x03
     cea:	9c 81       	ldd	r25, Y+4	; 0x04
     cec:	04 97       	sbiw	r24, 0x04	; 4
     cee:	24 f3       	brlt	.-56     	; 0xcb8 <KBD_u8Initialize+0xd6>
			{
				KBD_Au8RowsPins[i] = B4 + i;
				KBD_Au8ColsPins[i] = B3 - i;
			}
			break;
     cf0:	68 c0       	rjmp	.+208    	; 0xdc2 <KBD_u8Initialize+0x1e0>
		case 2:
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
     cf2:	6f e0       	ldi	r22, 0x0F	; 15
     cf4:	82 e0       	ldi	r24, 0x02	; 2
     cf6:	0e 94 25 04 	call	0x84a	; 0x84a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(C4,1);
     cfa:	61 e0       	ldi	r22, 0x01	; 1
     cfc:	84 e1       	ldi	r24, 0x14	; 20
     cfe:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C5,1);
     d02:	61 e0       	ldi	r22, 0x01	; 1
     d04:	85 e1       	ldi	r24, 0x15	; 21
     d06:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C6,1);
     d0a:	61 e0       	ldi	r22, 0x01	; 1
     d0c:	86 e1       	ldi	r24, 0x16	; 22
     d0e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C7,1);
     d12:	61 e0       	ldi	r22, 0x01	; 1
     d14:	87 e1       	ldi	r24, 0x17	; 23
     d16:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     d1a:	1e 82       	std	Y+6, r1	; 0x06
     d1c:	1d 82       	std	Y+5, r1	; 0x05
     d1e:	18 c0       	rjmp	.+48     	; 0xd50 <KBD_u8Initialize+0x16e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
     d20:	8d 81       	ldd	r24, Y+5	; 0x05
     d22:	24 e1       	ldi	r18, 0x14	; 20
     d24:	28 0f       	add	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	8e 5f       	subi	r24, 0xFE	; 254
     d2c:	98 4f       	sbci	r25, 0xF8	; 248
     d2e:	fc 01       	movw	r30, r24
     d30:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = C3 - i;
     d32:	8d 81       	ldd	r24, Y+5	; 0x05
     d34:	93 e1       	ldi	r25, 0x13	; 19
     d36:	29 2f       	mov	r18, r25
     d38:	28 1b       	sub	r18, r24
     d3a:	8d 81       	ldd	r24, Y+5	; 0x05
     d3c:	9e 81       	ldd	r25, Y+6	; 0x06
     d3e:	82 50       	subi	r24, 0x02	; 2
     d40:	99 4f       	sbci	r25, 0xF9	; 249
     d42:	fc 01       	movw	r30, r24
     d44:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
			DIO_u8SetPinValue(C4,1);
			DIO_u8SetPinValue(C5,1);
			DIO_u8SetPinValue(C6,1);
			DIO_u8SetPinValue(C7,1);
			for (int i=0;i<4;i++)
     d46:	8d 81       	ldd	r24, Y+5	; 0x05
     d48:	9e 81       	ldd	r25, Y+6	; 0x06
     d4a:	01 96       	adiw	r24, 0x01	; 1
     d4c:	9e 83       	std	Y+6, r25	; 0x06
     d4e:	8d 83       	std	Y+5, r24	; 0x05
     d50:	8d 81       	ldd	r24, Y+5	; 0x05
     d52:	9e 81       	ldd	r25, Y+6	; 0x06
     d54:	04 97       	sbiw	r24, 0x04	; 4
     d56:	24 f3       	brlt	.-56     	; 0xd20 <KBD_u8Initialize+0x13e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
				KBD_Au8ColsPins[i] = C3 - i;
			}
			break;
     d58:	34 c0       	rjmp	.+104    	; 0xdc2 <KBD_u8Initialize+0x1e0>
		case 3:
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
     d5a:	6f e0       	ldi	r22, 0x0F	; 15
     d5c:	83 e0       	ldi	r24, 0x03	; 3
     d5e:	0e 94 25 04 	call	0x84a	; 0x84a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(D4,1);
     d62:	61 e0       	ldi	r22, 0x01	; 1
     d64:	8c e1       	ldi	r24, 0x1C	; 28
     d66:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D5,1);
     d6a:	61 e0       	ldi	r22, 0x01	; 1
     d6c:	8d e1       	ldi	r24, 0x1D	; 29
     d6e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D6,1);
     d72:	61 e0       	ldi	r22, 0x01	; 1
     d74:	8e e1       	ldi	r24, 0x1E	; 30
     d76:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D7,1);
     d7a:	61 e0       	ldi	r22, 0x01	; 1
     d7c:	8f e1       	ldi	r24, 0x1F	; 31
     d7e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     d82:	18 86       	std	Y+8, r1	; 0x08
     d84:	1f 82       	std	Y+7, r1	; 0x07
     d86:	18 c0       	rjmp	.+48     	; 0xdb8 <KBD_u8Initialize+0x1d6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
     d88:	8f 81       	ldd	r24, Y+7	; 0x07
     d8a:	2c e1       	ldi	r18, 0x1C	; 28
     d8c:	28 0f       	add	r18, r24
     d8e:	8f 81       	ldd	r24, Y+7	; 0x07
     d90:	98 85       	ldd	r25, Y+8	; 0x08
     d92:	8e 5f       	subi	r24, 0xFE	; 254
     d94:	98 4f       	sbci	r25, 0xF8	; 248
     d96:	fc 01       	movw	r30, r24
     d98:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = D3 - i;
     d9a:	8f 81       	ldd	r24, Y+7	; 0x07
     d9c:	9b e1       	ldi	r25, 0x1B	; 27
     d9e:	29 2f       	mov	r18, r25
     da0:	28 1b       	sub	r18, r24
     da2:	8f 81       	ldd	r24, Y+7	; 0x07
     da4:	98 85       	ldd	r25, Y+8	; 0x08
     da6:	82 50       	subi	r24, 0x02	; 2
     da8:	99 4f       	sbci	r25, 0xF9	; 249
     daa:	fc 01       	movw	r30, r24
     dac:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
			DIO_u8SetPinValue(D4,1);
			DIO_u8SetPinValue(D5,1);
			DIO_u8SetPinValue(D6,1);
			DIO_u8SetPinValue(D7,1);
			for (int i=0;i<4;i++)
     dae:	8f 81       	ldd	r24, Y+7	; 0x07
     db0:	98 85       	ldd	r25, Y+8	; 0x08
     db2:	01 96       	adiw	r24, 0x01	; 1
     db4:	98 87       	std	Y+8, r25	; 0x08
     db6:	8f 83       	std	Y+7, r24	; 0x07
     db8:	8f 81       	ldd	r24, Y+7	; 0x07
     dba:	98 85       	ldd	r25, Y+8	; 0x08
     dbc:	04 97       	sbiw	r24, 0x04	; 4
     dbe:	24 f3       	brlt	.-56     	; 0xd88 <KBD_u8Initialize+0x1a6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
     dc0:	00 00       	nop
		}
	}
     dc2:	00 00       	nop
     dc4:	29 96       	adiw	r28, 0x09	; 9
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	de bf       	out	0x3e, r29	; 62
     dcc:	0f be       	out	0x3f, r0	; 63
     dce:	cd bf       	out	0x3d, r28	; 61
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	08 95       	ret

00000dd6 <KBD_keys_map>:
u8 KBD_keys_map(u8* keys)
{
     dd6:	cf 93       	push	r28
     dd8:	df 93       	push	r29
     dda:	00 d0       	rcall	.+0      	; 0xddc <KBD_keys_map+0x6>
     ddc:	1f 92       	push	r1
     dde:	cd b7       	in	r28, 0x3d	; 61
     de0:	de b7       	in	r29, 0x3e	; 62
     de2:	9b 83       	std	Y+3, r25	; 0x03
     de4:	8a 83       	std	Y+2, r24	; 0x02
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     de6:	19 82       	std	Y+1, r1	; 0x01
     de8:	16 c0       	rjmp	.+44     	; 0xe16 <KBD_keys_map+0x40>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
     dea:	89 81       	ldd	r24, Y+1	; 0x01
     dec:	88 2f       	mov	r24, r24
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	2a 81       	ldd	r18, Y+2	; 0x02
     df2:	3b 81       	ldd	r19, Y+3	; 0x03
     df4:	82 0f       	add	r24, r18
     df6:	93 1f       	adc	r25, r19
     df8:	fc 01       	movw	r30, r24
     dfa:	80 81       	ld	r24, Z
     dfc:	81 30       	cpi	r24, 0x01	; 1
     dfe:	41 f4       	brne	.+16     	; 0xe10 <KBD_keys_map+0x3a>
     e00:	89 81       	ldd	r24, Y+1	; 0x01
     e02:	88 2f       	mov	r24, r24
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	8f 59       	subi	r24, 0x9F	; 159
     e08:	9f 4f       	sbci	r25, 0xFF	; 255
     e0a:	fc 01       	movw	r30, r24
     e0c:	80 81       	ld	r24, Z
     e0e:	07 c0       	rjmp	.+14     	; 0xe1e <KBD_keys_map+0x48>
		}
	}
u8 KBD_keys_map(u8* keys)
{
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     e10:	89 81       	ldd	r24, Y+1	; 0x01
     e12:	8f 5f       	subi	r24, 0xFF	; 255
     e14:	89 83       	std	Y+1, r24	; 0x01
     e16:	89 81       	ldd	r24, Y+1	; 0x01
     e18:	80 31       	cpi	r24, 0x10	; 16
     e1a:	38 f3       	brcs	.-50     	; 0xdea <KBD_keys_map+0x14>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
    }
    return 0xff;
     e1c:	8f ef       	ldi	r24, 0xFF	; 255
}
     e1e:	0f 90       	pop	r0
     e20:	0f 90       	pop	r0
     e22:	0f 90       	pop	r0
     e24:	df 91       	pop	r29
     e26:	cf 91       	pop	r28
     e28:	08 95       	ret

00000e2a <LCD_Void_Write>:
#define F_CPU 8000000
#include "avr/delay.h"

static void LCD_Void_Write(u8 copy_u8_value) // the user wont use this func because only other functions will use it so the prototype will be in private.h
//and to make this func visible only in this file not on the whole project we will put static in front of it
{
     e2a:	cf 93       	push	r28
     e2c:	df 93       	push	r29
     e2e:	cd b7       	in	r28, 0x3d	; 61
     e30:	de b7       	in	r29, 0x3e	; 62
     e32:	2f 97       	sbiw	r28, 0x0f	; 15
     e34:	0f b6       	in	r0, 0x3f	; 63
     e36:	f8 94       	cli
     e38:	de bf       	out	0x3e, r29	; 62
     e3a:	0f be       	out	0x3f, r0	; 63
     e3c:	cd bf       	out	0x3d, r28	; 61
     e3e:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_u8SetPinValue(LCD_u8_RW_Pin,DIO_u8_LOW);
     e40:	60 e0       	ldi	r22, 0x00	; 0
     e42:	81 e1       	ldi	r24, 0x11	; 17
     e44:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D0_Pin,Get_Bit(copy_u8_value,0));
     e48:	8f 85       	ldd	r24, Y+15	; 0x0f
     e4a:	81 70       	andi	r24, 0x01	; 1
     e4c:	68 2f       	mov	r22, r24
     e4e:	87 e0       	ldi	r24, 0x07	; 7
     e50:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D1_Pin,Get_Bit(copy_u8_value,1));
     e54:	8f 85       	ldd	r24, Y+15	; 0x0f
     e56:	86 95       	lsr	r24
     e58:	81 70       	andi	r24, 0x01	; 1
     e5a:	68 2f       	mov	r22, r24
     e5c:	86 e0       	ldi	r24, 0x06	; 6
     e5e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D2_Pin,Get_Bit(copy_u8_value,2));
     e62:	8f 85       	ldd	r24, Y+15	; 0x0f
     e64:	86 95       	lsr	r24
     e66:	86 95       	lsr	r24
     e68:	81 70       	andi	r24, 0x01	; 1
     e6a:	68 2f       	mov	r22, r24
     e6c:	85 e0       	ldi	r24, 0x05	; 5
     e6e:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D3_Pin,Get_Bit(copy_u8_value,3));
     e72:	8f 85       	ldd	r24, Y+15	; 0x0f
     e74:	86 95       	lsr	r24
     e76:	86 95       	lsr	r24
     e78:	86 95       	lsr	r24
     e7a:	81 70       	andi	r24, 0x01	; 1
     e7c:	68 2f       	mov	r22, r24
     e7e:	84 e0       	ldi	r24, 0x04	; 4
     e80:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D4_Pin,Get_Bit(copy_u8_value,4));
     e84:	8f 85       	ldd	r24, Y+15	; 0x0f
     e86:	82 95       	swap	r24
     e88:	8f 70       	andi	r24, 0x0F	; 15
     e8a:	81 70       	andi	r24, 0x01	; 1
     e8c:	68 2f       	mov	r22, r24
     e8e:	83 e0       	ldi	r24, 0x03	; 3
     e90:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D5_Pin,Get_Bit(copy_u8_value,5));
     e94:	8f 85       	ldd	r24, Y+15	; 0x0f
     e96:	82 95       	swap	r24
     e98:	86 95       	lsr	r24
     e9a:	87 70       	andi	r24, 0x07	; 7
     e9c:	81 70       	andi	r24, 0x01	; 1
     e9e:	68 2f       	mov	r22, r24
     ea0:	82 e0       	ldi	r24, 0x02	; 2
     ea2:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D6_Pin,Get_Bit(copy_u8_value,6));
     ea6:	8f 85       	ldd	r24, Y+15	; 0x0f
     ea8:	82 95       	swap	r24
     eaa:	86 95       	lsr	r24
     eac:	86 95       	lsr	r24
     eae:	83 70       	andi	r24, 0x03	; 3
     eb0:	81 70       	andi	r24, 0x01	; 1
     eb2:	68 2f       	mov	r22, r24
     eb4:	81 e0       	ldi	r24, 0x01	; 1
     eb6:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D7_Pin,Get_Bit(copy_u8_value,7));
     eba:	8f 85       	ldd	r24, Y+15	; 0x0f
     ebc:	88 1f       	adc	r24, r24
     ebe:	88 27       	eor	r24, r24
     ec0:	88 1f       	adc	r24, r24
     ec2:	68 2f       	mov	r22, r24
     ec4:	80 e0       	ldi	r24, 0x00	; 0
     ec6:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_HIGH);
     eca:	61 e0       	ldi	r22, 0x01	; 1
     ecc:	82 e1       	ldi	r24, 0x12	; 18
     ece:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
     ed2:	80 e0       	ldi	r24, 0x00	; 0
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	a0 e8       	ldi	r26, 0x80	; 128
     ed8:	bf e3       	ldi	r27, 0x3F	; 63
     eda:	89 83       	std	Y+1, r24	; 0x01
     edc:	9a 83       	std	Y+2, r25	; 0x02
     ede:	ab 83       	std	Y+3, r26	; 0x03
     ee0:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     ee2:	20 e0       	ldi	r18, 0x00	; 0
     ee4:	30 e0       	ldi	r19, 0x00	; 0
     ee6:	4a ef       	ldi	r20, 0xFA	; 250
     ee8:	54 e4       	ldi	r21, 0x44	; 68
     eea:	69 81       	ldd	r22, Y+1	; 0x01
     eec:	7a 81       	ldd	r23, Y+2	; 0x02
     eee:	8b 81       	ldd	r24, Y+3	; 0x03
     ef0:	9c 81       	ldd	r25, Y+4	; 0x04
     ef2:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
     ef6:	dc 01       	movw	r26, r24
     ef8:	cb 01       	movw	r24, r22
     efa:	8d 83       	std	Y+5, r24	; 0x05
     efc:	9e 83       	std	Y+6, r25	; 0x06
     efe:	af 83       	std	Y+7, r26	; 0x07
     f00:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     f02:	20 e0       	ldi	r18, 0x00	; 0
     f04:	30 e0       	ldi	r19, 0x00	; 0
     f06:	40 e8       	ldi	r20, 0x80	; 128
     f08:	5f e3       	ldi	r21, 0x3F	; 63
     f0a:	6d 81       	ldd	r22, Y+5	; 0x05
     f0c:	7e 81       	ldd	r23, Y+6	; 0x06
     f0e:	8f 81       	ldd	r24, Y+7	; 0x07
     f10:	98 85       	ldd	r25, Y+8	; 0x08
     f12:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
     f16:	88 23       	and	r24, r24
     f18:	2c f4       	brge	.+10     	; 0xf24 <LCD_Void_Write+0xfa>
		__ticks = 1;
     f1a:	81 e0       	ldi	r24, 0x01	; 1
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	9a 87       	std	Y+10, r25	; 0x0a
     f20:	89 87       	std	Y+9, r24	; 0x09
     f22:	3f c0       	rjmp	.+126    	; 0xfa2 <LCD_Void_Write+0x178>
	else if (__tmp > 65535)
     f24:	20 e0       	ldi	r18, 0x00	; 0
     f26:	3f ef       	ldi	r19, 0xFF	; 255
     f28:	4f e7       	ldi	r20, 0x7F	; 127
     f2a:	57 e4       	ldi	r21, 0x47	; 71
     f2c:	6d 81       	ldd	r22, Y+5	; 0x05
     f2e:	7e 81       	ldd	r23, Y+6	; 0x06
     f30:	8f 81       	ldd	r24, Y+7	; 0x07
     f32:	98 85       	ldd	r25, Y+8	; 0x08
     f34:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
     f38:	18 16       	cp	r1, r24
     f3a:	4c f5       	brge	.+82     	; 0xf8e <LCD_Void_Write+0x164>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f3c:	20 e0       	ldi	r18, 0x00	; 0
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	40 e2       	ldi	r20, 0x20	; 32
     f42:	51 e4       	ldi	r21, 0x41	; 65
     f44:	69 81       	ldd	r22, Y+1	; 0x01
     f46:	7a 81       	ldd	r23, Y+2	; 0x02
     f48:	8b 81       	ldd	r24, Y+3	; 0x03
     f4a:	9c 81       	ldd	r25, Y+4	; 0x04
     f4c:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
     f50:	dc 01       	movw	r26, r24
     f52:	cb 01       	movw	r24, r22
     f54:	bc 01       	movw	r22, r24
     f56:	cd 01       	movw	r24, r26
     f58:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
     f5c:	dc 01       	movw	r26, r24
     f5e:	cb 01       	movw	r24, r22
     f60:	9a 87       	std	Y+10, r25	; 0x0a
     f62:	89 87       	std	Y+9, r24	; 0x09
     f64:	0f c0       	rjmp	.+30     	; 0xf84 <LCD_Void_Write+0x15a>
     f66:	88 ec       	ldi	r24, 0xC8	; 200
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	9c 87       	std	Y+12, r25	; 0x0c
     f6c:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     f6e:	8b 85       	ldd	r24, Y+11	; 0x0b
     f70:	9c 85       	ldd	r25, Y+12	; 0x0c
     f72:	01 97       	sbiw	r24, 0x01	; 1
     f74:	f1 f7       	brne	.-4      	; 0xf72 <LCD_Void_Write+0x148>
     f76:	9c 87       	std	Y+12, r25	; 0x0c
     f78:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f7a:	89 85       	ldd	r24, Y+9	; 0x09
     f7c:	9a 85       	ldd	r25, Y+10	; 0x0a
     f7e:	01 97       	sbiw	r24, 0x01	; 1
     f80:	9a 87       	std	Y+10, r25	; 0x0a
     f82:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f84:	89 85       	ldd	r24, Y+9	; 0x09
     f86:	9a 85       	ldd	r25, Y+10	; 0x0a
     f88:	89 2b       	or	r24, r25
     f8a:	69 f7       	brne	.-38     	; 0xf66 <LCD_Void_Write+0x13c>
     f8c:	14 c0       	rjmp	.+40     	; 0xfb6 <LCD_Void_Write+0x18c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f8e:	6d 81       	ldd	r22, Y+5	; 0x05
     f90:	7e 81       	ldd	r23, Y+6	; 0x06
     f92:	8f 81       	ldd	r24, Y+7	; 0x07
     f94:	98 85       	ldd	r25, Y+8	; 0x08
     f96:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
     f9a:	dc 01       	movw	r26, r24
     f9c:	cb 01       	movw	r24, r22
     f9e:	9a 87       	std	Y+10, r25	; 0x0a
     fa0:	89 87       	std	Y+9, r24	; 0x09
     fa2:	89 85       	ldd	r24, Y+9	; 0x09
     fa4:	9a 85       	ldd	r25, Y+10	; 0x0a
     fa6:	9e 87       	std	Y+14, r25	; 0x0e
     fa8:	8d 87       	std	Y+13, r24	; 0x0d
     faa:	8d 85       	ldd	r24, Y+13	; 0x0d
     fac:	9e 85       	ldd	r25, Y+14	; 0x0e
     fae:	01 97       	sbiw	r24, 0x01	; 1
     fb0:	f1 f7       	brne	.-4      	; 0xfae <LCD_Void_Write+0x184>
     fb2:	9e 87       	std	Y+14, r25	; 0x0e
     fb4:	8d 87       	std	Y+13, r24	; 0x0d
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_LOW);
     fb6:	60 e0       	ldi	r22, 0x00	; 0
     fb8:	82 e1       	ldi	r24, 0x12	; 18
     fba:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
}
     fbe:	00 00       	nop
     fc0:	2f 96       	adiw	r28, 0x0f	; 15
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	cd bf       	out	0x3d, r28	; 61
     fcc:	df 91       	pop	r29
     fce:	cf 91       	pop	r28
     fd0:	08 95       	ret

00000fd2 <LCD_Void_Write_Cmd>:

void LCD_Void_Write_Cmd(u8 copy_u8_cmd)
{
     fd2:	cf 93       	push	r28
     fd4:	df 93       	push	r29
     fd6:	1f 92       	push	r1
     fd8:	cd b7       	in	r28, 0x3d	; 61
     fda:	de b7       	in	r29, 0x3e	; 62
     fdc:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue (LCD_u8_RS_Pin,DIO_u8_LOW);
     fde:	60 e0       	ldi	r22, 0x00	; 0
     fe0:	80 e1       	ldi	r24, 0x10	; 16
     fe2:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_cmd);
     fe6:	89 81       	ldd	r24, Y+1	; 0x01
     fe8:	0e 94 15 07 	call	0xe2a	; 0xe2a <LCD_Void_Write>
}
     fec:	00 00       	nop
     fee:	0f 90       	pop	r0
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	08 95       	ret

00000ff6 <LCD_Void_Write_Data>:

void LCD_Void_Write_Data(u8 copy_u8_data)
{
     ff6:	cf 93       	push	r28
     ff8:	df 93       	push	r29
     ffa:	1f 92       	push	r1
     ffc:	cd b7       	in	r28, 0x3d	; 61
     ffe:	de b7       	in	r29, 0x3e	; 62
    1000:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue(LCD_u8_RS_Pin,DIO_u8_HIGH);
    1002:	61 e0       	ldi	r22, 0x01	; 1
    1004:	80 e1       	ldi	r24, 0x10	; 16
    1006:	0e 94 2f 03 	call	0x65e	; 0x65e <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_data);
    100a:	89 81       	ldd	r24, Y+1	; 0x01
    100c:	0e 94 15 07 	call	0xe2a	; 0xe2a <LCD_Void_Write>
}
    1010:	00 00       	nop
    1012:	0f 90       	pop	r0
    1014:	df 91       	pop	r29
    1016:	cf 91       	pop	r28
    1018:	08 95       	ret

0000101a <LCD_initialize>:


void LCD_initialize(void)
{
    101a:	0f 93       	push	r16
    101c:	1f 93       	push	r17
    101e:	cf 93       	push	r28
    1020:	df 93       	push	r29
    1022:	cd b7       	in	r28, 0x3d	; 61
    1024:	de b7       	in	r29, 0x3e	; 62
    1026:	ca 56       	subi	r28, 0x6A	; 106
    1028:	d1 09       	sbc	r29, r1
    102a:	0f b6       	in	r0, 0x3f	; 63
    102c:	f8 94       	cli
    102e:	de bf       	out	0x3e, r29	; 62
    1030:	0f be       	out	0x3f, r0	; 63
    1032:	cd bf       	out	0x3d, r28	; 61
	DIO_u8SetPinDirection(LCD_u8_RS_Pin,1);
    1034:	61 e0       	ldi	r22, 0x01	; 1
    1036:	80 e1       	ldi	r24, 0x10	; 16
    1038:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_RW_Pin,1);
    103c:	61 e0       	ldi	r22, 0x01	; 1
    103e:	81 e1       	ldi	r24, 0x11	; 17
    1040:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_E_Pin,1);
    1044:	61 e0       	ldi	r22, 0x01	; 1
    1046:	82 e1       	ldi	r24, 0x12	; 18
    1048:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D0_Pin,1);
    104c:	61 e0       	ldi	r22, 0x01	; 1
    104e:	87 e0       	ldi	r24, 0x07	; 7
    1050:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D1_Pin,1);
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	86 e0       	ldi	r24, 0x06	; 6
    1058:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D2_Pin,1);
    105c:	61 e0       	ldi	r22, 0x01	; 1
    105e:	85 e0       	ldi	r24, 0x05	; 5
    1060:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D3_Pin,1);
    1064:	61 e0       	ldi	r22, 0x01	; 1
    1066:	84 e0       	ldi	r24, 0x04	; 4
    1068:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D4_Pin,1);
    106c:	61 e0       	ldi	r22, 0x01	; 1
    106e:	83 e0       	ldi	r24, 0x03	; 3
    1070:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D5_Pin,1);
    1074:	61 e0       	ldi	r22, 0x01	; 1
    1076:	82 e0       	ldi	r24, 0x02	; 2
    1078:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D6_Pin,1);
    107c:	61 e0       	ldi	r22, 0x01	; 1
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D7_Pin,1);
    1084:	61 e0       	ldi	r22, 0x01	; 1
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	0e 94 39 02 	call	0x472	; 0x472 <DIO_u8SetPinDirection>
    108c:	80 e0       	ldi	r24, 0x00	; 0
    108e:	90 e0       	ldi	r25, 0x00	; 0
    1090:	a8 e4       	ldi	r26, 0x48	; 72
    1092:	b2 e4       	ldi	r27, 0x42	; 66
    1094:	89 83       	std	Y+1, r24	; 0x01
    1096:	9a 83       	std	Y+2, r25	; 0x02
    1098:	ab 83       	std	Y+3, r26	; 0x03
    109a:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    109c:	8e 01       	movw	r16, r28
    109e:	0f 59       	subi	r16, 0x9F	; 159
    10a0:	1f 4f       	sbci	r17, 0xFF	; 255
    10a2:	20 e0       	ldi	r18, 0x00	; 0
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	4a ef       	ldi	r20, 0xFA	; 250
    10a8:	54 e4       	ldi	r21, 0x44	; 68
    10aa:	69 81       	ldd	r22, Y+1	; 0x01
    10ac:	7a 81       	ldd	r23, Y+2	; 0x02
    10ae:	8b 81       	ldd	r24, Y+3	; 0x03
    10b0:	9c 81       	ldd	r25, Y+4	; 0x04
    10b2:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    10b6:	dc 01       	movw	r26, r24
    10b8:	cb 01       	movw	r24, r22
    10ba:	f8 01       	movw	r30, r16
    10bc:	80 83       	st	Z, r24
    10be:	91 83       	std	Z+1, r25	; 0x01
    10c0:	a2 83       	std	Z+2, r26	; 0x02
    10c2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    10c4:	ce 01       	movw	r24, r28
    10c6:	8f 59       	subi	r24, 0x9F	; 159
    10c8:	9f 4f       	sbci	r25, 0xFF	; 255
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	40 e8       	ldi	r20, 0x80	; 128
    10d0:	5f e3       	ldi	r21, 0x3F	; 63
    10d2:	fc 01       	movw	r30, r24
    10d4:	60 81       	ld	r22, Z
    10d6:	71 81       	ldd	r23, Z+1	; 0x01
    10d8:	82 81       	ldd	r24, Z+2	; 0x02
    10da:	93 81       	ldd	r25, Z+3	; 0x03
    10dc:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    10e0:	88 23       	and	r24, r24
    10e2:	4c f4       	brge	.+18     	; 0x10f6 <LCD_initialize+0xdc>
		__ticks = 1;
    10e4:	ce 01       	movw	r24, r28
    10e6:	8b 59       	subi	r24, 0x9B	; 155
    10e8:	9f 4f       	sbci	r25, 0xFF	; 255
    10ea:	21 e0       	ldi	r18, 0x01	; 1
    10ec:	30 e0       	ldi	r19, 0x00	; 0
    10ee:	fc 01       	movw	r30, r24
    10f0:	31 83       	std	Z+1, r19	; 0x01
    10f2:	20 83       	st	Z, r18
    10f4:	69 c0       	rjmp	.+210    	; 0x11c8 <LCD_initialize+0x1ae>
	else if (__tmp > 65535)
    10f6:	ce 01       	movw	r24, r28
    10f8:	8f 59       	subi	r24, 0x9F	; 159
    10fa:	9f 4f       	sbci	r25, 0xFF	; 255
    10fc:	20 e0       	ldi	r18, 0x00	; 0
    10fe:	3f ef       	ldi	r19, 0xFF	; 255
    1100:	4f e7       	ldi	r20, 0x7F	; 127
    1102:	57 e4       	ldi	r21, 0x47	; 71
    1104:	fc 01       	movw	r30, r24
    1106:	60 81       	ld	r22, Z
    1108:	71 81       	ldd	r23, Z+1	; 0x01
    110a:	82 81       	ldd	r24, Z+2	; 0x02
    110c:	93 81       	ldd	r25, Z+3	; 0x03
    110e:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    1112:	18 16       	cp	r1, r24
    1114:	0c f0       	brlt	.+2      	; 0x1118 <LCD_initialize+0xfe>
    1116:	46 c0       	rjmp	.+140    	; 0x11a4 <LCD_initialize+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1118:	20 e0       	ldi	r18, 0x00	; 0
    111a:	30 e0       	ldi	r19, 0x00	; 0
    111c:	40 e2       	ldi	r20, 0x20	; 32
    111e:	51 e4       	ldi	r21, 0x41	; 65
    1120:	69 81       	ldd	r22, Y+1	; 0x01
    1122:	7a 81       	ldd	r23, Y+2	; 0x02
    1124:	8b 81       	ldd	r24, Y+3	; 0x03
    1126:	9c 81       	ldd	r25, Y+4	; 0x04
    1128:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    112c:	dc 01       	movw	r26, r24
    112e:	cb 01       	movw	r24, r22
    1130:	8e 01       	movw	r16, r28
    1132:	0b 59       	subi	r16, 0x9B	; 155
    1134:	1f 4f       	sbci	r17, 0xFF	; 255
    1136:	bc 01       	movw	r22, r24
    1138:	cd 01       	movw	r24, r26
    113a:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    113e:	dc 01       	movw	r26, r24
    1140:	cb 01       	movw	r24, r22
    1142:	f8 01       	movw	r30, r16
    1144:	91 83       	std	Z+1, r25	; 0x01
    1146:	80 83       	st	Z, r24
    1148:	24 c0       	rjmp	.+72     	; 0x1192 <LCD_initialize+0x178>
    114a:	ce 01       	movw	r24, r28
    114c:	89 59       	subi	r24, 0x99	; 153
    114e:	9f 4f       	sbci	r25, 0xFF	; 255
    1150:	28 ec       	ldi	r18, 0xC8	; 200
    1152:	30 e0       	ldi	r19, 0x00	; 0
    1154:	fc 01       	movw	r30, r24
    1156:	31 83       	std	Z+1, r19	; 0x01
    1158:	20 83       	st	Z, r18
    115a:	ce 01       	movw	r24, r28
    115c:	89 59       	subi	r24, 0x99	; 153
    115e:	9f 4f       	sbci	r25, 0xFF	; 255
    1160:	fc 01       	movw	r30, r24
    1162:	80 81       	ld	r24, Z
    1164:	91 81       	ldd	r25, Z+1	; 0x01
    1166:	01 97       	sbiw	r24, 0x01	; 1
    1168:	f1 f7       	brne	.-4      	; 0x1166 <LCD_initialize+0x14c>
    116a:	9e 01       	movw	r18, r28
    116c:	29 59       	subi	r18, 0x99	; 153
    116e:	3f 4f       	sbci	r19, 0xFF	; 255
    1170:	f9 01       	movw	r30, r18
    1172:	91 83       	std	Z+1, r25	; 0x01
    1174:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1176:	ce 01       	movw	r24, r28
    1178:	8b 59       	subi	r24, 0x9B	; 155
    117a:	9f 4f       	sbci	r25, 0xFF	; 255
    117c:	9e 01       	movw	r18, r28
    117e:	2b 59       	subi	r18, 0x9B	; 155
    1180:	3f 4f       	sbci	r19, 0xFF	; 255
    1182:	f9 01       	movw	r30, r18
    1184:	20 81       	ld	r18, Z
    1186:	31 81       	ldd	r19, Z+1	; 0x01
    1188:	21 50       	subi	r18, 0x01	; 1
    118a:	31 09       	sbc	r19, r1
    118c:	fc 01       	movw	r30, r24
    118e:	31 83       	std	Z+1, r19	; 0x01
    1190:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1192:	ce 01       	movw	r24, r28
    1194:	8b 59       	subi	r24, 0x9B	; 155
    1196:	9f 4f       	sbci	r25, 0xFF	; 255
    1198:	fc 01       	movw	r30, r24
    119a:	80 81       	ld	r24, Z
    119c:	91 81       	ldd	r25, Z+1	; 0x01
    119e:	89 2b       	or	r24, r25
    11a0:	a1 f6       	brne	.-88     	; 0x114a <LCD_initialize+0x130>
    11a2:	2c c0       	rjmp	.+88     	; 0x11fc <LCD_initialize+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    11a4:	8e 01       	movw	r16, r28
    11a6:	0b 59       	subi	r16, 0x9B	; 155
    11a8:	1f 4f       	sbci	r17, 0xFF	; 255
    11aa:	ce 01       	movw	r24, r28
    11ac:	8f 59       	subi	r24, 0x9F	; 159
    11ae:	9f 4f       	sbci	r25, 0xFF	; 255
    11b0:	fc 01       	movw	r30, r24
    11b2:	60 81       	ld	r22, Z
    11b4:	71 81       	ldd	r23, Z+1	; 0x01
    11b6:	82 81       	ldd	r24, Z+2	; 0x02
    11b8:	93 81       	ldd	r25, Z+3	; 0x03
    11ba:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    11be:	dc 01       	movw	r26, r24
    11c0:	cb 01       	movw	r24, r22
    11c2:	f8 01       	movw	r30, r16
    11c4:	91 83       	std	Z+1, r25	; 0x01
    11c6:	80 83       	st	Z, r24
    11c8:	ce 01       	movw	r24, r28
    11ca:	87 59       	subi	r24, 0x97	; 151
    11cc:	9f 4f       	sbci	r25, 0xFF	; 255
    11ce:	9e 01       	movw	r18, r28
    11d0:	2b 59       	subi	r18, 0x9B	; 155
    11d2:	3f 4f       	sbci	r19, 0xFF	; 255
    11d4:	f9 01       	movw	r30, r18
    11d6:	20 81       	ld	r18, Z
    11d8:	31 81       	ldd	r19, Z+1	; 0x01
    11da:	fc 01       	movw	r30, r24
    11dc:	31 83       	std	Z+1, r19	; 0x01
    11de:	20 83       	st	Z, r18
    11e0:	ce 01       	movw	r24, r28
    11e2:	87 59       	subi	r24, 0x97	; 151
    11e4:	9f 4f       	sbci	r25, 0xFF	; 255
    11e6:	fc 01       	movw	r30, r24
    11e8:	80 81       	ld	r24, Z
    11ea:	91 81       	ldd	r25, Z+1	; 0x01
    11ec:	01 97       	sbiw	r24, 0x01	; 1
    11ee:	f1 f7       	brne	.-4      	; 0x11ec <LCD_initialize+0x1d2>
    11f0:	9e 01       	movw	r18, r28
    11f2:	27 59       	subi	r18, 0x97	; 151
    11f4:	3f 4f       	sbci	r19, 0xFF	; 255
    11f6:	f9 01       	movw	r30, r18
    11f8:	91 83       	std	Z+1, r25	; 0x01
    11fa:	80 83       	st	Z, r24
    11fc:	80 e0       	ldi	r24, 0x00	; 0
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	a0 e2       	ldi	r26, 0x20	; 32
    1202:	b2 e4       	ldi	r27, 0x42	; 66
    1204:	8d 83       	std	Y+5, r24	; 0x05
    1206:	9e 83       	std	Y+6, r25	; 0x06
    1208:	af 83       	std	Y+7, r26	; 0x07
    120a:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    120c:	8e 01       	movw	r16, r28
    120e:	09 5a       	subi	r16, 0xA9	; 169
    1210:	1f 4f       	sbci	r17, 0xFF	; 255
    1212:	20 e0       	ldi	r18, 0x00	; 0
    1214:	30 e0       	ldi	r19, 0x00	; 0
    1216:	4a ef       	ldi	r20, 0xFA	; 250
    1218:	54 e4       	ldi	r21, 0x44	; 68
    121a:	6d 81       	ldd	r22, Y+5	; 0x05
    121c:	7e 81       	ldd	r23, Y+6	; 0x06
    121e:	8f 81       	ldd	r24, Y+7	; 0x07
    1220:	98 85       	ldd	r25, Y+8	; 0x08
    1222:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1226:	dc 01       	movw	r26, r24
    1228:	cb 01       	movw	r24, r22
    122a:	f8 01       	movw	r30, r16
    122c:	80 83       	st	Z, r24
    122e:	91 83       	std	Z+1, r25	; 0x01
    1230:	a2 83       	std	Z+2, r26	; 0x02
    1232:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1234:	ce 01       	movw	r24, r28
    1236:	89 5a       	subi	r24, 0xA9	; 169
    1238:	9f 4f       	sbci	r25, 0xFF	; 255
    123a:	20 e0       	ldi	r18, 0x00	; 0
    123c:	30 e0       	ldi	r19, 0x00	; 0
    123e:	40 e8       	ldi	r20, 0x80	; 128
    1240:	5f e3       	ldi	r21, 0x3F	; 63
    1242:	fc 01       	movw	r30, r24
    1244:	60 81       	ld	r22, Z
    1246:	71 81       	ldd	r23, Z+1	; 0x01
    1248:	82 81       	ldd	r24, Z+2	; 0x02
    124a:	93 81       	ldd	r25, Z+3	; 0x03
    124c:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    1250:	88 23       	and	r24, r24
    1252:	4c f4       	brge	.+18     	; 0x1266 <LCD_initialize+0x24c>
		__ticks = 1;
    1254:	ce 01       	movw	r24, r28
    1256:	85 5a       	subi	r24, 0xA5	; 165
    1258:	9f 4f       	sbci	r25, 0xFF	; 255
    125a:	21 e0       	ldi	r18, 0x01	; 1
    125c:	30 e0       	ldi	r19, 0x00	; 0
    125e:	fc 01       	movw	r30, r24
    1260:	31 83       	std	Z+1, r19	; 0x01
    1262:	20 83       	st	Z, r18
    1264:	69 c0       	rjmp	.+210    	; 0x1338 <LCD_initialize+0x31e>
	else if (__tmp > 65535)
    1266:	ce 01       	movw	r24, r28
    1268:	89 5a       	subi	r24, 0xA9	; 169
    126a:	9f 4f       	sbci	r25, 0xFF	; 255
    126c:	20 e0       	ldi	r18, 0x00	; 0
    126e:	3f ef       	ldi	r19, 0xFF	; 255
    1270:	4f e7       	ldi	r20, 0x7F	; 127
    1272:	57 e4       	ldi	r21, 0x47	; 71
    1274:	fc 01       	movw	r30, r24
    1276:	60 81       	ld	r22, Z
    1278:	71 81       	ldd	r23, Z+1	; 0x01
    127a:	82 81       	ldd	r24, Z+2	; 0x02
    127c:	93 81       	ldd	r25, Z+3	; 0x03
    127e:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    1282:	18 16       	cp	r1, r24
    1284:	0c f0       	brlt	.+2      	; 0x1288 <LCD_initialize+0x26e>
    1286:	46 c0       	rjmp	.+140    	; 0x1314 <LCD_initialize+0x2fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1288:	20 e0       	ldi	r18, 0x00	; 0
    128a:	30 e0       	ldi	r19, 0x00	; 0
    128c:	40 e2       	ldi	r20, 0x20	; 32
    128e:	51 e4       	ldi	r21, 0x41	; 65
    1290:	6d 81       	ldd	r22, Y+5	; 0x05
    1292:	7e 81       	ldd	r23, Y+6	; 0x06
    1294:	8f 81       	ldd	r24, Y+7	; 0x07
    1296:	98 85       	ldd	r25, Y+8	; 0x08
    1298:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    129c:	dc 01       	movw	r26, r24
    129e:	cb 01       	movw	r24, r22
    12a0:	8e 01       	movw	r16, r28
    12a2:	05 5a       	subi	r16, 0xA5	; 165
    12a4:	1f 4f       	sbci	r17, 0xFF	; 255
    12a6:	bc 01       	movw	r22, r24
    12a8:	cd 01       	movw	r24, r26
    12aa:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    12ae:	dc 01       	movw	r26, r24
    12b0:	cb 01       	movw	r24, r22
    12b2:	f8 01       	movw	r30, r16
    12b4:	91 83       	std	Z+1, r25	; 0x01
    12b6:	80 83       	st	Z, r24
    12b8:	24 c0       	rjmp	.+72     	; 0x1302 <LCD_initialize+0x2e8>
    12ba:	ce 01       	movw	r24, r28
    12bc:	83 5a       	subi	r24, 0xA3	; 163
    12be:	9f 4f       	sbci	r25, 0xFF	; 255
    12c0:	28 ec       	ldi	r18, 0xC8	; 200
    12c2:	30 e0       	ldi	r19, 0x00	; 0
    12c4:	fc 01       	movw	r30, r24
    12c6:	31 83       	std	Z+1, r19	; 0x01
    12c8:	20 83       	st	Z, r18
    12ca:	ce 01       	movw	r24, r28
    12cc:	83 5a       	subi	r24, 0xA3	; 163
    12ce:	9f 4f       	sbci	r25, 0xFF	; 255
    12d0:	fc 01       	movw	r30, r24
    12d2:	80 81       	ld	r24, Z
    12d4:	91 81       	ldd	r25, Z+1	; 0x01
    12d6:	01 97       	sbiw	r24, 0x01	; 1
    12d8:	f1 f7       	brne	.-4      	; 0x12d6 <LCD_initialize+0x2bc>
    12da:	9e 01       	movw	r18, r28
    12dc:	23 5a       	subi	r18, 0xA3	; 163
    12de:	3f 4f       	sbci	r19, 0xFF	; 255
    12e0:	f9 01       	movw	r30, r18
    12e2:	91 83       	std	Z+1, r25	; 0x01
    12e4:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12e6:	ce 01       	movw	r24, r28
    12e8:	85 5a       	subi	r24, 0xA5	; 165
    12ea:	9f 4f       	sbci	r25, 0xFF	; 255
    12ec:	9e 01       	movw	r18, r28
    12ee:	25 5a       	subi	r18, 0xA5	; 165
    12f0:	3f 4f       	sbci	r19, 0xFF	; 255
    12f2:	f9 01       	movw	r30, r18
    12f4:	20 81       	ld	r18, Z
    12f6:	31 81       	ldd	r19, Z+1	; 0x01
    12f8:	21 50       	subi	r18, 0x01	; 1
    12fa:	31 09       	sbc	r19, r1
    12fc:	fc 01       	movw	r30, r24
    12fe:	31 83       	std	Z+1, r19	; 0x01
    1300:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1302:	ce 01       	movw	r24, r28
    1304:	85 5a       	subi	r24, 0xA5	; 165
    1306:	9f 4f       	sbci	r25, 0xFF	; 255
    1308:	fc 01       	movw	r30, r24
    130a:	80 81       	ld	r24, Z
    130c:	91 81       	ldd	r25, Z+1	; 0x01
    130e:	89 2b       	or	r24, r25
    1310:	a1 f6       	brne	.-88     	; 0x12ba <LCD_initialize+0x2a0>
    1312:	2c c0       	rjmp	.+88     	; 0x136c <LCD_initialize+0x352>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1314:	8e 01       	movw	r16, r28
    1316:	05 5a       	subi	r16, 0xA5	; 165
    1318:	1f 4f       	sbci	r17, 0xFF	; 255
    131a:	ce 01       	movw	r24, r28
    131c:	89 5a       	subi	r24, 0xA9	; 169
    131e:	9f 4f       	sbci	r25, 0xFF	; 255
    1320:	fc 01       	movw	r30, r24
    1322:	60 81       	ld	r22, Z
    1324:	71 81       	ldd	r23, Z+1	; 0x01
    1326:	82 81       	ldd	r24, Z+2	; 0x02
    1328:	93 81       	ldd	r25, Z+3	; 0x03
    132a:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    132e:	dc 01       	movw	r26, r24
    1330:	cb 01       	movw	r24, r22
    1332:	f8 01       	movw	r30, r16
    1334:	91 83       	std	Z+1, r25	; 0x01
    1336:	80 83       	st	Z, r24
    1338:	ce 01       	movw	r24, r28
    133a:	81 5a       	subi	r24, 0xA1	; 161
    133c:	9f 4f       	sbci	r25, 0xFF	; 255
    133e:	9e 01       	movw	r18, r28
    1340:	25 5a       	subi	r18, 0xA5	; 165
    1342:	3f 4f       	sbci	r19, 0xFF	; 255
    1344:	f9 01       	movw	r30, r18
    1346:	20 81       	ld	r18, Z
    1348:	31 81       	ldd	r19, Z+1	; 0x01
    134a:	fc 01       	movw	r30, r24
    134c:	31 83       	std	Z+1, r19	; 0x01
    134e:	20 83       	st	Z, r18
    1350:	ce 01       	movw	r24, r28
    1352:	81 5a       	subi	r24, 0xA1	; 161
    1354:	9f 4f       	sbci	r25, 0xFF	; 255
    1356:	fc 01       	movw	r30, r24
    1358:	80 81       	ld	r24, Z
    135a:	91 81       	ldd	r25, Z+1	; 0x01
    135c:	01 97       	sbiw	r24, 0x01	; 1
    135e:	f1 f7       	brne	.-4      	; 0x135c <LCD_initialize+0x342>
    1360:	9e 01       	movw	r18, r28
    1362:	21 5a       	subi	r18, 0xA1	; 161
    1364:	3f 4f       	sbci	r19, 0xFF	; 255
    1366:	f9 01       	movw	r30, r18
    1368:	91 83       	std	Z+1, r25	; 0x01
    136a:	80 83       	st	Z, r24
	_delay_ms(50);
	_delay_ms(40);
	LCD_Void_Write_Cmd(0b00111000);
    136c:	88 e3       	ldi	r24, 0x38	; 56
    136e:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	a8 e4       	ldi	r26, 0x48	; 72
    1378:	b2 e4       	ldi	r27, 0x42	; 66
    137a:	89 87       	std	Y+9, r24	; 0x09
    137c:	9a 87       	std	Y+10, r25	; 0x0a
    137e:	ab 87       	std	Y+11, r26	; 0x0b
    1380:	bc 87       	std	Y+12, r27	; 0x0c
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    1382:	2b ea       	ldi	r18, 0xAB	; 171
    1384:	3a ea       	ldi	r19, 0xAA	; 170
    1386:	4a e2       	ldi	r20, 0x2A	; 42
    1388:	50 e4       	ldi	r21, 0x40	; 64
    138a:	69 85       	ldd	r22, Y+9	; 0x09
    138c:	7a 85       	ldd	r23, Y+10	; 0x0a
    138e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1390:	9c 85       	ldd	r25, Y+12	; 0x0c
    1392:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1396:	dc 01       	movw	r26, r24
    1398:	cb 01       	movw	r24, r22
    139a:	8b af       	std	Y+59, r24	; 0x3b
    139c:	9c af       	std	Y+60, r25	; 0x3c
    139e:	ad af       	std	Y+61, r26	; 0x3d
    13a0:	be af       	std	Y+62, r27	; 0x3e
	__tmp2 = ((F_CPU) / 4e6) * __us;
    13a2:	8e 01       	movw	r16, r28
    13a4:	01 5c       	subi	r16, 0xC1	; 193
    13a6:	1f 4f       	sbci	r17, 0xFF	; 255
    13a8:	89 85       	ldd	r24, Y+9	; 0x09
    13aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    13ac:	ab 85       	ldd	r26, Y+11	; 0x0b
    13ae:	bc 85       	ldd	r27, Y+12	; 0x0c
    13b0:	9c 01       	movw	r18, r24
    13b2:	ad 01       	movw	r20, r26
    13b4:	bc 01       	movw	r22, r24
    13b6:	cd 01       	movw	r24, r26
    13b8:	0e 94 30 30 	call	0x6060	; 0x6060 <__addsf3>
    13bc:	dc 01       	movw	r26, r24
    13be:	cb 01       	movw	r24, r22
    13c0:	f8 01       	movw	r30, r16
    13c2:	80 83       	st	Z, r24
    13c4:	91 83       	std	Z+1, r25	; 0x01
    13c6:	a2 83       	std	Z+2, r26	; 0x02
    13c8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    13ca:	20 e0       	ldi	r18, 0x00	; 0
    13cc:	30 e0       	ldi	r19, 0x00	; 0
    13ce:	40 e8       	ldi	r20, 0x80	; 128
    13d0:	5f e3       	ldi	r21, 0x3F	; 63
    13d2:	6b ad       	ldd	r22, Y+59	; 0x3b
    13d4:	7c ad       	ldd	r23, Y+60	; 0x3c
    13d6:	8d ad       	ldd	r24, Y+61	; 0x3d
    13d8:	9e ad       	ldd	r25, Y+62	; 0x3e
    13da:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    13de:	88 23       	and	r24, r24
    13e0:	3c f4       	brge	.+14     	; 0x13f0 <LCD_initialize+0x3d6>
		__ticks = 1;
    13e2:	ce 01       	movw	r24, r28
    13e4:	8d 5b       	subi	r24, 0xBD	; 189
    13e6:	9f 4f       	sbci	r25, 0xFF	; 255
    13e8:	21 e0       	ldi	r18, 0x01	; 1
    13ea:	fc 01       	movw	r30, r24
    13ec:	20 83       	st	Z, r18
    13ee:	22 c1       	rjmp	.+580    	; 0x1634 <LCD_initialize+0x61a>
	else if (__tmp2 > 65535)
    13f0:	ce 01       	movw	r24, r28
    13f2:	cf 96       	adiw	r24, 0x3f	; 63
    13f4:	20 e0       	ldi	r18, 0x00	; 0
    13f6:	3f ef       	ldi	r19, 0xFF	; 255
    13f8:	4f e7       	ldi	r20, 0x7F	; 127
    13fa:	57 e4       	ldi	r21, 0x47	; 71
    13fc:	fc 01       	movw	r30, r24
    13fe:	60 81       	ld	r22, Z
    1400:	71 81       	ldd	r23, Z+1	; 0x01
    1402:	82 81       	ldd	r24, Z+2	; 0x02
    1404:	93 81       	ldd	r25, Z+3	; 0x03
    1406:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    140a:	18 16       	cp	r1, r24
    140c:	0c f0       	brlt	.+2      	; 0x1410 <LCD_initialize+0x3f6>
    140e:	cd c0       	rjmp	.+410    	; 0x15aa <LCD_initialize+0x590>
	{
		_delay_ms(__us / 1000.0);
    1410:	20 e0       	ldi	r18, 0x00	; 0
    1412:	30 e0       	ldi	r19, 0x00	; 0
    1414:	4a e7       	ldi	r20, 0x7A	; 122
    1416:	54 e4       	ldi	r21, 0x44	; 68
    1418:	69 85       	ldd	r22, Y+9	; 0x09
    141a:	7a 85       	ldd	r23, Y+10	; 0x0a
    141c:	8b 85       	ldd	r24, Y+11	; 0x0b
    141e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1420:	0e 94 a1 30 	call	0x6142	; 0x6142 <__divsf3>
    1424:	dc 01       	movw	r26, r24
    1426:	cb 01       	movw	r24, r22
    1428:	9e 01       	movw	r18, r28
    142a:	2c 5b       	subi	r18, 0xBC	; 188
    142c:	3f 4f       	sbci	r19, 0xFF	; 255
    142e:	f9 01       	movw	r30, r18
    1430:	80 83       	st	Z, r24
    1432:	91 83       	std	Z+1, r25	; 0x01
    1434:	a2 83       	std	Z+2, r26	; 0x02
    1436:	b3 83       	std	Z+3, r27	; 0x03

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1438:	8e 01       	movw	r16, r28
    143a:	08 5b       	subi	r16, 0xB8	; 184
    143c:	1f 4f       	sbci	r17, 0xFF	; 255
    143e:	ce 01       	movw	r24, r28
    1440:	8c 5b       	subi	r24, 0xBC	; 188
    1442:	9f 4f       	sbci	r25, 0xFF	; 255
    1444:	20 e0       	ldi	r18, 0x00	; 0
    1446:	30 e0       	ldi	r19, 0x00	; 0
    1448:	4a ef       	ldi	r20, 0xFA	; 250
    144a:	54 e4       	ldi	r21, 0x44	; 68
    144c:	fc 01       	movw	r30, r24
    144e:	60 81       	ld	r22, Z
    1450:	71 81       	ldd	r23, Z+1	; 0x01
    1452:	82 81       	ldd	r24, Z+2	; 0x02
    1454:	93 81       	ldd	r25, Z+3	; 0x03
    1456:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    145a:	dc 01       	movw	r26, r24
    145c:	cb 01       	movw	r24, r22
    145e:	f8 01       	movw	r30, r16
    1460:	80 83       	st	Z, r24
    1462:	91 83       	std	Z+1, r25	; 0x01
    1464:	a2 83       	std	Z+2, r26	; 0x02
    1466:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1468:	ce 01       	movw	r24, r28
    146a:	88 5b       	subi	r24, 0xB8	; 184
    146c:	9f 4f       	sbci	r25, 0xFF	; 255
    146e:	20 e0       	ldi	r18, 0x00	; 0
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	40 e8       	ldi	r20, 0x80	; 128
    1474:	5f e3       	ldi	r21, 0x3F	; 63
    1476:	fc 01       	movw	r30, r24
    1478:	60 81       	ld	r22, Z
    147a:	71 81       	ldd	r23, Z+1	; 0x01
    147c:	82 81       	ldd	r24, Z+2	; 0x02
    147e:	93 81       	ldd	r25, Z+3	; 0x03
    1480:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    1484:	88 23       	and	r24, r24
    1486:	4c f4       	brge	.+18     	; 0x149a <LCD_initialize+0x480>
		__ticks = 1;
    1488:	ce 01       	movw	r24, r28
    148a:	84 5b       	subi	r24, 0xB4	; 180
    148c:	9f 4f       	sbci	r25, 0xFF	; 255
    148e:	21 e0       	ldi	r18, 0x01	; 1
    1490:	30 e0       	ldi	r19, 0x00	; 0
    1492:	fc 01       	movw	r30, r24
    1494:	31 83       	std	Z+1, r19	; 0x01
    1496:	20 83       	st	Z, r18
    1498:	6d c0       	rjmp	.+218    	; 0x1574 <LCD_initialize+0x55a>
	else if (__tmp > 65535)
    149a:	ce 01       	movw	r24, r28
    149c:	88 5b       	subi	r24, 0xB8	; 184
    149e:	9f 4f       	sbci	r25, 0xFF	; 255
    14a0:	20 e0       	ldi	r18, 0x00	; 0
    14a2:	3f ef       	ldi	r19, 0xFF	; 255
    14a4:	4f e7       	ldi	r20, 0x7F	; 127
    14a6:	57 e4       	ldi	r21, 0x47	; 71
    14a8:	fc 01       	movw	r30, r24
    14aa:	60 81       	ld	r22, Z
    14ac:	71 81       	ldd	r23, Z+1	; 0x01
    14ae:	82 81       	ldd	r24, Z+2	; 0x02
    14b0:	93 81       	ldd	r25, Z+3	; 0x03
    14b2:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    14b6:	18 16       	cp	r1, r24
    14b8:	0c f0       	brlt	.+2      	; 0x14bc <LCD_initialize+0x4a2>
    14ba:	4a c0       	rjmp	.+148    	; 0x1550 <LCD_initialize+0x536>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    14bc:	ce 01       	movw	r24, r28
    14be:	8c 5b       	subi	r24, 0xBC	; 188
    14c0:	9f 4f       	sbci	r25, 0xFF	; 255
    14c2:	20 e0       	ldi	r18, 0x00	; 0
    14c4:	30 e0       	ldi	r19, 0x00	; 0
    14c6:	40 e2       	ldi	r20, 0x20	; 32
    14c8:	51 e4       	ldi	r21, 0x41	; 65
    14ca:	fc 01       	movw	r30, r24
    14cc:	60 81       	ld	r22, Z
    14ce:	71 81       	ldd	r23, Z+1	; 0x01
    14d0:	82 81       	ldd	r24, Z+2	; 0x02
    14d2:	93 81       	ldd	r25, Z+3	; 0x03
    14d4:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    14d8:	dc 01       	movw	r26, r24
    14da:	cb 01       	movw	r24, r22
    14dc:	8e 01       	movw	r16, r28
    14de:	04 5b       	subi	r16, 0xB4	; 180
    14e0:	1f 4f       	sbci	r17, 0xFF	; 255
    14e2:	bc 01       	movw	r22, r24
    14e4:	cd 01       	movw	r24, r26
    14e6:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    14ea:	dc 01       	movw	r26, r24
    14ec:	cb 01       	movw	r24, r22
    14ee:	f8 01       	movw	r30, r16
    14f0:	91 83       	std	Z+1, r25	; 0x01
    14f2:	80 83       	st	Z, r24
    14f4:	24 c0       	rjmp	.+72     	; 0x153e <LCD_initialize+0x524>
    14f6:	ce 01       	movw	r24, r28
    14f8:	82 5b       	subi	r24, 0xB2	; 178
    14fa:	9f 4f       	sbci	r25, 0xFF	; 255
    14fc:	28 ec       	ldi	r18, 0xC8	; 200
    14fe:	30 e0       	ldi	r19, 0x00	; 0
    1500:	fc 01       	movw	r30, r24
    1502:	31 83       	std	Z+1, r19	; 0x01
    1504:	20 83       	st	Z, r18
    1506:	ce 01       	movw	r24, r28
    1508:	82 5b       	subi	r24, 0xB2	; 178
    150a:	9f 4f       	sbci	r25, 0xFF	; 255
    150c:	fc 01       	movw	r30, r24
    150e:	80 81       	ld	r24, Z
    1510:	91 81       	ldd	r25, Z+1	; 0x01
    1512:	01 97       	sbiw	r24, 0x01	; 1
    1514:	f1 f7       	brne	.-4      	; 0x1512 <LCD_initialize+0x4f8>
    1516:	9e 01       	movw	r18, r28
    1518:	22 5b       	subi	r18, 0xB2	; 178
    151a:	3f 4f       	sbci	r19, 0xFF	; 255
    151c:	f9 01       	movw	r30, r18
    151e:	91 83       	std	Z+1, r25	; 0x01
    1520:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1522:	ce 01       	movw	r24, r28
    1524:	84 5b       	subi	r24, 0xB4	; 180
    1526:	9f 4f       	sbci	r25, 0xFF	; 255
    1528:	9e 01       	movw	r18, r28
    152a:	24 5b       	subi	r18, 0xB4	; 180
    152c:	3f 4f       	sbci	r19, 0xFF	; 255
    152e:	f9 01       	movw	r30, r18
    1530:	20 81       	ld	r18, Z
    1532:	31 81       	ldd	r19, Z+1	; 0x01
    1534:	21 50       	subi	r18, 0x01	; 1
    1536:	31 09       	sbc	r19, r1
    1538:	fc 01       	movw	r30, r24
    153a:	31 83       	std	Z+1, r19	; 0x01
    153c:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    153e:	ce 01       	movw	r24, r28
    1540:	84 5b       	subi	r24, 0xB4	; 180
    1542:	9f 4f       	sbci	r25, 0xFF	; 255
    1544:	fc 01       	movw	r30, r24
    1546:	80 81       	ld	r24, Z
    1548:	91 81       	ldd	r25, Z+1	; 0x01
    154a:	89 2b       	or	r24, r25
    154c:	a1 f6       	brne	.-88     	; 0x14f6 <LCD_initialize+0x4dc>
    154e:	72 c0       	rjmp	.+228    	; 0x1634 <LCD_initialize+0x61a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1550:	8e 01       	movw	r16, r28
    1552:	04 5b       	subi	r16, 0xB4	; 180
    1554:	1f 4f       	sbci	r17, 0xFF	; 255
    1556:	ce 01       	movw	r24, r28
    1558:	88 5b       	subi	r24, 0xB8	; 184
    155a:	9f 4f       	sbci	r25, 0xFF	; 255
    155c:	fc 01       	movw	r30, r24
    155e:	60 81       	ld	r22, Z
    1560:	71 81       	ldd	r23, Z+1	; 0x01
    1562:	82 81       	ldd	r24, Z+2	; 0x02
    1564:	93 81       	ldd	r25, Z+3	; 0x03
    1566:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    156a:	dc 01       	movw	r26, r24
    156c:	cb 01       	movw	r24, r22
    156e:	f8 01       	movw	r30, r16
    1570:	91 83       	std	Z+1, r25	; 0x01
    1572:	80 83       	st	Z, r24
    1574:	ce 01       	movw	r24, r28
    1576:	80 5b       	subi	r24, 0xB0	; 176
    1578:	9f 4f       	sbci	r25, 0xFF	; 255
    157a:	9e 01       	movw	r18, r28
    157c:	24 5b       	subi	r18, 0xB4	; 180
    157e:	3f 4f       	sbci	r19, 0xFF	; 255
    1580:	f9 01       	movw	r30, r18
    1582:	20 81       	ld	r18, Z
    1584:	31 81       	ldd	r19, Z+1	; 0x01
    1586:	fc 01       	movw	r30, r24
    1588:	31 83       	std	Z+1, r19	; 0x01
    158a:	20 83       	st	Z, r18
    158c:	ce 01       	movw	r24, r28
    158e:	80 5b       	subi	r24, 0xB0	; 176
    1590:	9f 4f       	sbci	r25, 0xFF	; 255
    1592:	fc 01       	movw	r30, r24
    1594:	80 81       	ld	r24, Z
    1596:	91 81       	ldd	r25, Z+1	; 0x01
    1598:	01 97       	sbiw	r24, 0x01	; 1
    159a:	f1 f7       	brne	.-4      	; 0x1598 <LCD_initialize+0x57e>
    159c:	9e 01       	movw	r18, r28
    159e:	20 5b       	subi	r18, 0xB0	; 176
    15a0:	3f 4f       	sbci	r19, 0xFF	; 255
    15a2:	f9 01       	movw	r30, r18
    15a4:	91 83       	std	Z+1, r25	; 0x01
    15a6:	80 83       	st	Z, r24
    15a8:	45 c0       	rjmp	.+138    	; 0x1634 <LCD_initialize+0x61a>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    15aa:	20 e0       	ldi	r18, 0x00	; 0
    15ac:	30 e0       	ldi	r19, 0x00	; 0
    15ae:	4f e7       	ldi	r20, 0x7F	; 127
    15b0:	53 e4       	ldi	r21, 0x43	; 67
    15b2:	6b ad       	ldd	r22, Y+59	; 0x3b
    15b4:	7c ad       	ldd	r23, Y+60	; 0x3c
    15b6:	8d ad       	ldd	r24, Y+61	; 0x3d
    15b8:	9e ad       	ldd	r25, Y+62	; 0x3e
    15ba:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    15be:	18 16       	cp	r1, r24
    15c0:	64 f5       	brge	.+88     	; 0x161a <LCD_initialize+0x600>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    15c2:	8e 01       	movw	r16, r28
    15c4:	0e 5a       	subi	r16, 0xAE	; 174
    15c6:	1f 4f       	sbci	r17, 0xFF	; 255
    15c8:	ce 01       	movw	r24, r28
    15ca:	cf 96       	adiw	r24, 0x3f	; 63
    15cc:	fc 01       	movw	r30, r24
    15ce:	60 81       	ld	r22, Z
    15d0:	71 81       	ldd	r23, Z+1	; 0x01
    15d2:	82 81       	ldd	r24, Z+2	; 0x02
    15d4:	93 81       	ldd	r25, Z+3	; 0x03
    15d6:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    15da:	dc 01       	movw	r26, r24
    15dc:	cb 01       	movw	r24, r22
    15de:	f8 01       	movw	r30, r16
    15e0:	91 83       	std	Z+1, r25	; 0x01
    15e2:	80 83       	st	Z, r24
    15e4:	ce 01       	movw	r24, r28
    15e6:	8c 5a       	subi	r24, 0xAC	; 172
    15e8:	9f 4f       	sbci	r25, 0xFF	; 255
    15ea:	9e 01       	movw	r18, r28
    15ec:	2e 5a       	subi	r18, 0xAE	; 174
    15ee:	3f 4f       	sbci	r19, 0xFF	; 255
    15f0:	f9 01       	movw	r30, r18
    15f2:	20 81       	ld	r18, Z
    15f4:	31 81       	ldd	r19, Z+1	; 0x01
    15f6:	fc 01       	movw	r30, r24
    15f8:	31 83       	std	Z+1, r19	; 0x01
    15fa:	20 83       	st	Z, r18
    15fc:	ce 01       	movw	r24, r28
    15fe:	8c 5a       	subi	r24, 0xAC	; 172
    1600:	9f 4f       	sbci	r25, 0xFF	; 255
    1602:	fc 01       	movw	r30, r24
    1604:	80 81       	ld	r24, Z
    1606:	91 81       	ldd	r25, Z+1	; 0x01
    1608:	01 97       	sbiw	r24, 0x01	; 1
    160a:	f1 f7       	brne	.-4      	; 0x1608 <LCD_initialize+0x5ee>
    160c:	9e 01       	movw	r18, r28
    160e:	2c 5a       	subi	r18, 0xAC	; 172
    1610:	3f 4f       	sbci	r19, 0xFF	; 255
    1612:	f9 01       	movw	r30, r18
    1614:	91 83       	std	Z+1, r25	; 0x01
    1616:	80 83       	st	Z, r24
    1618:	24 c0       	rjmp	.+72     	; 0x1662 <LCD_initialize+0x648>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    161a:	8e 01       	movw	r16, r28
    161c:	0d 5b       	subi	r16, 0xBD	; 189
    161e:	1f 4f       	sbci	r17, 0xFF	; 255
    1620:	6b ad       	ldd	r22, Y+59	; 0x3b
    1622:	7c ad       	ldd	r23, Y+60	; 0x3c
    1624:	8d ad       	ldd	r24, Y+61	; 0x3d
    1626:	9e ad       	ldd	r25, Y+62	; 0x3e
    1628:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    162c:	dc 01       	movw	r26, r24
    162e:	cb 01       	movw	r24, r22
    1630:	f8 01       	movw	r30, r16
    1632:	80 83       	st	Z, r24
    1634:	ce 01       	movw	r24, r28
    1636:	8a 5a       	subi	r24, 0xAA	; 170
    1638:	9f 4f       	sbci	r25, 0xFF	; 255
    163a:	9e 01       	movw	r18, r28
    163c:	2d 5b       	subi	r18, 0xBD	; 189
    163e:	3f 4f       	sbci	r19, 0xFF	; 255
    1640:	f9 01       	movw	r30, r18
    1642:	20 81       	ld	r18, Z
    1644:	fc 01       	movw	r30, r24
    1646:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1648:	ce 01       	movw	r24, r28
    164a:	8a 5a       	subi	r24, 0xAA	; 170
    164c:	9f 4f       	sbci	r25, 0xFF	; 255
    164e:	fc 01       	movw	r30, r24
    1650:	80 81       	ld	r24, Z
    1652:	28 2f       	mov	r18, r24
    1654:	2a 95       	dec	r18
    1656:	f1 f7       	brne	.-4      	; 0x1654 <LCD_initialize+0x63a>
    1658:	ce 01       	movw	r24, r28
    165a:	8a 5a       	subi	r24, 0xAA	; 170
    165c:	9f 4f       	sbci	r25, 0xFF	; 255
    165e:	fc 01       	movw	r30, r24
    1660:	20 83       	st	Z, r18
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00001100);
    1662:	8c e0       	ldi	r24, 0x0C	; 12
    1664:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
    1668:	80 e0       	ldi	r24, 0x00	; 0
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	a8 e4       	ldi	r26, 0x48	; 72
    166e:	b2 e4       	ldi	r27, 0x42	; 66
    1670:	8d 87       	std	Y+13, r24	; 0x0d
    1672:	9e 87       	std	Y+14, r25	; 0x0e
    1674:	af 87       	std	Y+15, r26	; 0x0f
    1676:	b8 8b       	std	Y+16, r27	; 0x10
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    1678:	2b ea       	ldi	r18, 0xAB	; 171
    167a:	3a ea       	ldi	r19, 0xAA	; 170
    167c:	4a e2       	ldi	r20, 0x2A	; 42
    167e:	50 e4       	ldi	r21, 0x40	; 64
    1680:	6d 85       	ldd	r22, Y+13	; 0x0d
    1682:	7e 85       	ldd	r23, Y+14	; 0x0e
    1684:	8f 85       	ldd	r24, Y+15	; 0x0f
    1686:	98 89       	ldd	r25, Y+16	; 0x10
    1688:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    168c:	dc 01       	movw	r26, r24
    168e:	cb 01       	movw	r24, r22
    1690:	8f 8f       	std	Y+31, r24	; 0x1f
    1692:	98 a3       	std	Y+32, r25	; 0x20
    1694:	a9 a3       	std	Y+33, r26	; 0x21
    1696:	ba a3       	std	Y+34, r27	; 0x22
	__tmp2 = ((F_CPU) / 4e6) * __us;
    1698:	8d 85       	ldd	r24, Y+13	; 0x0d
    169a:	9e 85       	ldd	r25, Y+14	; 0x0e
    169c:	af 85       	ldd	r26, Y+15	; 0x0f
    169e:	b8 89       	ldd	r27, Y+16	; 0x10
    16a0:	9c 01       	movw	r18, r24
    16a2:	ad 01       	movw	r20, r26
    16a4:	bc 01       	movw	r22, r24
    16a6:	cd 01       	movw	r24, r26
    16a8:	0e 94 30 30 	call	0x6060	; 0x6060 <__addsf3>
    16ac:	dc 01       	movw	r26, r24
    16ae:	cb 01       	movw	r24, r22
    16b0:	8b a3       	std	Y+35, r24	; 0x23
    16b2:	9c a3       	std	Y+36, r25	; 0x24
    16b4:	ad a3       	std	Y+37, r26	; 0x25
    16b6:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    16b8:	20 e0       	ldi	r18, 0x00	; 0
    16ba:	30 e0       	ldi	r19, 0x00	; 0
    16bc:	40 e8       	ldi	r20, 0x80	; 128
    16be:	5f e3       	ldi	r21, 0x3F	; 63
    16c0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    16c2:	78 a1       	ldd	r23, Y+32	; 0x20
    16c4:	89 a1       	ldd	r24, Y+33	; 0x21
    16c6:	9a a1       	ldd	r25, Y+34	; 0x22
    16c8:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    16cc:	88 23       	and	r24, r24
    16ce:	1c f4       	brge	.+6      	; 0x16d6 <LCD_initialize+0x6bc>
		__ticks = 1;
    16d0:	81 e0       	ldi	r24, 0x01	; 1
    16d2:	8f a3       	std	Y+39, r24	; 0x27
    16d4:	b2 c0       	rjmp	.+356    	; 0x183a <LCD_initialize+0x820>
	else if (__tmp2 > 65535)
    16d6:	20 e0       	ldi	r18, 0x00	; 0
    16d8:	3f ef       	ldi	r19, 0xFF	; 255
    16da:	4f e7       	ldi	r20, 0x7F	; 127
    16dc:	57 e4       	ldi	r21, 0x47	; 71
    16de:	6b a1       	ldd	r22, Y+35	; 0x23
    16e0:	7c a1       	ldd	r23, Y+36	; 0x24
    16e2:	8d a1       	ldd	r24, Y+37	; 0x25
    16e4:	9e a1       	ldd	r25, Y+38	; 0x26
    16e6:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    16ea:	18 16       	cp	r1, r24
    16ec:	0c f0       	brlt	.+2      	; 0x16f0 <LCD_initialize+0x6d6>
    16ee:	7b c0       	rjmp	.+246    	; 0x17e6 <LCD_initialize+0x7cc>
	{
		_delay_ms(__us / 1000.0);
    16f0:	20 e0       	ldi	r18, 0x00	; 0
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	4a e7       	ldi	r20, 0x7A	; 122
    16f6:	54 e4       	ldi	r21, 0x44	; 68
    16f8:	6d 85       	ldd	r22, Y+13	; 0x0d
    16fa:	7e 85       	ldd	r23, Y+14	; 0x0e
    16fc:	8f 85       	ldd	r24, Y+15	; 0x0f
    16fe:	98 89       	ldd	r25, Y+16	; 0x10
    1700:	0e 94 a1 30 	call	0x6142	; 0x6142 <__divsf3>
    1704:	dc 01       	movw	r26, r24
    1706:	cb 01       	movw	r24, r22
    1708:	88 a7       	std	Y+40, r24	; 0x28
    170a:	99 a7       	std	Y+41, r25	; 0x29
    170c:	aa a7       	std	Y+42, r26	; 0x2a
    170e:	bb a7       	std	Y+43, r27	; 0x2b

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	4a ef       	ldi	r20, 0xFA	; 250
    1716:	54 e4       	ldi	r21, 0x44	; 68
    1718:	68 a5       	ldd	r22, Y+40	; 0x28
    171a:	79 a5       	ldd	r23, Y+41	; 0x29
    171c:	8a a5       	ldd	r24, Y+42	; 0x2a
    171e:	9b a5       	ldd	r25, Y+43	; 0x2b
    1720:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1724:	dc 01       	movw	r26, r24
    1726:	cb 01       	movw	r24, r22
    1728:	8c a7       	std	Y+44, r24	; 0x2c
    172a:	9d a7       	std	Y+45, r25	; 0x2d
    172c:	ae a7       	std	Y+46, r26	; 0x2e
    172e:	bf a7       	std	Y+47, r27	; 0x2f
	if (__tmp < 1.0)
    1730:	20 e0       	ldi	r18, 0x00	; 0
    1732:	30 e0       	ldi	r19, 0x00	; 0
    1734:	40 e8       	ldi	r20, 0x80	; 128
    1736:	5f e3       	ldi	r21, 0x3F	; 63
    1738:	6c a5       	ldd	r22, Y+44	; 0x2c
    173a:	7d a5       	ldd	r23, Y+45	; 0x2d
    173c:	8e a5       	ldd	r24, Y+46	; 0x2e
    173e:	9f a5       	ldd	r25, Y+47	; 0x2f
    1740:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    1744:	88 23       	and	r24, r24
    1746:	2c f4       	brge	.+10     	; 0x1752 <LCD_initialize+0x738>
		__ticks = 1;
    1748:	81 e0       	ldi	r24, 0x01	; 1
    174a:	90 e0       	ldi	r25, 0x00	; 0
    174c:	99 ab       	std	Y+49, r25	; 0x31
    174e:	88 ab       	std	Y+48, r24	; 0x30
    1750:	3f c0       	rjmp	.+126    	; 0x17d0 <LCD_initialize+0x7b6>
	else if (__tmp > 65535)
    1752:	20 e0       	ldi	r18, 0x00	; 0
    1754:	3f ef       	ldi	r19, 0xFF	; 255
    1756:	4f e7       	ldi	r20, 0x7F	; 127
    1758:	57 e4       	ldi	r21, 0x47	; 71
    175a:	6c a5       	ldd	r22, Y+44	; 0x2c
    175c:	7d a5       	ldd	r23, Y+45	; 0x2d
    175e:	8e a5       	ldd	r24, Y+46	; 0x2e
    1760:	9f a5       	ldd	r25, Y+47	; 0x2f
    1762:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    1766:	18 16       	cp	r1, r24
    1768:	4c f5       	brge	.+82     	; 0x17bc <LCD_initialize+0x7a2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    176a:	20 e0       	ldi	r18, 0x00	; 0
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	40 e2       	ldi	r20, 0x20	; 32
    1770:	51 e4       	ldi	r21, 0x41	; 65
    1772:	68 a5       	ldd	r22, Y+40	; 0x28
    1774:	79 a5       	ldd	r23, Y+41	; 0x29
    1776:	8a a5       	ldd	r24, Y+42	; 0x2a
    1778:	9b a5       	ldd	r25, Y+43	; 0x2b
    177a:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    177e:	dc 01       	movw	r26, r24
    1780:	cb 01       	movw	r24, r22
    1782:	bc 01       	movw	r22, r24
    1784:	cd 01       	movw	r24, r26
    1786:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    178a:	dc 01       	movw	r26, r24
    178c:	cb 01       	movw	r24, r22
    178e:	99 ab       	std	Y+49, r25	; 0x31
    1790:	88 ab       	std	Y+48, r24	; 0x30
    1792:	0f c0       	rjmp	.+30     	; 0x17b2 <LCD_initialize+0x798>
    1794:	88 ec       	ldi	r24, 0xC8	; 200
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	9b ab       	std	Y+51, r25	; 0x33
    179a:	8a ab       	std	Y+50, r24	; 0x32
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    179c:	8a a9       	ldd	r24, Y+50	; 0x32
    179e:	9b a9       	ldd	r25, Y+51	; 0x33
    17a0:	01 97       	sbiw	r24, 0x01	; 1
    17a2:	f1 f7       	brne	.-4      	; 0x17a0 <LCD_initialize+0x786>
    17a4:	9b ab       	std	Y+51, r25	; 0x33
    17a6:	8a ab       	std	Y+50, r24	; 0x32
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17a8:	88 a9       	ldd	r24, Y+48	; 0x30
    17aa:	99 a9       	ldd	r25, Y+49	; 0x31
    17ac:	01 97       	sbiw	r24, 0x01	; 1
    17ae:	99 ab       	std	Y+49, r25	; 0x31
    17b0:	88 ab       	std	Y+48, r24	; 0x30
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17b2:	88 a9       	ldd	r24, Y+48	; 0x30
    17b4:	99 a9       	ldd	r25, Y+49	; 0x31
    17b6:	89 2b       	or	r24, r25
    17b8:	69 f7       	brne	.-38     	; 0x1794 <LCD_initialize+0x77a>
    17ba:	3f c0       	rjmp	.+126    	; 0x183a <LCD_initialize+0x820>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    17bc:	6c a5       	ldd	r22, Y+44	; 0x2c
    17be:	7d a5       	ldd	r23, Y+45	; 0x2d
    17c0:	8e a5       	ldd	r24, Y+46	; 0x2e
    17c2:	9f a5       	ldd	r25, Y+47	; 0x2f
    17c4:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    17c8:	dc 01       	movw	r26, r24
    17ca:	cb 01       	movw	r24, r22
    17cc:	99 ab       	std	Y+49, r25	; 0x31
    17ce:	88 ab       	std	Y+48, r24	; 0x30
    17d0:	88 a9       	ldd	r24, Y+48	; 0x30
    17d2:	99 a9       	ldd	r25, Y+49	; 0x31
    17d4:	9d ab       	std	Y+53, r25	; 0x35
    17d6:	8c ab       	std	Y+52, r24	; 0x34
    17d8:	8c a9       	ldd	r24, Y+52	; 0x34
    17da:	9d a9       	ldd	r25, Y+53	; 0x35
    17dc:	01 97       	sbiw	r24, 0x01	; 1
    17de:	f1 f7       	brne	.-4      	; 0x17dc <LCD_initialize+0x7c2>
    17e0:	9d ab       	std	Y+53, r25	; 0x35
    17e2:	8c ab       	std	Y+52, r24	; 0x34
    17e4:	2a c0       	rjmp	.+84     	; 0x183a <LCD_initialize+0x820>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    17e6:	20 e0       	ldi	r18, 0x00	; 0
    17e8:	30 e0       	ldi	r19, 0x00	; 0
    17ea:	4f e7       	ldi	r20, 0x7F	; 127
    17ec:	53 e4       	ldi	r21, 0x43	; 67
    17ee:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17f0:	78 a1       	ldd	r23, Y+32	; 0x20
    17f2:	89 a1       	ldd	r24, Y+33	; 0x21
    17f4:	9a a1       	ldd	r25, Y+34	; 0x22
    17f6:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    17fa:	18 16       	cp	r1, r24
    17fc:	ac f4       	brge	.+42     	; 0x1828 <LCD_initialize+0x80e>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    17fe:	6b a1       	ldd	r22, Y+35	; 0x23
    1800:	7c a1       	ldd	r23, Y+36	; 0x24
    1802:	8d a1       	ldd	r24, Y+37	; 0x25
    1804:	9e a1       	ldd	r25, Y+38	; 0x26
    1806:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    180a:	dc 01       	movw	r26, r24
    180c:	cb 01       	movw	r24, r22
    180e:	9f ab       	std	Y+55, r25	; 0x37
    1810:	8e ab       	std	Y+54, r24	; 0x36
    1812:	8e a9       	ldd	r24, Y+54	; 0x36
    1814:	9f a9       	ldd	r25, Y+55	; 0x37
    1816:	99 af       	std	Y+57, r25	; 0x39
    1818:	88 af       	std	Y+56, r24	; 0x38
    181a:	88 ad       	ldd	r24, Y+56	; 0x38
    181c:	99 ad       	ldd	r25, Y+57	; 0x39
    181e:	01 97       	sbiw	r24, 0x01	; 1
    1820:	f1 f7       	brne	.-4      	; 0x181e <LCD_initialize+0x804>
    1822:	99 af       	std	Y+57, r25	; 0x39
    1824:	88 af       	std	Y+56, r24	; 0x38
    1826:	0f c0       	rjmp	.+30     	; 0x1846 <LCD_initialize+0x82c>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1828:	6f 8d       	ldd	r22, Y+31	; 0x1f
    182a:	78 a1       	ldd	r23, Y+32	; 0x20
    182c:	89 a1       	ldd	r24, Y+33	; 0x21
    182e:	9a a1       	ldd	r25, Y+34	; 0x22
    1830:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    1834:	dc 01       	movw	r26, r24
    1836:	cb 01       	movw	r24, r22
    1838:	8f a3       	std	Y+39, r24	; 0x27
    183a:	8f a1       	ldd	r24, Y+39	; 0x27
    183c:	8a af       	std	Y+58, r24	; 0x3a
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    183e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1840:	8a 95       	dec	r24
    1842:	f1 f7       	brne	.-4      	; 0x1840 <LCD_initialize+0x826>
    1844:	8a af       	std	Y+58, r24	; 0x3a
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00000001);
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
    184c:	80 e0       	ldi	r24, 0x00	; 0
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	a0 e0       	ldi	r26, 0x00	; 0
    1852:	b0 e4       	ldi	r27, 0x40	; 64
    1854:	89 8b       	std	Y+17, r24	; 0x11
    1856:	9a 8b       	std	Y+18, r25	; 0x12
    1858:	ab 8b       	std	Y+19, r26	; 0x13
    185a:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    185c:	20 e0       	ldi	r18, 0x00	; 0
    185e:	30 e0       	ldi	r19, 0x00	; 0
    1860:	4a ef       	ldi	r20, 0xFA	; 250
    1862:	54 e4       	ldi	r21, 0x44	; 68
    1864:	69 89       	ldd	r22, Y+17	; 0x11
    1866:	7a 89       	ldd	r23, Y+18	; 0x12
    1868:	8b 89       	ldd	r24, Y+19	; 0x13
    186a:	9c 89       	ldd	r25, Y+20	; 0x14
    186c:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1870:	dc 01       	movw	r26, r24
    1872:	cb 01       	movw	r24, r22
    1874:	8d 8b       	std	Y+21, r24	; 0x15
    1876:	9e 8b       	std	Y+22, r25	; 0x16
    1878:	af 8b       	std	Y+23, r26	; 0x17
    187a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    187c:	20 e0       	ldi	r18, 0x00	; 0
    187e:	30 e0       	ldi	r19, 0x00	; 0
    1880:	40 e8       	ldi	r20, 0x80	; 128
    1882:	5f e3       	ldi	r21, 0x3F	; 63
    1884:	6d 89       	ldd	r22, Y+21	; 0x15
    1886:	7e 89       	ldd	r23, Y+22	; 0x16
    1888:	8f 89       	ldd	r24, Y+23	; 0x17
    188a:	98 8d       	ldd	r25, Y+24	; 0x18
    188c:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    1890:	88 23       	and	r24, r24
    1892:	2c f4       	brge	.+10     	; 0x189e <LCD_initialize+0x884>
		__ticks = 1;
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	9a 8f       	std	Y+26, r25	; 0x1a
    189a:	89 8f       	std	Y+25, r24	; 0x19
    189c:	3f c0       	rjmp	.+126    	; 0x191c <LCD_initialize+0x902>
	else if (__tmp > 65535)
    189e:	20 e0       	ldi	r18, 0x00	; 0
    18a0:	3f ef       	ldi	r19, 0xFF	; 255
    18a2:	4f e7       	ldi	r20, 0x7F	; 127
    18a4:	57 e4       	ldi	r21, 0x47	; 71
    18a6:	6d 89       	ldd	r22, Y+21	; 0x15
    18a8:	7e 89       	ldd	r23, Y+22	; 0x16
    18aa:	8f 89       	ldd	r24, Y+23	; 0x17
    18ac:	98 8d       	ldd	r25, Y+24	; 0x18
    18ae:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    18b2:	18 16       	cp	r1, r24
    18b4:	4c f5       	brge	.+82     	; 0x1908 <LCD_initialize+0x8ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    18b6:	20 e0       	ldi	r18, 0x00	; 0
    18b8:	30 e0       	ldi	r19, 0x00	; 0
    18ba:	40 e2       	ldi	r20, 0x20	; 32
    18bc:	51 e4       	ldi	r21, 0x41	; 65
    18be:	69 89       	ldd	r22, Y+17	; 0x11
    18c0:	7a 89       	ldd	r23, Y+18	; 0x12
    18c2:	8b 89       	ldd	r24, Y+19	; 0x13
    18c4:	9c 89       	ldd	r25, Y+20	; 0x14
    18c6:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    18ca:	dc 01       	movw	r26, r24
    18cc:	cb 01       	movw	r24, r22
    18ce:	bc 01       	movw	r22, r24
    18d0:	cd 01       	movw	r24, r26
    18d2:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    18d6:	dc 01       	movw	r26, r24
    18d8:	cb 01       	movw	r24, r22
    18da:	9a 8f       	std	Y+26, r25	; 0x1a
    18dc:	89 8f       	std	Y+25, r24	; 0x19
    18de:	0f c0       	rjmp	.+30     	; 0x18fe <LCD_initialize+0x8e4>
    18e0:	88 ec       	ldi	r24, 0xC8	; 200
    18e2:	90 e0       	ldi	r25, 0x00	; 0
    18e4:	9c 8f       	std	Y+28, r25	; 0x1c
    18e6:	8b 8f       	std	Y+27, r24	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    18e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	f1 f7       	brne	.-4      	; 0x18ec <LCD_initialize+0x8d2>
    18f0:	9c 8f       	std	Y+28, r25	; 0x1c
    18f2:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18f4:	89 8d       	ldd	r24, Y+25	; 0x19
    18f6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18f8:	01 97       	sbiw	r24, 0x01	; 1
    18fa:	9a 8f       	std	Y+26, r25	; 0x1a
    18fc:	89 8f       	std	Y+25, r24	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18fe:	89 8d       	ldd	r24, Y+25	; 0x19
    1900:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1902:	89 2b       	or	r24, r25
    1904:	69 f7       	brne	.-38     	; 0x18e0 <LCD_initialize+0x8c6>
	_delay_ms(2);

}
    1906:	14 c0       	rjmp	.+40     	; 0x1930 <LCD_initialize+0x916>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1908:	6d 89       	ldd	r22, Y+21	; 0x15
    190a:	7e 89       	ldd	r23, Y+22	; 0x16
    190c:	8f 89       	ldd	r24, Y+23	; 0x17
    190e:	98 8d       	ldd	r25, Y+24	; 0x18
    1910:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    1914:	dc 01       	movw	r26, r24
    1916:	cb 01       	movw	r24, r22
    1918:	9a 8f       	std	Y+26, r25	; 0x1a
    191a:	89 8f       	std	Y+25, r24	; 0x19
    191c:	89 8d       	ldd	r24, Y+25	; 0x19
    191e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1920:	9e 8f       	std	Y+30, r25	; 0x1e
    1922:	8d 8f       	std	Y+29, r24	; 0x1d
    1924:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1926:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1928:	01 97       	sbiw	r24, 0x01	; 1
    192a:	f1 f7       	brne	.-4      	; 0x1928 <LCD_initialize+0x90e>
    192c:	9e 8f       	std	Y+30, r25	; 0x1e
    192e:	8d 8f       	std	Y+29, r24	; 0x1d
    1930:	00 00       	nop
    1932:	c6 59       	subi	r28, 0x96	; 150
    1934:	df 4f       	sbci	r29, 0xFF	; 255
    1936:	0f b6       	in	r0, 0x3f	; 63
    1938:	f8 94       	cli
    193a:	de bf       	out	0x3e, r29	; 62
    193c:	0f be       	out	0x3f, r0	; 63
    193e:	cd bf       	out	0x3d, r28	; 61
    1940:	df 91       	pop	r29
    1942:	cf 91       	pop	r28
    1944:	1f 91       	pop	r17
    1946:	0f 91       	pop	r16
    1948:	08 95       	ret

0000194a <LCD_Void_Write_String>:

void LCD_Void_Write_String(u8* copy_string)
{
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	00 d0       	rcall	.+0      	; 0x1950 <LCD_Void_Write_String+0x6>
    1950:	1f 92       	push	r1
    1952:	cd b7       	in	r28, 0x3d	; 61
    1954:	de b7       	in	r29, 0x3e	; 62
    1956:	9b 83       	std	Y+3, r25	; 0x03
    1958:	8a 83       	std	Y+2, r24	; 0x02
	u8 i = 0;
    195a:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    195c:	14 c0       	rjmp	.+40     	; 0x1986 <LCD_Void_Write_String+0x3c>
	{	if(i==16)
    195e:	89 81       	ldd	r24, Y+1	; 0x01
    1960:	80 31       	cpi	r24, 0x10	; 16
    1962:	19 f4       	brne	.+6      	; 0x196a <LCD_Void_Write_String+0x20>
		{
			LCD_Set_Block(16);
    1964:	80 e1       	ldi	r24, 0x10	; 16
    1966:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
		}
		LCD_Void_Write_Data(copy_string[i]);
    196a:	89 81       	ldd	r24, Y+1	; 0x01
    196c:	88 2f       	mov	r24, r24
    196e:	90 e0       	ldi	r25, 0x00	; 0
    1970:	2a 81       	ldd	r18, Y+2	; 0x02
    1972:	3b 81       	ldd	r19, Y+3	; 0x03
    1974:	82 0f       	add	r24, r18
    1976:	93 1f       	adc	r25, r19
    1978:	fc 01       	movw	r30, r24
    197a:	80 81       	ld	r24, Z
    197c:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
		i++;
    1980:	89 81       	ldd	r24, Y+1	; 0x01
    1982:	8f 5f       	subi	r24, 0xFF	; 255
    1984:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1986:	89 81       	ldd	r24, Y+1	; 0x01
    1988:	88 2f       	mov	r24, r24
    198a:	90 e0       	ldi	r25, 0x00	; 0
    198c:	2a 81       	ldd	r18, Y+2	; 0x02
    198e:	3b 81       	ldd	r19, Y+3	; 0x03
    1990:	82 0f       	add	r24, r18
    1992:	93 1f       	adc	r25, r19
    1994:	fc 01       	movw	r30, r24
    1996:	80 81       	ld	r24, Z
    1998:	88 23       	and	r24, r24
    199a:	09 f7       	brne	.-62     	; 0x195e <LCD_Void_Write_String+0x14>
			LCD_Set_Block(16);
		}
		LCD_Void_Write_Data(copy_string[i]);
		i++;
	}
}
    199c:	00 00       	nop
    199e:	0f 90       	pop	r0
    19a0:	0f 90       	pop	r0
    19a2:	0f 90       	pop	r0
    19a4:	df 91       	pop	r29
    19a6:	cf 91       	pop	r28
    19a8:	08 95       	ret

000019aa <LCD_Void_Clear>:

void LCD_Void_Clear(void)
{
    19aa:	cf 93       	push	r28
    19ac:	df 93       	push	r29
    19ae:	cd b7       	in	r28, 0x3d	; 61
    19b0:	de b7       	in	r29, 0x3e	; 62
	LCD_Void_Write_Cmd(0b00000001);
    19b2:	81 e0       	ldi	r24, 0x01	; 1
    19b4:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
}
    19b8:	00 00       	nop
    19ba:	df 91       	pop	r29
    19bc:	cf 91       	pop	r28
    19be:	08 95       	ret

000019c0 <LCD_Void_Write_Blinking_String>:

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
    19c0:	cf 93       	push	r28
    19c2:	df 93       	push	r29
    19c4:	cd b7       	in	r28, 0x3d	; 61
    19c6:	de b7       	in	r29, 0x3e	; 62
    19c8:	61 97       	sbiw	r28, 0x11	; 17
    19ca:	0f b6       	in	r0, 0x3f	; 63
    19cc:	f8 94       	cli
    19ce:	de bf       	out	0x3e, r29	; 62
    19d0:	0f be       	out	0x3f, r0	; 63
    19d2:	cd bf       	out	0x3d, r28	; 61
    19d4:	99 8b       	std	Y+17, r25	; 0x11
    19d6:	88 8b       	std	Y+16, r24	; 0x10
	u8 i = 0;
    19d8:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    19da:	80 c0       	rjmp	.+256    	; 0x1adc <LCD_Void_Write_Blinking_String+0x11c>
	{
		LCD_Void_Write_Data(copy_string[i]);
    19dc:	89 81       	ldd	r24, Y+1	; 0x01
    19de:	88 2f       	mov	r24, r24
    19e0:	90 e0       	ldi	r25, 0x00	; 0
    19e2:	28 89       	ldd	r18, Y+16	; 0x10
    19e4:	39 89       	ldd	r19, Y+17	; 0x11
    19e6:	82 0f       	add	r24, r18
    19e8:	93 1f       	adc	r25, r19
    19ea:	fc 01       	movw	r30, r24
    19ec:	80 81       	ld	r24, Z
    19ee:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
    19f2:	80 e0       	ldi	r24, 0x00	; 0
    19f4:	90 e0       	ldi	r25, 0x00	; 0
    19f6:	aa ef       	ldi	r26, 0xFA	; 250
    19f8:	b3 e4       	ldi	r27, 0x43	; 67
    19fa:	8a 83       	std	Y+2, r24	; 0x02
    19fc:	9b 83       	std	Y+3, r25	; 0x03
    19fe:	ac 83       	std	Y+4, r26	; 0x04
    1a00:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1a02:	20 e0       	ldi	r18, 0x00	; 0
    1a04:	30 e0       	ldi	r19, 0x00	; 0
    1a06:	4a ef       	ldi	r20, 0xFA	; 250
    1a08:	54 e4       	ldi	r21, 0x44	; 68
    1a0a:	6a 81       	ldd	r22, Y+2	; 0x02
    1a0c:	7b 81       	ldd	r23, Y+3	; 0x03
    1a0e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a10:	9d 81       	ldd	r25, Y+5	; 0x05
    1a12:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1a16:	dc 01       	movw	r26, r24
    1a18:	cb 01       	movw	r24, r22
    1a1a:	8e 83       	std	Y+6, r24	; 0x06
    1a1c:	9f 83       	std	Y+7, r25	; 0x07
    1a1e:	a8 87       	std	Y+8, r26	; 0x08
    1a20:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    1a22:	20 e0       	ldi	r18, 0x00	; 0
    1a24:	30 e0       	ldi	r19, 0x00	; 0
    1a26:	40 e8       	ldi	r20, 0x80	; 128
    1a28:	5f e3       	ldi	r21, 0x3F	; 63
    1a2a:	6e 81       	ldd	r22, Y+6	; 0x06
    1a2c:	7f 81       	ldd	r23, Y+7	; 0x07
    1a2e:	88 85       	ldd	r24, Y+8	; 0x08
    1a30:	99 85       	ldd	r25, Y+9	; 0x09
    1a32:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    1a36:	88 23       	and	r24, r24
    1a38:	2c f4       	brge	.+10     	; 0x1a44 <LCD_Void_Write_Blinking_String+0x84>
		__ticks = 1;
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
    1a3e:	9b 87       	std	Y+11, r25	; 0x0b
    1a40:	8a 87       	std	Y+10, r24	; 0x0a
    1a42:	3f c0       	rjmp	.+126    	; 0x1ac2 <LCD_Void_Write_Blinking_String+0x102>
	else if (__tmp > 65535)
    1a44:	20 e0       	ldi	r18, 0x00	; 0
    1a46:	3f ef       	ldi	r19, 0xFF	; 255
    1a48:	4f e7       	ldi	r20, 0x7F	; 127
    1a4a:	57 e4       	ldi	r21, 0x47	; 71
    1a4c:	6e 81       	ldd	r22, Y+6	; 0x06
    1a4e:	7f 81       	ldd	r23, Y+7	; 0x07
    1a50:	88 85       	ldd	r24, Y+8	; 0x08
    1a52:	99 85       	ldd	r25, Y+9	; 0x09
    1a54:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    1a58:	18 16       	cp	r1, r24
    1a5a:	4c f5       	brge	.+82     	; 0x1aae <LCD_Void_Write_Blinking_String+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a5c:	20 e0       	ldi	r18, 0x00	; 0
    1a5e:	30 e0       	ldi	r19, 0x00	; 0
    1a60:	40 e2       	ldi	r20, 0x20	; 32
    1a62:	51 e4       	ldi	r21, 0x41	; 65
    1a64:	6a 81       	ldd	r22, Y+2	; 0x02
    1a66:	7b 81       	ldd	r23, Y+3	; 0x03
    1a68:	8c 81       	ldd	r24, Y+4	; 0x04
    1a6a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a6c:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1a70:	dc 01       	movw	r26, r24
    1a72:	cb 01       	movw	r24, r22
    1a74:	bc 01       	movw	r22, r24
    1a76:	cd 01       	movw	r24, r26
    1a78:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    1a7c:	dc 01       	movw	r26, r24
    1a7e:	cb 01       	movw	r24, r22
    1a80:	9b 87       	std	Y+11, r25	; 0x0b
    1a82:	8a 87       	std	Y+10, r24	; 0x0a
    1a84:	0f c0       	rjmp	.+30     	; 0x1aa4 <LCD_Void_Write_Blinking_String+0xe4>
    1a86:	88 ec       	ldi	r24, 0xC8	; 200
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	9d 87       	std	Y+13, r25	; 0x0d
    1a8c:	8c 87       	std	Y+12, r24	; 0x0c
    1a8e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a90:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a92:	01 97       	sbiw	r24, 0x01	; 1
    1a94:	f1 f7       	brne	.-4      	; 0x1a92 <LCD_Void_Write_Blinking_String+0xd2>
    1a96:	9d 87       	std	Y+13, r25	; 0x0d
    1a98:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a9a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a9c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a9e:	01 97       	sbiw	r24, 0x01	; 1
    1aa0:	9b 87       	std	Y+11, r25	; 0x0b
    1aa2:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1aa4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1aa6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1aa8:	89 2b       	or	r24, r25
    1aaa:	69 f7       	brne	.-38     	; 0x1a86 <LCD_Void_Write_Blinking_String+0xc6>
    1aac:	14 c0       	rjmp	.+40     	; 0x1ad6 <LCD_Void_Write_Blinking_String+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1aae:	6e 81       	ldd	r22, Y+6	; 0x06
    1ab0:	7f 81       	ldd	r23, Y+7	; 0x07
    1ab2:	88 85       	ldd	r24, Y+8	; 0x08
    1ab4:	99 85       	ldd	r25, Y+9	; 0x09
    1ab6:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    1aba:	dc 01       	movw	r26, r24
    1abc:	cb 01       	movw	r24, r22
    1abe:	9b 87       	std	Y+11, r25	; 0x0b
    1ac0:	8a 87       	std	Y+10, r24	; 0x0a
    1ac2:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ac4:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ac6:	9f 87       	std	Y+15, r25	; 0x0f
    1ac8:	8e 87       	std	Y+14, r24	; 0x0e
    1aca:	8e 85       	ldd	r24, Y+14	; 0x0e
    1acc:	9f 85       	ldd	r25, Y+15	; 0x0f
    1ace:	01 97       	sbiw	r24, 0x01	; 1
    1ad0:	f1 f7       	brne	.-4      	; 0x1ace <LCD_Void_Write_Blinking_String+0x10e>
    1ad2:	9f 87       	std	Y+15, r25	; 0x0f
    1ad4:	8e 87       	std	Y+14, r24	; 0x0e
		_delay_ms(500);
		i++;
    1ad6:	89 81       	ldd	r24, Y+1	; 0x01
    1ad8:	8f 5f       	subi	r24, 0xFF	; 255
    1ada:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1adc:	89 81       	ldd	r24, Y+1	; 0x01
    1ade:	88 2f       	mov	r24, r24
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    1ae2:	28 89       	ldd	r18, Y+16	; 0x10
    1ae4:	39 89       	ldd	r19, Y+17	; 0x11
    1ae6:	82 0f       	add	r24, r18
    1ae8:	93 1f       	adc	r25, r19
    1aea:	fc 01       	movw	r30, r24
    1aec:	80 81       	ld	r24, Z
    1aee:	88 23       	and	r24, r24
    1af0:	09 f0       	breq	.+2      	; 0x1af4 <LCD_Void_Write_Blinking_String+0x134>
    1af2:	74 cf       	rjmp	.-280    	; 0x19dc <LCD_Void_Write_Blinking_String+0x1c>
	{
		LCD_Void_Write_Data(copy_string[i]);
		_delay_ms(500);
		i++;
	}
}
    1af4:	00 00       	nop
    1af6:	61 96       	adiw	r28, 0x11	; 17
    1af8:	0f b6       	in	r0, 0x3f	; 63
    1afa:	f8 94       	cli
    1afc:	de bf       	out	0x3e, r29	; 62
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	cd bf       	out	0x3d, r28	; 61
    1b02:	df 91       	pop	r29
    1b04:	cf 91       	pop	r28
    1b06:	08 95       	ret

00001b08 <LCD_Set_Block>:

void LCD_Set_Block(u8 copy_block_nb) // sets the ddram address to the block you want to write
{
    1b08:	cf 93       	push	r28
    1b0a:	df 93       	push	r29
    1b0c:	1f 92       	push	r1
    1b0e:	cd b7       	in	r28, 0x3d	; 61
    1b10:	de b7       	in	r29, 0x3e	; 62
    1b12:	89 83       	std	Y+1, r24	; 0x01
	if(copy_block_nb<16)
    1b14:	89 81       	ldd	r24, Y+1	; 0x01
    1b16:	80 31       	cpi	r24, 0x10	; 16
    1b18:	28 f4       	brcc	.+10     	; 0x1b24 <LCD_Set_Block+0x1c>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
    1b1a:	89 81       	ldd	r24, Y+1	; 0x01
    1b1c:	80 58       	subi	r24, 0x80	; 128
    1b1e:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
	}
}
    1b22:	04 c0       	rjmp	.+8      	; 0x1b2c <LCD_Set_Block+0x24>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
    1b24:	89 81       	ldd	r24, Y+1	; 0x01
    1b26:	80 55       	subi	r24, 0x50	; 80
    1b28:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
	}
}
    1b2c:	00 00       	nop
    1b2e:	0f 90       	pop	r0
    1b30:	df 91       	pop	r29
    1b32:	cf 91       	pop	r28
    1b34:	08 95       	ret

00001b36 <LCD_Void_Write_Moving_String>:

void LCD_Void_Write_Moving_String(u8* copy_string)
{
    1b36:	cf 93       	push	r28
    1b38:	df 93       	push	r29
    1b3a:	cd b7       	in	r28, 0x3d	; 61
    1b3c:	de b7       	in	r29, 0x3e	; 62
    1b3e:	63 97       	sbiw	r28, 0x13	; 19
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	f8 94       	cli
    1b44:	de bf       	out	0x3e, r29	; 62
    1b46:	0f be       	out	0x3f, r0	; 63
    1b48:	cd bf       	out	0x3d, r28	; 61
    1b4a:	9b 8b       	std	Y+19, r25	; 0x13
    1b4c:	8a 8b       	std	Y+18, r24	; 0x12
	u8 i;
	for (int j = 0; j<5 ;j++)
    1b4e:	1b 82       	std	Y+3, r1	; 0x03
    1b50:	1a 82       	std	Y+2, r1	; 0x02
    1b52:	97 c0       	rjmp	.+302    	; 0x1c82 <LCD_Void_Write_Moving_String+0x14c>
	{
		LCD_Set_Block(j);
    1b54:	8a 81       	ldd	r24, Y+2	; 0x02
    1b56:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <LCD_Set_Block>
		i = 0;
    1b5a:	19 82       	std	Y+1, r1	; 0x01
		while(copy_string[i] != '\0')
    1b5c:	0e c0       	rjmp	.+28     	; 0x1b7a <LCD_Void_Write_Moving_String+0x44>
		{

			LCD_Void_Write_Data(copy_string[i]);
    1b5e:	89 81       	ldd	r24, Y+1	; 0x01
    1b60:	88 2f       	mov	r24, r24
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	2a 89       	ldd	r18, Y+18	; 0x12
    1b66:	3b 89       	ldd	r19, Y+19	; 0x13
    1b68:	82 0f       	add	r24, r18
    1b6a:	93 1f       	adc	r25, r19
    1b6c:	fc 01       	movw	r30, r24
    1b6e:	80 81       	ld	r24, Z
    1b70:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
			i++;
    1b74:	89 81       	ldd	r24, Y+1	; 0x01
    1b76:	8f 5f       	subi	r24, 0xFF	; 255
    1b78:	89 83       	std	Y+1, r24	; 0x01
	u8 i;
	for (int j = 0; j<5 ;j++)
	{
		LCD_Set_Block(j);
		i = 0;
		while(copy_string[i] != '\0')
    1b7a:	89 81       	ldd	r24, Y+1	; 0x01
    1b7c:	88 2f       	mov	r24, r24
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	2a 89       	ldd	r18, Y+18	; 0x12
    1b82:	3b 89       	ldd	r19, Y+19	; 0x13
    1b84:	82 0f       	add	r24, r18
    1b86:	93 1f       	adc	r25, r19
    1b88:	fc 01       	movw	r30, r24
    1b8a:	80 81       	ld	r24, Z
    1b8c:	88 23       	and	r24, r24
    1b8e:	39 f7       	brne	.-50     	; 0x1b5e <LCD_Void_Write_Moving_String+0x28>
    1b90:	80 e0       	ldi	r24, 0x00	; 0
    1b92:	90 e0       	ldi	r25, 0x00	; 0
    1b94:	aa e7       	ldi	r26, 0x7A	; 122
    1b96:	b4 e4       	ldi	r27, 0x44	; 68
    1b98:	8c 83       	std	Y+4, r24	; 0x04
    1b9a:	9d 83       	std	Y+5, r25	; 0x05
    1b9c:	ae 83       	std	Y+6, r26	; 0x06
    1b9e:	bf 83       	std	Y+7, r27	; 0x07

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	4a ef       	ldi	r20, 0xFA	; 250
    1ba6:	54 e4       	ldi	r21, 0x44	; 68
    1ba8:	6c 81       	ldd	r22, Y+4	; 0x04
    1baa:	7d 81       	ldd	r23, Y+5	; 0x05
    1bac:	8e 81       	ldd	r24, Y+6	; 0x06
    1bae:	9f 81       	ldd	r25, Y+7	; 0x07
    1bb0:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1bb4:	dc 01       	movw	r26, r24
    1bb6:	cb 01       	movw	r24, r22
    1bb8:	88 87       	std	Y+8, r24	; 0x08
    1bba:	99 87       	std	Y+9, r25	; 0x09
    1bbc:	aa 87       	std	Y+10, r26	; 0x0a
    1bbe:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1bc0:	20 e0       	ldi	r18, 0x00	; 0
    1bc2:	30 e0       	ldi	r19, 0x00	; 0
    1bc4:	40 e8       	ldi	r20, 0x80	; 128
    1bc6:	5f e3       	ldi	r21, 0x3F	; 63
    1bc8:	68 85       	ldd	r22, Y+8	; 0x08
    1bca:	79 85       	ldd	r23, Y+9	; 0x09
    1bcc:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bce:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bd0:	0e 94 9c 30 	call	0x6138	; 0x6138 <__cmpsf2>
    1bd4:	88 23       	and	r24, r24
    1bd6:	2c f4       	brge	.+10     	; 0x1be2 <LCD_Void_Write_Moving_String+0xac>
		__ticks = 1;
    1bd8:	81 e0       	ldi	r24, 0x01	; 1
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	9d 87       	std	Y+13, r25	; 0x0d
    1bde:	8c 87       	std	Y+12, r24	; 0x0c
    1be0:	3f c0       	rjmp	.+126    	; 0x1c60 <LCD_Void_Write_Moving_String+0x12a>
	else if (__tmp > 65535)
    1be2:	20 e0       	ldi	r18, 0x00	; 0
    1be4:	3f ef       	ldi	r19, 0xFF	; 255
    1be6:	4f e7       	ldi	r20, 0x7F	; 127
    1be8:	57 e4       	ldi	r21, 0x47	; 71
    1bea:	68 85       	ldd	r22, Y+8	; 0x08
    1bec:	79 85       	ldd	r23, Y+9	; 0x09
    1bee:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bf0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bf2:	0e 94 b7 31 	call	0x636e	; 0x636e <__gesf2>
    1bf6:	18 16       	cp	r1, r24
    1bf8:	4c f5       	brge	.+82     	; 0x1c4c <LCD_Void_Write_Moving_String+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bfa:	20 e0       	ldi	r18, 0x00	; 0
    1bfc:	30 e0       	ldi	r19, 0x00	; 0
    1bfe:	40 e2       	ldi	r20, 0x20	; 32
    1c00:	51 e4       	ldi	r21, 0x41	; 65
    1c02:	6c 81       	ldd	r22, Y+4	; 0x04
    1c04:	7d 81       	ldd	r23, Y+5	; 0x05
    1c06:	8e 81       	ldd	r24, Y+6	; 0x06
    1c08:	9f 81       	ldd	r25, Y+7	; 0x07
    1c0a:	0e 94 bc 31 	call	0x6378	; 0x6378 <__mulsf3>
    1c0e:	dc 01       	movw	r26, r24
    1c10:	cb 01       	movw	r24, r22
    1c12:	bc 01       	movw	r22, r24
    1c14:	cd 01       	movw	r24, r26
    1c16:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    1c1a:	dc 01       	movw	r26, r24
    1c1c:	cb 01       	movw	r24, r22
    1c1e:	9d 87       	std	Y+13, r25	; 0x0d
    1c20:	8c 87       	std	Y+12, r24	; 0x0c
    1c22:	0f c0       	rjmp	.+30     	; 0x1c42 <LCD_Void_Write_Moving_String+0x10c>
    1c24:	88 ec       	ldi	r24, 0xC8	; 200
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	9f 87       	std	Y+15, r25	; 0x0f
    1c2a:	8e 87       	std	Y+14, r24	; 0x0e
    1c2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c2e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c30:	01 97       	sbiw	r24, 0x01	; 1
    1c32:	f1 f7       	brne	.-4      	; 0x1c30 <LCD_Void_Write_Moving_String+0xfa>
    1c34:	9f 87       	std	Y+15, r25	; 0x0f
    1c36:	8e 87       	std	Y+14, r24	; 0x0e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c38:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c3a:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c3c:	01 97       	sbiw	r24, 0x01	; 1
    1c3e:	9d 87       	std	Y+13, r25	; 0x0d
    1c40:	8c 87       	std	Y+12, r24	; 0x0c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c42:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c44:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c46:	89 2b       	or	r24, r25
    1c48:	69 f7       	brne	.-38     	; 0x1c24 <LCD_Void_Write_Moving_String+0xee>
    1c4a:	14 c0       	rjmp	.+40     	; 0x1c74 <LCD_Void_Write_Moving_String+0x13e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c4c:	68 85       	ldd	r22, Y+8	; 0x08
    1c4e:	79 85       	ldd	r23, Y+9	; 0x09
    1c50:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c52:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c54:	0e 94 13 31 	call	0x6226	; 0x6226 <__fixunssfsi>
    1c58:	dc 01       	movw	r26, r24
    1c5a:	cb 01       	movw	r24, r22
    1c5c:	9d 87       	std	Y+13, r25	; 0x0d
    1c5e:	8c 87       	std	Y+12, r24	; 0x0c
    1c60:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c62:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c64:	99 8b       	std	Y+17, r25	; 0x11
    1c66:	88 8b       	std	Y+16, r24	; 0x10
    1c68:	88 89       	ldd	r24, Y+16	; 0x10
    1c6a:	99 89       	ldd	r25, Y+17	; 0x11
    1c6c:	01 97       	sbiw	r24, 0x01	; 1
    1c6e:	f1 f7       	brne	.-4      	; 0x1c6c <LCD_Void_Write_Moving_String+0x136>
    1c70:	99 8b       	std	Y+17, r25	; 0x11
    1c72:	88 8b       	std	Y+16, r24	; 0x10

			LCD_Void_Write_Data(copy_string[i]);
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
    1c74:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_Void_Clear>
}

void LCD_Void_Write_Moving_String(u8* copy_string)
{
	u8 i;
	for (int j = 0; j<5 ;j++)
    1c78:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c7c:	01 96       	adiw	r24, 0x01	; 1
    1c7e:	9b 83       	std	Y+3, r25	; 0x03
    1c80:	8a 83       	std	Y+2, r24	; 0x02
    1c82:	8a 81       	ldd	r24, Y+2	; 0x02
    1c84:	9b 81       	ldd	r25, Y+3	; 0x03
    1c86:	05 97       	sbiw	r24, 0x05	; 5
    1c88:	0c f4       	brge	.+2      	; 0x1c8c <LCD_Void_Write_Moving_String+0x156>
    1c8a:	64 cf       	rjmp	.-312    	; 0x1b54 <LCD_Void_Write_Moving_String+0x1e>
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
	}
}
    1c8c:	00 00       	nop
    1c8e:	63 96       	adiw	r28, 0x13	; 19
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	de bf       	out	0x3e, r29	; 62
    1c96:	0f be       	out	0x3f, r0	; 63
    1c98:	cd bf       	out	0x3d, r28	; 61
    1c9a:	df 91       	pop	r29
    1c9c:	cf 91       	pop	r28
    1c9e:	08 95       	ret

00001ca0 <LCD_Void_Write_CGRAM>:

void LCD_Void_Write_CGRAM(u8 copy_row_0,u8 copy_row_1,u8 copy_row_2,u8 copy_row_3,u8 copy_row_4,u8 copy_row_5,u8 copy_row_6,u8 copy_row_7,u8 copy_CGRAM_address)
{
    1ca0:	8f 92       	push	r8
    1ca2:	af 92       	push	r10
    1ca4:	cf 92       	push	r12
    1ca6:	ef 92       	push	r14
    1ca8:	0f 93       	push	r16
    1caa:	cf 93       	push	r28
    1cac:	df 93       	push	r29
    1cae:	cd b7       	in	r28, 0x3d	; 61
    1cb0:	de b7       	in	r29, 0x3e	; 62
    1cb2:	29 97       	sbiw	r28, 0x09	; 9
    1cb4:	0f b6       	in	r0, 0x3f	; 63
    1cb6:	f8 94       	cli
    1cb8:	de bf       	out	0x3e, r29	; 62
    1cba:	0f be       	out	0x3f, r0	; 63
    1cbc:	cd bf       	out	0x3d, r28	; 61
    1cbe:	89 83       	std	Y+1, r24	; 0x01
    1cc0:	6a 83       	std	Y+2, r22	; 0x02
    1cc2:	4b 83       	std	Y+3, r20	; 0x03
    1cc4:	2c 83       	std	Y+4, r18	; 0x04
    1cc6:	0d 83       	std	Y+5, r16	; 0x05
    1cc8:	ee 82       	std	Y+6, r14	; 0x06
    1cca:	cf 82       	std	Y+7, r12	; 0x07
    1ccc:	a8 86       	std	Y+8, r10	; 0x08
    1cce:	89 86       	std	Y+9, r8	; 0x09
	LCD_Void_Write_Cmd(copy_CGRAM_address);
    1cd0:	89 85       	ldd	r24, Y+9	; 0x09
    1cd2:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
	LCD_Void_Write_Data(copy_row_0);
    1cd6:	89 81       	ldd	r24, Y+1	; 0x01
    1cd8:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_1);
    1cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cde:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_2);
    1ce2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce4:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_3);
    1ce8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cea:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_4);
    1cee:	8d 81       	ldd	r24, Y+5	; 0x05
    1cf0:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_5);
    1cf4:	8e 81       	ldd	r24, Y+6	; 0x06
    1cf6:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_6);
    1cfa:	8f 81       	ldd	r24, Y+7	; 0x07
    1cfc:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_7);
    1d00:	88 85       	ldd	r24, Y+8	; 0x08
    1d02:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Cmd(0b10000000);
    1d06:	80 e8       	ldi	r24, 0x80	; 128
    1d08:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <LCD_Void_Write_Cmd>
}
    1d0c:	00 00       	nop
    1d0e:	29 96       	adiw	r28, 0x09	; 9
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	f8 94       	cli
    1d14:	de bf       	out	0x3e, r29	; 62
    1d16:	0f be       	out	0x3f, r0	; 63
    1d18:	cd bf       	out	0x3d, r28	; 61
    1d1a:	df 91       	pop	r29
    1d1c:	cf 91       	pop	r28
    1d1e:	0f 91       	pop	r16
    1d20:	ef 90       	pop	r14
    1d22:	cf 90       	pop	r12
    1d24:	af 90       	pop	r10
    1d26:	8f 90       	pop	r8
    1d28:	08 95       	ret

00001d2a <LCD_Void_Write_Number>:

void LCD_Void_Write_Number(u32 Number)
{
    1d2a:	cf 93       	push	r28
    1d2c:	df 93       	push	r29
    1d2e:	00 d0       	rcall	.+0      	; 0x1d30 <LCD_Void_Write_Number+0x6>
    1d30:	00 d0       	rcall	.+0      	; 0x1d32 <LCD_Void_Write_Number+0x8>
    1d32:	1f 92       	push	r1
    1d34:	cd b7       	in	r28, 0x3d	; 61
    1d36:	de b7       	in	r29, 0x3e	; 62
    1d38:	9d 83       	std	Y+5, r25	; 0x05
    1d3a:	8c 83       	std	Y+4, r24	; 0x04
	u32 Reversed_Num = 0;
    1d3c:	1a 82       	std	Y+2, r1	; 0x02
    1d3e:	19 82       	std	Y+1, r1	; 0x01
	u8 count = 0;
    1d40:	1b 82       	std	Y+3, r1	; 0x03
	while(Number > 0)
    1d42:	3c c0       	rjmp	.+120    	; 0x1dbc <LCD_Void_Write_Number+0x92>
	{
		Reversed_Num = (Number%10) + (Reversed_Num*10);
    1d44:	4c 81       	ldd	r20, Y+4	; 0x04
    1d46:	5d 81       	ldd	r21, Y+5	; 0x05
    1d48:	9a 01       	movw	r18, r20
    1d4a:	ad ec       	ldi	r26, 0xCD	; 205
    1d4c:	bc ec       	ldi	r27, 0xCC	; 204
    1d4e:	0e 94 20 30 	call	0x6040	; 0x6040 <__umulhisi3>
    1d52:	9c 01       	movw	r18, r24
    1d54:	36 95       	lsr	r19
    1d56:	27 95       	ror	r18
    1d58:	36 95       	lsr	r19
    1d5a:	27 95       	ror	r18
    1d5c:	36 95       	lsr	r19
    1d5e:	27 95       	ror	r18
    1d60:	c9 01       	movw	r24, r18
    1d62:	88 0f       	add	r24, r24
    1d64:	99 1f       	adc	r25, r25
    1d66:	9c 01       	movw	r18, r24
    1d68:	22 0f       	add	r18, r18
    1d6a:	33 1f       	adc	r19, r19
    1d6c:	22 0f       	add	r18, r18
    1d6e:	33 1f       	adc	r19, r19
    1d70:	82 0f       	add	r24, r18
    1d72:	93 1f       	adc	r25, r19
    1d74:	9a 01       	movw	r18, r20
    1d76:	28 1b       	sub	r18, r24
    1d78:	39 0b       	sbc	r19, r25
    1d7a:	89 81       	ldd	r24, Y+1	; 0x01
    1d7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d7e:	88 0f       	add	r24, r24
    1d80:	99 1f       	adc	r25, r25
    1d82:	ac 01       	movw	r20, r24
    1d84:	44 0f       	add	r20, r20
    1d86:	55 1f       	adc	r21, r21
    1d88:	44 0f       	add	r20, r20
    1d8a:	55 1f       	adc	r21, r21
    1d8c:	84 0f       	add	r24, r20
    1d8e:	95 1f       	adc	r25, r21
    1d90:	82 0f       	add	r24, r18
    1d92:	93 1f       	adc	r25, r19
    1d94:	9a 83       	std	Y+2, r25	; 0x02
    1d96:	89 83       	std	Y+1, r24	; 0x01
		Number /= 10;
    1d98:	8c 81       	ldd	r24, Y+4	; 0x04
    1d9a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d9c:	9c 01       	movw	r18, r24
    1d9e:	ad ec       	ldi	r26, 0xCD	; 205
    1da0:	bc ec       	ldi	r27, 0xCC	; 204
    1da2:	0e 94 20 30 	call	0x6040	; 0x6040 <__umulhisi3>
    1da6:	96 95       	lsr	r25
    1da8:	87 95       	ror	r24
    1daa:	96 95       	lsr	r25
    1dac:	87 95       	ror	r24
    1dae:	96 95       	lsr	r25
    1db0:	87 95       	ror	r24
    1db2:	9d 83       	std	Y+5, r25	; 0x05
    1db4:	8c 83       	std	Y+4, r24	; 0x04
		count ++;
    1db6:	8b 81       	ldd	r24, Y+3	; 0x03
    1db8:	8f 5f       	subi	r24, 0xFF	; 255
    1dba:	8b 83       	std	Y+3, r24	; 0x03

void LCD_Void_Write_Number(u32 Number)
{
	u32 Reversed_Num = 0;
	u8 count = 0;
	while(Number > 0)
    1dbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1dbe:	9d 81       	ldd	r25, Y+5	; 0x05
    1dc0:	89 2b       	or	r24, r25
    1dc2:	09 f0       	breq	.+2      	; 0x1dc6 <LCD_Void_Write_Number+0x9c>
    1dc4:	bf cf       	rjmp	.-130    	; 0x1d44 <LCD_Void_Write_Number+0x1a>
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1dc6:	1d 82       	std	Y+5, r1	; 0x05
    1dc8:	1c 82       	std	Y+4, r1	; 0x04
    1dca:	31 c0       	rjmp	.+98     	; 0x1e2e <LCD_Void_Write_Number+0x104>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
    1dcc:	49 81       	ldd	r20, Y+1	; 0x01
    1dce:	5a 81       	ldd	r21, Y+2	; 0x02
    1dd0:	9a 01       	movw	r18, r20
    1dd2:	ad ec       	ldi	r26, 0xCD	; 205
    1dd4:	bc ec       	ldi	r27, 0xCC	; 204
    1dd6:	0e 94 20 30 	call	0x6040	; 0x6040 <__umulhisi3>
    1dda:	96 95       	lsr	r25
    1ddc:	87 95       	ror	r24
    1dde:	96 95       	lsr	r25
    1de0:	87 95       	ror	r24
    1de2:	96 95       	lsr	r25
    1de4:	87 95       	ror	r24
    1de6:	88 0f       	add	r24, r24
    1de8:	99 1f       	adc	r25, r25
    1dea:	9c 01       	movw	r18, r24
    1dec:	22 0f       	add	r18, r18
    1dee:	33 1f       	adc	r19, r19
    1df0:	22 0f       	add	r18, r18
    1df2:	33 1f       	adc	r19, r19
    1df4:	82 0f       	add	r24, r18
    1df6:	93 1f       	adc	r25, r19
    1df8:	9a 01       	movw	r18, r20
    1dfa:	28 1b       	sub	r18, r24
    1dfc:	39 0b       	sbc	r19, r25
    1dfe:	c9 01       	movw	r24, r18
    1e00:	80 5d       	subi	r24, 0xD0	; 208
    1e02:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
		Reversed_Num /= 10;
    1e06:	89 81       	ldd	r24, Y+1	; 0x01
    1e08:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0a:	9c 01       	movw	r18, r24
    1e0c:	ad ec       	ldi	r26, 0xCD	; 205
    1e0e:	bc ec       	ldi	r27, 0xCC	; 204
    1e10:	0e 94 20 30 	call	0x6040	; 0x6040 <__umulhisi3>
    1e14:	96 95       	lsr	r25
    1e16:	87 95       	ror	r24
    1e18:	96 95       	lsr	r25
    1e1a:	87 95       	ror	r24
    1e1c:	96 95       	lsr	r25
    1e1e:	87 95       	ror	r24
    1e20:	9a 83       	std	Y+2, r25	; 0x02
    1e22:	89 83       	std	Y+1, r24	; 0x01
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1e24:	8c 81       	ldd	r24, Y+4	; 0x04
    1e26:	9d 81       	ldd	r25, Y+5	; 0x05
    1e28:	01 96       	adiw	r24, 0x01	; 1
    1e2a:	9d 83       	std	Y+5, r25	; 0x05
    1e2c:	8c 83       	std	Y+4, r24	; 0x04
    1e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e30:	28 2f       	mov	r18, r24
    1e32:	30 e0       	ldi	r19, 0x00	; 0
    1e34:	8c 81       	ldd	r24, Y+4	; 0x04
    1e36:	9d 81       	ldd	r25, Y+5	; 0x05
    1e38:	82 17       	cp	r24, r18
    1e3a:	93 07       	cpc	r25, r19
    1e3c:	38 f2       	brcs	.-114    	; 0x1dcc <LCD_Void_Write_Number+0xa2>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
		Reversed_Num /= 10;
	}

}
    1e3e:	00 00       	nop
    1e40:	0f 90       	pop	r0
    1e42:	0f 90       	pop	r0
    1e44:	0f 90       	pop	r0
    1e46:	0f 90       	pop	r0
    1e48:	0f 90       	pop	r0
    1e4a:	df 91       	pop	r29
    1e4c:	cf 91       	pop	r28
    1e4e:	08 95       	ret

00001e50 <LCD_Void_Write_Number_2>:


void LCD_Void_Write_Number_2(u8 Number)
{
    1e50:	cf 93       	push	r28
    1e52:	df 93       	push	r29
    1e54:	1f 92       	push	r1
    1e56:	cd b7       	in	r28, 0x3d	; 61
    1e58:	de b7       	in	r29, 0x3e	; 62
    1e5a:	89 83       	std	Y+1, r24	; 0x01

	LCD_Void_Write_Data((Number/10)+'0');
    1e5c:	99 81       	ldd	r25, Y+1	; 0x01
    1e5e:	8d ec       	ldi	r24, 0xCD	; 205
    1e60:	98 9f       	mul	r25, r24
    1e62:	81 2d       	mov	r24, r1
    1e64:	11 24       	eor	r1, r1
    1e66:	86 95       	lsr	r24
    1e68:	86 95       	lsr	r24
    1e6a:	86 95       	lsr	r24
    1e6c:	80 5d       	subi	r24, 0xD0	; 208
    1e6e:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data((Number%10)+'0');
    1e72:	99 81       	ldd	r25, Y+1	; 0x01
    1e74:	8d ec       	ldi	r24, 0xCD	; 205
    1e76:	98 9f       	mul	r25, r24
    1e78:	81 2d       	mov	r24, r1
    1e7a:	11 24       	eor	r1, r1
    1e7c:	86 95       	lsr	r24
    1e7e:	86 95       	lsr	r24
    1e80:	86 95       	lsr	r24
    1e82:	88 0f       	add	r24, r24
    1e84:	28 2f       	mov	r18, r24
    1e86:	22 0f       	add	r18, r18
    1e88:	22 0f       	add	r18, r18
    1e8a:	82 0f       	add	r24, r18
    1e8c:	29 2f       	mov	r18, r25
    1e8e:	28 1b       	sub	r18, r24
    1e90:	82 2f       	mov	r24, r18
    1e92:	80 5d       	subi	r24, 0xD0	; 208
    1e94:	0e 94 fb 07 	call	0xff6	; 0xff6 <LCD_Void_Write_Data>

}
    1e98:	00 00       	nop
    1e9a:	0f 90       	pop	r0
    1e9c:	df 91       	pop	r29
    1e9e:	cf 91       	pop	r28
    1ea0:	08 95       	ret

00001ea2 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1ea2:	cf 93       	push	r28
    1ea4:	df 93       	push	r29
    1ea6:	00 d0       	rcall	.+0      	; 0x1ea8 <xEventGroupCreate+0x6>
    1ea8:	cd b7       	in	r28, 0x3d	; 61
    1eaa:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1eac:	8b e0       	ldi	r24, 0x0B	; 11
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	0e 94 b2 12 	call	0x2564	; 0x2564 <pvPortMalloc>
    1eb4:	9a 83       	std	Y+2, r25	; 0x02
    1eb6:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    1eb8:	89 81       	ldd	r24, Y+1	; 0x01
    1eba:	9a 81       	ldd	r25, Y+2	; 0x02
    1ebc:	89 2b       	or	r24, r25
    1ebe:	51 f0       	breq	.+20     	; 0x1ed4 <xEventGroupCreate+0x32>
		{
			pxEventBits->uxEventBits = 0;
    1ec0:	89 81       	ldd	r24, Y+1	; 0x01
    1ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ec4:	fc 01       	movw	r30, r24
    1ec6:	11 82       	std	Z+1, r1	; 0x01
    1ec8:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1eca:	89 81       	ldd	r24, Y+1	; 0x01
    1ecc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ece:	02 96       	adiw	r24, 0x02	; 2
    1ed0:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    1ed4:	89 81       	ldd	r24, Y+1	; 0x01
    1ed6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1ed8:	0f 90       	pop	r0
    1eda:	0f 90       	pop	r0
    1edc:	df 91       	pop	r29
    1ede:	cf 91       	pop	r28
    1ee0:	08 95       	ret

00001ee2 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1ee2:	cf 93       	push	r28
    1ee4:	df 93       	push	r29
    1ee6:	cd b7       	in	r28, 0x3d	; 61
    1ee8:	de b7       	in	r29, 0x3e	; 62
    1eea:	60 97       	sbiw	r28, 0x10	; 16
    1eec:	0f b6       	in	r0, 0x3f	; 63
    1eee:	f8 94       	cli
    1ef0:	de bf       	out	0x3e, r29	; 62
    1ef2:	0f be       	out	0x3f, r0	; 63
    1ef4:	cd bf       	out	0x3d, r28	; 61
    1ef6:	9a 87       	std	Y+10, r25	; 0x0a
    1ef8:	89 87       	std	Y+9, r24	; 0x09
    1efa:	7c 87       	std	Y+12, r23	; 0x0c
    1efc:	6b 87       	std	Y+11, r22	; 0x0b
    1efe:	5e 87       	std	Y+14, r21	; 0x0e
    1f00:	4d 87       	std	Y+13, r20	; 0x0d
    1f02:	38 8b       	std	Y+16, r19	; 0x10
    1f04:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    1f06:	89 85       	ldd	r24, Y+9	; 0x09
    1f08:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f0a:	9c 83       	std	Y+4, r25	; 0x04
    1f0c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1f0e:	1d 82       	std	Y+5, r1	; 0x05
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1f10:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1f14:	8b 81       	ldd	r24, Y+3	; 0x03
    1f16:	9c 81       	ldd	r25, Y+4	; 0x04
    1f18:	fc 01       	movw	r30, r24
    1f1a:	80 81       	ld	r24, Z
    1f1c:	91 81       	ldd	r25, Z+1	; 0x01
    1f1e:	9f 83       	std	Y+7, r25	; 0x07
    1f20:	8e 83       	std	Y+6, r24	; 0x06

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1f22:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f24:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f26:	89 85       	ldd	r24, Y+9	; 0x09
    1f28:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f2a:	b9 01       	movw	r22, r18
    1f2c:	0e 94 53 11 	call	0x22a6	; 0x22a6 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f30:	2e 81       	ldd	r18, Y+6	; 0x06
    1f32:	3f 81       	ldd	r19, Y+7	; 0x07
    1f34:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f36:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f38:	28 2b       	or	r18, r24
    1f3a:	39 2b       	or	r19, r25
    1f3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f40:	28 23       	and	r18, r24
    1f42:	39 23       	and	r19, r25
    1f44:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f46:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f48:	28 17       	cp	r18, r24
    1f4a:	39 07       	cpc	r19, r25
    1f4c:	d9 f4       	brne	.+54     	; 0x1f84 <xEventGroupSync+0xa2>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1f4e:	2e 81       	ldd	r18, Y+6	; 0x06
    1f50:	3f 81       	ldd	r19, Y+7	; 0x07
    1f52:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f54:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f56:	82 2b       	or	r24, r18
    1f58:	93 2b       	or	r25, r19
    1f5a:	9a 83       	std	Y+2, r25	; 0x02
    1f5c:	89 83       	std	Y+1, r24	; 0x01

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f60:	9c 81       	ldd	r25, Y+4	; 0x04
    1f62:	fc 01       	movw	r30, r24
    1f64:	20 81       	ld	r18, Z
    1f66:	31 81       	ldd	r19, Z+1	; 0x01
    1f68:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f6c:	80 95       	com	r24
    1f6e:	90 95       	com	r25
    1f70:	28 23       	and	r18, r24
    1f72:	39 23       	and	r19, r25
    1f74:	8b 81       	ldd	r24, Y+3	; 0x03
    1f76:	9c 81       	ldd	r25, Y+4	; 0x04
    1f78:	fc 01       	movw	r30, r24
    1f7a:	31 83       	std	Z+1, r19	; 0x01
    1f7c:	20 83       	st	Z, r18

			xTicksToWait = 0;
    1f7e:	18 8a       	std	Y+16, r1	; 0x10
    1f80:	1f 86       	std	Y+15, r1	; 0x0f
    1f82:	1c c0       	rjmp	.+56     	; 0x1fbc <xEventGroupSync+0xda>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1f84:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f86:	98 89       	ldd	r25, Y+16	; 0x10
    1f88:	89 2b       	or	r24, r25
    1f8a:	79 f0       	breq	.+30     	; 0x1faa <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1f8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f90:	9c 01       	movw	r18, r24
    1f92:	35 60       	ori	r19, 0x05	; 5
    1f94:	8b 81       	ldd	r24, Y+3	; 0x03
    1f96:	9c 81       	ldd	r25, Y+4	; 0x04
    1f98:	02 96       	adiw	r24, 0x02	; 2
    1f9a:	4f 85       	ldd	r20, Y+15	; 0x0f
    1f9c:	58 89       	ldd	r21, Y+16	; 0x10
    1f9e:	b9 01       	movw	r22, r18
    1fa0:	0e 94 41 27 	call	0x4e82	; 0x4e82 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1fa4:	1a 82       	std	Y+2, r1	; 0x02
    1fa6:	19 82       	std	Y+1, r1	; 0x01
    1fa8:	09 c0       	rjmp	.+18     	; 0x1fbc <xEventGroupSync+0xda>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1faa:	8b 81       	ldd	r24, Y+3	; 0x03
    1fac:	9c 81       	ldd	r25, Y+4	; 0x04
    1fae:	fc 01       	movw	r30, r24
    1fb0:	80 81       	ld	r24, Z
    1fb2:	91 81       	ldd	r25, Z+1	; 0x01
    1fb4:	9a 83       	std	Y+2, r25	; 0x02
    1fb6:	89 83       	std	Y+1, r24	; 0x01
				xTimeoutOccurred = pdTRUE;
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1fbc:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    1fc0:	88 87       	std	Y+8, r24	; 0x08

	if( xTicksToWait != ( TickType_t ) 0 )
    1fc2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fc4:	98 89       	ldd	r25, Y+16	; 0x10
    1fc6:	89 2b       	or	r24, r25
    1fc8:	09 f4       	brne	.+2      	; 0x1fcc <xEventGroupSync+0xea>
    1fca:	3d c0       	rjmp	.+122    	; 0x2046 <xEventGroupSync+0x164>
	{
		if( xAlreadyYielded == pdFALSE )
    1fcc:	88 85       	ldd	r24, Y+8	; 0x08
    1fce:	88 23       	and	r24, r24
    1fd0:	11 f4       	brne	.+4      	; 0x1fd6 <xEventGroupSync+0xf4>
		{
			portYIELD_WITHIN_API();
    1fd2:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1fd6:	0e 94 a4 2b 	call	0x5748	; 0x5748 <uxTaskResetEventItemValue>
    1fda:	9a 83       	std	Y+2, r25	; 0x02
    1fdc:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1fde:	89 81       	ldd	r24, Y+1	; 0x01
    1fe0:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe2:	88 27       	eor	r24, r24
    1fe4:	92 70       	andi	r25, 0x02	; 2
    1fe6:	89 2b       	or	r24, r25
    1fe8:	49 f5       	brne	.+82     	; 0x203c <xEventGroupSync+0x15a>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1fea:	0f b6       	in	r0, 0x3f	; 63
    1fec:	f8 94       	cli
    1fee:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff4:	fc 01       	movw	r30, r24
    1ff6:	80 81       	ld	r24, Z
    1ff8:	91 81       	ldd	r25, Z+1	; 0x01
    1ffa:	9a 83       	std	Y+2, r25	; 0x02
    1ffc:	89 83       	std	Y+1, r24	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1ffe:	29 81       	ldd	r18, Y+1	; 0x01
    2000:	3a 81       	ldd	r19, Y+2	; 0x02
    2002:	8d 85       	ldd	r24, Y+13	; 0x0d
    2004:	9e 85       	ldd	r25, Y+14	; 0x0e
    2006:	28 23       	and	r18, r24
    2008:	39 23       	and	r19, r25
    200a:	8d 85       	ldd	r24, Y+13	; 0x0d
    200c:	9e 85       	ldd	r25, Y+14	; 0x0e
    200e:	28 17       	cp	r18, r24
    2010:	39 07       	cpc	r19, r25
    2012:	81 f4       	brne	.+32     	; 0x2034 <xEventGroupSync+0x152>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2014:	8b 81       	ldd	r24, Y+3	; 0x03
    2016:	9c 81       	ldd	r25, Y+4	; 0x04
    2018:	fc 01       	movw	r30, r24
    201a:	20 81       	ld	r18, Z
    201c:	31 81       	ldd	r19, Z+1	; 0x01
    201e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2020:	9e 85       	ldd	r25, Y+14	; 0x0e
    2022:	80 95       	com	r24
    2024:	90 95       	com	r25
    2026:	28 23       	and	r18, r24
    2028:	39 23       	and	r19, r25
    202a:	8b 81       	ldd	r24, Y+3	; 0x03
    202c:	9c 81       	ldd	r25, Y+4	; 0x04
    202e:	fc 01       	movw	r30, r24
    2030:	31 83       	std	Z+1, r19	; 0x01
    2032:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2034:	0f 90       	pop	r0
    2036:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2038:	81 e0       	ldi	r24, 0x01	; 1
    203a:	8d 83       	std	Y+5, r24	; 0x05
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    203c:	89 81       	ldd	r24, Y+1	; 0x01
    203e:	9a 81       	ldd	r25, Y+2	; 0x02
    2040:	99 27       	eor	r25, r25
    2042:	9a 83       	std	Y+2, r25	; 0x02
    2044:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2046:	89 81       	ldd	r24, Y+1	; 0x01
    2048:	9a 81       	ldd	r25, Y+2	; 0x02
}
    204a:	60 96       	adiw	r28, 0x10	; 16
    204c:	0f b6       	in	r0, 0x3f	; 63
    204e:	f8 94       	cli
    2050:	de bf       	out	0x3e, r29	; 62
    2052:	0f be       	out	0x3f, r0	; 63
    2054:	cd bf       	out	0x3d, r28	; 61
    2056:	df 91       	pop	r29
    2058:	cf 91       	pop	r28
    205a:	08 95       	ret

0000205c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    205c:	0f 93       	push	r16
    205e:	1f 93       	push	r17
    2060:	cf 93       	push	r28
    2062:	df 93       	push	r29
    2064:	cd b7       	in	r28, 0x3d	; 61
    2066:	de b7       	in	r29, 0x3e	; 62
    2068:	63 97       	sbiw	r28, 0x13	; 19
    206a:	0f b6       	in	r0, 0x3f	; 63
    206c:	f8 94       	cli
    206e:	de bf       	out	0x3e, r29	; 62
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	cd bf       	out	0x3d, r28	; 61
    2074:	9d 87       	std	Y+13, r25	; 0x0d
    2076:	8c 87       	std	Y+12, r24	; 0x0c
    2078:	7f 87       	std	Y+15, r23	; 0x0f
    207a:	6e 87       	std	Y+14, r22	; 0x0e
    207c:	48 8b       	std	Y+16, r20	; 0x10
    207e:	29 8b       	std	Y+17, r18	; 0x11
    2080:	1b 8b       	std	Y+19, r17	; 0x13
    2082:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    2084:	8c 85       	ldd	r24, Y+12	; 0x0c
    2086:	9d 85       	ldd	r25, Y+13	; 0x0d
    2088:	9e 83       	std	Y+6, r25	; 0x06
    208a:	8d 83       	std	Y+5, r24	; 0x05
EventBits_t uxReturn, uxControlBits = 0;
    208c:	1c 82       	std	Y+4, r1	; 0x04
    208e:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2090:	1f 82       	std	Y+7, r1	; 0x07
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2092:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2096:	8d 81       	ldd	r24, Y+5	; 0x05
    2098:	9e 81       	ldd	r25, Y+6	; 0x06
    209a:	fc 01       	movw	r30, r24
    209c:	80 81       	ld	r24, Z
    209e:	91 81       	ldd	r25, Z+1	; 0x01
    20a0:	99 87       	std	Y+9, r25	; 0x09
    20a2:	88 87       	std	Y+8, r24	; 0x08

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    20a4:	2e 85       	ldd	r18, Y+14	; 0x0e
    20a6:	3f 85       	ldd	r19, Y+15	; 0x0f
    20a8:	88 85       	ldd	r24, Y+8	; 0x08
    20aa:	99 85       	ldd	r25, Y+9	; 0x09
    20ac:	49 89       	ldd	r20, Y+17	; 0x11
    20ae:	b9 01       	movw	r22, r18
    20b0:	0e 94 80 12 	call	0x2500	; 0x2500 <prvTestWaitCondition>
    20b4:	8a 87       	std	Y+10, r24	; 0x0a

		if( xWaitConditionMet != pdFALSE )
    20b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    20b8:	88 23       	and	r24, r24
    20ba:	d1 f0       	breq	.+52     	; 0x20f0 <xEventGroupWaitBits+0x94>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    20bc:	88 85       	ldd	r24, Y+8	; 0x08
    20be:	99 85       	ldd	r25, Y+9	; 0x09
    20c0:	9a 83       	std	Y+2, r25	; 0x02
    20c2:	89 83       	std	Y+1, r24	; 0x01
			xTicksToWait = ( TickType_t ) 0;
    20c4:	1b 8a       	std	Y+19, r1	; 0x13
    20c6:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    20c8:	88 89       	ldd	r24, Y+16	; 0x10
    20ca:	88 23       	and	r24, r24
    20cc:	e1 f1       	breq	.+120    	; 0x2146 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    20ce:	8d 81       	ldd	r24, Y+5	; 0x05
    20d0:	9e 81       	ldd	r25, Y+6	; 0x06
    20d2:	fc 01       	movw	r30, r24
    20d4:	20 81       	ld	r18, Z
    20d6:	31 81       	ldd	r19, Z+1	; 0x01
    20d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    20da:	9f 85       	ldd	r25, Y+15	; 0x0f
    20dc:	80 95       	com	r24
    20de:	90 95       	com	r25
    20e0:	28 23       	and	r18, r24
    20e2:	39 23       	and	r19, r25
    20e4:	8d 81       	ldd	r24, Y+5	; 0x05
    20e6:	9e 81       	ldd	r25, Y+6	; 0x06
    20e8:	fc 01       	movw	r30, r24
    20ea:	31 83       	std	Z+1, r19	; 0x01
    20ec:	20 83       	st	Z, r18
    20ee:	2b c0       	rjmp	.+86     	; 0x2146 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    20f0:	8a 89       	ldd	r24, Y+18	; 0x12
    20f2:	9b 89       	ldd	r25, Y+19	; 0x13
    20f4:	89 2b       	or	r24, r25
    20f6:	39 f4       	brne	.+14     	; 0x2106 <xEventGroupWaitBits+0xaa>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    20f8:	88 85       	ldd	r24, Y+8	; 0x08
    20fa:	99 85       	ldd	r25, Y+9	; 0x09
    20fc:	9a 83       	std	Y+2, r25	; 0x02
    20fe:	89 83       	std	Y+1, r24	; 0x01
			xTimeoutOccurred = pdTRUE;
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	8f 83       	std	Y+7, r24	; 0x07
    2104:	20 c0       	rjmp	.+64     	; 0x2146 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2106:	88 89       	ldd	r24, Y+16	; 0x10
    2108:	88 23       	and	r24, r24
    210a:	29 f0       	breq	.+10     	; 0x2116 <xEventGroupWaitBits+0xba>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    210c:	8b 81       	ldd	r24, Y+3	; 0x03
    210e:	9c 81       	ldd	r25, Y+4	; 0x04
    2110:	91 60       	ori	r25, 0x01	; 1
    2112:	9c 83       	std	Y+4, r25	; 0x04
    2114:	8b 83       	std	Y+3, r24	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2116:	89 89       	ldd	r24, Y+17	; 0x11
    2118:	88 23       	and	r24, r24
    211a:	29 f0       	breq	.+10     	; 0x2126 <xEventGroupWaitBits+0xca>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    211c:	8b 81       	ldd	r24, Y+3	; 0x03
    211e:	9c 81       	ldd	r25, Y+4	; 0x04
    2120:	94 60       	ori	r25, 0x04	; 4
    2122:	9c 83       	std	Y+4, r25	; 0x04
    2124:	8b 83       	std	Y+3, r24	; 0x03
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2126:	2e 85       	ldd	r18, Y+14	; 0x0e
    2128:	3f 85       	ldd	r19, Y+15	; 0x0f
    212a:	8b 81       	ldd	r24, Y+3	; 0x03
    212c:	9c 81       	ldd	r25, Y+4	; 0x04
    212e:	28 2b       	or	r18, r24
    2130:	39 2b       	or	r19, r25
    2132:	8d 81       	ldd	r24, Y+5	; 0x05
    2134:	9e 81       	ldd	r25, Y+6	; 0x06
    2136:	02 96       	adiw	r24, 0x02	; 2
    2138:	4a 89       	ldd	r20, Y+18	; 0x12
    213a:	5b 89       	ldd	r21, Y+19	; 0x13
    213c:	b9 01       	movw	r22, r18
    213e:	0e 94 41 27 	call	0x4e82	; 0x4e82 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2142:	1a 82       	std	Y+2, r1	; 0x02
    2144:	19 82       	std	Y+1, r1	; 0x01

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2146:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    214a:	8b 87       	std	Y+11, r24	; 0x0b

	if( xTicksToWait != ( TickType_t ) 0 )
    214c:	8a 89       	ldd	r24, Y+18	; 0x12
    214e:	9b 89       	ldd	r25, Y+19	; 0x13
    2150:	89 2b       	or	r24, r25
    2152:	09 f4       	brne	.+2      	; 0x2156 <xEventGroupWaitBits+0xfa>
    2154:	3f c0       	rjmp	.+126    	; 0x21d4 <xEventGroupWaitBits+0x178>
	{
		if( xAlreadyYielded == pdFALSE )
    2156:	8b 85       	ldd	r24, Y+11	; 0x0b
    2158:	88 23       	and	r24, r24
    215a:	11 f4       	brne	.+4      	; 0x2160 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    215c:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2160:	0e 94 a4 2b 	call	0x5748	; 0x5748 <uxTaskResetEventItemValue>
    2164:	9a 83       	std	Y+2, r25	; 0x02
    2166:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2168:	89 81       	ldd	r24, Y+1	; 0x01
    216a:	9a 81       	ldd	r25, Y+2	; 0x02
    216c:	88 27       	eor	r24, r24
    216e:	92 70       	andi	r25, 0x02	; 2
    2170:	89 2b       	or	r24, r25
    2172:	59 f5       	brne	.+86     	; 0x21ca <xEventGroupWaitBits+0x16e>
		{
			taskENTER_CRITICAL();
    2174:	0f b6       	in	r0, 0x3f	; 63
    2176:	f8 94       	cli
    2178:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    217a:	8d 81       	ldd	r24, Y+5	; 0x05
    217c:	9e 81       	ldd	r25, Y+6	; 0x06
    217e:	fc 01       	movw	r30, r24
    2180:	80 81       	ld	r24, Z
    2182:	91 81       	ldd	r25, Z+1	; 0x01
    2184:	9a 83       	std	Y+2, r25	; 0x02
    2186:	89 83       	std	Y+1, r24	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2188:	2e 85       	ldd	r18, Y+14	; 0x0e
    218a:	3f 85       	ldd	r19, Y+15	; 0x0f
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	9a 81       	ldd	r25, Y+2	; 0x02
    2190:	49 89       	ldd	r20, Y+17	; 0x11
    2192:	b9 01       	movw	r22, r18
    2194:	0e 94 80 12 	call	0x2500	; 0x2500 <prvTestWaitCondition>
    2198:	88 23       	and	r24, r24
    219a:	99 f0       	breq	.+38     	; 0x21c2 <xEventGroupWaitBits+0x166>
				{
					if( xClearOnExit != pdFALSE )
    219c:	88 89       	ldd	r24, Y+16	; 0x10
    219e:	88 23       	and	r24, r24
    21a0:	81 f0       	breq	.+32     	; 0x21c2 <xEventGroupWaitBits+0x166>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    21a2:	8d 81       	ldd	r24, Y+5	; 0x05
    21a4:	9e 81       	ldd	r25, Y+6	; 0x06
    21a6:	fc 01       	movw	r30, r24
    21a8:	20 81       	ld	r18, Z
    21aa:	31 81       	ldd	r19, Z+1	; 0x01
    21ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    21ae:	9f 85       	ldd	r25, Y+15	; 0x0f
    21b0:	80 95       	com	r24
    21b2:	90 95       	com	r25
    21b4:	28 23       	and	r18, r24
    21b6:	39 23       	and	r19, r25
    21b8:	8d 81       	ldd	r24, Y+5	; 0x05
    21ba:	9e 81       	ldd	r25, Y+6	; 0x06
    21bc:	fc 01       	movw	r30, r24
    21be:	31 83       	std	Z+1, r19	; 0x01
    21c0:	20 83       	st	Z, r18
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    21c2:	81 e0       	ldi	r24, 0x01	; 1
    21c4:	8f 83       	std	Y+7, r24	; 0x07
			}
			taskEXIT_CRITICAL();
    21c6:	0f 90       	pop	r0
    21c8:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    21ca:	89 81       	ldd	r24, Y+1	; 0x01
    21cc:	9a 81       	ldd	r25, Y+2	; 0x02
    21ce:	99 27       	eor	r25, r25
    21d0:	9a 83       	std	Y+2, r25	; 0x02
    21d2:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    21d4:	89 81       	ldd	r24, Y+1	; 0x01
    21d6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    21d8:	63 96       	adiw	r28, 0x13	; 19
    21da:	0f b6       	in	r0, 0x3f	; 63
    21dc:	f8 94       	cli
    21de:	de bf       	out	0x3e, r29	; 62
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	cd bf       	out	0x3d, r28	; 61
    21e4:	df 91       	pop	r29
    21e6:	cf 91       	pop	r28
    21e8:	1f 91       	pop	r17
    21ea:	0f 91       	pop	r16
    21ec:	08 95       	ret

000021ee <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    21ee:	cf 93       	push	r28
    21f0:	df 93       	push	r29
    21f2:	cd b7       	in	r28, 0x3d	; 61
    21f4:	de b7       	in	r29, 0x3e	; 62
    21f6:	28 97       	sbiw	r28, 0x08	; 8
    21f8:	0f b6       	in	r0, 0x3f	; 63
    21fa:	f8 94       	cli
    21fc:	de bf       	out	0x3e, r29	; 62
    21fe:	0f be       	out	0x3f, r0	; 63
    2200:	cd bf       	out	0x3d, r28	; 61
    2202:	9e 83       	std	Y+6, r25	; 0x06
    2204:	8d 83       	std	Y+5, r24	; 0x05
    2206:	78 87       	std	Y+8, r23	; 0x08
    2208:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    220a:	8d 81       	ldd	r24, Y+5	; 0x05
    220c:	9e 81       	ldd	r25, Y+6	; 0x06
    220e:	9a 83       	std	Y+2, r25	; 0x02
    2210:	89 83       	std	Y+1, r24	; 0x01
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2212:	0f b6       	in	r0, 0x3f	; 63
    2214:	f8 94       	cli
    2216:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2218:	89 81       	ldd	r24, Y+1	; 0x01
    221a:	9a 81       	ldd	r25, Y+2	; 0x02
    221c:	fc 01       	movw	r30, r24
    221e:	80 81       	ld	r24, Z
    2220:	91 81       	ldd	r25, Z+1	; 0x01
    2222:	9c 83       	std	Y+4, r25	; 0x04
    2224:	8b 83       	std	Y+3, r24	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2226:	89 81       	ldd	r24, Y+1	; 0x01
    2228:	9a 81       	ldd	r25, Y+2	; 0x02
    222a:	fc 01       	movw	r30, r24
    222c:	20 81       	ld	r18, Z
    222e:	31 81       	ldd	r19, Z+1	; 0x01
    2230:	8f 81       	ldd	r24, Y+7	; 0x07
    2232:	98 85       	ldd	r25, Y+8	; 0x08
    2234:	80 95       	com	r24
    2236:	90 95       	com	r25
    2238:	28 23       	and	r18, r24
    223a:	39 23       	and	r19, r25
    223c:	89 81       	ldd	r24, Y+1	; 0x01
    223e:	9a 81       	ldd	r25, Y+2	; 0x02
    2240:	fc 01       	movw	r30, r24
    2242:	31 83       	std	Z+1, r19	; 0x01
    2244:	20 83       	st	Z, r18
	}
	taskEXIT_CRITICAL();
    2246:	0f 90       	pop	r0
    2248:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    224a:	8b 81       	ldd	r24, Y+3	; 0x03
    224c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    224e:	28 96       	adiw	r28, 0x08	; 8
    2250:	0f b6       	in	r0, 0x3f	; 63
    2252:	f8 94       	cli
    2254:	de bf       	out	0x3e, r29	; 62
    2256:	0f be       	out	0x3f, r0	; 63
    2258:	cd bf       	out	0x3d, r28	; 61
    225a:	df 91       	pop	r29
    225c:	cf 91       	pop	r28
    225e:	08 95       	ret

00002260 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2260:	cf 93       	push	r28
    2262:	df 93       	push	r29
    2264:	cd b7       	in	r28, 0x3d	; 61
    2266:	de b7       	in	r29, 0x3e	; 62
    2268:	27 97       	sbiw	r28, 0x07	; 7
    226a:	0f b6       	in	r0, 0x3f	; 63
    226c:	f8 94       	cli
    226e:	de bf       	out	0x3e, r29	; 62
    2270:	0f be       	out	0x3f, r0	; 63
    2272:	cd bf       	out	0x3d, r28	; 61
    2274:	9f 83       	std	Y+7, r25	; 0x07
    2276:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    2278:	8e 81       	ldd	r24, Y+6	; 0x06
    227a:	9f 81       	ldd	r25, Y+7	; 0x07
    227c:	9a 83       	std	Y+2, r25	; 0x02
    227e:	89 83       	std	Y+1, r24	; 0x01
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2280:	1b 82       	std	Y+3, r1	; 0x03
	{
		uxReturn = pxEventBits->uxEventBits;
    2282:	89 81       	ldd	r24, Y+1	; 0x01
    2284:	9a 81       	ldd	r25, Y+2	; 0x02
    2286:	fc 01       	movw	r30, r24
    2288:	80 81       	ld	r24, Z
    228a:	91 81       	ldd	r25, Z+1	; 0x01
    228c:	9d 83       	std	Y+5, r25	; 0x05
    228e:	8c 83       	std	Y+4, r24	; 0x04
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2290:	8c 81       	ldd	r24, Y+4	; 0x04
    2292:	9d 81       	ldd	r25, Y+5	; 0x05
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2294:	27 96       	adiw	r28, 0x07	; 7
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	f8 94       	cli
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	cd bf       	out	0x3d, r28	; 61
    22a0:	df 91       	pop	r29
    22a2:	cf 91       	pop	r28
    22a4:	08 95       	ret

000022a6 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    22a6:	cf 93       	push	r28
    22a8:	df 93       	push	r29
    22aa:	cd b7       	in	r28, 0x3d	; 61
    22ac:	de b7       	in	r29, 0x3e	; 62
    22ae:	65 97       	sbiw	r28, 0x15	; 21
    22b0:	0f b6       	in	r0, 0x3f	; 63
    22b2:	f8 94       	cli
    22b4:	de bf       	out	0x3e, r29	; 62
    22b6:	0f be       	out	0x3f, r0	; 63
    22b8:	cd bf       	out	0x3d, r28	; 61
    22ba:	9b 8b       	std	Y+19, r25	; 0x13
    22bc:	8a 8b       	std	Y+18, r24	; 0x12
    22be:	7d 8b       	std	Y+21, r23	; 0x15
    22c0:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    22c2:	1c 82       	std	Y+4, r1	; 0x04
    22c4:	1b 82       	std	Y+3, r1	; 0x03
EventGroup_t *pxEventBits = xEventGroup;
    22c6:	8a 89       	ldd	r24, Y+18	; 0x12
    22c8:	9b 89       	ldd	r25, Y+19	; 0x13
    22ca:	9f 83       	std	Y+7, r25	; 0x07
    22cc:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xMatchFound = pdFALSE;
    22ce:	1d 82       	std	Y+5, r1	; 0x05
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    22d0:	8e 81       	ldd	r24, Y+6	; 0x06
    22d2:	9f 81       	ldd	r25, Y+7	; 0x07
    22d4:	02 96       	adiw	r24, 0x02	; 2
    22d6:	99 87       	std	Y+9, r25	; 0x09
    22d8:	88 87       	std	Y+8, r24	; 0x08
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    22da:	88 85       	ldd	r24, Y+8	; 0x08
    22dc:	99 85       	ldd	r25, Y+9	; 0x09
    22de:	03 96       	adiw	r24, 0x03	; 3
    22e0:	9b 87       	std	Y+11, r25	; 0x0b
    22e2:	8a 87       	std	Y+10, r24	; 0x0a
	vTaskSuspendAll();
    22e4:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    22e8:	88 85       	ldd	r24, Y+8	; 0x08
    22ea:	99 85       	ldd	r25, Y+9	; 0x09
    22ec:	fc 01       	movw	r30, r24
    22ee:	85 81       	ldd	r24, Z+5	; 0x05
    22f0:	96 81       	ldd	r25, Z+6	; 0x06
    22f2:	9a 83       	std	Y+2, r25	; 0x02
    22f4:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    22f6:	8e 81       	ldd	r24, Y+6	; 0x06
    22f8:	9f 81       	ldd	r25, Y+7	; 0x07
    22fa:	fc 01       	movw	r30, r24
    22fc:	20 81       	ld	r18, Z
    22fe:	31 81       	ldd	r19, Z+1	; 0x01
    2300:	8c 89       	ldd	r24, Y+20	; 0x14
    2302:	9d 89       	ldd	r25, Y+21	; 0x15
    2304:	28 2b       	or	r18, r24
    2306:	39 2b       	or	r19, r25
    2308:	8e 81       	ldd	r24, Y+6	; 0x06
    230a:	9f 81       	ldd	r25, Y+7	; 0x07
    230c:	fc 01       	movw	r30, r24
    230e:	31 83       	std	Z+1, r19	; 0x01
    2310:	20 83       	st	Z, r18

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2312:	5e c0       	rjmp	.+188    	; 0x23d0 <xEventGroupSetBits+0x12a>
		{
			pxNext = listGET_NEXT( pxListItem );
    2314:	89 81       	ldd	r24, Y+1	; 0x01
    2316:	9a 81       	ldd	r25, Y+2	; 0x02
    2318:	fc 01       	movw	r30, r24
    231a:	82 81       	ldd	r24, Z+2	; 0x02
    231c:	93 81       	ldd	r25, Z+3	; 0x03
    231e:	9d 87       	std	Y+13, r25	; 0x0d
    2320:	8c 87       	std	Y+12, r24	; 0x0c
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2322:	89 81       	ldd	r24, Y+1	; 0x01
    2324:	9a 81       	ldd	r25, Y+2	; 0x02
    2326:	fc 01       	movw	r30, r24
    2328:	80 81       	ld	r24, Z
    232a:	91 81       	ldd	r25, Z+1	; 0x01
    232c:	9f 87       	std	Y+15, r25	; 0x0f
    232e:	8e 87       	std	Y+14, r24	; 0x0e
			xMatchFound = pdFALSE;
    2330:	1d 82       	std	Y+5, r1	; 0x05

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2332:	8e 85       	ldd	r24, Y+14	; 0x0e
    2334:	9f 85       	ldd	r25, Y+15	; 0x0f
    2336:	88 27       	eor	r24, r24
    2338:	99 8b       	std	Y+17, r25	; 0x11
    233a:	88 8b       	std	Y+16, r24	; 0x10
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    233c:	8e 85       	ldd	r24, Y+14	; 0x0e
    233e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2340:	99 27       	eor	r25, r25
    2342:	9f 87       	std	Y+15, r25	; 0x0f
    2344:	8e 87       	std	Y+14, r24	; 0x0e

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2346:	88 89       	ldd	r24, Y+16	; 0x10
    2348:	99 89       	ldd	r25, Y+17	; 0x11
    234a:	88 27       	eor	r24, r24
    234c:	94 70       	andi	r25, 0x04	; 4
    234e:	89 2b       	or	r24, r25
    2350:	71 f4       	brne	.+28     	; 0x236e <xEventGroupSetBits+0xc8>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2352:	8e 81       	ldd	r24, Y+6	; 0x06
    2354:	9f 81       	ldd	r25, Y+7	; 0x07
    2356:	fc 01       	movw	r30, r24
    2358:	20 81       	ld	r18, Z
    235a:	31 81       	ldd	r19, Z+1	; 0x01
    235c:	8e 85       	ldd	r24, Y+14	; 0x0e
    235e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2360:	82 23       	and	r24, r18
    2362:	93 23       	and	r25, r19
    2364:	89 2b       	or	r24, r25
    2366:	99 f0       	breq	.+38     	; 0x238e <xEventGroupSetBits+0xe8>
				{
					xMatchFound = pdTRUE;
    2368:	81 e0       	ldi	r24, 0x01	; 1
    236a:	8d 83       	std	Y+5, r24	; 0x05
    236c:	10 c0       	rjmp	.+32     	; 0x238e <xEventGroupSetBits+0xe8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    236e:	8e 81       	ldd	r24, Y+6	; 0x06
    2370:	9f 81       	ldd	r25, Y+7	; 0x07
    2372:	fc 01       	movw	r30, r24
    2374:	20 81       	ld	r18, Z
    2376:	31 81       	ldd	r19, Z+1	; 0x01
    2378:	8e 85       	ldd	r24, Y+14	; 0x0e
    237a:	9f 85       	ldd	r25, Y+15	; 0x0f
    237c:	28 23       	and	r18, r24
    237e:	39 23       	and	r19, r25
    2380:	8e 85       	ldd	r24, Y+14	; 0x0e
    2382:	9f 85       	ldd	r25, Y+15	; 0x0f
    2384:	28 17       	cp	r18, r24
    2386:	39 07       	cpc	r19, r25
    2388:	11 f4       	brne	.+4      	; 0x238e <xEventGroupSetBits+0xe8>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    238a:	81 e0       	ldi	r24, 0x01	; 1
    238c:	8d 83       	std	Y+5, r24	; 0x05
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    238e:	8d 81       	ldd	r24, Y+5	; 0x05
    2390:	88 23       	and	r24, r24
    2392:	d1 f0       	breq	.+52     	; 0x23c8 <xEventGroupSetBits+0x122>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2394:	88 89       	ldd	r24, Y+16	; 0x10
    2396:	99 89       	ldd	r25, Y+17	; 0x11
    2398:	88 27       	eor	r24, r24
    239a:	91 70       	andi	r25, 0x01	; 1
    239c:	89 2b       	or	r24, r25
    239e:	41 f0       	breq	.+16     	; 0x23b0 <xEventGroupSetBits+0x10a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    23a0:	2b 81       	ldd	r18, Y+3	; 0x03
    23a2:	3c 81       	ldd	r19, Y+4	; 0x04
    23a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    23a6:	9f 85       	ldd	r25, Y+15	; 0x0f
    23a8:	82 2b       	or	r24, r18
    23aa:	93 2b       	or	r25, r19
    23ac:	9c 83       	std	Y+4, r25	; 0x04
    23ae:	8b 83       	std	Y+3, r24	; 0x03
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    23b0:	8e 81       	ldd	r24, Y+6	; 0x06
    23b2:	9f 81       	ldd	r25, Y+7	; 0x07
    23b4:	fc 01       	movw	r30, r24
    23b6:	80 81       	ld	r24, Z
    23b8:	91 81       	ldd	r25, Z+1	; 0x01
    23ba:	9c 01       	movw	r18, r24
    23bc:	32 60       	ori	r19, 0x02	; 2
    23be:	89 81       	ldd	r24, Y+1	; 0x01
    23c0:	9a 81       	ldd	r25, Y+2	; 0x02
    23c2:	b9 01       	movw	r22, r18
    23c4:	0e 94 e0 27 	call	0x4fc0	; 0x4fc0 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    23c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    23ca:	9d 85       	ldd	r25, Y+13	; 0x0d
    23cc:	9a 83       	std	Y+2, r25	; 0x02
    23ce:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    23d0:	29 81       	ldd	r18, Y+1	; 0x01
    23d2:	3a 81       	ldd	r19, Y+2	; 0x02
    23d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    23d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    23d8:	28 17       	cp	r18, r24
    23da:	39 07       	cpc	r19, r25
    23dc:	09 f0       	breq	.+2      	; 0x23e0 <xEventGroupSetBits+0x13a>
    23de:	9a cf       	rjmp	.-204    	; 0x2314 <xEventGroupSetBits+0x6e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    23e0:	8e 81       	ldd	r24, Y+6	; 0x06
    23e2:	9f 81       	ldd	r25, Y+7	; 0x07
    23e4:	fc 01       	movw	r30, r24
    23e6:	20 81       	ld	r18, Z
    23e8:	31 81       	ldd	r19, Z+1	; 0x01
    23ea:	8b 81       	ldd	r24, Y+3	; 0x03
    23ec:	9c 81       	ldd	r25, Y+4	; 0x04
    23ee:	80 95       	com	r24
    23f0:	90 95       	com	r25
    23f2:	28 23       	and	r18, r24
    23f4:	39 23       	and	r19, r25
    23f6:	8e 81       	ldd	r24, Y+6	; 0x06
    23f8:	9f 81       	ldd	r25, Y+7	; 0x07
    23fa:	fc 01       	movw	r30, r24
    23fc:	31 83       	std	Z+1, r19	; 0x01
    23fe:	20 83       	st	Z, r18
	}
	( void ) xTaskResumeAll();
    2400:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    2404:	8e 81       	ldd	r24, Y+6	; 0x06
    2406:	9f 81       	ldd	r25, Y+7	; 0x07
    2408:	fc 01       	movw	r30, r24
    240a:	80 81       	ld	r24, Z
    240c:	91 81       	ldd	r25, Z+1	; 0x01
}
    240e:	65 96       	adiw	r28, 0x15	; 21
    2410:	0f b6       	in	r0, 0x3f	; 63
    2412:	f8 94       	cli
    2414:	de bf       	out	0x3e, r29	; 62
    2416:	0f be       	out	0x3f, r0	; 63
    2418:	cd bf       	out	0x3d, r28	; 61
    241a:	df 91       	pop	r29
    241c:	cf 91       	pop	r28
    241e:	08 95       	ret

00002420 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2420:	cf 93       	push	r28
    2422:	df 93       	push	r29
    2424:	00 d0       	rcall	.+0      	; 0x2426 <vEventGroupDelete+0x6>
    2426:	00 d0       	rcall	.+0      	; 0x2428 <vEventGroupDelete+0x8>
    2428:	00 d0       	rcall	.+0      	; 0x242a <vEventGroupDelete+0xa>
    242a:	cd b7       	in	r28, 0x3d	; 61
    242c:	de b7       	in	r29, 0x3e	; 62
    242e:	9e 83       	std	Y+6, r25	; 0x06
    2430:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    2432:	8d 81       	ldd	r24, Y+5	; 0x05
    2434:	9e 81       	ldd	r25, Y+6	; 0x06
    2436:	9a 83       	std	Y+2, r25	; 0x02
    2438:	89 83       	std	Y+1, r24	; 0x01
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    243a:	89 81       	ldd	r24, Y+1	; 0x01
    243c:	9a 81       	ldd	r25, Y+2	; 0x02
    243e:	02 96       	adiw	r24, 0x02	; 2
    2440:	9c 83       	std	Y+4, r25	; 0x04
    2442:	8b 83       	std	Y+3, r24	; 0x03

	vTaskSuspendAll();
    2444:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2448:	09 c0       	rjmp	.+18     	; 0x245c <vEventGroupDelete+0x3c>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	fc 01       	movw	r30, r24
    2450:	85 81       	ldd	r24, Z+5	; 0x05
    2452:	96 81       	ldd	r25, Z+6	; 0x06
    2454:	60 e0       	ldi	r22, 0x00	; 0
    2456:	72 e0       	ldi	r23, 0x02	; 2
    2458:	0e 94 e0 27 	call	0x4fc0	; 0x4fc0 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    245c:	8b 81       	ldd	r24, Y+3	; 0x03
    245e:	9c 81       	ldd	r25, Y+4	; 0x04
    2460:	fc 01       	movw	r30, r24
    2462:	80 81       	ld	r24, Z
    2464:	88 23       	and	r24, r24
    2466:	89 f7       	brne	.-30     	; 0x244a <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    2468:	89 81       	ldd	r24, Y+1	; 0x01
    246a:	9a 81       	ldd	r25, Y+2	; 0x02
    246c:	0e 94 07 13 	call	0x260e	; 0x260e <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    2470:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
}
    2474:	00 00       	nop
    2476:	26 96       	adiw	r28, 0x06	; 6
    2478:	0f b6       	in	r0, 0x3f	; 63
    247a:	f8 94       	cli
    247c:	de bf       	out	0x3e, r29	; 62
    247e:	0f be       	out	0x3f, r0	; 63
    2480:	cd bf       	out	0x3d, r28	; 61
    2482:	df 91       	pop	r29
    2484:	cf 91       	pop	r28
    2486:	08 95       	ret

00002488 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    2488:	cf 93       	push	r28
    248a:	df 93       	push	r29
    248c:	00 d0       	rcall	.+0      	; 0x248e <vEventGroupSetBitsCallback+0x6>
    248e:	00 d0       	rcall	.+0      	; 0x2490 <vEventGroupSetBitsCallback+0x8>
    2490:	00 d0       	rcall	.+0      	; 0x2492 <vEventGroupSetBitsCallback+0xa>
    2492:	cd b7       	in	r28, 0x3d	; 61
    2494:	de b7       	in	r29, 0x3e	; 62
    2496:	9a 83       	std	Y+2, r25	; 0x02
    2498:	89 83       	std	Y+1, r24	; 0x01
    249a:	4b 83       	std	Y+3, r20	; 0x03
    249c:	5c 83       	std	Y+4, r21	; 0x04
    249e:	6d 83       	std	Y+5, r22	; 0x05
    24a0:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    24a2:	2b 81       	ldd	r18, Y+3	; 0x03
    24a4:	3c 81       	ldd	r19, Y+4	; 0x04
    24a6:	89 81       	ldd	r24, Y+1	; 0x01
    24a8:	9a 81       	ldd	r25, Y+2	; 0x02
    24aa:	b9 01       	movw	r22, r18
    24ac:	0e 94 53 11 	call	0x22a6	; 0x22a6 <xEventGroupSetBits>
}
    24b0:	00 00       	nop
    24b2:	26 96       	adiw	r28, 0x06	; 6
    24b4:	0f b6       	in	r0, 0x3f	; 63
    24b6:	f8 94       	cli
    24b8:	de bf       	out	0x3e, r29	; 62
    24ba:	0f be       	out	0x3f, r0	; 63
    24bc:	cd bf       	out	0x3d, r28	; 61
    24be:	df 91       	pop	r29
    24c0:	cf 91       	pop	r28
    24c2:	08 95       	ret

000024c4 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    24c4:	cf 93       	push	r28
    24c6:	df 93       	push	r29
    24c8:	00 d0       	rcall	.+0      	; 0x24ca <vEventGroupClearBitsCallback+0x6>
    24ca:	00 d0       	rcall	.+0      	; 0x24cc <vEventGroupClearBitsCallback+0x8>
    24cc:	00 d0       	rcall	.+0      	; 0x24ce <vEventGroupClearBitsCallback+0xa>
    24ce:	cd b7       	in	r28, 0x3d	; 61
    24d0:	de b7       	in	r29, 0x3e	; 62
    24d2:	9a 83       	std	Y+2, r25	; 0x02
    24d4:	89 83       	std	Y+1, r24	; 0x01
    24d6:	4b 83       	std	Y+3, r20	; 0x03
    24d8:	5c 83       	std	Y+4, r21	; 0x04
    24da:	6d 83       	std	Y+5, r22	; 0x05
    24dc:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    24de:	2b 81       	ldd	r18, Y+3	; 0x03
    24e0:	3c 81       	ldd	r19, Y+4	; 0x04
    24e2:	89 81       	ldd	r24, Y+1	; 0x01
    24e4:	9a 81       	ldd	r25, Y+2	; 0x02
    24e6:	b9 01       	movw	r22, r18
    24e8:	0e 94 f7 10 	call	0x21ee	; 0x21ee <xEventGroupClearBits>
}
    24ec:	00 00       	nop
    24ee:	26 96       	adiw	r28, 0x06	; 6
    24f0:	0f b6       	in	r0, 0x3f	; 63
    24f2:	f8 94       	cli
    24f4:	de bf       	out	0x3e, r29	; 62
    24f6:	0f be       	out	0x3f, r0	; 63
    24f8:	cd bf       	out	0x3d, r28	; 61
    24fa:	df 91       	pop	r29
    24fc:	cf 91       	pop	r28
    24fe:	08 95       	ret

00002500 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    2500:	cf 93       	push	r28
    2502:	df 93       	push	r29
    2504:	00 d0       	rcall	.+0      	; 0x2506 <prvTestWaitCondition+0x6>
    2506:	00 d0       	rcall	.+0      	; 0x2508 <prvTestWaitCondition+0x8>
    2508:	00 d0       	rcall	.+0      	; 0x250a <prvTestWaitCondition+0xa>
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	9b 83       	std	Y+3, r25	; 0x03
    2510:	8a 83       	std	Y+2, r24	; 0x02
    2512:	7d 83       	std	Y+5, r23	; 0x05
    2514:	6c 83       	std	Y+4, r22	; 0x04
    2516:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    2518:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    251a:	8e 81       	ldd	r24, Y+6	; 0x06
    251c:	88 23       	and	r24, r24
    251e:	59 f4       	brne	.+22     	; 0x2536 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2520:	2a 81       	ldd	r18, Y+2	; 0x02
    2522:	3b 81       	ldd	r19, Y+3	; 0x03
    2524:	8c 81       	ldd	r24, Y+4	; 0x04
    2526:	9d 81       	ldd	r25, Y+5	; 0x05
    2528:	82 23       	and	r24, r18
    252a:	93 23       	and	r25, r19
    252c:	89 2b       	or	r24, r25
    252e:	81 f0       	breq	.+32     	; 0x2550 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    2530:	81 e0       	ldi	r24, 0x01	; 1
    2532:	89 83       	std	Y+1, r24	; 0x01
    2534:	0d c0       	rjmp	.+26     	; 0x2550 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2536:	2a 81       	ldd	r18, Y+2	; 0x02
    2538:	3b 81       	ldd	r19, Y+3	; 0x03
    253a:	8c 81       	ldd	r24, Y+4	; 0x04
    253c:	9d 81       	ldd	r25, Y+5	; 0x05
    253e:	28 23       	and	r18, r24
    2540:	39 23       	and	r19, r25
    2542:	8c 81       	ldd	r24, Y+4	; 0x04
    2544:	9d 81       	ldd	r25, Y+5	; 0x05
    2546:	28 17       	cp	r18, r24
    2548:	39 07       	cpc	r19, r25
    254a:	11 f4       	brne	.+4      	; 0x2550 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    254c:	81 e0       	ldi	r24, 0x01	; 1
    254e:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    2550:	89 81       	ldd	r24, Y+1	; 0x01
}
    2552:	26 96       	adiw	r28, 0x06	; 6
    2554:	0f b6       	in	r0, 0x3f	; 63
    2556:	f8 94       	cli
    2558:	de bf       	out	0x3e, r29	; 62
    255a:	0f be       	out	0x3f, r0	; 63
    255c:	cd bf       	out	0x3d, r28	; 61
    255e:	df 91       	pop	r29
    2560:	cf 91       	pop	r28
    2562:	08 95       	ret

00002564 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2564:	cf 93       	push	r28
    2566:	df 93       	push	r29
    2568:	00 d0       	rcall	.+0      	; 0x256a <pvPortMalloc+0x6>
    256a:	00 d0       	rcall	.+0      	; 0x256c <pvPortMalloc+0x8>
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
    2570:	9c 83       	std	Y+4, r25	; 0x04
    2572:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2574:	1a 82       	std	Y+2, r1	; 0x02
    2576:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2578:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    257c:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <pucAlignedHeap.2085>
    2580:	90 91 8c 06 	lds	r25, 0x068C	; 0x80068c <pucAlignedHeap.2085+0x1>
    2584:	89 2b       	or	r24, r25
    2586:	31 f4       	brne	.+12     	; 0x2594 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2588:	8e ea       	ldi	r24, 0xAE	; 174
    258a:	90 e0       	ldi	r25, 0x00	; 0
    258c:	90 93 8c 06 	sts	0x068C, r25	; 0x80068c <pucAlignedHeap.2085+0x1>
    2590:	80 93 8b 06 	sts	0x068B, r24	; 0x80068b <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2594:	20 91 89 06 	lds	r18, 0x0689	; 0x800689 <xNextFreeByte>
    2598:	30 91 8a 06 	lds	r19, 0x068A	; 0x80068a <xNextFreeByte+0x1>
    259c:	8b 81       	ldd	r24, Y+3	; 0x03
    259e:	9c 81       	ldd	r25, Y+4	; 0x04
    25a0:	82 0f       	add	r24, r18
    25a2:	93 1f       	adc	r25, r19
    25a4:	8b 3d       	cpi	r24, 0xDB	; 219
    25a6:	95 40       	sbci	r25, 0x05	; 5
    25a8:	38 f5       	brcc	.+78     	; 0x25f8 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    25aa:	20 91 89 06 	lds	r18, 0x0689	; 0x800689 <xNextFreeByte>
    25ae:	30 91 8a 06 	lds	r19, 0x068A	; 0x80068a <xNextFreeByte+0x1>
    25b2:	8b 81       	ldd	r24, Y+3	; 0x03
    25b4:	9c 81       	ldd	r25, Y+4	; 0x04
    25b6:	28 0f       	add	r18, r24
    25b8:	39 1f       	adc	r19, r25
    25ba:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xNextFreeByte>
    25be:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    25c2:	82 17       	cp	r24, r18
    25c4:	93 07       	cpc	r25, r19
    25c6:	c0 f4       	brcc	.+48     	; 0x25f8 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    25c8:	20 91 8b 06 	lds	r18, 0x068B	; 0x80068b <pucAlignedHeap.2085>
    25cc:	30 91 8c 06 	lds	r19, 0x068C	; 0x80068c <pucAlignedHeap.2085+0x1>
    25d0:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xNextFreeByte>
    25d4:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <xNextFreeByte+0x1>
    25d8:	82 0f       	add	r24, r18
    25da:	93 1f       	adc	r25, r19
    25dc:	9a 83       	std	Y+2, r25	; 0x02
    25de:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    25e0:	20 91 89 06 	lds	r18, 0x0689	; 0x800689 <xNextFreeByte>
    25e4:	30 91 8a 06 	lds	r19, 0x068A	; 0x80068a <xNextFreeByte+0x1>
    25e8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ea:	9c 81       	ldd	r25, Y+4	; 0x04
    25ec:	82 0f       	add	r24, r18
    25ee:	93 1f       	adc	r25, r19
    25f0:	90 93 8a 06 	sts	0x068A, r25	; 0x80068a <xNextFreeByte+0x1>
    25f4:	80 93 89 06 	sts	0x0689, r24	; 0x800689 <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    25f8:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    25fc:	89 81       	ldd	r24, Y+1	; 0x01
    25fe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2600:	0f 90       	pop	r0
    2602:	0f 90       	pop	r0
    2604:	0f 90       	pop	r0
    2606:	0f 90       	pop	r0
    2608:	df 91       	pop	r29
    260a:	cf 91       	pop	r28
    260c:	08 95       	ret

0000260e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    260e:	cf 93       	push	r28
    2610:	df 93       	push	r29
    2612:	00 d0       	rcall	.+0      	; 0x2614 <vPortFree+0x6>
    2614:	cd b7       	in	r28, 0x3d	; 61
    2616:	de b7       	in	r29, 0x3e	; 62
    2618:	9a 83       	std	Y+2, r25	; 0x02
    261a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    261c:	00 00       	nop
    261e:	0f 90       	pop	r0
    2620:	0f 90       	pop	r0
    2622:	df 91       	pop	r29
    2624:	cf 91       	pop	r28
    2626:	08 95       	ret

00002628 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2628:	cf 93       	push	r28
    262a:	df 93       	push	r29
    262c:	cd b7       	in	r28, 0x3d	; 61
    262e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2630:	10 92 8a 06 	sts	0x068A, r1	; 0x80068a <xNextFreeByte+0x1>
    2634:	10 92 89 06 	sts	0x0689, r1	; 0x800689 <xNextFreeByte>
}
    2638:	00 00       	nop
    263a:	df 91       	pop	r29
    263c:	cf 91       	pop	r28
    263e:	08 95       	ret

00002640 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2640:	cf 93       	push	r28
    2642:	df 93       	push	r29
    2644:	cd b7       	in	r28, 0x3d	; 61
    2646:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2648:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xNextFreeByte>
    264c:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <xNextFreeByte+0x1>
    2650:	2b ed       	ldi	r18, 0xDB	; 219
    2652:	35 e0       	ldi	r19, 0x05	; 5
    2654:	a9 01       	movw	r20, r18
    2656:	48 1b       	sub	r20, r24
    2658:	59 0b       	sbc	r21, r25
    265a:	ca 01       	movw	r24, r20
}
    265c:	df 91       	pop	r29
    265e:	cf 91       	pop	r28
    2660:	08 95       	ret

00002662 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2662:	cf 93       	push	r28
    2664:	df 93       	push	r29
    2666:	00 d0       	rcall	.+0      	; 0x2668 <vListInitialise+0x6>
    2668:	cd b7       	in	r28, 0x3d	; 61
    266a:	de b7       	in	r29, 0x3e	; 62
    266c:	9a 83       	std	Y+2, r25	; 0x02
    266e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2670:	89 81       	ldd	r24, Y+1	; 0x01
    2672:	9a 81       	ldd	r25, Y+2	; 0x02
    2674:	9c 01       	movw	r18, r24
    2676:	2d 5f       	subi	r18, 0xFD	; 253
    2678:	3f 4f       	sbci	r19, 0xFF	; 255
    267a:	89 81       	ldd	r24, Y+1	; 0x01
    267c:	9a 81       	ldd	r25, Y+2	; 0x02
    267e:	fc 01       	movw	r30, r24
    2680:	32 83       	std	Z+2, r19	; 0x02
    2682:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2684:	89 81       	ldd	r24, Y+1	; 0x01
    2686:	9a 81       	ldd	r25, Y+2	; 0x02
    2688:	2f ef       	ldi	r18, 0xFF	; 255
    268a:	3f ef       	ldi	r19, 0xFF	; 255
    268c:	fc 01       	movw	r30, r24
    268e:	34 83       	std	Z+4, r19	; 0x04
    2690:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2692:	89 81       	ldd	r24, Y+1	; 0x01
    2694:	9a 81       	ldd	r25, Y+2	; 0x02
    2696:	9c 01       	movw	r18, r24
    2698:	2d 5f       	subi	r18, 0xFD	; 253
    269a:	3f 4f       	sbci	r19, 0xFF	; 255
    269c:	89 81       	ldd	r24, Y+1	; 0x01
    269e:	9a 81       	ldd	r25, Y+2	; 0x02
    26a0:	fc 01       	movw	r30, r24
    26a2:	36 83       	std	Z+6, r19	; 0x06
    26a4:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    26a6:	89 81       	ldd	r24, Y+1	; 0x01
    26a8:	9a 81       	ldd	r25, Y+2	; 0x02
    26aa:	9c 01       	movw	r18, r24
    26ac:	2d 5f       	subi	r18, 0xFD	; 253
    26ae:	3f 4f       	sbci	r19, 0xFF	; 255
    26b0:	89 81       	ldd	r24, Y+1	; 0x01
    26b2:	9a 81       	ldd	r25, Y+2	; 0x02
    26b4:	fc 01       	movw	r30, r24
    26b6:	30 87       	std	Z+8, r19	; 0x08
    26b8:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    26ba:	89 81       	ldd	r24, Y+1	; 0x01
    26bc:	9a 81       	ldd	r25, Y+2	; 0x02
    26be:	fc 01       	movw	r30, r24
    26c0:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    26c2:	00 00       	nop
    26c4:	0f 90       	pop	r0
    26c6:	0f 90       	pop	r0
    26c8:	df 91       	pop	r29
    26ca:	cf 91       	pop	r28
    26cc:	08 95       	ret

000026ce <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    26ce:	cf 93       	push	r28
    26d0:	df 93       	push	r29
    26d2:	00 d0       	rcall	.+0      	; 0x26d4 <vListInitialiseItem+0x6>
    26d4:	cd b7       	in	r28, 0x3d	; 61
    26d6:	de b7       	in	r29, 0x3e	; 62
    26d8:	9a 83       	std	Y+2, r25	; 0x02
    26da:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    26dc:	89 81       	ldd	r24, Y+1	; 0x01
    26de:	9a 81       	ldd	r25, Y+2	; 0x02
    26e0:	fc 01       	movw	r30, r24
    26e2:	11 86       	std	Z+9, r1	; 0x09
    26e4:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    26e6:	00 00       	nop
    26e8:	0f 90       	pop	r0
    26ea:	0f 90       	pop	r0
    26ec:	df 91       	pop	r29
    26ee:	cf 91       	pop	r28
    26f0:	08 95       	ret

000026f2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    26f2:	cf 93       	push	r28
    26f4:	df 93       	push	r29
    26f6:	00 d0       	rcall	.+0      	; 0x26f8 <vListInsertEnd+0x6>
    26f8:	00 d0       	rcall	.+0      	; 0x26fa <vListInsertEnd+0x8>
    26fa:	00 d0       	rcall	.+0      	; 0x26fc <vListInsertEnd+0xa>
    26fc:	cd b7       	in	r28, 0x3d	; 61
    26fe:	de b7       	in	r29, 0x3e	; 62
    2700:	9c 83       	std	Y+4, r25	; 0x04
    2702:	8b 83       	std	Y+3, r24	; 0x03
    2704:	7e 83       	std	Y+6, r23	; 0x06
    2706:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2708:	8b 81       	ldd	r24, Y+3	; 0x03
    270a:	9c 81       	ldd	r25, Y+4	; 0x04
    270c:	fc 01       	movw	r30, r24
    270e:	81 81       	ldd	r24, Z+1	; 0x01
    2710:	92 81       	ldd	r25, Z+2	; 0x02
    2712:	9a 83       	std	Y+2, r25	; 0x02
    2714:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2716:	8d 81       	ldd	r24, Y+5	; 0x05
    2718:	9e 81       	ldd	r25, Y+6	; 0x06
    271a:	29 81       	ldd	r18, Y+1	; 0x01
    271c:	3a 81       	ldd	r19, Y+2	; 0x02
    271e:	fc 01       	movw	r30, r24
    2720:	33 83       	std	Z+3, r19	; 0x03
    2722:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2724:	89 81       	ldd	r24, Y+1	; 0x01
    2726:	9a 81       	ldd	r25, Y+2	; 0x02
    2728:	fc 01       	movw	r30, r24
    272a:	24 81       	ldd	r18, Z+4	; 0x04
    272c:	35 81       	ldd	r19, Z+5	; 0x05
    272e:	8d 81       	ldd	r24, Y+5	; 0x05
    2730:	9e 81       	ldd	r25, Y+6	; 0x06
    2732:	fc 01       	movw	r30, r24
    2734:	35 83       	std	Z+5, r19	; 0x05
    2736:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2738:	89 81       	ldd	r24, Y+1	; 0x01
    273a:	9a 81       	ldd	r25, Y+2	; 0x02
    273c:	fc 01       	movw	r30, r24
    273e:	84 81       	ldd	r24, Z+4	; 0x04
    2740:	95 81       	ldd	r25, Z+5	; 0x05
    2742:	2d 81       	ldd	r18, Y+5	; 0x05
    2744:	3e 81       	ldd	r19, Y+6	; 0x06
    2746:	fc 01       	movw	r30, r24
    2748:	33 83       	std	Z+3, r19	; 0x03
    274a:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    274c:	89 81       	ldd	r24, Y+1	; 0x01
    274e:	9a 81       	ldd	r25, Y+2	; 0x02
    2750:	2d 81       	ldd	r18, Y+5	; 0x05
    2752:	3e 81       	ldd	r19, Y+6	; 0x06
    2754:	fc 01       	movw	r30, r24
    2756:	35 83       	std	Z+5, r19	; 0x05
    2758:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    275a:	8d 81       	ldd	r24, Y+5	; 0x05
    275c:	9e 81       	ldd	r25, Y+6	; 0x06
    275e:	2b 81       	ldd	r18, Y+3	; 0x03
    2760:	3c 81       	ldd	r19, Y+4	; 0x04
    2762:	fc 01       	movw	r30, r24
    2764:	31 87       	std	Z+9, r19	; 0x09
    2766:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2768:	8b 81       	ldd	r24, Y+3	; 0x03
    276a:	9c 81       	ldd	r25, Y+4	; 0x04
    276c:	fc 01       	movw	r30, r24
    276e:	80 81       	ld	r24, Z
    2770:	21 e0       	ldi	r18, 0x01	; 1
    2772:	28 0f       	add	r18, r24
    2774:	8b 81       	ldd	r24, Y+3	; 0x03
    2776:	9c 81       	ldd	r25, Y+4	; 0x04
    2778:	fc 01       	movw	r30, r24
    277a:	20 83       	st	Z, r18
}
    277c:	00 00       	nop
    277e:	26 96       	adiw	r28, 0x06	; 6
    2780:	0f b6       	in	r0, 0x3f	; 63
    2782:	f8 94       	cli
    2784:	de bf       	out	0x3e, r29	; 62
    2786:	0f be       	out	0x3f, r0	; 63
    2788:	cd bf       	out	0x3d, r28	; 61
    278a:	df 91       	pop	r29
    278c:	cf 91       	pop	r28
    278e:	08 95       	ret

00002790 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2790:	cf 93       	push	r28
    2792:	df 93       	push	r29
    2794:	cd b7       	in	r28, 0x3d	; 61
    2796:	de b7       	in	r29, 0x3e	; 62
    2798:	28 97       	sbiw	r28, 0x08	; 8
    279a:	0f b6       	in	r0, 0x3f	; 63
    279c:	f8 94       	cli
    279e:	de bf       	out	0x3e, r29	; 62
    27a0:	0f be       	out	0x3f, r0	; 63
    27a2:	cd bf       	out	0x3d, r28	; 61
    27a4:	9e 83       	std	Y+6, r25	; 0x06
    27a6:	8d 83       	std	Y+5, r24	; 0x05
    27a8:	78 87       	std	Y+8, r23	; 0x08
    27aa:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    27ac:	8f 81       	ldd	r24, Y+7	; 0x07
    27ae:	98 85       	ldd	r25, Y+8	; 0x08
    27b0:	fc 01       	movw	r30, r24
    27b2:	80 81       	ld	r24, Z
    27b4:	91 81       	ldd	r25, Z+1	; 0x01
    27b6:	9c 83       	std	Y+4, r25	; 0x04
    27b8:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    27ba:	8b 81       	ldd	r24, Y+3	; 0x03
    27bc:	9c 81       	ldd	r25, Y+4	; 0x04
    27be:	01 96       	adiw	r24, 0x01	; 1
    27c0:	41 f4       	brne	.+16     	; 0x27d2 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    27c2:	8d 81       	ldd	r24, Y+5	; 0x05
    27c4:	9e 81       	ldd	r25, Y+6	; 0x06
    27c6:	fc 01       	movw	r30, r24
    27c8:	87 81       	ldd	r24, Z+7	; 0x07
    27ca:	90 85       	ldd	r25, Z+8	; 0x08
    27cc:	9a 83       	std	Y+2, r25	; 0x02
    27ce:	89 83       	std	Y+1, r24	; 0x01
    27d0:	1a c0       	rjmp	.+52     	; 0x2806 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    27d2:	8d 81       	ldd	r24, Y+5	; 0x05
    27d4:	9e 81       	ldd	r25, Y+6	; 0x06
    27d6:	03 96       	adiw	r24, 0x03	; 3
    27d8:	9a 83       	std	Y+2, r25	; 0x02
    27da:	89 83       	std	Y+1, r24	; 0x01
    27dc:	07 c0       	rjmp	.+14     	; 0x27ec <vListInsert+0x5c>
    27de:	89 81       	ldd	r24, Y+1	; 0x01
    27e0:	9a 81       	ldd	r25, Y+2	; 0x02
    27e2:	fc 01       	movw	r30, r24
    27e4:	82 81       	ldd	r24, Z+2	; 0x02
    27e6:	93 81       	ldd	r25, Z+3	; 0x03
    27e8:	9a 83       	std	Y+2, r25	; 0x02
    27ea:	89 83       	std	Y+1, r24	; 0x01
    27ec:	89 81       	ldd	r24, Y+1	; 0x01
    27ee:	9a 81       	ldd	r25, Y+2	; 0x02
    27f0:	fc 01       	movw	r30, r24
    27f2:	82 81       	ldd	r24, Z+2	; 0x02
    27f4:	93 81       	ldd	r25, Z+3	; 0x03
    27f6:	fc 01       	movw	r30, r24
    27f8:	20 81       	ld	r18, Z
    27fa:	31 81       	ldd	r19, Z+1	; 0x01
    27fc:	8b 81       	ldd	r24, Y+3	; 0x03
    27fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2800:	82 17       	cp	r24, r18
    2802:	93 07       	cpc	r25, r19
    2804:	60 f7       	brcc	.-40     	; 0x27de <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2806:	89 81       	ldd	r24, Y+1	; 0x01
    2808:	9a 81       	ldd	r25, Y+2	; 0x02
    280a:	fc 01       	movw	r30, r24
    280c:	22 81       	ldd	r18, Z+2	; 0x02
    280e:	33 81       	ldd	r19, Z+3	; 0x03
    2810:	8f 81       	ldd	r24, Y+7	; 0x07
    2812:	98 85       	ldd	r25, Y+8	; 0x08
    2814:	fc 01       	movw	r30, r24
    2816:	33 83       	std	Z+3, r19	; 0x03
    2818:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    281a:	8f 81       	ldd	r24, Y+7	; 0x07
    281c:	98 85       	ldd	r25, Y+8	; 0x08
    281e:	fc 01       	movw	r30, r24
    2820:	82 81       	ldd	r24, Z+2	; 0x02
    2822:	93 81       	ldd	r25, Z+3	; 0x03
    2824:	2f 81       	ldd	r18, Y+7	; 0x07
    2826:	38 85       	ldd	r19, Y+8	; 0x08
    2828:	fc 01       	movw	r30, r24
    282a:	35 83       	std	Z+5, r19	; 0x05
    282c:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    282e:	8f 81       	ldd	r24, Y+7	; 0x07
    2830:	98 85       	ldd	r25, Y+8	; 0x08
    2832:	29 81       	ldd	r18, Y+1	; 0x01
    2834:	3a 81       	ldd	r19, Y+2	; 0x02
    2836:	fc 01       	movw	r30, r24
    2838:	35 83       	std	Z+5, r19	; 0x05
    283a:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    283c:	89 81       	ldd	r24, Y+1	; 0x01
    283e:	9a 81       	ldd	r25, Y+2	; 0x02
    2840:	2f 81       	ldd	r18, Y+7	; 0x07
    2842:	38 85       	ldd	r19, Y+8	; 0x08
    2844:	fc 01       	movw	r30, r24
    2846:	33 83       	std	Z+3, r19	; 0x03
    2848:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    284a:	8f 81       	ldd	r24, Y+7	; 0x07
    284c:	98 85       	ldd	r25, Y+8	; 0x08
    284e:	2d 81       	ldd	r18, Y+5	; 0x05
    2850:	3e 81       	ldd	r19, Y+6	; 0x06
    2852:	fc 01       	movw	r30, r24
    2854:	31 87       	std	Z+9, r19	; 0x09
    2856:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2858:	8d 81       	ldd	r24, Y+5	; 0x05
    285a:	9e 81       	ldd	r25, Y+6	; 0x06
    285c:	fc 01       	movw	r30, r24
    285e:	80 81       	ld	r24, Z
    2860:	21 e0       	ldi	r18, 0x01	; 1
    2862:	28 0f       	add	r18, r24
    2864:	8d 81       	ldd	r24, Y+5	; 0x05
    2866:	9e 81       	ldd	r25, Y+6	; 0x06
    2868:	fc 01       	movw	r30, r24
    286a:	20 83       	st	Z, r18
}
    286c:	00 00       	nop
    286e:	28 96       	adiw	r28, 0x08	; 8
    2870:	0f b6       	in	r0, 0x3f	; 63
    2872:	f8 94       	cli
    2874:	de bf       	out	0x3e, r29	; 62
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	cd bf       	out	0x3d, r28	; 61
    287a:	df 91       	pop	r29
    287c:	cf 91       	pop	r28
    287e:	08 95       	ret

00002880 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2880:	cf 93       	push	r28
    2882:	df 93       	push	r29
    2884:	00 d0       	rcall	.+0      	; 0x2886 <uxListRemove+0x6>
    2886:	00 d0       	rcall	.+0      	; 0x2888 <uxListRemove+0x8>
    2888:	cd b7       	in	r28, 0x3d	; 61
    288a:	de b7       	in	r29, 0x3e	; 62
    288c:	9c 83       	std	Y+4, r25	; 0x04
    288e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2890:	8b 81       	ldd	r24, Y+3	; 0x03
    2892:	9c 81       	ldd	r25, Y+4	; 0x04
    2894:	fc 01       	movw	r30, r24
    2896:	80 85       	ldd	r24, Z+8	; 0x08
    2898:	91 85       	ldd	r25, Z+9	; 0x09
    289a:	9a 83       	std	Y+2, r25	; 0x02
    289c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    289e:	8b 81       	ldd	r24, Y+3	; 0x03
    28a0:	9c 81       	ldd	r25, Y+4	; 0x04
    28a2:	fc 01       	movw	r30, r24
    28a4:	82 81       	ldd	r24, Z+2	; 0x02
    28a6:	93 81       	ldd	r25, Z+3	; 0x03
    28a8:	2b 81       	ldd	r18, Y+3	; 0x03
    28aa:	3c 81       	ldd	r19, Y+4	; 0x04
    28ac:	f9 01       	movw	r30, r18
    28ae:	24 81       	ldd	r18, Z+4	; 0x04
    28b0:	35 81       	ldd	r19, Z+5	; 0x05
    28b2:	fc 01       	movw	r30, r24
    28b4:	35 83       	std	Z+5, r19	; 0x05
    28b6:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    28b8:	8b 81       	ldd	r24, Y+3	; 0x03
    28ba:	9c 81       	ldd	r25, Y+4	; 0x04
    28bc:	fc 01       	movw	r30, r24
    28be:	84 81       	ldd	r24, Z+4	; 0x04
    28c0:	95 81       	ldd	r25, Z+5	; 0x05
    28c2:	2b 81       	ldd	r18, Y+3	; 0x03
    28c4:	3c 81       	ldd	r19, Y+4	; 0x04
    28c6:	f9 01       	movw	r30, r18
    28c8:	22 81       	ldd	r18, Z+2	; 0x02
    28ca:	33 81       	ldd	r19, Z+3	; 0x03
    28cc:	fc 01       	movw	r30, r24
    28ce:	33 83       	std	Z+3, r19	; 0x03
    28d0:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    28d2:	89 81       	ldd	r24, Y+1	; 0x01
    28d4:	9a 81       	ldd	r25, Y+2	; 0x02
    28d6:	fc 01       	movw	r30, r24
    28d8:	21 81       	ldd	r18, Z+1	; 0x01
    28da:	32 81       	ldd	r19, Z+2	; 0x02
    28dc:	8b 81       	ldd	r24, Y+3	; 0x03
    28de:	9c 81       	ldd	r25, Y+4	; 0x04
    28e0:	28 17       	cp	r18, r24
    28e2:	39 07       	cpc	r19, r25
    28e4:	51 f4       	brne	.+20     	; 0x28fa <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    28e6:	8b 81       	ldd	r24, Y+3	; 0x03
    28e8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ea:	fc 01       	movw	r30, r24
    28ec:	24 81       	ldd	r18, Z+4	; 0x04
    28ee:	35 81       	ldd	r19, Z+5	; 0x05
    28f0:	89 81       	ldd	r24, Y+1	; 0x01
    28f2:	9a 81       	ldd	r25, Y+2	; 0x02
    28f4:	fc 01       	movw	r30, r24
    28f6:	32 83       	std	Z+2, r19	; 0x02
    28f8:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    28fa:	8b 81       	ldd	r24, Y+3	; 0x03
    28fc:	9c 81       	ldd	r25, Y+4	; 0x04
    28fe:	fc 01       	movw	r30, r24
    2900:	11 86       	std	Z+9, r1	; 0x09
    2902:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2904:	89 81       	ldd	r24, Y+1	; 0x01
    2906:	9a 81       	ldd	r25, Y+2	; 0x02
    2908:	fc 01       	movw	r30, r24
    290a:	80 81       	ld	r24, Z
    290c:	2f ef       	ldi	r18, 0xFF	; 255
    290e:	28 0f       	add	r18, r24
    2910:	89 81       	ldd	r24, Y+1	; 0x01
    2912:	9a 81       	ldd	r25, Y+2	; 0x02
    2914:	fc 01       	movw	r30, r24
    2916:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2918:	89 81       	ldd	r24, Y+1	; 0x01
    291a:	9a 81       	ldd	r25, Y+2	; 0x02
    291c:	fc 01       	movw	r30, r24
    291e:	80 81       	ld	r24, Z
}
    2920:	0f 90       	pop	r0
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
    2926:	0f 90       	pop	r0
    2928:	df 91       	pop	r29
    292a:	cf 91       	pop	r28
    292c:	08 95       	ret

0000292e <main>:
#include "avr/sleep.h"
#include "KBD_interface.h"


int main(void)
{
    292e:	ef 92       	push	r14
    2930:	ff 92       	push	r15
    2932:	0f 93       	push	r16
    2934:	cf 93       	push	r28
    2936:	df 93       	push	r29
    2938:	cd b7       	in	r28, 0x3d	; 61
    293a:	de b7       	in	r29, 0x3e	; 62
	LCD_initialize();
    293c:	0e 94 0d 08 	call	0x101a	; 0x101a <LCD_initialize>
	LCD_Void_Clear();
    2940:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_Void_Clear>
	Clock_Print_Default_Interface();
    2944:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
	KBD_u8Initialize(GROUP_B);
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <KBD_u8Initialize>
	xTaskCreate(Clock_Second,"seconds",150,NULL,1,NULL);
    294e:	e1 2c       	mov	r14, r1
    2950:	f1 2c       	mov	r15, r1
    2952:	01 e0       	ldi	r16, 0x01	; 1
    2954:	20 e0       	ldi	r18, 0x00	; 0
    2956:	30 e0       	ldi	r19, 0x00	; 0
    2958:	46 e9       	ldi	r20, 0x96	; 150
    295a:	50 e0       	ldi	r21, 0x00	; 0
    295c:	61 e7       	ldi	r22, 0x71	; 113
    295e:	70 e0       	ldi	r23, 0x00	; 0
    2960:	8c e6       	ldi	r24, 0x6C	; 108
    2962:	90 e0       	ldi	r25, 0x00	; 0
    2964:	0e 94 42 20 	call	0x4084	; 0x4084 <xTaskCreate>
	xTaskCreate(Clock_Minute,"minutes",150,NULL,1,NULL);
    2968:	e1 2c       	mov	r14, r1
    296a:	f1 2c       	mov	r15, r1
    296c:	01 e0       	ldi	r16, 0x01	; 1
    296e:	20 e0       	ldi	r18, 0x00	; 0
    2970:	30 e0       	ldi	r19, 0x00	; 0
    2972:	46 e9       	ldi	r20, 0x96	; 150
    2974:	50 e0       	ldi	r21, 0x00	; 0
    2976:	69 e7       	ldi	r22, 0x79	; 121
    2978:	70 e0       	ldi	r23, 0x00	; 0
    297a:	8f eb       	ldi	r24, 0xBF	; 191
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	0e 94 42 20 	call	0x4084	; 0x4084 <xTaskCreate>
	xTaskCreate(Clock_Hours,"hours",150,NULL,1,NULL);
    2982:	e1 2c       	mov	r14, r1
    2984:	f1 2c       	mov	r15, r1
    2986:	01 e0       	ldi	r16, 0x01	; 1
    2988:	20 e0       	ldi	r18, 0x00	; 0
    298a:	30 e0       	ldi	r19, 0x00	; 0
    298c:	46 e9       	ldi	r20, 0x96	; 150
    298e:	50 e0       	ldi	r21, 0x00	; 0
    2990:	61 e8       	ldi	r22, 0x81	; 129
    2992:	70 e0       	ldi	r23, 0x00	; 0
    2994:	8b e0       	ldi	r24, 0x0B	; 11
    2996:	91 e0       	ldi	r25, 0x01	; 1
    2998:	0e 94 42 20 	call	0x4084	; 0x4084 <xTaskCreate>
	xTaskCreate(Clock_Check_KPD,"KPD_check",150,NULL,2,NULL);
    299c:	e1 2c       	mov	r14, r1
    299e:	f1 2c       	mov	r15, r1
    29a0:	02 e0       	ldi	r16, 0x02	; 2
    29a2:	20 e0       	ldi	r18, 0x00	; 0
    29a4:	30 e0       	ldi	r19, 0x00	; 0
    29a6:	46 e9       	ldi	r20, 0x96	; 150
    29a8:	50 e0       	ldi	r21, 0x00	; 0
    29aa:	67 e8       	ldi	r22, 0x87	; 135
    29ac:	70 e0       	ldi	r23, 0x00	; 0
    29ae:	87 e6       	ldi	r24, 0x67	; 103
    29b0:	91 e0       	ldi	r25, 0x01	; 1
    29b2:	0e 94 42 20 	call	0x4084	; 0x4084 <xTaskCreate>
	xTaskCreate(Clock_Enter_Typing_Mode,"Enter typing mode",300,NULL,2,NULL);
    29b6:	e1 2c       	mov	r14, r1
    29b8:	f1 2c       	mov	r15, r1
    29ba:	02 e0       	ldi	r16, 0x02	; 2
    29bc:	20 e0       	ldi	r18, 0x00	; 0
    29be:	30 e0       	ldi	r19, 0x00	; 0
    29c0:	4c e2       	ldi	r20, 0x2C	; 44
    29c2:	51 e0       	ldi	r21, 0x01	; 1
    29c4:	61 e9       	ldi	r22, 0x91	; 145
    29c6:	70 e0       	ldi	r23, 0x00	; 0
    29c8:	8e e9       	ldi	r24, 0x9E	; 158
    29ca:	91 e0       	ldi	r25, 0x01	; 1
    29cc:	0e 94 42 20 	call	0x4084	; 0x4084 <xTaskCreate>
	vTaskStartScheduler();
    29d0:	0e 94 83 24 	call	0x4906	; 0x4906 <vTaskStartScheduler>

	while(1)
	{

	}
    29d4:	ff cf       	rjmp	.-2      	; 0x29d4 <main+0xa6>

000029d6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    29d6:	cf 93       	push	r28
    29d8:	df 93       	push	r29
    29da:	cd b7       	in	r28, 0x3d	; 61
    29dc:	de b7       	in	r29, 0x3e	; 62
    29de:	28 97       	sbiw	r28, 0x08	; 8
    29e0:	0f b6       	in	r0, 0x3f	; 63
    29e2:	f8 94       	cli
    29e4:	de bf       	out	0x3e, r29	; 62
    29e6:	0f be       	out	0x3f, r0	; 63
    29e8:	cd bf       	out	0x3d, r28	; 61
    29ea:	9c 83       	std	Y+4, r25	; 0x04
    29ec:	8b 83       	std	Y+3, r24	; 0x03
    29ee:	7e 83       	std	Y+6, r23	; 0x06
    29f0:	6d 83       	std	Y+5, r22	; 0x05
    29f2:	58 87       	std	Y+8, r21	; 0x08
    29f4:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    29f6:	8b 81       	ldd	r24, Y+3	; 0x03
    29f8:	9c 81       	ldd	r25, Y+4	; 0x04
    29fa:	21 e1       	ldi	r18, 0x11	; 17
    29fc:	fc 01       	movw	r30, r24
    29fe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a00:	8b 81       	ldd	r24, Y+3	; 0x03
    2a02:	9c 81       	ldd	r25, Y+4	; 0x04
    2a04:	01 97       	sbiw	r24, 0x01	; 1
    2a06:	9c 83       	std	Y+4, r25	; 0x04
    2a08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a0e:	22 e2       	ldi	r18, 0x22	; 34
    2a10:	fc 01       	movw	r30, r24
    2a12:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a14:	8b 81       	ldd	r24, Y+3	; 0x03
    2a16:	9c 81       	ldd	r25, Y+4	; 0x04
    2a18:	01 97       	sbiw	r24, 0x01	; 1
    2a1a:	9c 83       	std	Y+4, r25	; 0x04
    2a1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a20:	9c 81       	ldd	r25, Y+4	; 0x04
    2a22:	23 e3       	ldi	r18, 0x33	; 51
    2a24:	fc 01       	movw	r30, r24
    2a26:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a28:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2c:	01 97       	sbiw	r24, 0x01	; 1
    2a2e:	9c 83       	std	Y+4, r25	; 0x04
    2a30:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2a32:	8d 81       	ldd	r24, Y+5	; 0x05
    2a34:	9e 81       	ldd	r25, Y+6	; 0x06
    2a36:	9a 83       	std	Y+2, r25	; 0x02
    2a38:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2a3a:	29 81       	ldd	r18, Y+1	; 0x01
    2a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a40:	fc 01       	movw	r30, r24
    2a42:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a44:	8b 81       	ldd	r24, Y+3	; 0x03
    2a46:	9c 81       	ldd	r25, Y+4	; 0x04
    2a48:	01 97       	sbiw	r24, 0x01	; 1
    2a4a:	9c 83       	std	Y+4, r25	; 0x04
    2a4c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2a4e:	89 81       	ldd	r24, Y+1	; 0x01
    2a50:	9a 81       	ldd	r25, Y+2	; 0x02
    2a52:	89 2f       	mov	r24, r25
    2a54:	99 27       	eor	r25, r25
    2a56:	9a 83       	std	Y+2, r25	; 0x02
    2a58:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2a5a:	29 81       	ldd	r18, Y+1	; 0x01
    2a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a60:	fc 01       	movw	r30, r24
    2a62:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a64:	8b 81       	ldd	r24, Y+3	; 0x03
    2a66:	9c 81       	ldd	r25, Y+4	; 0x04
    2a68:	01 97       	sbiw	r24, 0x01	; 1
    2a6a:	9c 83       	std	Y+4, r25	; 0x04
    2a6c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a70:	9c 81       	ldd	r25, Y+4	; 0x04
    2a72:	fc 01       	movw	r30, r24
    2a74:	10 82       	st	Z, r1
	pxTopOfStack--;
    2a76:	8b 81       	ldd	r24, Y+3	; 0x03
    2a78:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7a:	01 97       	sbiw	r24, 0x01	; 1
    2a7c:	9c 83       	std	Y+4, r25	; 0x04
    2a7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2a80:	8b 81       	ldd	r24, Y+3	; 0x03
    2a82:	9c 81       	ldd	r25, Y+4	; 0x04
    2a84:	20 e8       	ldi	r18, 0x80	; 128
    2a86:	fc 01       	movw	r30, r24
    2a88:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8e:	01 97       	sbiw	r24, 0x01	; 1
    2a90:	9c 83       	std	Y+4, r25	; 0x04
    2a92:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2a94:	8b 81       	ldd	r24, Y+3	; 0x03
    2a96:	9c 81       	ldd	r25, Y+4	; 0x04
    2a98:	fc 01       	movw	r30, r24
    2a9a:	10 82       	st	Z, r1
	pxTopOfStack--;
    2a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa0:	01 97       	sbiw	r24, 0x01	; 1
    2aa2:	9c 83       	std	Y+4, r25	; 0x04
    2aa4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aaa:	22 e0       	ldi	r18, 0x02	; 2
    2aac:	fc 01       	movw	r30, r24
    2aae:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab4:	01 97       	sbiw	r24, 0x01	; 1
    2ab6:	9c 83       	std	Y+4, r25	; 0x04
    2ab8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2aba:	8b 81       	ldd	r24, Y+3	; 0x03
    2abc:	9c 81       	ldd	r25, Y+4	; 0x04
    2abe:	23 e0       	ldi	r18, 0x03	; 3
    2ac0:	fc 01       	movw	r30, r24
    2ac2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac8:	01 97       	sbiw	r24, 0x01	; 1
    2aca:	9c 83       	std	Y+4, r25	; 0x04
    2acc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2ace:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad2:	24 e0       	ldi	r18, 0x04	; 4
    2ad4:	fc 01       	movw	r30, r24
    2ad6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ad8:	8b 81       	ldd	r24, Y+3	; 0x03
    2ada:	9c 81       	ldd	r25, Y+4	; 0x04
    2adc:	01 97       	sbiw	r24, 0x01	; 1
    2ade:	9c 83       	std	Y+4, r25	; 0x04
    2ae0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae6:	25 e0       	ldi	r18, 0x05	; 5
    2ae8:	fc 01       	movw	r30, r24
    2aea:	20 83       	st	Z, r18
	pxTopOfStack--;
    2aec:	8b 81       	ldd	r24, Y+3	; 0x03
    2aee:	9c 81       	ldd	r25, Y+4	; 0x04
    2af0:	01 97       	sbiw	r24, 0x01	; 1
    2af2:	9c 83       	std	Y+4, r25	; 0x04
    2af4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2af6:	8b 81       	ldd	r24, Y+3	; 0x03
    2af8:	9c 81       	ldd	r25, Y+4	; 0x04
    2afa:	26 e0       	ldi	r18, 0x06	; 6
    2afc:	fc 01       	movw	r30, r24
    2afe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b00:	8b 81       	ldd	r24, Y+3	; 0x03
    2b02:	9c 81       	ldd	r25, Y+4	; 0x04
    2b04:	01 97       	sbiw	r24, 0x01	; 1
    2b06:	9c 83       	std	Y+4, r25	; 0x04
    2b08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0e:	27 e0       	ldi	r18, 0x07	; 7
    2b10:	fc 01       	movw	r30, r24
    2b12:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b14:	8b 81       	ldd	r24, Y+3	; 0x03
    2b16:	9c 81       	ldd	r25, Y+4	; 0x04
    2b18:	01 97       	sbiw	r24, 0x01	; 1
    2b1a:	9c 83       	std	Y+4, r25	; 0x04
    2b1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2b1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b20:	9c 81       	ldd	r25, Y+4	; 0x04
    2b22:	28 e0       	ldi	r18, 0x08	; 8
    2b24:	fc 01       	movw	r30, r24
    2b26:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b28:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2c:	01 97       	sbiw	r24, 0x01	; 1
    2b2e:	9c 83       	std	Y+4, r25	; 0x04
    2b30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2b32:	8b 81       	ldd	r24, Y+3	; 0x03
    2b34:	9c 81       	ldd	r25, Y+4	; 0x04
    2b36:	29 e0       	ldi	r18, 0x09	; 9
    2b38:	fc 01       	movw	r30, r24
    2b3a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b40:	01 97       	sbiw	r24, 0x01	; 1
    2b42:	9c 83       	std	Y+4, r25	; 0x04
    2b44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2b46:	8b 81       	ldd	r24, Y+3	; 0x03
    2b48:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4a:	20 e1       	ldi	r18, 0x10	; 16
    2b4c:	fc 01       	movw	r30, r24
    2b4e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b50:	8b 81       	ldd	r24, Y+3	; 0x03
    2b52:	9c 81       	ldd	r25, Y+4	; 0x04
    2b54:	01 97       	sbiw	r24, 0x01	; 1
    2b56:	9c 83       	std	Y+4, r25	; 0x04
    2b58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5e:	21 e1       	ldi	r18, 0x11	; 17
    2b60:	fc 01       	movw	r30, r24
    2b62:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b64:	8b 81       	ldd	r24, Y+3	; 0x03
    2b66:	9c 81       	ldd	r25, Y+4	; 0x04
    2b68:	01 97       	sbiw	r24, 0x01	; 1
    2b6a:	9c 83       	std	Y+4, r25	; 0x04
    2b6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b70:	9c 81       	ldd	r25, Y+4	; 0x04
    2b72:	22 e1       	ldi	r18, 0x12	; 18
    2b74:	fc 01       	movw	r30, r24
    2b76:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b78:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7c:	01 97       	sbiw	r24, 0x01	; 1
    2b7e:	9c 83       	std	Y+4, r25	; 0x04
    2b80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2b82:	8b 81       	ldd	r24, Y+3	; 0x03
    2b84:	9c 81       	ldd	r25, Y+4	; 0x04
    2b86:	23 e1       	ldi	r18, 0x13	; 19
    2b88:	fc 01       	movw	r30, r24
    2b8a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b90:	01 97       	sbiw	r24, 0x01	; 1
    2b92:	9c 83       	std	Y+4, r25	; 0x04
    2b94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2b96:	8b 81       	ldd	r24, Y+3	; 0x03
    2b98:	9c 81       	ldd	r25, Y+4	; 0x04
    2b9a:	24 e1       	ldi	r18, 0x14	; 20
    2b9c:	fc 01       	movw	r30, r24
    2b9e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba4:	01 97       	sbiw	r24, 0x01	; 1
    2ba6:	9c 83       	std	Y+4, r25	; 0x04
    2ba8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2baa:	8b 81       	ldd	r24, Y+3	; 0x03
    2bac:	9c 81       	ldd	r25, Y+4	; 0x04
    2bae:	25 e1       	ldi	r18, 0x15	; 21
    2bb0:	fc 01       	movw	r30, r24
    2bb2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb8:	01 97       	sbiw	r24, 0x01	; 1
    2bba:	9c 83       	std	Y+4, r25	; 0x04
    2bbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2bbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc2:	26 e1       	ldi	r18, 0x16	; 22
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bca:	9c 81       	ldd	r25, Y+4	; 0x04
    2bcc:	01 97       	sbiw	r24, 0x01	; 1
    2bce:	9c 83       	std	Y+4, r25	; 0x04
    2bd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bd6:	27 e1       	ldi	r18, 0x17	; 23
    2bd8:	fc 01       	movw	r30, r24
    2bda:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bde:	9c 81       	ldd	r25, Y+4	; 0x04
    2be0:	01 97       	sbiw	r24, 0x01	; 1
    2be2:	9c 83       	std	Y+4, r25	; 0x04
    2be4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2be6:	8b 81       	ldd	r24, Y+3	; 0x03
    2be8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bea:	28 e1       	ldi	r18, 0x18	; 24
    2bec:	fc 01       	movw	r30, r24
    2bee:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf2:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf4:	01 97       	sbiw	r24, 0x01	; 1
    2bf6:	9c 83       	std	Y+4, r25	; 0x04
    2bf8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2bfa:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfe:	29 e1       	ldi	r18, 0x19	; 25
    2c00:	fc 01       	movw	r30, r24
    2c02:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c04:	8b 81       	ldd	r24, Y+3	; 0x03
    2c06:	9c 81       	ldd	r25, Y+4	; 0x04
    2c08:	01 97       	sbiw	r24, 0x01	; 1
    2c0a:	9c 83       	std	Y+4, r25	; 0x04
    2c0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c10:	9c 81       	ldd	r25, Y+4	; 0x04
    2c12:	20 e2       	ldi	r18, 0x20	; 32
    2c14:	fc 01       	movw	r30, r24
    2c16:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c18:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1c:	01 97       	sbiw	r24, 0x01	; 1
    2c1e:	9c 83       	std	Y+4, r25	; 0x04
    2c20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2c22:	8b 81       	ldd	r24, Y+3	; 0x03
    2c24:	9c 81       	ldd	r25, Y+4	; 0x04
    2c26:	21 e2       	ldi	r18, 0x21	; 33
    2c28:	fc 01       	movw	r30, r24
    2c2a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c30:	01 97       	sbiw	r24, 0x01	; 1
    2c32:	9c 83       	std	Y+4, r25	; 0x04
    2c34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2c36:	8b 81       	ldd	r24, Y+3	; 0x03
    2c38:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3a:	22 e2       	ldi	r18, 0x22	; 34
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c40:	8b 81       	ldd	r24, Y+3	; 0x03
    2c42:	9c 81       	ldd	r25, Y+4	; 0x04
    2c44:	01 97       	sbiw	r24, 0x01	; 1
    2c46:	9c 83       	std	Y+4, r25	; 0x04
    2c48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4e:	23 e2       	ldi	r18, 0x23	; 35
    2c50:	fc 01       	movw	r30, r24
    2c52:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c54:	8b 81       	ldd	r24, Y+3	; 0x03
    2c56:	9c 81       	ldd	r25, Y+4	; 0x04
    2c58:	01 97       	sbiw	r24, 0x01	; 1
    2c5a:	9c 83       	std	Y+4, r25	; 0x04
    2c5c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2c5e:	8f 81       	ldd	r24, Y+7	; 0x07
    2c60:	98 85       	ldd	r25, Y+8	; 0x08
    2c62:	9a 83       	std	Y+2, r25	; 0x02
    2c64:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c66:	29 81       	ldd	r18, Y+1	; 0x01
    2c68:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c6c:	fc 01       	movw	r30, r24
    2c6e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c70:	8b 81       	ldd	r24, Y+3	; 0x03
    2c72:	9c 81       	ldd	r25, Y+4	; 0x04
    2c74:	01 97       	sbiw	r24, 0x01	; 1
    2c76:	9c 83       	std	Y+4, r25	; 0x04
    2c78:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2c7a:	89 81       	ldd	r24, Y+1	; 0x01
    2c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c7e:	89 2f       	mov	r24, r25
    2c80:	99 27       	eor	r25, r25
    2c82:	9a 83       	std	Y+2, r25	; 0x02
    2c84:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c86:	29 81       	ldd	r18, Y+1	; 0x01
    2c88:	8b 81       	ldd	r24, Y+3	; 0x03
    2c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8c:	fc 01       	movw	r30, r24
    2c8e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c90:	8b 81       	ldd	r24, Y+3	; 0x03
    2c92:	9c 81       	ldd	r25, Y+4	; 0x04
    2c94:	01 97       	sbiw	r24, 0x01	; 1
    2c96:	9c 83       	std	Y+4, r25	; 0x04
    2c98:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9e:	26 e2       	ldi	r18, 0x26	; 38
    2ca0:	fc 01       	movw	r30, r24
    2ca2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca8:	01 97       	sbiw	r24, 0x01	; 1
    2caa:	9c 83       	std	Y+4, r25	; 0x04
    2cac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2cae:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb2:	27 e2       	ldi	r18, 0x27	; 39
    2cb4:	fc 01       	movw	r30, r24
    2cb6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cba:	9c 81       	ldd	r25, Y+4	; 0x04
    2cbc:	01 97       	sbiw	r24, 0x01	; 1
    2cbe:	9c 83       	std	Y+4, r25	; 0x04
    2cc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc6:	28 e2       	ldi	r18, 0x28	; 40
    2cc8:	fc 01       	movw	r30, r24
    2cca:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cce:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd0:	01 97       	sbiw	r24, 0x01	; 1
    2cd2:	9c 83       	std	Y+4, r25	; 0x04
    2cd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cda:	29 e2       	ldi	r18, 0x29	; 41
    2cdc:	fc 01       	movw	r30, r24
    2cde:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce4:	01 97       	sbiw	r24, 0x01	; 1
    2ce6:	9c 83       	std	Y+4, r25	; 0x04
    2ce8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2cea:	8b 81       	ldd	r24, Y+3	; 0x03
    2cec:	9c 81       	ldd	r25, Y+4	; 0x04
    2cee:	20 e3       	ldi	r18, 0x30	; 48
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cf8:	01 97       	sbiw	r24, 0x01	; 1
    2cfa:	9c 83       	std	Y+4, r25	; 0x04
    2cfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2d00:	9c 81       	ldd	r25, Y+4	; 0x04
    2d02:	21 e3       	ldi	r18, 0x31	; 49
    2d04:	fc 01       	movw	r30, r24
    2d06:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d08:	8b 81       	ldd	r24, Y+3	; 0x03
    2d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d0c:	01 97       	sbiw	r24, 0x01	; 1
    2d0e:	9c 83       	std	Y+4, r25	; 0x04
    2d10:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2d12:	8b 81       	ldd	r24, Y+3	; 0x03
    2d14:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2d16:	28 96       	adiw	r28, 0x08	; 8
    2d18:	0f b6       	in	r0, 0x3f	; 63
    2d1a:	f8 94       	cli
    2d1c:	de bf       	out	0x3e, r29	; 62
    2d1e:	0f be       	out	0x3f, r0	; 63
    2d20:	cd bf       	out	0x3d, r28	; 61
    2d22:	df 91       	pop	r29
    2d24:	cf 91       	pop	r28
    2d26:	08 95       	ret

00002d28 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2d28:	cf 93       	push	r28
    2d2a:	df 93       	push	r29
    2d2c:	cd b7       	in	r28, 0x3d	; 61
    2d2e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2d30:	0e 94 89 17 	call	0x2f12	; 0x2f12 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2d34:	a0 91 8d 06 	lds	r26, 0x068D	; 0x80068d <pxCurrentTCB>
    2d38:	b0 91 8e 06 	lds	r27, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    2d3c:	cd 91       	ld	r28, X+
    2d3e:	cd bf       	out	0x3d, r28	; 61
    2d40:	dd 91       	ld	r29, X+
    2d42:	de bf       	out	0x3e, r29	; 62
    2d44:	ff 91       	pop	r31
    2d46:	ef 91       	pop	r30
    2d48:	df 91       	pop	r29
    2d4a:	cf 91       	pop	r28
    2d4c:	bf 91       	pop	r27
    2d4e:	af 91       	pop	r26
    2d50:	9f 91       	pop	r25
    2d52:	8f 91       	pop	r24
    2d54:	7f 91       	pop	r23
    2d56:	6f 91       	pop	r22
    2d58:	5f 91       	pop	r21
    2d5a:	4f 91       	pop	r20
    2d5c:	3f 91       	pop	r19
    2d5e:	2f 91       	pop	r18
    2d60:	1f 91       	pop	r17
    2d62:	0f 91       	pop	r16
    2d64:	ff 90       	pop	r15
    2d66:	ef 90       	pop	r14
    2d68:	df 90       	pop	r13
    2d6a:	cf 90       	pop	r12
    2d6c:	bf 90       	pop	r11
    2d6e:	af 90       	pop	r10
    2d70:	9f 90       	pop	r9
    2d72:	8f 90       	pop	r8
    2d74:	7f 90       	pop	r7
    2d76:	6f 90       	pop	r6
    2d78:	5f 90       	pop	r5
    2d7a:	4f 90       	pop	r4
    2d7c:	3f 90       	pop	r3
    2d7e:	2f 90       	pop	r2
    2d80:	1f 90       	pop	r1
    2d82:	0f 90       	pop	r0
    2d84:	0f be       	out	0x3f, r0	; 63
    2d86:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2d88:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2d8a:	81 e0       	ldi	r24, 0x01	; 1
}
    2d8c:	df 91       	pop	r29
    2d8e:	cf 91       	pop	r28
    2d90:	08 95       	ret

00002d92 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2d92:	cf 93       	push	r28
    2d94:	df 93       	push	r29
    2d96:	cd b7       	in	r28, 0x3d	; 61
    2d98:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2d9a:	00 00       	nop
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	08 95       	ret

00002da2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2da2:	0f 92       	push	r0
    2da4:	0f b6       	in	r0, 0x3f	; 63
    2da6:	f8 94       	cli
    2da8:	0f 92       	push	r0
    2daa:	1f 92       	push	r1
    2dac:	11 24       	eor	r1, r1
    2dae:	2f 92       	push	r2
    2db0:	3f 92       	push	r3
    2db2:	4f 92       	push	r4
    2db4:	5f 92       	push	r5
    2db6:	6f 92       	push	r6
    2db8:	7f 92       	push	r7
    2dba:	8f 92       	push	r8
    2dbc:	9f 92       	push	r9
    2dbe:	af 92       	push	r10
    2dc0:	bf 92       	push	r11
    2dc2:	cf 92       	push	r12
    2dc4:	df 92       	push	r13
    2dc6:	ef 92       	push	r14
    2dc8:	ff 92       	push	r15
    2dca:	0f 93       	push	r16
    2dcc:	1f 93       	push	r17
    2dce:	2f 93       	push	r18
    2dd0:	3f 93       	push	r19
    2dd2:	4f 93       	push	r20
    2dd4:	5f 93       	push	r21
    2dd6:	6f 93       	push	r22
    2dd8:	7f 93       	push	r23
    2dda:	8f 93       	push	r24
    2ddc:	9f 93       	push	r25
    2dde:	af 93       	push	r26
    2de0:	bf 93       	push	r27
    2de2:	cf 93       	push	r28
    2de4:	df 93       	push	r29
    2de6:	ef 93       	push	r30
    2de8:	ff 93       	push	r31
    2dea:	a0 91 8d 06 	lds	r26, 0x068D	; 0x80068d <pxCurrentTCB>
    2dee:	b0 91 8e 06 	lds	r27, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    2df2:	0d b6       	in	r0, 0x3d	; 61
    2df4:	0d 92       	st	X+, r0
    2df6:	0e b6       	in	r0, 0x3e	; 62
    2df8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2dfa:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2dfe:	a0 91 8d 06 	lds	r26, 0x068D	; 0x80068d <pxCurrentTCB>
    2e02:	b0 91 8e 06 	lds	r27, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    2e06:	cd 91       	ld	r28, X+
    2e08:	cd bf       	out	0x3d, r28	; 61
    2e0a:	dd 91       	ld	r29, X+
    2e0c:	de bf       	out	0x3e, r29	; 62
    2e0e:	ff 91       	pop	r31
    2e10:	ef 91       	pop	r30
    2e12:	df 91       	pop	r29
    2e14:	cf 91       	pop	r28
    2e16:	bf 91       	pop	r27
    2e18:	af 91       	pop	r26
    2e1a:	9f 91       	pop	r25
    2e1c:	8f 91       	pop	r24
    2e1e:	7f 91       	pop	r23
    2e20:	6f 91       	pop	r22
    2e22:	5f 91       	pop	r21
    2e24:	4f 91       	pop	r20
    2e26:	3f 91       	pop	r19
    2e28:	2f 91       	pop	r18
    2e2a:	1f 91       	pop	r17
    2e2c:	0f 91       	pop	r16
    2e2e:	ff 90       	pop	r15
    2e30:	ef 90       	pop	r14
    2e32:	df 90       	pop	r13
    2e34:	cf 90       	pop	r12
    2e36:	bf 90       	pop	r11
    2e38:	af 90       	pop	r10
    2e3a:	9f 90       	pop	r9
    2e3c:	8f 90       	pop	r8
    2e3e:	7f 90       	pop	r7
    2e40:	6f 90       	pop	r6
    2e42:	5f 90       	pop	r5
    2e44:	4f 90       	pop	r4
    2e46:	3f 90       	pop	r3
    2e48:	2f 90       	pop	r2
    2e4a:	1f 90       	pop	r1
    2e4c:	0f 90       	pop	r0
    2e4e:	0f be       	out	0x3f, r0	; 63
    2e50:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e52:	08 95       	ret
	...

00002e56 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2e56:	0f 92       	push	r0
    2e58:	0f b6       	in	r0, 0x3f	; 63
    2e5a:	f8 94       	cli
    2e5c:	0f 92       	push	r0
    2e5e:	1f 92       	push	r1
    2e60:	11 24       	eor	r1, r1
    2e62:	2f 92       	push	r2
    2e64:	3f 92       	push	r3
    2e66:	4f 92       	push	r4
    2e68:	5f 92       	push	r5
    2e6a:	6f 92       	push	r6
    2e6c:	7f 92       	push	r7
    2e6e:	8f 92       	push	r8
    2e70:	9f 92       	push	r9
    2e72:	af 92       	push	r10
    2e74:	bf 92       	push	r11
    2e76:	cf 92       	push	r12
    2e78:	df 92       	push	r13
    2e7a:	ef 92       	push	r14
    2e7c:	ff 92       	push	r15
    2e7e:	0f 93       	push	r16
    2e80:	1f 93       	push	r17
    2e82:	2f 93       	push	r18
    2e84:	3f 93       	push	r19
    2e86:	4f 93       	push	r20
    2e88:	5f 93       	push	r21
    2e8a:	6f 93       	push	r22
    2e8c:	7f 93       	push	r23
    2e8e:	8f 93       	push	r24
    2e90:	9f 93       	push	r25
    2e92:	af 93       	push	r26
    2e94:	bf 93       	push	r27
    2e96:	cf 93       	push	r28
    2e98:	df 93       	push	r29
    2e9a:	ef 93       	push	r30
    2e9c:	ff 93       	push	r31
    2e9e:	a0 91 8d 06 	lds	r26, 0x068D	; 0x80068d <pxCurrentTCB>
    2ea2:	b0 91 8e 06 	lds	r27, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    2ea6:	0d b6       	in	r0, 0x3d	; 61
    2ea8:	0d 92       	st	X+, r0
    2eaa:	0e b6       	in	r0, 0x3e	; 62
    2eac:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2eae:	0e 94 bd 25 	call	0x4b7a	; 0x4b7a <xTaskIncrementTick>
    2eb2:	88 23       	and	r24, r24
    2eb4:	11 f0       	breq	.+4      	; 0x2eba <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2eb6:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2eba:	a0 91 8d 06 	lds	r26, 0x068D	; 0x80068d <pxCurrentTCB>
    2ebe:	b0 91 8e 06 	lds	r27, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    2ec2:	cd 91       	ld	r28, X+
    2ec4:	cd bf       	out	0x3d, r28	; 61
    2ec6:	dd 91       	ld	r29, X+
    2ec8:	de bf       	out	0x3e, r29	; 62
    2eca:	ff 91       	pop	r31
    2ecc:	ef 91       	pop	r30
    2ece:	df 91       	pop	r29
    2ed0:	cf 91       	pop	r28
    2ed2:	bf 91       	pop	r27
    2ed4:	af 91       	pop	r26
    2ed6:	9f 91       	pop	r25
    2ed8:	8f 91       	pop	r24
    2eda:	7f 91       	pop	r23
    2edc:	6f 91       	pop	r22
    2ede:	5f 91       	pop	r21
    2ee0:	4f 91       	pop	r20
    2ee2:	3f 91       	pop	r19
    2ee4:	2f 91       	pop	r18
    2ee6:	1f 91       	pop	r17
    2ee8:	0f 91       	pop	r16
    2eea:	ff 90       	pop	r15
    2eec:	ef 90       	pop	r14
    2eee:	df 90       	pop	r13
    2ef0:	cf 90       	pop	r12
    2ef2:	bf 90       	pop	r11
    2ef4:	af 90       	pop	r10
    2ef6:	9f 90       	pop	r9
    2ef8:	8f 90       	pop	r8
    2efa:	7f 90       	pop	r7
    2efc:	6f 90       	pop	r6
    2efe:	5f 90       	pop	r5
    2f00:	4f 90       	pop	r4
    2f02:	3f 90       	pop	r3
    2f04:	2f 90       	pop	r2
    2f06:	1f 90       	pop	r1
    2f08:	0f 90       	pop	r0
    2f0a:	0f be       	out	0x3f, r0	; 63
    2f0c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2f0e:	08 95       	ret
	...

00002f12 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2f12:	cf 93       	push	r28
    2f14:	df 93       	push	r29
    2f16:	00 d0       	rcall	.+0      	; 0x2f18 <prvSetupTimerInterrupt+0x6>
    2f18:	00 d0       	rcall	.+0      	; 0x2f1a <prvSetupTimerInterrupt+0x8>
    2f1a:	00 d0       	rcall	.+0      	; 0x2f1c <prvSetupTimerInterrupt+0xa>
    2f1c:	cd b7       	in	r28, 0x3d	; 61
    2f1e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2f20:	80 e0       	ldi	r24, 0x00	; 0
    2f22:	9a e6       	ldi	r25, 0x6A	; 106
    2f24:	a8 e1       	ldi	r26, 0x18	; 24
    2f26:	b0 e0       	ldi	r27, 0x00	; 0
    2f28:	89 83       	std	Y+1, r24	; 0x01
    2f2a:	9a 83       	std	Y+2, r25	; 0x02
    2f2c:	ab 83       	std	Y+3, r26	; 0x03
    2f2e:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2f30:	89 81       	ldd	r24, Y+1	; 0x01
    2f32:	9a 81       	ldd	r25, Y+2	; 0x02
    2f34:	ab 81       	ldd	r26, Y+3	; 0x03
    2f36:	bc 81       	ldd	r27, Y+4	; 0x04
    2f38:	68 94       	set
    2f3a:	15 f8       	bld	r1, 5
    2f3c:	b6 95       	lsr	r27
    2f3e:	a7 95       	ror	r26
    2f40:	97 95       	ror	r25
    2f42:	87 95       	ror	r24
    2f44:	16 94       	lsr	r1
    2f46:	d1 f7       	brne	.-12     	; 0x2f3c <prvSetupTimerInterrupt+0x2a>
    2f48:	89 83       	std	Y+1, r24	; 0x01
    2f4a:	9a 83       	std	Y+2, r25	; 0x02
    2f4c:	ab 83       	std	Y+3, r26	; 0x03
    2f4e:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2f50:	89 81       	ldd	r24, Y+1	; 0x01
    2f52:	9a 81       	ldd	r25, Y+2	; 0x02
    2f54:	ab 81       	ldd	r26, Y+3	; 0x03
    2f56:	bc 81       	ldd	r27, Y+4	; 0x04
    2f58:	01 97       	sbiw	r24, 0x01	; 1
    2f5a:	a1 09       	sbc	r26, r1
    2f5c:	b1 09       	sbc	r27, r1
    2f5e:	89 83       	std	Y+1, r24	; 0x01
    2f60:	9a 83       	std	Y+2, r25	; 0x02
    2f62:	ab 83       	std	Y+3, r26	; 0x03
    2f64:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2f66:	89 81       	ldd	r24, Y+1	; 0x01
    2f68:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    2f6a:	89 81       	ldd	r24, Y+1	; 0x01
    2f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f6e:	ab 81       	ldd	r26, Y+3	; 0x03
    2f70:	bc 81       	ldd	r27, Y+4	; 0x04
    2f72:	89 2f       	mov	r24, r25
    2f74:	9a 2f       	mov	r25, r26
    2f76:	ab 2f       	mov	r26, r27
    2f78:	bb 27       	eor	r27, r27
    2f7a:	89 83       	std	Y+1, r24	; 0x01
    2f7c:	9a 83       	std	Y+2, r25	; 0x02
    2f7e:	ab 83       	std	Y+3, r26	; 0x03
    2f80:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2f82:	89 81       	ldd	r24, Y+1	; 0x01
    2f84:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    2f86:	8b e4       	ldi	r24, 0x4B	; 75
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	2e 81       	ldd	r18, Y+6	; 0x06
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    2f90:	8a e4       	ldi	r24, 0x4A	; 74
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	2d 81       	ldd	r18, Y+5	; 0x05
    2f96:	fc 01       	movw	r30, r24
    2f98:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2f9a:	8b e0       	ldi	r24, 0x0B	; 11
    2f9c:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    2f9e:	8e e4       	ldi	r24, 0x4E	; 78
    2fa0:	90 e0       	ldi	r25, 0x00	; 0
    2fa2:	2d 81       	ldd	r18, Y+5	; 0x05
    2fa4:	fc 01       	movw	r30, r24
    2fa6:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2fa8:	89 e5       	ldi	r24, 0x59	; 89
    2faa:	90 e0       	ldi	r25, 0x00	; 0
    2fac:	fc 01       	movw	r30, r24
    2fae:	80 81       	ld	r24, Z
    2fb0:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    2fb4:	80 61       	ori	r24, 0x10	; 16
    2fb6:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK = ucLowByte;
    2fb8:	89 e5       	ldi	r24, 0x59	; 89
    2fba:	90 e0       	ldi	r25, 0x00	; 0
    2fbc:	2d 81       	ldd	r18, Y+5	; 0x05
    2fbe:	fc 01       	movw	r30, r24
    2fc0:	20 83       	st	Z, r18
}
    2fc2:	00 00       	nop
    2fc4:	26 96       	adiw	r28, 0x06	; 6
    2fc6:	0f b6       	in	r0, 0x3f	; 63
    2fc8:	f8 94       	cli
    2fca:	de bf       	out	0x3e, r29	; 62
    2fcc:	0f be       	out	0x3f, r0	; 63
    2fce:	cd bf       	out	0x3d, r28	; 61
    2fd0:	df 91       	pop	r29
    2fd2:	cf 91       	pop	r28
    2fd4:	08 95       	ret

00002fd6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void _VECTOR(7)( void ) __attribute__ ( ( signal, naked ) );
	void _VECTOR(7)( void )
	{
		vPortYieldFromTick();
    2fd6:	0e 94 2b 17 	call	0x2e56	; 0x2e56 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2fda:	18 95       	reti
	...

00002fde <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2fde:	cf 93       	push	r28
    2fe0:	df 93       	push	r29
    2fe2:	00 d0       	rcall	.+0      	; 0x2fe4 <xQueueGenericReset+0x6>
    2fe4:	00 d0       	rcall	.+0      	; 0x2fe6 <xQueueGenericReset+0x8>
    2fe6:	1f 92       	push	r1
    2fe8:	cd b7       	in	r28, 0x3d	; 61
    2fea:	de b7       	in	r29, 0x3e	; 62
    2fec:	9c 83       	std	Y+4, r25	; 0x04
    2fee:	8b 83       	std	Y+3, r24	; 0x03
    2ff0:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff6:	9a 83       	std	Y+2, r25	; 0x02
    2ff8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2ffa:	0f b6       	in	r0, 0x3f	; 63
    2ffc:	f8 94       	cli
    2ffe:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3000:	89 81       	ldd	r24, Y+1	; 0x01
    3002:	9a 81       	ldd	r25, Y+2	; 0x02
    3004:	fc 01       	movw	r30, r24
    3006:	80 81       	ld	r24, Z
    3008:	91 81       	ldd	r25, Z+1	; 0x01
    300a:	29 81       	ldd	r18, Y+1	; 0x01
    300c:	3a 81       	ldd	r19, Y+2	; 0x02
    300e:	f9 01       	movw	r30, r18
    3010:	23 8d       	ldd	r18, Z+27	; 0x1b
    3012:	42 2f       	mov	r20, r18
    3014:	50 e0       	ldi	r21, 0x00	; 0
    3016:	29 81       	ldd	r18, Y+1	; 0x01
    3018:	3a 81       	ldd	r19, Y+2	; 0x02
    301a:	f9 01       	movw	r30, r18
    301c:	24 8d       	ldd	r18, Z+28	; 0x1c
    301e:	22 2f       	mov	r18, r18
    3020:	30 e0       	ldi	r19, 0x00	; 0
    3022:	42 9f       	mul	r20, r18
    3024:	b0 01       	movw	r22, r0
    3026:	43 9f       	mul	r20, r19
    3028:	70 0d       	add	r23, r0
    302a:	52 9f       	mul	r21, r18
    302c:	70 0d       	add	r23, r0
    302e:	11 24       	eor	r1, r1
    3030:	9b 01       	movw	r18, r22
    3032:	28 0f       	add	r18, r24
    3034:	39 1f       	adc	r19, r25
    3036:	89 81       	ldd	r24, Y+1	; 0x01
    3038:	9a 81       	ldd	r25, Y+2	; 0x02
    303a:	fc 01       	movw	r30, r24
    303c:	35 83       	std	Z+5, r19	; 0x05
    303e:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	9a 81       	ldd	r25, Y+2	; 0x02
    3044:	fc 01       	movw	r30, r24
    3046:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3048:	89 81       	ldd	r24, Y+1	; 0x01
    304a:	9a 81       	ldd	r25, Y+2	; 0x02
    304c:	fc 01       	movw	r30, r24
    304e:	20 81       	ld	r18, Z
    3050:	31 81       	ldd	r19, Z+1	; 0x01
    3052:	89 81       	ldd	r24, Y+1	; 0x01
    3054:	9a 81       	ldd	r25, Y+2	; 0x02
    3056:	fc 01       	movw	r30, r24
    3058:	33 83       	std	Z+3, r19	; 0x03
    305a:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    305c:	89 81       	ldd	r24, Y+1	; 0x01
    305e:	9a 81       	ldd	r25, Y+2	; 0x02
    3060:	fc 01       	movw	r30, r24
    3062:	20 81       	ld	r18, Z
    3064:	31 81       	ldd	r19, Z+1	; 0x01
    3066:	89 81       	ldd	r24, Y+1	; 0x01
    3068:	9a 81       	ldd	r25, Y+2	; 0x02
    306a:	fc 01       	movw	r30, r24
    306c:	83 8d       	ldd	r24, Z+27	; 0x1b
    306e:	88 2f       	mov	r24, r24
    3070:	90 e0       	ldi	r25, 0x00	; 0
    3072:	bc 01       	movw	r22, r24
    3074:	61 50       	subi	r22, 0x01	; 1
    3076:	71 09       	sbc	r23, r1
    3078:	89 81       	ldd	r24, Y+1	; 0x01
    307a:	9a 81       	ldd	r25, Y+2	; 0x02
    307c:	fc 01       	movw	r30, r24
    307e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3080:	48 2f       	mov	r20, r24
    3082:	50 e0       	ldi	r21, 0x00	; 0
    3084:	64 9f       	mul	r22, r20
    3086:	c0 01       	movw	r24, r0
    3088:	65 9f       	mul	r22, r21
    308a:	90 0d       	add	r25, r0
    308c:	74 9f       	mul	r23, r20
    308e:	90 0d       	add	r25, r0
    3090:	11 24       	eor	r1, r1
    3092:	28 0f       	add	r18, r24
    3094:	39 1f       	adc	r19, r25
    3096:	89 81       	ldd	r24, Y+1	; 0x01
    3098:	9a 81       	ldd	r25, Y+2	; 0x02
    309a:	fc 01       	movw	r30, r24
    309c:	37 83       	std	Z+7, r19	; 0x07
    309e:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    30a0:	89 81       	ldd	r24, Y+1	; 0x01
    30a2:	9a 81       	ldd	r25, Y+2	; 0x02
    30a4:	2f ef       	ldi	r18, 0xFF	; 255
    30a6:	fc 01       	movw	r30, r24
    30a8:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    30aa:	89 81       	ldd	r24, Y+1	; 0x01
    30ac:	9a 81       	ldd	r25, Y+2	; 0x02
    30ae:	2f ef       	ldi	r18, 0xFF	; 255
    30b0:	fc 01       	movw	r30, r24
    30b2:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    30b4:	8d 81       	ldd	r24, Y+5	; 0x05
    30b6:	88 23       	and	r24, r24
    30b8:	81 f4       	brne	.+32     	; 0x30da <xQueueGenericReset+0xfc>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30ba:	89 81       	ldd	r24, Y+1	; 0x01
    30bc:	9a 81       	ldd	r25, Y+2	; 0x02
    30be:	fc 01       	movw	r30, r24
    30c0:	80 85       	ldd	r24, Z+8	; 0x08
    30c2:	88 23       	and	r24, r24
    30c4:	a1 f0       	breq	.+40     	; 0x30ee <xQueueGenericReset+0x110>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30c6:	89 81       	ldd	r24, Y+1	; 0x01
    30c8:	9a 81       	ldd	r25, Y+2	; 0x02
    30ca:	08 96       	adiw	r24, 0x08	; 8
    30cc:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    30d0:	88 23       	and	r24, r24
    30d2:	69 f0       	breq	.+26     	; 0x30ee <xQueueGenericReset+0x110>
				{
					queueYIELD_IF_USING_PREEMPTION();
    30d4:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
    30d8:	0a c0       	rjmp	.+20     	; 0x30ee <xQueueGenericReset+0x110>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    30da:	89 81       	ldd	r24, Y+1	; 0x01
    30dc:	9a 81       	ldd	r25, Y+2	; 0x02
    30de:	08 96       	adiw	r24, 0x08	; 8
    30e0:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    30e4:	89 81       	ldd	r24, Y+1	; 0x01
    30e6:	9a 81       	ldd	r25, Y+2	; 0x02
    30e8:	41 96       	adiw	r24, 0x11	; 17
    30ea:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    30ee:	0f 90       	pop	r0
    30f0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    30f2:	81 e0       	ldi	r24, 0x01	; 1
}
    30f4:	0f 90       	pop	r0
    30f6:	0f 90       	pop	r0
    30f8:	0f 90       	pop	r0
    30fa:	0f 90       	pop	r0
    30fc:	0f 90       	pop	r0
    30fe:	df 91       	pop	r29
    3100:	cf 91       	pop	r28
    3102:	08 95       	ret

00003104 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    3104:	0f 93       	push	r16
    3106:	1f 93       	push	r17
    3108:	cf 93       	push	r28
    310a:	df 93       	push	r29
    310c:	cd b7       	in	r28, 0x3d	; 61
    310e:	de b7       	in	r29, 0x3e	; 62
    3110:	29 97       	sbiw	r28, 0x09	; 9
    3112:	0f b6       	in	r0, 0x3f	; 63
    3114:	f8 94       	cli
    3116:	de bf       	out	0x3e, r29	; 62
    3118:	0f be       	out	0x3f, r0	; 63
    311a:	cd bf       	out	0x3d, r28	; 61
    311c:	8f 83       	std	Y+7, r24	; 0x07
    311e:	68 87       	std	Y+8, r22	; 0x08
    3120:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    3122:	88 85       	ldd	r24, Y+8	; 0x08
    3124:	88 23       	and	r24, r24
    3126:	19 f4       	brne	.+6      	; 0x312e <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    3128:	1a 82       	std	Y+2, r1	; 0x02
    312a:	19 82       	std	Y+1, r1	; 0x01
    312c:	0f c0       	rjmp	.+30     	; 0x314c <xQueueGenericCreate+0x48>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    312e:	8f 81       	ldd	r24, Y+7	; 0x07
    3130:	48 2f       	mov	r20, r24
    3132:	50 e0       	ldi	r21, 0x00	; 0
    3134:	88 85       	ldd	r24, Y+8	; 0x08
    3136:	28 2f       	mov	r18, r24
    3138:	30 e0       	ldi	r19, 0x00	; 0
    313a:	42 9f       	mul	r20, r18
    313c:	c0 01       	movw	r24, r0
    313e:	43 9f       	mul	r20, r19
    3140:	90 0d       	add	r25, r0
    3142:	52 9f       	mul	r21, r18
    3144:	90 0d       	add	r25, r0
    3146:	11 24       	eor	r1, r1
    3148:	9a 83       	std	Y+2, r25	; 0x02
    314a:	89 83       	std	Y+1, r24	; 0x01
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    314c:	89 81       	ldd	r24, Y+1	; 0x01
    314e:	9a 81       	ldd	r25, Y+2	; 0x02
    3150:	4f 96       	adiw	r24, 0x1f	; 31
    3152:	0e 94 b2 12 	call	0x2564	; 0x2564 <pvPortMalloc>
    3156:	9c 83       	std	Y+4, r25	; 0x04
    3158:	8b 83       	std	Y+3, r24	; 0x03

		if( pxNewQueue != NULL )
    315a:	8b 81       	ldd	r24, Y+3	; 0x03
    315c:	9c 81       	ldd	r25, Y+4	; 0x04
    315e:	89 2b       	or	r24, r25
    3160:	a1 f0       	breq	.+40     	; 0x318a <xQueueGenericCreate+0x86>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    3162:	8b 81       	ldd	r24, Y+3	; 0x03
    3164:	9c 81       	ldd	r25, Y+4	; 0x04
    3166:	9e 83       	std	Y+6, r25	; 0x06
    3168:	8d 83       	std	Y+5, r24	; 0x05
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    316a:	8d 81       	ldd	r24, Y+5	; 0x05
    316c:	9e 81       	ldd	r25, Y+6	; 0x06
    316e:	4f 96       	adiw	r24, 0x1f	; 31
    3170:	9e 83       	std	Y+6, r25	; 0x06
    3172:	8d 83       	std	Y+5, r24	; 0x05
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    3174:	2b 81       	ldd	r18, Y+3	; 0x03
    3176:	3c 81       	ldd	r19, Y+4	; 0x04
    3178:	8d 81       	ldd	r24, Y+5	; 0x05
    317a:	9e 81       	ldd	r25, Y+6	; 0x06
    317c:	89 01       	movw	r16, r18
    317e:	29 85       	ldd	r18, Y+9	; 0x09
    3180:	ac 01       	movw	r20, r24
    3182:	68 85       	ldd	r22, Y+8	; 0x08
    3184:	8f 81       	ldd	r24, Y+7	; 0x07
    3186:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    318a:	8b 81       	ldd	r24, Y+3	; 0x03
    318c:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    318e:	29 96       	adiw	r28, 0x09	; 9
    3190:	0f b6       	in	r0, 0x3f	; 63
    3192:	f8 94       	cli
    3194:	de bf       	out	0x3e, r29	; 62
    3196:	0f be       	out	0x3f, r0	; 63
    3198:	cd bf       	out	0x3d, r28	; 61
    319a:	df 91       	pop	r29
    319c:	cf 91       	pop	r28
    319e:	1f 91       	pop	r17
    31a0:	0f 91       	pop	r16
    31a2:	08 95       	ret

000031a4 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    31a4:	0f 93       	push	r16
    31a6:	1f 93       	push	r17
    31a8:	cf 93       	push	r28
    31aa:	df 93       	push	r29
    31ac:	cd b7       	in	r28, 0x3d	; 61
    31ae:	de b7       	in	r29, 0x3e	; 62
    31b0:	27 97       	sbiw	r28, 0x07	; 7
    31b2:	0f b6       	in	r0, 0x3f	; 63
    31b4:	f8 94       	cli
    31b6:	de bf       	out	0x3e, r29	; 62
    31b8:	0f be       	out	0x3f, r0	; 63
    31ba:	cd bf       	out	0x3d, r28	; 61
    31bc:	89 83       	std	Y+1, r24	; 0x01
    31be:	6a 83       	std	Y+2, r22	; 0x02
    31c0:	5c 83       	std	Y+4, r21	; 0x04
    31c2:	4b 83       	std	Y+3, r20	; 0x03
    31c4:	2d 83       	std	Y+5, r18	; 0x05
    31c6:	1f 83       	std	Y+7, r17	; 0x07
    31c8:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    31ca:	8a 81       	ldd	r24, Y+2	; 0x02
    31cc:	88 23       	and	r24, r24
    31ce:	41 f4       	brne	.+16     	; 0x31e0 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    31d0:	8e 81       	ldd	r24, Y+6	; 0x06
    31d2:	9f 81       	ldd	r25, Y+7	; 0x07
    31d4:	2e 81       	ldd	r18, Y+6	; 0x06
    31d6:	3f 81       	ldd	r19, Y+7	; 0x07
    31d8:	fc 01       	movw	r30, r24
    31da:	31 83       	std	Z+1, r19	; 0x01
    31dc:	20 83       	st	Z, r18
    31de:	07 c0       	rjmp	.+14     	; 0x31ee <prvInitialiseNewQueue+0x4a>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    31e0:	8e 81       	ldd	r24, Y+6	; 0x06
    31e2:	9f 81       	ldd	r25, Y+7	; 0x07
    31e4:	2b 81       	ldd	r18, Y+3	; 0x03
    31e6:	3c 81       	ldd	r19, Y+4	; 0x04
    31e8:	fc 01       	movw	r30, r24
    31ea:	31 83       	std	Z+1, r19	; 0x01
    31ec:	20 83       	st	Z, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    31ee:	8e 81       	ldd	r24, Y+6	; 0x06
    31f0:	9f 81       	ldd	r25, Y+7	; 0x07
    31f2:	29 81       	ldd	r18, Y+1	; 0x01
    31f4:	fc 01       	movw	r30, r24
    31f6:	23 8f       	std	Z+27, r18	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    31f8:	8e 81       	ldd	r24, Y+6	; 0x06
    31fa:	9f 81       	ldd	r25, Y+7	; 0x07
    31fc:	2a 81       	ldd	r18, Y+2	; 0x02
    31fe:	fc 01       	movw	r30, r24
    3200:	24 8f       	std	Z+28, r18	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3202:	8e 81       	ldd	r24, Y+6	; 0x06
    3204:	9f 81       	ldd	r25, Y+7	; 0x07
    3206:	61 e0       	ldi	r22, 0x01	; 1
    3208:	0e 94 ef 17 	call	0x2fde	; 0x2fde <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    320c:	00 00       	nop
    320e:	27 96       	adiw	r28, 0x07	; 7
    3210:	0f b6       	in	r0, 0x3f	; 63
    3212:	f8 94       	cli
    3214:	de bf       	out	0x3e, r29	; 62
    3216:	0f be       	out	0x3f, r0	; 63
    3218:	cd bf       	out	0x3d, r28	; 61
    321a:	df 91       	pop	r29
    321c:	cf 91       	pop	r28
    321e:	1f 91       	pop	r17
    3220:	0f 91       	pop	r16
    3222:	08 95       	ret

00003224 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    3224:	cf 93       	push	r28
    3226:	df 93       	push	r29
    3228:	00 d0       	rcall	.+0      	; 0x322a <prvInitialiseMutex+0x6>
    322a:	cd b7       	in	r28, 0x3d	; 61
    322c:	de b7       	in	r29, 0x3e	; 62
    322e:	9a 83       	std	Y+2, r25	; 0x02
    3230:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    3232:	89 81       	ldd	r24, Y+1	; 0x01
    3234:	9a 81       	ldd	r25, Y+2	; 0x02
    3236:	89 2b       	or	r24, r25
    3238:	b9 f0       	breq	.+46     	; 0x3268 <prvInitialiseMutex+0x44>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    323a:	89 81       	ldd	r24, Y+1	; 0x01
    323c:	9a 81       	ldd	r25, Y+2	; 0x02
    323e:	fc 01       	movw	r30, r24
    3240:	15 82       	std	Z+5, r1	; 0x05
    3242:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    3244:	89 81       	ldd	r24, Y+1	; 0x01
    3246:	9a 81       	ldd	r25, Y+2	; 0x02
    3248:	fc 01       	movw	r30, r24
    324a:	11 82       	std	Z+1, r1	; 0x01
    324c:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    324e:	89 81       	ldd	r24, Y+1	; 0x01
    3250:	9a 81       	ldd	r25, Y+2	; 0x02
    3252:	fc 01       	movw	r30, r24
    3254:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    3256:	89 81       	ldd	r24, Y+1	; 0x01
    3258:	9a 81       	ldd	r25, Y+2	; 0x02
    325a:	20 e0       	ldi	r18, 0x00	; 0
    325c:	40 e0       	ldi	r20, 0x00	; 0
    325e:	50 e0       	ldi	r21, 0x00	; 0
    3260:	60 e0       	ldi	r22, 0x00	; 0
    3262:	70 e0       	ldi	r23, 0x00	; 0
    3264:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    3268:	00 00       	nop
    326a:	0f 90       	pop	r0
    326c:	0f 90       	pop	r0
    326e:	df 91       	pop	r29
    3270:	cf 91       	pop	r28
    3272:	08 95       	ret

00003274 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    3274:	cf 93       	push	r28
    3276:	df 93       	push	r29
    3278:	00 d0       	rcall	.+0      	; 0x327a <xQueueCreateMutex+0x6>
    327a:	00 d0       	rcall	.+0      	; 0x327c <xQueueCreateMutex+0x8>
    327c:	1f 92       	push	r1
    327e:	cd b7       	in	r28, 0x3d	; 61
    3280:	de b7       	in	r29, 0x3e	; 62
    3282:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    3284:	81 e0       	ldi	r24, 0x01	; 1
    3286:	89 83       	std	Y+1, r24	; 0x01
    3288:	1a 82       	std	Y+2, r1	; 0x02

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    328a:	4d 81       	ldd	r20, Y+5	; 0x05
    328c:	6a 81       	ldd	r22, Y+2	; 0x02
    328e:	89 81       	ldd	r24, Y+1	; 0x01
    3290:	0e 94 82 18 	call	0x3104	; 0x3104 <xQueueGenericCreate>
    3294:	9c 83       	std	Y+4, r25	; 0x04
    3296:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    3298:	8b 81       	ldd	r24, Y+3	; 0x03
    329a:	9c 81       	ldd	r25, Y+4	; 0x04
    329c:	0e 94 12 19 	call	0x3224	; 0x3224 <prvInitialiseMutex>

		return xNewQueue;
    32a0:	8b 81       	ldd	r24, Y+3	; 0x03
    32a2:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    32a4:	0f 90       	pop	r0
    32a6:	0f 90       	pop	r0
    32a8:	0f 90       	pop	r0
    32aa:	0f 90       	pop	r0
    32ac:	0f 90       	pop	r0
    32ae:	df 91       	pop	r29
    32b0:	cf 91       	pop	r28
    32b2:	08 95       	ret

000032b4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    32b4:	cf 93       	push	r28
    32b6:	df 93       	push	r29
    32b8:	cd b7       	in	r28, 0x3d	; 61
    32ba:	de b7       	in	r29, 0x3e	; 62
    32bc:	2e 97       	sbiw	r28, 0x0e	; 14
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	de bf       	out	0x3e, r29	; 62
    32c4:	0f be       	out	0x3f, r0	; 63
    32c6:	cd bf       	out	0x3d, r28	; 61
    32c8:	99 87       	std	Y+9, r25	; 0x09
    32ca:	88 87       	std	Y+8, r24	; 0x08
    32cc:	7b 87       	std	Y+11, r23	; 0x0b
    32ce:	6a 87       	std	Y+10, r22	; 0x0a
    32d0:	5d 87       	std	Y+13, r21	; 0x0d
    32d2:	4c 87       	std	Y+12, r20	; 0x0c
    32d4:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    32d6:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    32d8:	88 85       	ldd	r24, Y+8	; 0x08
    32da:	99 85       	ldd	r25, Y+9	; 0x09
    32dc:	9b 83       	std	Y+3, r25	; 0x03
    32de:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    32e0:	0f b6       	in	r0, 0x3f	; 63
    32e2:	f8 94       	cli
    32e4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    32e6:	8a 81       	ldd	r24, Y+2	; 0x02
    32e8:	9b 81       	ldd	r25, Y+3	; 0x03
    32ea:	fc 01       	movw	r30, r24
    32ec:	22 8d       	ldd	r18, Z+26	; 0x1a
    32ee:	8a 81       	ldd	r24, Y+2	; 0x02
    32f0:	9b 81       	ldd	r25, Y+3	; 0x03
    32f2:	fc 01       	movw	r30, r24
    32f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    32f6:	28 17       	cp	r18, r24
    32f8:	18 f0       	brcs	.+6      	; 0x3300 <xQueueGenericSend+0x4c>
    32fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    32fc:	82 30       	cpi	r24, 0x02	; 2
    32fe:	11 f5       	brne	.+68     	; 0x3344 <xQueueGenericSend+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3300:	2a 85       	ldd	r18, Y+10	; 0x0a
    3302:	3b 85       	ldd	r19, Y+11	; 0x0b
    3304:	8a 81       	ldd	r24, Y+2	; 0x02
    3306:	9b 81       	ldd	r25, Y+3	; 0x03
    3308:	4e 85       	ldd	r20, Y+14	; 0x0e
    330a:	b9 01       	movw	r22, r18
    330c:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <prvCopyDataToQueue>
    3310:	8c 83       	std	Y+4, r24	; 0x04

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3312:	8a 81       	ldd	r24, Y+2	; 0x02
    3314:	9b 81       	ldd	r25, Y+3	; 0x03
    3316:	fc 01       	movw	r30, r24
    3318:	81 89       	ldd	r24, Z+17	; 0x11
    331a:	88 23       	and	r24, r24
    331c:	51 f0       	breq	.+20     	; 0x3332 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    331e:	8a 81       	ldd	r24, Y+2	; 0x02
    3320:	9b 81       	ldd	r25, Y+3	; 0x03
    3322:	41 96       	adiw	r24, 0x11	; 17
    3324:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    3328:	88 23       	and	r24, r24
    332a:	41 f0       	breq	.+16     	; 0x333c <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    332c:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
    3330:	05 c0       	rjmp	.+10     	; 0x333c <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3332:	8c 81       	ldd	r24, Y+4	; 0x04
    3334:	88 23       	and	r24, r24
    3336:	11 f0       	breq	.+4      	; 0x333c <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3338:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    333c:	0f 90       	pop	r0
    333e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3340:	81 e0       	ldi	r24, 0x01	; 1
    3342:	60 c0       	rjmp	.+192    	; 0x3404 <xQueueGenericSend+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3344:	8c 85       	ldd	r24, Y+12	; 0x0c
    3346:	9d 85       	ldd	r25, Y+13	; 0x0d
    3348:	89 2b       	or	r24, r25
    334a:	21 f4       	brne	.+8      	; 0x3354 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    334c:	0f 90       	pop	r0
    334e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3350:	80 e0       	ldi	r24, 0x00	; 0
    3352:	58 c0       	rjmp	.+176    	; 0x3404 <xQueueGenericSend+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    3354:	89 81       	ldd	r24, Y+1	; 0x01
    3356:	88 23       	and	r24, r24
    3358:	31 f4       	brne	.+12     	; 0x3366 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    335a:	ce 01       	movw	r24, r28
    335c:	05 96       	adiw	r24, 0x05	; 5
    335e:	0e 94 65 28 	call	0x50ca	; 0x50ca <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3362:	81 e0       	ldi	r24, 0x01	; 1
    3364:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3366:	0f 90       	pop	r0
    3368:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    336a:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    336e:	0f b6       	in	r0, 0x3f	; 63
    3370:	f8 94       	cli
    3372:	0f 92       	push	r0
    3374:	8a 81       	ldd	r24, Y+2	; 0x02
    3376:	9b 81       	ldd	r25, Y+3	; 0x03
    3378:	fc 01       	movw	r30, r24
    337a:	85 8d       	ldd	r24, Z+29	; 0x1d
    337c:	8f 3f       	cpi	r24, 0xFF	; 255
    337e:	21 f4       	brne	.+8      	; 0x3388 <xQueueGenericSend+0xd4>
    3380:	8a 81       	ldd	r24, Y+2	; 0x02
    3382:	9b 81       	ldd	r25, Y+3	; 0x03
    3384:	fc 01       	movw	r30, r24
    3386:	15 8e       	std	Z+29, r1	; 0x1d
    3388:	8a 81       	ldd	r24, Y+2	; 0x02
    338a:	9b 81       	ldd	r25, Y+3	; 0x03
    338c:	fc 01       	movw	r30, r24
    338e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3390:	8f 3f       	cpi	r24, 0xFF	; 255
    3392:	21 f4       	brne	.+8      	; 0x339c <xQueueGenericSend+0xe8>
    3394:	8a 81       	ldd	r24, Y+2	; 0x02
    3396:	9b 81       	ldd	r25, Y+3	; 0x03
    3398:	fc 01       	movw	r30, r24
    339a:	16 8e       	std	Z+30, r1	; 0x1e
    339c:	0f 90       	pop	r0
    339e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    33a0:	9e 01       	movw	r18, r28
    33a2:	24 5f       	subi	r18, 0xF4	; 244
    33a4:	3f 4f       	sbci	r19, 0xFF	; 255
    33a6:	ce 01       	movw	r24, r28
    33a8:	05 96       	adiw	r24, 0x05	; 5
    33aa:	b9 01       	movw	r22, r18
    33ac:	0e 94 81 28 	call	0x5102	; 0x5102 <xTaskCheckForTimeOut>
    33b0:	88 23       	and	r24, r24
    33b2:	09 f5       	brne	.+66     	; 0x33f6 <xQueueGenericSend+0x142>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    33b4:	8a 81       	ldd	r24, Y+2	; 0x02
    33b6:	9b 81       	ldd	r25, Y+3	; 0x03
    33b8:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <prvIsQueueFull>
    33bc:	88 23       	and	r24, r24
    33be:	a1 f0       	breq	.+40     	; 0x33e8 <xQueueGenericSend+0x134>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    33c0:	2c 85       	ldd	r18, Y+12	; 0x0c
    33c2:	3d 85       	ldd	r19, Y+13	; 0x0d
    33c4:	8a 81       	ldd	r24, Y+2	; 0x02
    33c6:	9b 81       	ldd	r25, Y+3	; 0x03
    33c8:	08 96       	adiw	r24, 0x08	; 8
    33ca:	b9 01       	movw	r22, r18
    33cc:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    33d0:	8a 81       	ldd	r24, Y+2	; 0x02
    33d2:	9b 81       	ldd	r25, Y+3	; 0x03
    33d4:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    33d8:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    33dc:	88 23       	and	r24, r24
    33de:	09 f0       	breq	.+2      	; 0x33e2 <xQueueGenericSend+0x12e>
    33e0:	7f cf       	rjmp	.-258    	; 0x32e0 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    33e2:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
    33e6:	7c cf       	rjmp	.-264    	; 0x32e0 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    33e8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ea:	9b 81       	ldd	r25, Y+3	; 0x03
    33ec:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    33f0:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    33f4:	75 cf       	rjmp	.-278    	; 0x32e0 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    33f6:	8a 81       	ldd	r24, Y+2	; 0x02
    33f8:	9b 81       	ldd	r25, Y+3	; 0x03
    33fa:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    33fe:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3402:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    3404:	2e 96       	adiw	r28, 0x0e	; 14
    3406:	0f b6       	in	r0, 0x3f	; 63
    3408:	f8 94       	cli
    340a:	de bf       	out	0x3e, r29	; 62
    340c:	0f be       	out	0x3f, r0	; 63
    340e:	cd bf       	out	0x3d, r28	; 61
    3410:	df 91       	pop	r29
    3412:	cf 91       	pop	r28
    3414:	08 95       	ret

00003416 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3416:	cf 93       	push	r28
    3418:	df 93       	push	r29
    341a:	cd b7       	in	r28, 0x3d	; 61
    341c:	de b7       	in	r29, 0x3e	; 62
    341e:	2c 97       	sbiw	r28, 0x0c	; 12
    3420:	0f b6       	in	r0, 0x3f	; 63
    3422:	f8 94       	cli
    3424:	de bf       	out	0x3e, r29	; 62
    3426:	0f be       	out	0x3f, r0	; 63
    3428:	cd bf       	out	0x3d, r28	; 61
    342a:	9f 83       	std	Y+7, r25	; 0x07
    342c:	8e 83       	std	Y+6, r24	; 0x06
    342e:	79 87       	std	Y+9, r23	; 0x09
    3430:	68 87       	std	Y+8, r22	; 0x08
    3432:	5b 87       	std	Y+11, r21	; 0x0b
    3434:	4a 87       	std	Y+10, r20	; 0x0a
    3436:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3438:	8e 81       	ldd	r24, Y+6	; 0x06
    343a:	9f 81       	ldd	r25, Y+7	; 0x07
    343c:	9b 83       	std	Y+3, r25	; 0x03
    343e:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3440:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3442:	8a 81       	ldd	r24, Y+2	; 0x02
    3444:	9b 81       	ldd	r25, Y+3	; 0x03
    3446:	fc 01       	movw	r30, r24
    3448:	22 8d       	ldd	r18, Z+26	; 0x1a
    344a:	8a 81       	ldd	r24, Y+2	; 0x02
    344c:	9b 81       	ldd	r25, Y+3	; 0x03
    344e:	fc 01       	movw	r30, r24
    3450:	83 8d       	ldd	r24, Z+27	; 0x1b
    3452:	28 17       	cp	r18, r24
    3454:	18 f0       	brcs	.+6      	; 0x345c <xQueueGenericSendFromISR+0x46>
    3456:	8c 85       	ldd	r24, Y+12	; 0x0c
    3458:	82 30       	cpi	r24, 0x02	; 2
    345a:	89 f5       	brne	.+98     	; 0x34be <xQueueGenericSendFromISR+0xa8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    345c:	8a 81       	ldd	r24, Y+2	; 0x02
    345e:	9b 81       	ldd	r25, Y+3	; 0x03
    3460:	fc 01       	movw	r30, r24
    3462:	86 8d       	ldd	r24, Z+30	; 0x1e
    3464:	8d 83       	std	Y+5, r24	; 0x05
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3466:	28 85       	ldd	r18, Y+8	; 0x08
    3468:	39 85       	ldd	r19, Y+9	; 0x09
    346a:	8a 81       	ldd	r24, Y+2	; 0x02
    346c:	9b 81       	ldd	r25, Y+3	; 0x03
    346e:	4c 85       	ldd	r20, Y+12	; 0x0c
    3470:	b9 01       	movw	r22, r18
    3472:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3476:	8d 81       	ldd	r24, Y+5	; 0x05
    3478:	8f 3f       	cpi	r24, 0xFF	; 255
    347a:	b9 f4       	brne	.+46     	; 0x34aa <xQueueGenericSendFromISR+0x94>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    347c:	8a 81       	ldd	r24, Y+2	; 0x02
    347e:	9b 81       	ldd	r25, Y+3	; 0x03
    3480:	fc 01       	movw	r30, r24
    3482:	81 89       	ldd	r24, Z+17	; 0x11
    3484:	88 23       	and	r24, r24
    3486:	c1 f0       	breq	.+48     	; 0x34b8 <xQueueGenericSendFromISR+0xa2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3488:	8a 81       	ldd	r24, Y+2	; 0x02
    348a:	9b 81       	ldd	r25, Y+3	; 0x03
    348c:	41 96       	adiw	r24, 0x11	; 17
    348e:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    3492:	88 23       	and	r24, r24
    3494:	89 f0       	breq	.+34     	; 0x34b8 <xQueueGenericSendFromISR+0xa2>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3496:	8a 85       	ldd	r24, Y+10	; 0x0a
    3498:	9b 85       	ldd	r25, Y+11	; 0x0b
    349a:	89 2b       	or	r24, r25
    349c:	69 f0       	breq	.+26     	; 0x34b8 <xQueueGenericSendFromISR+0xa2>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    349e:	8a 85       	ldd	r24, Y+10	; 0x0a
    34a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    34a2:	21 e0       	ldi	r18, 0x01	; 1
    34a4:	fc 01       	movw	r30, r24
    34a6:	20 83       	st	Z, r18
    34a8:	07 c0       	rjmp	.+14     	; 0x34b8 <xQueueGenericSendFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    34aa:	8d 81       	ldd	r24, Y+5	; 0x05
    34ac:	8f 5f       	subi	r24, 0xFF	; 255
    34ae:	28 2f       	mov	r18, r24
    34b0:	8a 81       	ldd	r24, Y+2	; 0x02
    34b2:	9b 81       	ldd	r25, Y+3	; 0x03
    34b4:	fc 01       	movw	r30, r24
    34b6:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    34b8:	81 e0       	ldi	r24, 0x01	; 1
    34ba:	89 83       	std	Y+1, r24	; 0x01
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
    34bc:	01 c0       	rjmp	.+2      	; 0x34c0 <xQueueGenericSendFromISR+0xaa>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    34be:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    34c0:	89 81       	ldd	r24, Y+1	; 0x01
}
    34c2:	2c 96       	adiw	r28, 0x0c	; 12
    34c4:	0f b6       	in	r0, 0x3f	; 63
    34c6:	f8 94       	cli
    34c8:	de bf       	out	0x3e, r29	; 62
    34ca:	0f be       	out	0x3f, r0	; 63
    34cc:	cd bf       	out	0x3d, r28	; 61
    34ce:	df 91       	pop	r29
    34d0:	cf 91       	pop	r28
    34d2:	08 95       	ret

000034d4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    34d4:	cf 93       	push	r28
    34d6:	df 93       	push	r29
    34d8:	cd b7       	in	r28, 0x3d	; 61
    34da:	de b7       	in	r29, 0x3e	; 62
    34dc:	2a 97       	sbiw	r28, 0x0a	; 10
    34de:	0f b6       	in	r0, 0x3f	; 63
    34e0:	f8 94       	cli
    34e2:	de bf       	out	0x3e, r29	; 62
    34e4:	0f be       	out	0x3f, r0	; 63
    34e6:	cd bf       	out	0x3d, r28	; 61
    34e8:	98 87       	std	Y+8, r25	; 0x08
    34ea:	8f 83       	std	Y+7, r24	; 0x07
    34ec:	7a 87       	std	Y+10, r23	; 0x0a
    34ee:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    34f0:	8f 81       	ldd	r24, Y+7	; 0x07
    34f2:	98 85       	ldd	r25, Y+8	; 0x08
    34f4:	9b 83       	std	Y+3, r25	; 0x03
    34f6:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    34f8:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    34fa:	8a 81       	ldd	r24, Y+2	; 0x02
    34fc:	9b 81       	ldd	r25, Y+3	; 0x03
    34fe:	fc 01       	movw	r30, r24
    3500:	82 8d       	ldd	r24, Z+26	; 0x1a
    3502:	8d 83       	std	Y+5, r24	; 0x05

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    3504:	8a 81       	ldd	r24, Y+2	; 0x02
    3506:	9b 81       	ldd	r25, Y+3	; 0x03
    3508:	fc 01       	movw	r30, r24
    350a:	93 8d       	ldd	r25, Z+27	; 0x1b
    350c:	8d 81       	ldd	r24, Y+5	; 0x05
    350e:	89 17       	cp	r24, r25
    3510:	80 f5       	brcc	.+96     	; 0x3572 <xQueueGiveFromISR+0x9e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3512:	8a 81       	ldd	r24, Y+2	; 0x02
    3514:	9b 81       	ldd	r25, Y+3	; 0x03
    3516:	fc 01       	movw	r30, r24
    3518:	86 8d       	ldd	r24, Z+30	; 0x1e
    351a:	8e 83       	std	Y+6, r24	; 0x06
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    351c:	8d 81       	ldd	r24, Y+5	; 0x05
    351e:	21 e0       	ldi	r18, 0x01	; 1
    3520:	28 0f       	add	r18, r24
    3522:	8a 81       	ldd	r24, Y+2	; 0x02
    3524:	9b 81       	ldd	r25, Y+3	; 0x03
    3526:	fc 01       	movw	r30, r24
    3528:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    352a:	8e 81       	ldd	r24, Y+6	; 0x06
    352c:	8f 3f       	cpi	r24, 0xFF	; 255
    352e:	b9 f4       	brne	.+46     	; 0x355e <xQueueGiveFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3530:	8a 81       	ldd	r24, Y+2	; 0x02
    3532:	9b 81       	ldd	r25, Y+3	; 0x03
    3534:	fc 01       	movw	r30, r24
    3536:	81 89       	ldd	r24, Z+17	; 0x11
    3538:	88 23       	and	r24, r24
    353a:	c1 f0       	breq	.+48     	; 0x356c <xQueueGiveFromISR+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    353c:	8a 81       	ldd	r24, Y+2	; 0x02
    353e:	9b 81       	ldd	r25, Y+3	; 0x03
    3540:	41 96       	adiw	r24, 0x11	; 17
    3542:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    3546:	88 23       	and	r24, r24
    3548:	89 f0       	breq	.+34     	; 0x356c <xQueueGiveFromISR+0x98>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    354a:	89 85       	ldd	r24, Y+9	; 0x09
    354c:	9a 85       	ldd	r25, Y+10	; 0x0a
    354e:	89 2b       	or	r24, r25
    3550:	69 f0       	breq	.+26     	; 0x356c <xQueueGiveFromISR+0x98>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3552:	89 85       	ldd	r24, Y+9	; 0x09
    3554:	9a 85       	ldd	r25, Y+10	; 0x0a
    3556:	21 e0       	ldi	r18, 0x01	; 1
    3558:	fc 01       	movw	r30, r24
    355a:	20 83       	st	Z, r18
    355c:	07 c0       	rjmp	.+14     	; 0x356c <xQueueGiveFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    355e:	8e 81       	ldd	r24, Y+6	; 0x06
    3560:	8f 5f       	subi	r24, 0xFF	; 255
    3562:	28 2f       	mov	r18, r24
    3564:	8a 81       	ldd	r24, Y+2	; 0x02
    3566:	9b 81       	ldd	r25, Y+3	; 0x03
    3568:	fc 01       	movw	r30, r24
    356a:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    356c:	81 e0       	ldi	r24, 0x01	; 1
    356e:	89 83       	std	Y+1, r24	; 0x01
    3570:	01 c0       	rjmp	.+2      	; 0x3574 <xQueueGiveFromISR+0xa0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3572:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3574:	89 81       	ldd	r24, Y+1	; 0x01
}
    3576:	2a 96       	adiw	r28, 0x0a	; 10
    3578:	0f b6       	in	r0, 0x3f	; 63
    357a:	f8 94       	cli
    357c:	de bf       	out	0x3e, r29	; 62
    357e:	0f be       	out	0x3f, r0	; 63
    3580:	cd bf       	out	0x3d, r28	; 61
    3582:	df 91       	pop	r29
    3584:	cf 91       	pop	r28
    3586:	08 95       	ret

00003588 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3588:	cf 93       	push	r28
    358a:	df 93       	push	r29
    358c:	cd b7       	in	r28, 0x3d	; 61
    358e:	de b7       	in	r29, 0x3e	; 62
    3590:	2d 97       	sbiw	r28, 0x0d	; 13
    3592:	0f b6       	in	r0, 0x3f	; 63
    3594:	f8 94       	cli
    3596:	de bf       	out	0x3e, r29	; 62
    3598:	0f be       	out	0x3f, r0	; 63
    359a:	cd bf       	out	0x3d, r28	; 61
    359c:	99 87       	std	Y+9, r25	; 0x09
    359e:	88 87       	std	Y+8, r24	; 0x08
    35a0:	7b 87       	std	Y+11, r23	; 0x0b
    35a2:	6a 87       	std	Y+10, r22	; 0x0a
    35a4:	5d 87       	std	Y+13, r21	; 0x0d
    35a6:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    35a8:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    35aa:	88 85       	ldd	r24, Y+8	; 0x08
    35ac:	99 85       	ldd	r25, Y+9	; 0x09
    35ae:	9b 83       	std	Y+3, r25	; 0x03
    35b0:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    35b2:	0f b6       	in	r0, 0x3f	; 63
    35b4:	f8 94       	cli
    35b6:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    35b8:	8a 81       	ldd	r24, Y+2	; 0x02
    35ba:	9b 81       	ldd	r25, Y+3	; 0x03
    35bc:	fc 01       	movw	r30, r24
    35be:	82 8d       	ldd	r24, Z+26	; 0x1a
    35c0:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    35c2:	8c 81       	ldd	r24, Y+4	; 0x04
    35c4:	88 23       	and	r24, r24
    35c6:	09 f1       	breq	.+66     	; 0x360a <xQueueReceive+0x82>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    35c8:	2a 85       	ldd	r18, Y+10	; 0x0a
    35ca:	3b 85       	ldd	r19, Y+11	; 0x0b
    35cc:	8a 81       	ldd	r24, Y+2	; 0x02
    35ce:	9b 81       	ldd	r25, Y+3	; 0x03
    35d0:	b9 01       	movw	r22, r18
    35d2:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    35d6:	8c 81       	ldd	r24, Y+4	; 0x04
    35d8:	2f ef       	ldi	r18, 0xFF	; 255
    35da:	28 0f       	add	r18, r24
    35dc:	8a 81       	ldd	r24, Y+2	; 0x02
    35de:	9b 81       	ldd	r25, Y+3	; 0x03
    35e0:	fc 01       	movw	r30, r24
    35e2:	22 8f       	std	Z+26, r18	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35e4:	8a 81       	ldd	r24, Y+2	; 0x02
    35e6:	9b 81       	ldd	r25, Y+3	; 0x03
    35e8:	fc 01       	movw	r30, r24
    35ea:	80 85       	ldd	r24, Z+8	; 0x08
    35ec:	88 23       	and	r24, r24
    35ee:	49 f0       	breq	.+18     	; 0x3602 <xQueueReceive+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    35f0:	8a 81       	ldd	r24, Y+2	; 0x02
    35f2:	9b 81       	ldd	r25, Y+3	; 0x03
    35f4:	08 96       	adiw	r24, 0x08	; 8
    35f6:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    35fa:	88 23       	and	r24, r24
    35fc:	11 f0       	breq	.+4      	; 0x3602 <xQueueReceive+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    35fe:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3602:	0f 90       	pop	r0
    3604:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3606:	81 e0       	ldi	r24, 0x01	; 1
    3608:	67 c0       	rjmp	.+206    	; 0x36d8 <xQueueReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    360a:	8c 85       	ldd	r24, Y+12	; 0x0c
    360c:	9d 85       	ldd	r25, Y+13	; 0x0d
    360e:	89 2b       	or	r24, r25
    3610:	21 f4       	brne	.+8      	; 0x361a <xQueueReceive+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3612:	0f 90       	pop	r0
    3614:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3616:	80 e0       	ldi	r24, 0x00	; 0
    3618:	5f c0       	rjmp	.+190    	; 0x36d8 <xQueueReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    361a:	89 81       	ldd	r24, Y+1	; 0x01
    361c:	88 23       	and	r24, r24
    361e:	31 f4       	brne	.+12     	; 0x362c <xQueueReceive+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3620:	ce 01       	movw	r24, r28
    3622:	05 96       	adiw	r24, 0x05	; 5
    3624:	0e 94 65 28 	call	0x50ca	; 0x50ca <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3628:	81 e0       	ldi	r24, 0x01	; 1
    362a:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    362c:	0f 90       	pop	r0
    362e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3630:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3634:	0f b6       	in	r0, 0x3f	; 63
    3636:	f8 94       	cli
    3638:	0f 92       	push	r0
    363a:	8a 81       	ldd	r24, Y+2	; 0x02
    363c:	9b 81       	ldd	r25, Y+3	; 0x03
    363e:	fc 01       	movw	r30, r24
    3640:	85 8d       	ldd	r24, Z+29	; 0x1d
    3642:	8f 3f       	cpi	r24, 0xFF	; 255
    3644:	21 f4       	brne	.+8      	; 0x364e <xQueueReceive+0xc6>
    3646:	8a 81       	ldd	r24, Y+2	; 0x02
    3648:	9b 81       	ldd	r25, Y+3	; 0x03
    364a:	fc 01       	movw	r30, r24
    364c:	15 8e       	std	Z+29, r1	; 0x1d
    364e:	8a 81       	ldd	r24, Y+2	; 0x02
    3650:	9b 81       	ldd	r25, Y+3	; 0x03
    3652:	fc 01       	movw	r30, r24
    3654:	86 8d       	ldd	r24, Z+30	; 0x1e
    3656:	8f 3f       	cpi	r24, 0xFF	; 255
    3658:	21 f4       	brne	.+8      	; 0x3662 <xQueueReceive+0xda>
    365a:	8a 81       	ldd	r24, Y+2	; 0x02
    365c:	9b 81       	ldd	r25, Y+3	; 0x03
    365e:	fc 01       	movw	r30, r24
    3660:	16 8e       	std	Z+30, r1	; 0x1e
    3662:	0f 90       	pop	r0
    3664:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3666:	9e 01       	movw	r18, r28
    3668:	24 5f       	subi	r18, 0xF4	; 244
    366a:	3f 4f       	sbci	r19, 0xFF	; 255
    366c:	ce 01       	movw	r24, r28
    366e:	05 96       	adiw	r24, 0x05	; 5
    3670:	b9 01       	movw	r22, r18
    3672:	0e 94 81 28 	call	0x5102	; 0x5102 <xTaskCheckForTimeOut>
    3676:	88 23       	and	r24, r24
    3678:	09 f5       	brne	.+66     	; 0x36bc <xQueueReceive+0x134>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    367a:	8a 81       	ldd	r24, Y+2	; 0x02
    367c:	9b 81       	ldd	r25, Y+3	; 0x03
    367e:	0e 94 be 1f 	call	0x3f7c	; 0x3f7c <prvIsQueueEmpty>
    3682:	88 23       	and	r24, r24
    3684:	a1 f0       	breq	.+40     	; 0x36ae <xQueueReceive+0x126>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3686:	2c 85       	ldd	r18, Y+12	; 0x0c
    3688:	3d 85       	ldd	r19, Y+13	; 0x0d
    368a:	8a 81       	ldd	r24, Y+2	; 0x02
    368c:	9b 81       	ldd	r25, Y+3	; 0x03
    368e:	41 96       	adiw	r24, 0x11	; 17
    3690:	b9 01       	movw	r22, r18
    3692:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3696:	8a 81       	ldd	r24, Y+2	; 0x02
    3698:	9b 81       	ldd	r25, Y+3	; 0x03
    369a:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    369e:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    36a2:	88 23       	and	r24, r24
    36a4:	09 f0       	breq	.+2      	; 0x36a8 <xQueueReceive+0x120>
    36a6:	85 cf       	rjmp	.-246    	; 0x35b2 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    36a8:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
    36ac:	82 cf       	rjmp	.-252    	; 0x35b2 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    36ae:	8a 81       	ldd	r24, Y+2	; 0x02
    36b0:	9b 81       	ldd	r25, Y+3	; 0x03
    36b2:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    36b6:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    36ba:	7b cf       	rjmp	.-266    	; 0x35b2 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    36bc:	8a 81       	ldd	r24, Y+2	; 0x02
    36be:	9b 81       	ldd	r25, Y+3	; 0x03
    36c0:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    36c4:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    36c8:	8a 81       	ldd	r24, Y+2	; 0x02
    36ca:	9b 81       	ldd	r25, Y+3	; 0x03
    36cc:	0e 94 be 1f 	call	0x3f7c	; 0x3f7c <prvIsQueueEmpty>
    36d0:	88 23       	and	r24, r24
    36d2:	09 f4       	brne	.+2      	; 0x36d6 <xQueueReceive+0x14e>
    36d4:	6e cf       	rjmp	.-292    	; 0x35b2 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    36d6:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    36d8:	2d 96       	adiw	r28, 0x0d	; 13
    36da:	0f b6       	in	r0, 0x3f	; 63
    36dc:	f8 94       	cli
    36de:	de bf       	out	0x3e, r29	; 62
    36e0:	0f be       	out	0x3f, r0	; 63
    36e2:	cd bf       	out	0x3d, r28	; 61
    36e4:	df 91       	pop	r29
    36e6:	cf 91       	pop	r28
    36e8:	08 95       	ret

000036ea <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    36ea:	cf 93       	push	r28
    36ec:	df 93       	push	r29
    36ee:	cd b7       	in	r28, 0x3d	; 61
    36f0:	de b7       	in	r29, 0x3e	; 62
    36f2:	2d 97       	sbiw	r28, 0x0d	; 13
    36f4:	0f b6       	in	r0, 0x3f	; 63
    36f6:	f8 94       	cli
    36f8:	de bf       	out	0x3e, r29	; 62
    36fa:	0f be       	out	0x3f, r0	; 63
    36fc:	cd bf       	out	0x3d, r28	; 61
    36fe:	9b 87       	std	Y+11, r25	; 0x0b
    3700:	8a 87       	std	Y+10, r24	; 0x0a
    3702:	7d 87       	std	Y+13, r23	; 0x0d
    3704:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3706:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3708:	8a 85       	ldd	r24, Y+10	; 0x0a
    370a:	9b 85       	ldd	r25, Y+11	; 0x0b
    370c:	9c 83       	std	Y+4, r25	; 0x04
    370e:	8b 83       	std	Y+3, r24	; 0x03

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    3710:	1a 82       	std	Y+2, r1	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3712:	0f b6       	in	r0, 0x3f	; 63
    3714:	f8 94       	cli
    3716:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3718:	8b 81       	ldd	r24, Y+3	; 0x03
    371a:	9c 81       	ldd	r25, Y+4	; 0x04
    371c:	fc 01       	movw	r30, r24
    371e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3720:	8d 83       	std	Y+5, r24	; 0x05

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3722:	8d 81       	ldd	r24, Y+5	; 0x05
    3724:	88 23       	and	r24, r24
    3726:	49 f1       	breq	.+82     	; 0x377a <xQueueSemaphoreTake+0x90>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3728:	8d 81       	ldd	r24, Y+5	; 0x05
    372a:	2f ef       	ldi	r18, 0xFF	; 255
    372c:	28 0f       	add	r18, r24
    372e:	8b 81       	ldd	r24, Y+3	; 0x03
    3730:	9c 81       	ldd	r25, Y+4	; 0x04
    3732:	fc 01       	movw	r30, r24
    3734:	22 8f       	std	Z+26, r18	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3736:	8b 81       	ldd	r24, Y+3	; 0x03
    3738:	9c 81       	ldd	r25, Y+4	; 0x04
    373a:	fc 01       	movw	r30, r24
    373c:	80 81       	ld	r24, Z
    373e:	91 81       	ldd	r25, Z+1	; 0x01
    3740:	89 2b       	or	r24, r25
    3742:	41 f4       	brne	.+16     	; 0x3754 <xQueueSemaphoreTake+0x6a>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    3744:	0e 94 ce 2b 	call	0x579c	; 0x579c <pvTaskIncrementMutexHeldCount>
    3748:	9c 01       	movw	r18, r24
    374a:	8b 81       	ldd	r24, Y+3	; 0x03
    374c:	9c 81       	ldd	r25, Y+4	; 0x04
    374e:	fc 01       	movw	r30, r24
    3750:	35 83       	std	Z+5, r19	; 0x05
    3752:	24 83       	std	Z+4, r18	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3754:	8b 81       	ldd	r24, Y+3	; 0x03
    3756:	9c 81       	ldd	r25, Y+4	; 0x04
    3758:	fc 01       	movw	r30, r24
    375a:	80 85       	ldd	r24, Z+8	; 0x08
    375c:	88 23       	and	r24, r24
    375e:	49 f0       	breq	.+18     	; 0x3772 <xQueueSemaphoreTake+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3760:	8b 81       	ldd	r24, Y+3	; 0x03
    3762:	9c 81       	ldd	r25, Y+4	; 0x04
    3764:	08 96       	adiw	r24, 0x08	; 8
    3766:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    376a:	88 23       	and	r24, r24
    376c:	11 f0       	breq	.+4      	; 0x3772 <xQueueSemaphoreTake+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
    376e:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3772:	0f 90       	pop	r0
    3774:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3776:	81 e0       	ldi	r24, 0x01	; 1
    3778:	90 c0       	rjmp	.+288    	; 0x389a <xQueueSemaphoreTake+0x1b0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    377a:	8c 85       	ldd	r24, Y+12	; 0x0c
    377c:	9d 85       	ldd	r25, Y+13	; 0x0d
    377e:	89 2b       	or	r24, r25
    3780:	21 f4       	brne	.+8      	; 0x378a <xQueueSemaphoreTake+0xa0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    3782:	0f 90       	pop	r0
    3784:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3786:	80 e0       	ldi	r24, 0x00	; 0
    3788:	88 c0       	rjmp	.+272    	; 0x389a <xQueueSemaphoreTake+0x1b0>
				}
				else if( xEntryTimeSet == pdFALSE )
    378a:	89 81       	ldd	r24, Y+1	; 0x01
    378c:	88 23       	and	r24, r24
    378e:	31 f4       	brne	.+12     	; 0x379c <xQueueSemaphoreTake+0xb2>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3790:	ce 01       	movw	r24, r28
    3792:	07 96       	adiw	r24, 0x07	; 7
    3794:	0e 94 65 28 	call	0x50ca	; 0x50ca <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3798:	81 e0       	ldi	r24, 0x01	; 1
    379a:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    379c:	0f 90       	pop	r0
    379e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    37a0:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    37a4:	0f b6       	in	r0, 0x3f	; 63
    37a6:	f8 94       	cli
    37a8:	0f 92       	push	r0
    37aa:	8b 81       	ldd	r24, Y+3	; 0x03
    37ac:	9c 81       	ldd	r25, Y+4	; 0x04
    37ae:	fc 01       	movw	r30, r24
    37b0:	85 8d       	ldd	r24, Z+29	; 0x1d
    37b2:	8f 3f       	cpi	r24, 0xFF	; 255
    37b4:	21 f4       	brne	.+8      	; 0x37be <xQueueSemaphoreTake+0xd4>
    37b6:	8b 81       	ldd	r24, Y+3	; 0x03
    37b8:	9c 81       	ldd	r25, Y+4	; 0x04
    37ba:	fc 01       	movw	r30, r24
    37bc:	15 8e       	std	Z+29, r1	; 0x1d
    37be:	8b 81       	ldd	r24, Y+3	; 0x03
    37c0:	9c 81       	ldd	r25, Y+4	; 0x04
    37c2:	fc 01       	movw	r30, r24
    37c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    37c6:	8f 3f       	cpi	r24, 0xFF	; 255
    37c8:	21 f4       	brne	.+8      	; 0x37d2 <xQueueSemaphoreTake+0xe8>
    37ca:	8b 81       	ldd	r24, Y+3	; 0x03
    37cc:	9c 81       	ldd	r25, Y+4	; 0x04
    37ce:	fc 01       	movw	r30, r24
    37d0:	16 8e       	std	Z+30, r1	; 0x1e
    37d2:	0f 90       	pop	r0
    37d4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    37d6:	9e 01       	movw	r18, r28
    37d8:	24 5f       	subi	r18, 0xF4	; 244
    37da:	3f 4f       	sbci	r19, 0xFF	; 255
    37dc:	ce 01       	movw	r24, r28
    37de:	07 96       	adiw	r24, 0x07	; 7
    37e0:	b9 01       	movw	r22, r18
    37e2:	0e 94 81 28 	call	0x5102	; 0x5102 <xTaskCheckForTimeOut>
    37e6:	88 23       	and	r24, r24
    37e8:	a9 f5       	brne	.+106    	; 0x3854 <xQueueSemaphoreTake+0x16a>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37ea:	8b 81       	ldd	r24, Y+3	; 0x03
    37ec:	9c 81       	ldd	r25, Y+4	; 0x04
    37ee:	0e 94 be 1f 	call	0x3f7c	; 0x3f7c <prvIsQueueEmpty>
    37f2:	88 23       	and	r24, r24
    37f4:	41 f1       	breq	.+80     	; 0x3846 <xQueueSemaphoreTake+0x15c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    37f6:	8b 81       	ldd	r24, Y+3	; 0x03
    37f8:	9c 81       	ldd	r25, Y+4	; 0x04
    37fa:	fc 01       	movw	r30, r24
    37fc:	80 81       	ld	r24, Z
    37fe:	91 81       	ldd	r25, Z+1	; 0x01
    3800:	89 2b       	or	r24, r25
    3802:	69 f4       	brne	.+26     	; 0x381e <xQueueSemaphoreTake+0x134>
					{
						taskENTER_CRITICAL();
    3804:	0f b6       	in	r0, 0x3f	; 63
    3806:	f8 94       	cli
    3808:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    380a:	8b 81       	ldd	r24, Y+3	; 0x03
    380c:	9c 81       	ldd	r25, Y+4	; 0x04
    380e:	fc 01       	movw	r30, r24
    3810:	84 81       	ldd	r24, Z+4	; 0x04
    3812:	95 81       	ldd	r25, Z+5	; 0x05
    3814:	0e 94 db 29 	call	0x53b6	; 0x53b6 <xTaskPriorityInherit>
    3818:	8a 83       	std	Y+2, r24	; 0x02
						}
						taskEXIT_CRITICAL();
    381a:	0f 90       	pop	r0
    381c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    381e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3820:	3d 85       	ldd	r19, Y+13	; 0x0d
    3822:	8b 81       	ldd	r24, Y+3	; 0x03
    3824:	9c 81       	ldd	r25, Y+4	; 0x04
    3826:	41 96       	adiw	r24, 0x11	; 17
    3828:	b9 01       	movw	r22, r18
    382a:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    382e:	8b 81       	ldd	r24, Y+3	; 0x03
    3830:	9c 81       	ldd	r25, Y+4	; 0x04
    3832:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3836:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    383a:	88 23       	and	r24, r24
    383c:	09 f0       	breq	.+2      	; 0x3840 <xQueueSemaphoreTake+0x156>
    383e:	69 cf       	rjmp	.-302    	; 0x3712 <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    3840:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
    3844:	66 cf       	rjmp	.-308    	; 0x3712 <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    3846:	8b 81       	ldd	r24, Y+3	; 0x03
    3848:	9c 81       	ldd	r25, Y+4	; 0x04
    384a:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    384e:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    3852:	5f cf       	rjmp	.-322    	; 0x3712 <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    3854:	8b 81       	ldd	r24, Y+3	; 0x03
    3856:	9c 81       	ldd	r25, Y+4	; 0x04
    3858:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    385c:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3860:	8b 81       	ldd	r24, Y+3	; 0x03
    3862:	9c 81       	ldd	r25, Y+4	; 0x04
    3864:	0e 94 be 1f 	call	0x3f7c	; 0x3f7c <prvIsQueueEmpty>
    3868:	88 23       	and	r24, r24
    386a:	09 f4       	brne	.+2      	; 0x386e <xQueueSemaphoreTake+0x184>
    386c:	52 cf       	rjmp	.-348    	; 0x3712 <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    386e:	8a 81       	ldd	r24, Y+2	; 0x02
    3870:	88 23       	and	r24, r24
    3872:	91 f0       	breq	.+36     	; 0x3898 <xQueueSemaphoreTake+0x1ae>
					{
						taskENTER_CRITICAL();
    3874:	0f b6       	in	r0, 0x3f	; 63
    3876:	f8 94       	cli
    3878:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    387a:	8b 81       	ldd	r24, Y+3	; 0x03
    387c:	9c 81       	ldd	r25, Y+4	; 0x04
    387e:	0e 94 1c 1e 	call	0x3c38	; 0x3c38 <prvGetDisinheritPriorityAfterTimeout>
    3882:	8e 83       	std	Y+6, r24	; 0x06
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    3884:	8b 81       	ldd	r24, Y+3	; 0x03
    3886:	9c 81       	ldd	r25, Y+4	; 0x04
    3888:	fc 01       	movw	r30, r24
    388a:	84 81       	ldd	r24, Z+4	; 0x04
    388c:	95 81       	ldd	r25, Z+5	; 0x05
    388e:	6e 81       	ldd	r22, Y+6	; 0x06
    3890:	0e 94 04 2b 	call	0x5608	; 0x5608 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    3894:	0f 90       	pop	r0
    3896:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3898:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    389a:	2d 96       	adiw	r28, 0x0d	; 13
    389c:	0f b6       	in	r0, 0x3f	; 63
    389e:	f8 94       	cli
    38a0:	de bf       	out	0x3e, r29	; 62
    38a2:	0f be       	out	0x3f, r0	; 63
    38a4:	cd bf       	out	0x3d, r28	; 61
    38a6:	df 91       	pop	r29
    38a8:	cf 91       	pop	r28
    38aa:	08 95       	ret

000038ac <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    38ac:	cf 93       	push	r28
    38ae:	df 93       	push	r29
    38b0:	cd b7       	in	r28, 0x3d	; 61
    38b2:	de b7       	in	r29, 0x3e	; 62
    38b4:	2f 97       	sbiw	r28, 0x0f	; 15
    38b6:	0f b6       	in	r0, 0x3f	; 63
    38b8:	f8 94       	cli
    38ba:	de bf       	out	0x3e, r29	; 62
    38bc:	0f be       	out	0x3f, r0	; 63
    38be:	cd bf       	out	0x3d, r28	; 61
    38c0:	9b 87       	std	Y+11, r25	; 0x0b
    38c2:	8a 87       	std	Y+10, r24	; 0x0a
    38c4:	7d 87       	std	Y+13, r23	; 0x0d
    38c6:	6c 87       	std	Y+12, r22	; 0x0c
    38c8:	5f 87       	std	Y+15, r21	; 0x0f
    38ca:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    38cc:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    38ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    38d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    38d2:	9b 83       	std	Y+3, r25	; 0x03
    38d4:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    38d6:	0f b6       	in	r0, 0x3f	; 63
    38d8:	f8 94       	cli
    38da:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    38dc:	8a 81       	ldd	r24, Y+2	; 0x02
    38de:	9b 81       	ldd	r25, Y+3	; 0x03
    38e0:	fc 01       	movw	r30, r24
    38e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    38e4:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    38e6:	8c 81       	ldd	r24, Y+4	; 0x04
    38e8:	88 23       	and	r24, r24
    38ea:	41 f1       	breq	.+80     	; 0x393c <xQueuePeek+0x90>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    38ec:	8a 81       	ldd	r24, Y+2	; 0x02
    38ee:	9b 81       	ldd	r25, Y+3	; 0x03
    38f0:	fc 01       	movw	r30, r24
    38f2:	86 81       	ldd	r24, Z+6	; 0x06
    38f4:	97 81       	ldd	r25, Z+7	; 0x07
    38f6:	9e 83       	std	Y+6, r25	; 0x06
    38f8:	8d 83       	std	Y+5, r24	; 0x05

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    38fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    38fc:	3d 85       	ldd	r19, Y+13	; 0x0d
    38fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3900:	9b 81       	ldd	r25, Y+3	; 0x03
    3902:	b9 01       	movw	r22, r18
    3904:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3908:	8a 81       	ldd	r24, Y+2	; 0x02
    390a:	9b 81       	ldd	r25, Y+3	; 0x03
    390c:	2d 81       	ldd	r18, Y+5	; 0x05
    390e:	3e 81       	ldd	r19, Y+6	; 0x06
    3910:	fc 01       	movw	r30, r24
    3912:	37 83       	std	Z+7, r19	; 0x07
    3914:	26 83       	std	Z+6, r18	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3916:	8a 81       	ldd	r24, Y+2	; 0x02
    3918:	9b 81       	ldd	r25, Y+3	; 0x03
    391a:	fc 01       	movw	r30, r24
    391c:	81 89       	ldd	r24, Z+17	; 0x11
    391e:	88 23       	and	r24, r24
    3920:	49 f0       	breq	.+18     	; 0x3934 <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3922:	8a 81       	ldd	r24, Y+2	; 0x02
    3924:	9b 81       	ldd	r25, Y+3	; 0x03
    3926:	41 96       	adiw	r24, 0x11	; 17
    3928:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    392c:	88 23       	and	r24, r24
    392e:	11 f0       	breq	.+4      	; 0x3934 <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    3930:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3934:	0f 90       	pop	r0
    3936:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3938:	81 e0       	ldi	r24, 0x01	; 1
    393a:	67 c0       	rjmp	.+206    	; 0x3a0a <xQueuePeek+0x15e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    393c:	8e 85       	ldd	r24, Y+14	; 0x0e
    393e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3940:	89 2b       	or	r24, r25
    3942:	21 f4       	brne	.+8      	; 0x394c <xQueuePeek+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3944:	0f 90       	pop	r0
    3946:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3948:	80 e0       	ldi	r24, 0x00	; 0
    394a:	5f c0       	rjmp	.+190    	; 0x3a0a <xQueuePeek+0x15e>
				}
				else if( xEntryTimeSet == pdFALSE )
    394c:	89 81       	ldd	r24, Y+1	; 0x01
    394e:	88 23       	and	r24, r24
    3950:	31 f4       	brne	.+12     	; 0x395e <xQueuePeek+0xb2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3952:	ce 01       	movw	r24, r28
    3954:	07 96       	adiw	r24, 0x07	; 7
    3956:	0e 94 65 28 	call	0x50ca	; 0x50ca <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    395a:	81 e0       	ldi	r24, 0x01	; 1
    395c:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    395e:	0f 90       	pop	r0
    3960:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3962:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3966:	0f b6       	in	r0, 0x3f	; 63
    3968:	f8 94       	cli
    396a:	0f 92       	push	r0
    396c:	8a 81       	ldd	r24, Y+2	; 0x02
    396e:	9b 81       	ldd	r25, Y+3	; 0x03
    3970:	fc 01       	movw	r30, r24
    3972:	85 8d       	ldd	r24, Z+29	; 0x1d
    3974:	8f 3f       	cpi	r24, 0xFF	; 255
    3976:	21 f4       	brne	.+8      	; 0x3980 <xQueuePeek+0xd4>
    3978:	8a 81       	ldd	r24, Y+2	; 0x02
    397a:	9b 81       	ldd	r25, Y+3	; 0x03
    397c:	fc 01       	movw	r30, r24
    397e:	15 8e       	std	Z+29, r1	; 0x1d
    3980:	8a 81       	ldd	r24, Y+2	; 0x02
    3982:	9b 81       	ldd	r25, Y+3	; 0x03
    3984:	fc 01       	movw	r30, r24
    3986:	86 8d       	ldd	r24, Z+30	; 0x1e
    3988:	8f 3f       	cpi	r24, 0xFF	; 255
    398a:	21 f4       	brne	.+8      	; 0x3994 <xQueuePeek+0xe8>
    398c:	8a 81       	ldd	r24, Y+2	; 0x02
    398e:	9b 81       	ldd	r25, Y+3	; 0x03
    3990:	fc 01       	movw	r30, r24
    3992:	16 8e       	std	Z+30, r1	; 0x1e
    3994:	0f 90       	pop	r0
    3996:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3998:	9e 01       	movw	r18, r28
    399a:	22 5f       	subi	r18, 0xF2	; 242
    399c:	3f 4f       	sbci	r19, 0xFF	; 255
    399e:	ce 01       	movw	r24, r28
    39a0:	07 96       	adiw	r24, 0x07	; 7
    39a2:	b9 01       	movw	r22, r18
    39a4:	0e 94 81 28 	call	0x5102	; 0x5102 <xTaskCheckForTimeOut>
    39a8:	88 23       	and	r24, r24
    39aa:	09 f5       	brne	.+66     	; 0x39ee <xQueuePeek+0x142>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    39ac:	8a 81       	ldd	r24, Y+2	; 0x02
    39ae:	9b 81       	ldd	r25, Y+3	; 0x03
    39b0:	0e 94 be 1f 	call	0x3f7c	; 0x3f7c <prvIsQueueEmpty>
    39b4:	88 23       	and	r24, r24
    39b6:	a1 f0       	breq	.+40     	; 0x39e0 <xQueuePeek+0x134>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    39b8:	2e 85       	ldd	r18, Y+14	; 0x0e
    39ba:	3f 85       	ldd	r19, Y+15	; 0x0f
    39bc:	8a 81       	ldd	r24, Y+2	; 0x02
    39be:	9b 81       	ldd	r25, Y+3	; 0x03
    39c0:	41 96       	adiw	r24, 0x11	; 17
    39c2:	b9 01       	movw	r22, r18
    39c4:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    39c8:	8a 81       	ldd	r24, Y+2	; 0x02
    39ca:	9b 81       	ldd	r25, Y+3	; 0x03
    39cc:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    39d0:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    39d4:	88 23       	and	r24, r24
    39d6:	09 f0       	breq	.+2      	; 0x39da <xQueuePeek+0x12e>
    39d8:	7e cf       	rjmp	.-260    	; 0x38d6 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    39da:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
    39de:	7b cf       	rjmp	.-266    	; 0x38d6 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    39e0:	8a 81       	ldd	r24, Y+2	; 0x02
    39e2:	9b 81       	ldd	r25, Y+3	; 0x03
    39e4:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    39e8:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    39ec:	74 cf       	rjmp	.-280    	; 0x38d6 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    39ee:	8a 81       	ldd	r24, Y+2	; 0x02
    39f0:	9b 81       	ldd	r25, Y+3	; 0x03
    39f2:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    39f6:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    39fa:	8a 81       	ldd	r24, Y+2	; 0x02
    39fc:	9b 81       	ldd	r25, Y+3	; 0x03
    39fe:	0e 94 be 1f 	call	0x3f7c	; 0x3f7c <prvIsQueueEmpty>
    3a02:	88 23       	and	r24, r24
    3a04:	09 f4       	brne	.+2      	; 0x3a08 <xQueuePeek+0x15c>
    3a06:	67 cf       	rjmp	.-306    	; 0x38d6 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3a08:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3a0a:	2f 96       	adiw	r28, 0x0f	; 15
    3a0c:	0f b6       	in	r0, 0x3f	; 63
    3a0e:	f8 94       	cli
    3a10:	de bf       	out	0x3e, r29	; 62
    3a12:	0f be       	out	0x3f, r0	; 63
    3a14:	cd bf       	out	0x3d, r28	; 61
    3a16:	df 91       	pop	r29
    3a18:	cf 91       	pop	r28
    3a1a:	08 95       	ret

00003a1c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3a1c:	cf 93       	push	r28
    3a1e:	df 93       	push	r29
    3a20:	cd b7       	in	r28, 0x3d	; 61
    3a22:	de b7       	in	r29, 0x3e	; 62
    3a24:	2c 97       	sbiw	r28, 0x0c	; 12
    3a26:	0f b6       	in	r0, 0x3f	; 63
    3a28:	f8 94       	cli
    3a2a:	de bf       	out	0x3e, r29	; 62
    3a2c:	0f be       	out	0x3f, r0	; 63
    3a2e:	cd bf       	out	0x3d, r28	; 61
    3a30:	98 87       	std	Y+8, r25	; 0x08
    3a32:	8f 83       	std	Y+7, r24	; 0x07
    3a34:	7a 87       	std	Y+10, r23	; 0x0a
    3a36:	69 87       	std	Y+9, r22	; 0x09
    3a38:	5c 87       	std	Y+12, r21	; 0x0c
    3a3a:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3a3c:	8f 81       	ldd	r24, Y+7	; 0x07
    3a3e:	98 85       	ldd	r25, Y+8	; 0x08
    3a40:	9b 83       	std	Y+3, r25	; 0x03
    3a42:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3a44:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3a46:	8a 81       	ldd	r24, Y+2	; 0x02
    3a48:	9b 81       	ldd	r25, Y+3	; 0x03
    3a4a:	fc 01       	movw	r30, r24
    3a4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a4e:	8d 83       	std	Y+5, r24	; 0x05

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a50:	8d 81       	ldd	r24, Y+5	; 0x05
    3a52:	88 23       	and	r24, r24
    3a54:	b9 f1       	breq	.+110    	; 0x3ac4 <xQueueReceiveFromISR+0xa8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    3a56:	8a 81       	ldd	r24, Y+2	; 0x02
    3a58:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5a:	fc 01       	movw	r30, r24
    3a5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a5e:	8e 83       	std	Y+6, r24	; 0x06

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a60:	29 85       	ldd	r18, Y+9	; 0x09
    3a62:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a64:	8a 81       	ldd	r24, Y+2	; 0x02
    3a66:	9b 81       	ldd	r25, Y+3	; 0x03
    3a68:	b9 01       	movw	r22, r18
    3a6a:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3a6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a70:	2f ef       	ldi	r18, 0xFF	; 255
    3a72:	28 0f       	add	r18, r24
    3a74:	8a 81       	ldd	r24, Y+2	; 0x02
    3a76:	9b 81       	ldd	r25, Y+3	; 0x03
    3a78:	fc 01       	movw	r30, r24
    3a7a:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    3a7c:	8e 81       	ldd	r24, Y+6	; 0x06
    3a7e:	8f 3f       	cpi	r24, 0xFF	; 255
    3a80:	b9 f4       	brne	.+46     	; 0x3ab0 <xQueueReceiveFromISR+0x94>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3a82:	8a 81       	ldd	r24, Y+2	; 0x02
    3a84:	9b 81       	ldd	r25, Y+3	; 0x03
    3a86:	fc 01       	movw	r30, r24
    3a88:	80 85       	ldd	r24, Z+8	; 0x08
    3a8a:	88 23       	and	r24, r24
    3a8c:	c1 f0       	breq	.+48     	; 0x3abe <xQueueReceiveFromISR+0xa2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a90:	9b 81       	ldd	r25, Y+3	; 0x03
    3a92:	08 96       	adiw	r24, 0x08	; 8
    3a94:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    3a98:	88 23       	and	r24, r24
    3a9a:	89 f0       	breq	.+34     	; 0x3abe <xQueueReceiveFromISR+0xa2>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3a9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3aa0:	89 2b       	or	r24, r25
    3aa2:	69 f0       	breq	.+26     	; 0x3abe <xQueueReceiveFromISR+0xa2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3aa4:	8b 85       	ldd	r24, Y+11	; 0x0b
    3aa6:	9c 85       	ldd	r25, Y+12	; 0x0c
    3aa8:	21 e0       	ldi	r18, 0x01	; 1
    3aaa:	fc 01       	movw	r30, r24
    3aac:	20 83       	st	Z, r18
    3aae:	07 c0       	rjmp	.+14     	; 0x3abe <xQueueReceiveFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3ab0:	8e 81       	ldd	r24, Y+6	; 0x06
    3ab2:	8f 5f       	subi	r24, 0xFF	; 255
    3ab4:	28 2f       	mov	r18, r24
    3ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ab8:	9b 81       	ldd	r25, Y+3	; 0x03
    3aba:	fc 01       	movw	r30, r24
    3abc:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3abe:	81 e0       	ldi	r24, 0x01	; 1
    3ac0:	89 83       	std	Y+1, r24	; 0x01
    3ac2:	01 c0       	rjmp	.+2      	; 0x3ac6 <xQueueReceiveFromISR+0xaa>
		}
		else
		{
			xReturn = pdFAIL;
    3ac4:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3ac6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ac8:	2c 96       	adiw	r28, 0x0c	; 12
    3aca:	0f b6       	in	r0, 0x3f	; 63
    3acc:	f8 94       	cli
    3ace:	de bf       	out	0x3e, r29	; 62
    3ad0:	0f be       	out	0x3f, r0	; 63
    3ad2:	cd bf       	out	0x3d, r28	; 61
    3ad4:	df 91       	pop	r29
    3ad6:	cf 91       	pop	r28
    3ad8:	08 95       	ret

00003ada <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3ada:	cf 93       	push	r28
    3adc:	df 93       	push	r29
    3ade:	cd b7       	in	r28, 0x3d	; 61
    3ae0:	de b7       	in	r29, 0x3e	; 62
    3ae2:	2a 97       	sbiw	r28, 0x0a	; 10
    3ae4:	0f b6       	in	r0, 0x3f	; 63
    3ae6:	f8 94       	cli
    3ae8:	de bf       	out	0x3e, r29	; 62
    3aea:	0f be       	out	0x3f, r0	; 63
    3aec:	cd bf       	out	0x3d, r28	; 61
    3aee:	98 87       	std	Y+8, r25	; 0x08
    3af0:	8f 83       	std	Y+7, r24	; 0x07
    3af2:	7a 87       	std	Y+10, r23	; 0x0a
    3af4:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3af6:	8f 81       	ldd	r24, Y+7	; 0x07
    3af8:	98 85       	ldd	r25, Y+8	; 0x08
    3afa:	9b 83       	std	Y+3, r25	; 0x03
    3afc:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3afe:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3b00:	8a 81       	ldd	r24, Y+2	; 0x02
    3b02:	9b 81       	ldd	r25, Y+3	; 0x03
    3b04:	fc 01       	movw	r30, r24
    3b06:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b08:	88 23       	and	r24, r24
    3b0a:	c1 f0       	breq	.+48     	; 0x3b3c <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b0e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b10:	fc 01       	movw	r30, r24
    3b12:	86 81       	ldd	r24, Z+6	; 0x06
    3b14:	97 81       	ldd	r25, Z+7	; 0x07
    3b16:	9e 83       	std	Y+6, r25	; 0x06
    3b18:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b1a:	29 85       	ldd	r18, Y+9	; 0x09
    3b1c:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    3b20:	9b 81       	ldd	r25, Y+3	; 0x03
    3b22:	b9 01       	movw	r22, r18
    3b24:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3b28:	8a 81       	ldd	r24, Y+2	; 0x02
    3b2a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b2c:	2d 81       	ldd	r18, Y+5	; 0x05
    3b2e:	3e 81       	ldd	r19, Y+6	; 0x06
    3b30:	fc 01       	movw	r30, r24
    3b32:	37 83       	std	Z+7, r19	; 0x07
    3b34:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3b36:	81 e0       	ldi	r24, 0x01	; 1
    3b38:	89 83       	std	Y+1, r24	; 0x01
    3b3a:	01 c0       	rjmp	.+2      	; 0x3b3e <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    3b3c:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b3e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b40:	2a 96       	adiw	r28, 0x0a	; 10
    3b42:	0f b6       	in	r0, 0x3f	; 63
    3b44:	f8 94       	cli
    3b46:	de bf       	out	0x3e, r29	; 62
    3b48:	0f be       	out	0x3f, r0	; 63
    3b4a:	cd bf       	out	0x3d, r28	; 61
    3b4c:	df 91       	pop	r29
    3b4e:	cf 91       	pop	r28
    3b50:	08 95       	ret

00003b52 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3b52:	cf 93       	push	r28
    3b54:	df 93       	push	r29
    3b56:	00 d0       	rcall	.+0      	; 0x3b58 <uxQueueMessagesWaiting+0x6>
    3b58:	1f 92       	push	r1
    3b5a:	cd b7       	in	r28, 0x3d	; 61
    3b5c:	de b7       	in	r29, 0x3e	; 62
    3b5e:	9b 83       	std	Y+3, r25	; 0x03
    3b60:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	f8 94       	cli
    3b66:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3b68:	8a 81       	ldd	r24, Y+2	; 0x02
    3b6a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b6c:	fc 01       	movw	r30, r24
    3b6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b70:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3b72:	0f 90       	pop	r0
    3b74:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3b76:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b78:	0f 90       	pop	r0
    3b7a:	0f 90       	pop	r0
    3b7c:	0f 90       	pop	r0
    3b7e:	df 91       	pop	r29
    3b80:	cf 91       	pop	r28
    3b82:	08 95       	ret

00003b84 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3b84:	cf 93       	push	r28
    3b86:	df 93       	push	r29
    3b88:	00 d0       	rcall	.+0      	; 0x3b8a <uxQueueSpacesAvailable+0x6>
    3b8a:	00 d0       	rcall	.+0      	; 0x3b8c <uxQueueSpacesAvailable+0x8>
    3b8c:	1f 92       	push	r1
    3b8e:	cd b7       	in	r28, 0x3d	; 61
    3b90:	de b7       	in	r29, 0x3e	; 62
    3b92:	9d 83       	std	Y+5, r25	; 0x05
    3b94:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3b96:	8c 81       	ldd	r24, Y+4	; 0x04
    3b98:	9d 81       	ldd	r25, Y+5	; 0x05
    3b9a:	9a 83       	std	Y+2, r25	; 0x02
    3b9c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3b9e:	0f b6       	in	r0, 0x3f	; 63
    3ba0:	f8 94       	cli
    3ba2:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3ba4:	89 81       	ldd	r24, Y+1	; 0x01
    3ba6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba8:	fc 01       	movw	r30, r24
    3baa:	23 8d       	ldd	r18, Z+27	; 0x1b
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
    3bae:	9a 81       	ldd	r25, Y+2	; 0x02
    3bb0:	fc 01       	movw	r30, r24
    3bb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bb4:	f2 2f       	mov	r31, r18
    3bb6:	f8 1b       	sub	r31, r24
    3bb8:	8f 2f       	mov	r24, r31
    3bba:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3bbc:	0f 90       	pop	r0
    3bbe:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3bc0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3bc2:	0f 90       	pop	r0
    3bc4:	0f 90       	pop	r0
    3bc6:	0f 90       	pop	r0
    3bc8:	0f 90       	pop	r0
    3bca:	0f 90       	pop	r0
    3bcc:	df 91       	pop	r29
    3bce:	cf 91       	pop	r28
    3bd0:	08 95       	ret

00003bd2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3bd2:	cf 93       	push	r28
    3bd4:	df 93       	push	r29
    3bd6:	00 d0       	rcall	.+0      	; 0x3bd8 <uxQueueMessagesWaitingFromISR+0x6>
    3bd8:	00 d0       	rcall	.+0      	; 0x3bda <uxQueueMessagesWaitingFromISR+0x8>
    3bda:	1f 92       	push	r1
    3bdc:	cd b7       	in	r28, 0x3d	; 61
    3bde:	de b7       	in	r29, 0x3e	; 62
    3be0:	9d 83       	std	Y+5, r25	; 0x05
    3be2:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3be4:	8c 81       	ldd	r24, Y+4	; 0x04
    3be6:	9d 81       	ldd	r25, Y+5	; 0x05
    3be8:	9a 83       	std	Y+2, r25	; 0x02
    3bea:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3bec:	89 81       	ldd	r24, Y+1	; 0x01
    3bee:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf0:	fc 01       	movw	r30, r24
    3bf2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bf4:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3bf6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3bf8:	0f 90       	pop	r0
    3bfa:	0f 90       	pop	r0
    3bfc:	0f 90       	pop	r0
    3bfe:	0f 90       	pop	r0
    3c00:	0f 90       	pop	r0
    3c02:	df 91       	pop	r29
    3c04:	cf 91       	pop	r28
    3c06:	08 95       	ret

00003c08 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3c08:	cf 93       	push	r28
    3c0a:	df 93       	push	r29
    3c0c:	00 d0       	rcall	.+0      	; 0x3c0e <vQueueDelete+0x6>
    3c0e:	00 d0       	rcall	.+0      	; 0x3c10 <vQueueDelete+0x8>
    3c10:	cd b7       	in	r28, 0x3d	; 61
    3c12:	de b7       	in	r29, 0x3e	; 62
    3c14:	9c 83       	std	Y+4, r25	; 0x04
    3c16:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3c18:	8b 81       	ldd	r24, Y+3	; 0x03
    3c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c1c:	9a 83       	std	Y+2, r25	; 0x02
    3c1e:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3c20:	89 81       	ldd	r24, Y+1	; 0x01
    3c22:	9a 81       	ldd	r25, Y+2	; 0x02
    3c24:	0e 94 07 13 	call	0x260e	; 0x260e <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3c28:	00 00       	nop
    3c2a:	0f 90       	pop	r0
    3c2c:	0f 90       	pop	r0
    3c2e:	0f 90       	pop	r0
    3c30:	0f 90       	pop	r0
    3c32:	df 91       	pop	r29
    3c34:	cf 91       	pop	r28
    3c36:	08 95       	ret

00003c38 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    3c38:	cf 93       	push	r28
    3c3a:	df 93       	push	r29
    3c3c:	00 d0       	rcall	.+0      	; 0x3c3e <prvGetDisinheritPriorityAfterTimeout+0x6>
    3c3e:	1f 92       	push	r1
    3c40:	cd b7       	in	r28, 0x3d	; 61
    3c42:	de b7       	in	r29, 0x3e	; 62
    3c44:	9b 83       	std	Y+3, r25	; 0x03
    3c46:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    3c48:	8a 81       	ldd	r24, Y+2	; 0x02
    3c4a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c4c:	fc 01       	movw	r30, r24
    3c4e:	81 89       	ldd	r24, Z+17	; 0x11
    3c50:	88 23       	and	r24, r24
    3c52:	69 f0       	breq	.+26     	; 0x3c6e <prvGetDisinheritPriorityAfterTimeout+0x36>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    3c54:	8a 81       	ldd	r24, Y+2	; 0x02
    3c56:	9b 81       	ldd	r25, Y+3	; 0x03
    3c58:	fc 01       	movw	r30, r24
    3c5a:	86 89       	ldd	r24, Z+22	; 0x16
    3c5c:	97 89       	ldd	r25, Z+23	; 0x17
    3c5e:	fc 01       	movw	r30, r24
    3c60:	80 81       	ld	r24, Z
    3c62:	91 81       	ldd	r25, Z+1	; 0x01
    3c64:	98 2f       	mov	r25, r24
    3c66:	85 e0       	ldi	r24, 0x05	; 5
    3c68:	89 1b       	sub	r24, r25
    3c6a:	89 83       	std	Y+1, r24	; 0x01
    3c6c:	01 c0       	rjmp	.+2      	; 0x3c70 <prvGetDisinheritPriorityAfterTimeout+0x38>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    3c6e:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    3c70:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3c72:	0f 90       	pop	r0
    3c74:	0f 90       	pop	r0
    3c76:	0f 90       	pop	r0
    3c78:	df 91       	pop	r29
    3c7a:	cf 91       	pop	r28
    3c7c:	08 95       	ret

00003c7e <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3c7e:	cf 93       	push	r28
    3c80:	df 93       	push	r29
    3c82:	cd b7       	in	r28, 0x3d	; 61
    3c84:	de b7       	in	r29, 0x3e	; 62
    3c86:	27 97       	sbiw	r28, 0x07	; 7
    3c88:	0f b6       	in	r0, 0x3f	; 63
    3c8a:	f8 94       	cli
    3c8c:	de bf       	out	0x3e, r29	; 62
    3c8e:	0f be       	out	0x3f, r0	; 63
    3c90:	cd bf       	out	0x3d, r28	; 61
    3c92:	9c 83       	std	Y+4, r25	; 0x04
    3c94:	8b 83       	std	Y+3, r24	; 0x03
    3c96:	7e 83       	std	Y+6, r23	; 0x06
    3c98:	6d 83       	std	Y+5, r22	; 0x05
    3c9a:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3c9c:	19 82       	std	Y+1, r1	; 0x01
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3c9e:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ca2:	fc 01       	movw	r30, r24
    3ca4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ca6:	8a 83       	std	Y+2, r24	; 0x02

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3ca8:	8b 81       	ldd	r24, Y+3	; 0x03
    3caa:	9c 81       	ldd	r25, Y+4	; 0x04
    3cac:	fc 01       	movw	r30, r24
    3cae:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cb0:	88 23       	and	r24, r24
    3cb2:	b1 f4       	brne	.+44     	; 0x3ce0 <prvCopyDataToQueue+0x62>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb8:	fc 01       	movw	r30, r24
    3cba:	80 81       	ld	r24, Z
    3cbc:	91 81       	ldd	r25, Z+1	; 0x01
    3cbe:	89 2b       	or	r24, r25
    3cc0:	09 f0       	breq	.+2      	; 0x3cc4 <prvCopyDataToQueue+0x46>
    3cc2:	9c c0       	rjmp	.+312    	; 0x3dfc <prvCopyDataToQueue+0x17e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    3cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc8:	fc 01       	movw	r30, r24
    3cca:	84 81       	ldd	r24, Z+4	; 0x04
    3ccc:	95 81       	ldd	r25, Z+5	; 0x05
    3cce:	0e 94 87 2a 	call	0x550e	; 0x550e <xTaskPriorityDisinherit>
    3cd2:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    3cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd8:	fc 01       	movw	r30, r24
    3cda:	15 82       	std	Z+5, r1	; 0x05
    3cdc:	14 82       	std	Z+4, r1	; 0x04
    3cde:	8e c0       	rjmp	.+284    	; 0x3dfc <prvCopyDataToQueue+0x17e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3ce0:	8f 81       	ldd	r24, Y+7	; 0x07
    3ce2:	88 23       	and	r24, r24
    3ce4:	d9 f5       	brne	.+118    	; 0x3d5c <prvCopyDataToQueue+0xde>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cea:	fc 01       	movw	r30, r24
    3cec:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cee:	48 2f       	mov	r20, r24
    3cf0:	50 e0       	ldi	r21, 0x00	; 0
    3cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf6:	fc 01       	movw	r30, r24
    3cf8:	82 81       	ldd	r24, Z+2	; 0x02
    3cfa:	93 81       	ldd	r25, Z+3	; 0x03
    3cfc:	2d 81       	ldd	r18, Y+5	; 0x05
    3cfe:	3e 81       	ldd	r19, Y+6	; 0x06
    3d00:	b9 01       	movw	r22, r18
    3d02:	0e 94 29 32 	call	0x6452	; 0x6452 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3d06:	8b 81       	ldd	r24, Y+3	; 0x03
    3d08:	9c 81       	ldd	r25, Y+4	; 0x04
    3d0a:	fc 01       	movw	r30, r24
    3d0c:	22 81       	ldd	r18, Z+2	; 0x02
    3d0e:	33 81       	ldd	r19, Z+3	; 0x03
    3d10:	8b 81       	ldd	r24, Y+3	; 0x03
    3d12:	9c 81       	ldd	r25, Y+4	; 0x04
    3d14:	fc 01       	movw	r30, r24
    3d16:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d18:	88 2f       	mov	r24, r24
    3d1a:	90 e0       	ldi	r25, 0x00	; 0
    3d1c:	28 0f       	add	r18, r24
    3d1e:	39 1f       	adc	r19, r25
    3d20:	8b 81       	ldd	r24, Y+3	; 0x03
    3d22:	9c 81       	ldd	r25, Y+4	; 0x04
    3d24:	fc 01       	movw	r30, r24
    3d26:	33 83       	std	Z+3, r19	; 0x03
    3d28:	22 83       	std	Z+2, r18	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d2e:	fc 01       	movw	r30, r24
    3d30:	22 81       	ldd	r18, Z+2	; 0x02
    3d32:	33 81       	ldd	r19, Z+3	; 0x03
    3d34:	8b 81       	ldd	r24, Y+3	; 0x03
    3d36:	9c 81       	ldd	r25, Y+4	; 0x04
    3d38:	fc 01       	movw	r30, r24
    3d3a:	84 81       	ldd	r24, Z+4	; 0x04
    3d3c:	95 81       	ldd	r25, Z+5	; 0x05
    3d3e:	28 17       	cp	r18, r24
    3d40:	39 07       	cpc	r19, r25
    3d42:	08 f4       	brcc	.+2      	; 0x3d46 <prvCopyDataToQueue+0xc8>
    3d44:	5b c0       	rjmp	.+182    	; 0x3dfc <prvCopyDataToQueue+0x17e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3d46:	8b 81       	ldd	r24, Y+3	; 0x03
    3d48:	9c 81       	ldd	r25, Y+4	; 0x04
    3d4a:	fc 01       	movw	r30, r24
    3d4c:	20 81       	ld	r18, Z
    3d4e:	31 81       	ldd	r19, Z+1	; 0x01
    3d50:	8b 81       	ldd	r24, Y+3	; 0x03
    3d52:	9c 81       	ldd	r25, Y+4	; 0x04
    3d54:	fc 01       	movw	r30, r24
    3d56:	33 83       	std	Z+3, r19	; 0x03
    3d58:	22 83       	std	Z+2, r18	; 0x02
    3d5a:	50 c0       	rjmp	.+160    	; 0x3dfc <prvCopyDataToQueue+0x17e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d60:	fc 01       	movw	r30, r24
    3d62:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d64:	48 2f       	mov	r20, r24
    3d66:	50 e0       	ldi	r21, 0x00	; 0
    3d68:	8b 81       	ldd	r24, Y+3	; 0x03
    3d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d6c:	fc 01       	movw	r30, r24
    3d6e:	86 81       	ldd	r24, Z+6	; 0x06
    3d70:	97 81       	ldd	r25, Z+7	; 0x07
    3d72:	2d 81       	ldd	r18, Y+5	; 0x05
    3d74:	3e 81       	ldd	r19, Y+6	; 0x06
    3d76:	b9 01       	movw	r22, r18
    3d78:	0e 94 29 32 	call	0x6452	; 0x6452 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d80:	fc 01       	movw	r30, r24
    3d82:	26 81       	ldd	r18, Z+6	; 0x06
    3d84:	37 81       	ldd	r19, Z+7	; 0x07
    3d86:	8b 81       	ldd	r24, Y+3	; 0x03
    3d88:	9c 81       	ldd	r25, Y+4	; 0x04
    3d8a:	fc 01       	movw	r30, r24
    3d8c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d8e:	88 2f       	mov	r24, r24
    3d90:	90 e0       	ldi	r25, 0x00	; 0
    3d92:	91 95       	neg	r25
    3d94:	81 95       	neg	r24
    3d96:	91 09       	sbc	r25, r1
    3d98:	28 0f       	add	r18, r24
    3d9a:	39 1f       	adc	r19, r25
    3d9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d9e:	9c 81       	ldd	r25, Y+4	; 0x04
    3da0:	fc 01       	movw	r30, r24
    3da2:	37 83       	std	Z+7, r19	; 0x07
    3da4:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3da6:	8b 81       	ldd	r24, Y+3	; 0x03
    3da8:	9c 81       	ldd	r25, Y+4	; 0x04
    3daa:	fc 01       	movw	r30, r24
    3dac:	26 81       	ldd	r18, Z+6	; 0x06
    3dae:	37 81       	ldd	r19, Z+7	; 0x07
    3db0:	8b 81       	ldd	r24, Y+3	; 0x03
    3db2:	9c 81       	ldd	r25, Y+4	; 0x04
    3db4:	fc 01       	movw	r30, r24
    3db6:	80 81       	ld	r24, Z
    3db8:	91 81       	ldd	r25, Z+1	; 0x01
    3dba:	28 17       	cp	r18, r24
    3dbc:	39 07       	cpc	r19, r25
    3dbe:	a8 f4       	brcc	.+42     	; 0x3dea <prvCopyDataToQueue+0x16c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3dc4:	fc 01       	movw	r30, r24
    3dc6:	24 81       	ldd	r18, Z+4	; 0x04
    3dc8:	35 81       	ldd	r19, Z+5	; 0x05
    3dca:	8b 81       	ldd	r24, Y+3	; 0x03
    3dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    3dce:	fc 01       	movw	r30, r24
    3dd0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3dd2:	88 2f       	mov	r24, r24
    3dd4:	90 e0       	ldi	r25, 0x00	; 0
    3dd6:	91 95       	neg	r25
    3dd8:	81 95       	neg	r24
    3dda:	91 09       	sbc	r25, r1
    3ddc:	28 0f       	add	r18, r24
    3dde:	39 1f       	adc	r19, r25
    3de0:	8b 81       	ldd	r24, Y+3	; 0x03
    3de2:	9c 81       	ldd	r25, Y+4	; 0x04
    3de4:	fc 01       	movw	r30, r24
    3de6:	37 83       	std	Z+7, r19	; 0x07
    3de8:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3dea:	8f 81       	ldd	r24, Y+7	; 0x07
    3dec:	82 30       	cpi	r24, 0x02	; 2
    3dee:	31 f4       	brne	.+12     	; 0x3dfc <prvCopyDataToQueue+0x17e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3df0:	8a 81       	ldd	r24, Y+2	; 0x02
    3df2:	88 23       	and	r24, r24
    3df4:	19 f0       	breq	.+6      	; 0x3dfc <prvCopyDataToQueue+0x17e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3df6:	8a 81       	ldd	r24, Y+2	; 0x02
    3df8:	81 50       	subi	r24, 0x01	; 1
    3dfa:	8a 83       	std	Y+2, r24	; 0x02
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dfe:	21 e0       	ldi	r18, 0x01	; 1
    3e00:	28 0f       	add	r18, r24
    3e02:	8b 81       	ldd	r24, Y+3	; 0x03
    3e04:	9c 81       	ldd	r25, Y+4	; 0x04
    3e06:	fc 01       	movw	r30, r24
    3e08:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3e0a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e0c:	27 96       	adiw	r28, 0x07	; 7
    3e0e:	0f b6       	in	r0, 0x3f	; 63
    3e10:	f8 94       	cli
    3e12:	de bf       	out	0x3e, r29	; 62
    3e14:	0f be       	out	0x3f, r0	; 63
    3e16:	cd bf       	out	0x3d, r28	; 61
    3e18:	df 91       	pop	r29
    3e1a:	cf 91       	pop	r28
    3e1c:	08 95       	ret

00003e1e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3e1e:	cf 93       	push	r28
    3e20:	df 93       	push	r29
    3e22:	00 d0       	rcall	.+0      	; 0x3e24 <prvCopyDataFromQueue+0x6>
    3e24:	00 d0       	rcall	.+0      	; 0x3e26 <prvCopyDataFromQueue+0x8>
    3e26:	cd b7       	in	r28, 0x3d	; 61
    3e28:	de b7       	in	r29, 0x3e	; 62
    3e2a:	9a 83       	std	Y+2, r25	; 0x02
    3e2c:	89 83       	std	Y+1, r24	; 0x01
    3e2e:	7c 83       	std	Y+4, r23	; 0x04
    3e30:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3e32:	89 81       	ldd	r24, Y+1	; 0x01
    3e34:	9a 81       	ldd	r25, Y+2	; 0x02
    3e36:	fc 01       	movw	r30, r24
    3e38:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e3a:	88 23       	and	r24, r24
    3e3c:	c9 f1       	breq	.+114    	; 0x3eb0 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3e3e:	89 81       	ldd	r24, Y+1	; 0x01
    3e40:	9a 81       	ldd	r25, Y+2	; 0x02
    3e42:	fc 01       	movw	r30, r24
    3e44:	26 81       	ldd	r18, Z+6	; 0x06
    3e46:	37 81       	ldd	r19, Z+7	; 0x07
    3e48:	89 81       	ldd	r24, Y+1	; 0x01
    3e4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4c:	fc 01       	movw	r30, r24
    3e4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e50:	88 2f       	mov	r24, r24
    3e52:	90 e0       	ldi	r25, 0x00	; 0
    3e54:	28 0f       	add	r18, r24
    3e56:	39 1f       	adc	r19, r25
    3e58:	89 81       	ldd	r24, Y+1	; 0x01
    3e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e5c:	fc 01       	movw	r30, r24
    3e5e:	37 83       	std	Z+7, r19	; 0x07
    3e60:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3e62:	89 81       	ldd	r24, Y+1	; 0x01
    3e64:	9a 81       	ldd	r25, Y+2	; 0x02
    3e66:	fc 01       	movw	r30, r24
    3e68:	26 81       	ldd	r18, Z+6	; 0x06
    3e6a:	37 81       	ldd	r19, Z+7	; 0x07
    3e6c:	89 81       	ldd	r24, Y+1	; 0x01
    3e6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e70:	fc 01       	movw	r30, r24
    3e72:	84 81       	ldd	r24, Z+4	; 0x04
    3e74:	95 81       	ldd	r25, Z+5	; 0x05
    3e76:	28 17       	cp	r18, r24
    3e78:	39 07       	cpc	r19, r25
    3e7a:	50 f0       	brcs	.+20     	; 0x3e90 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3e7c:	89 81       	ldd	r24, Y+1	; 0x01
    3e7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e80:	fc 01       	movw	r30, r24
    3e82:	20 81       	ld	r18, Z
    3e84:	31 81       	ldd	r19, Z+1	; 0x01
    3e86:	89 81       	ldd	r24, Y+1	; 0x01
    3e88:	9a 81       	ldd	r25, Y+2	; 0x02
    3e8a:	fc 01       	movw	r30, r24
    3e8c:	37 83       	std	Z+7, r19	; 0x07
    3e8e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3e90:	89 81       	ldd	r24, Y+1	; 0x01
    3e92:	9a 81       	ldd	r25, Y+2	; 0x02
    3e94:	fc 01       	movw	r30, r24
    3e96:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e98:	48 2f       	mov	r20, r24
    3e9a:	50 e0       	ldi	r21, 0x00	; 0
    3e9c:	89 81       	ldd	r24, Y+1	; 0x01
    3e9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea0:	fc 01       	movw	r30, r24
    3ea2:	26 81       	ldd	r18, Z+6	; 0x06
    3ea4:	37 81       	ldd	r19, Z+7	; 0x07
    3ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    3eaa:	b9 01       	movw	r22, r18
    3eac:	0e 94 29 32 	call	0x6452	; 0x6452 <memcpy>
	}
}
    3eb0:	00 00       	nop
    3eb2:	0f 90       	pop	r0
    3eb4:	0f 90       	pop	r0
    3eb6:	0f 90       	pop	r0
    3eb8:	0f 90       	pop	r0
    3eba:	df 91       	pop	r29
    3ebc:	cf 91       	pop	r28
    3ebe:	08 95       	ret

00003ec0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3ec0:	cf 93       	push	r28
    3ec2:	df 93       	push	r29
    3ec4:	00 d0       	rcall	.+0      	; 0x3ec6 <prvUnlockQueue+0x6>
    3ec6:	00 d0       	rcall	.+0      	; 0x3ec8 <prvUnlockQueue+0x8>
    3ec8:	cd b7       	in	r28, 0x3d	; 61
    3eca:	de b7       	in	r29, 0x3e	; 62
    3ecc:	9c 83       	std	Y+4, r25	; 0x04
    3ece:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3ed0:	0f b6       	in	r0, 0x3f	; 63
    3ed2:	f8 94       	cli
    3ed4:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3ed6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed8:	9c 81       	ldd	r25, Y+4	; 0x04
    3eda:	fc 01       	movw	r30, r24
    3edc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ede:	89 83       	std	Y+1, r24	; 0x01

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3ee0:	12 c0       	rjmp	.+36     	; 0x3f06 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee6:	fc 01       	movw	r30, r24
    3ee8:	81 89       	ldd	r24, Z+17	; 0x11
    3eea:	88 23       	and	r24, r24
    3eec:	81 f0       	breq	.+32     	; 0x3f0e <prvUnlockQueue+0x4e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3eee:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef2:	41 96       	adiw	r24, 0x11	; 17
    3ef4:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    3ef8:	88 23       	and	r24, r24
    3efa:	11 f0       	breq	.+4      	; 0x3f00 <prvUnlockQueue+0x40>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3efc:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3f00:	89 81       	ldd	r24, Y+1	; 0x01
    3f02:	81 50       	subi	r24, 0x01	; 1
    3f04:	89 83       	std	Y+1, r24	; 0x01
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3f06:	89 81       	ldd	r24, Y+1	; 0x01
    3f08:	18 16       	cp	r1, r24
    3f0a:	5c f3       	brlt	.-42     	; 0x3ee2 <prvUnlockQueue+0x22>
    3f0c:	01 c0       	rjmp	.+2      	; 0x3f10 <prvUnlockQueue+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3f0e:	00 00       	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3f10:	8b 81       	ldd	r24, Y+3	; 0x03
    3f12:	9c 81       	ldd	r25, Y+4	; 0x04
    3f14:	2f ef       	ldi	r18, 0xFF	; 255
    3f16:	fc 01       	movw	r30, r24
    3f18:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3f1a:	0f 90       	pop	r0
    3f1c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	f8 94       	cli
    3f22:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3f24:	8b 81       	ldd	r24, Y+3	; 0x03
    3f26:	9c 81       	ldd	r25, Y+4	; 0x04
    3f28:	fc 01       	movw	r30, r24
    3f2a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f2c:	8a 83       	std	Y+2, r24	; 0x02

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3f2e:	12 c0       	rjmp	.+36     	; 0x3f54 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f30:	8b 81       	ldd	r24, Y+3	; 0x03
    3f32:	9c 81       	ldd	r25, Y+4	; 0x04
    3f34:	fc 01       	movw	r30, r24
    3f36:	80 85       	ldd	r24, Z+8	; 0x08
    3f38:	88 23       	and	r24, r24
    3f3a:	81 f0       	breq	.+32     	; 0x3f5c <prvUnlockQueue+0x9c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f40:	08 96       	adiw	r24, 0x08	; 8
    3f42:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <xTaskRemoveFromEventList>
    3f46:	88 23       	and	r24, r24
    3f48:	11 f0       	breq	.+4      	; 0x3f4e <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    3f4a:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f50:	81 50       	subi	r24, 0x01	; 1
    3f52:	8a 83       	std	Y+2, r24	; 0x02
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3f54:	8a 81       	ldd	r24, Y+2	; 0x02
    3f56:	18 16       	cp	r1, r24
    3f58:	5c f3       	brlt	.-42     	; 0x3f30 <prvUnlockQueue+0x70>
    3f5a:	01 c0       	rjmp	.+2      	; 0x3f5e <prvUnlockQueue+0x9e>

				--cRxLock;
			}
			else
			{
				break;
    3f5c:	00 00       	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f60:	9c 81       	ldd	r25, Y+4	; 0x04
    3f62:	2f ef       	ldi	r18, 0xFF	; 255
    3f64:	fc 01       	movw	r30, r24
    3f66:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    3f68:	0f 90       	pop	r0
    3f6a:	0f be       	out	0x3f, r0	; 63
}
    3f6c:	00 00       	nop
    3f6e:	0f 90       	pop	r0
    3f70:	0f 90       	pop	r0
    3f72:	0f 90       	pop	r0
    3f74:	0f 90       	pop	r0
    3f76:	df 91       	pop	r29
    3f78:	cf 91       	pop	r28
    3f7a:	08 95       	ret

00003f7c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3f7c:	cf 93       	push	r28
    3f7e:	df 93       	push	r29
    3f80:	00 d0       	rcall	.+0      	; 0x3f82 <prvIsQueueEmpty+0x6>
    3f82:	1f 92       	push	r1
    3f84:	cd b7       	in	r28, 0x3d	; 61
    3f86:	de b7       	in	r29, 0x3e	; 62
    3f88:	9b 83       	std	Y+3, r25	; 0x03
    3f8a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3f8c:	0f b6       	in	r0, 0x3f	; 63
    3f8e:	f8 94       	cli
    3f90:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3f92:	8a 81       	ldd	r24, Y+2	; 0x02
    3f94:	9b 81       	ldd	r25, Y+3	; 0x03
    3f96:	fc 01       	movw	r30, r24
    3f98:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f9a:	88 23       	and	r24, r24
    3f9c:	19 f4       	brne	.+6      	; 0x3fa4 <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    3f9e:	81 e0       	ldi	r24, 0x01	; 1
    3fa0:	89 83       	std	Y+1, r24	; 0x01
    3fa2:	01 c0       	rjmp	.+2      	; 0x3fa6 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    3fa4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3fa6:	0f 90       	pop	r0
    3fa8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3faa:	89 81       	ldd	r24, Y+1	; 0x01
}
    3fac:	0f 90       	pop	r0
    3fae:	0f 90       	pop	r0
    3fb0:	0f 90       	pop	r0
    3fb2:	df 91       	pop	r29
    3fb4:	cf 91       	pop	r28
    3fb6:	08 95       	ret

00003fb8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3fb8:	cf 93       	push	r28
    3fba:	df 93       	push	r29
    3fbc:	00 d0       	rcall	.+0      	; 0x3fbe <xQueueIsQueueEmptyFromISR+0x6>
    3fbe:	00 d0       	rcall	.+0      	; 0x3fc0 <xQueueIsQueueEmptyFromISR+0x8>
    3fc0:	1f 92       	push	r1
    3fc2:	cd b7       	in	r28, 0x3d	; 61
    3fc4:	de b7       	in	r29, 0x3e	; 62
    3fc6:	9d 83       	std	Y+5, r25	; 0x05
    3fc8:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3fca:	8c 81       	ldd	r24, Y+4	; 0x04
    3fcc:	9d 81       	ldd	r25, Y+5	; 0x05
    3fce:	9b 83       	std	Y+3, r25	; 0x03
    3fd0:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3fd2:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd4:	9b 81       	ldd	r25, Y+3	; 0x03
    3fd6:	fc 01       	movw	r30, r24
    3fd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3fda:	88 23       	and	r24, r24
    3fdc:	19 f4       	brne	.+6      	; 0x3fe4 <xQueueIsQueueEmptyFromISR+0x2c>
	{
		xReturn = pdTRUE;
    3fde:	81 e0       	ldi	r24, 0x01	; 1
    3fe0:	89 83       	std	Y+1, r24	; 0x01
    3fe2:	01 c0       	rjmp	.+2      	; 0x3fe6 <xQueueIsQueueEmptyFromISR+0x2e>
	}
	else
	{
		xReturn = pdFALSE;
    3fe4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3fe6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3fe8:	0f 90       	pop	r0
    3fea:	0f 90       	pop	r0
    3fec:	0f 90       	pop	r0
    3fee:	0f 90       	pop	r0
    3ff0:	0f 90       	pop	r0
    3ff2:	df 91       	pop	r29
    3ff4:	cf 91       	pop	r28
    3ff6:	08 95       	ret

00003ff8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3ff8:	cf 93       	push	r28
    3ffa:	df 93       	push	r29
    3ffc:	00 d0       	rcall	.+0      	; 0x3ffe <prvIsQueueFull+0x6>
    3ffe:	1f 92       	push	r1
    4000:	cd b7       	in	r28, 0x3d	; 61
    4002:	de b7       	in	r29, 0x3e	; 62
    4004:	9b 83       	std	Y+3, r25	; 0x03
    4006:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4008:	0f b6       	in	r0, 0x3f	; 63
    400a:	f8 94       	cli
    400c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    400e:	8a 81       	ldd	r24, Y+2	; 0x02
    4010:	9b 81       	ldd	r25, Y+3	; 0x03
    4012:	fc 01       	movw	r30, r24
    4014:	22 8d       	ldd	r18, Z+26	; 0x1a
    4016:	8a 81       	ldd	r24, Y+2	; 0x02
    4018:	9b 81       	ldd	r25, Y+3	; 0x03
    401a:	fc 01       	movw	r30, r24
    401c:	83 8d       	ldd	r24, Z+27	; 0x1b
    401e:	28 17       	cp	r18, r24
    4020:	19 f4       	brne	.+6      	; 0x4028 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    4022:	81 e0       	ldi	r24, 0x01	; 1
    4024:	89 83       	std	Y+1, r24	; 0x01
    4026:	01 c0       	rjmp	.+2      	; 0x402a <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    4028:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    402a:	0f 90       	pop	r0
    402c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    402e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4030:	0f 90       	pop	r0
    4032:	0f 90       	pop	r0
    4034:	0f 90       	pop	r0
    4036:	df 91       	pop	r29
    4038:	cf 91       	pop	r28
    403a:	08 95       	ret

0000403c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    403c:	cf 93       	push	r28
    403e:	df 93       	push	r29
    4040:	00 d0       	rcall	.+0      	; 0x4042 <xQueueIsQueueFullFromISR+0x6>
    4042:	00 d0       	rcall	.+0      	; 0x4044 <xQueueIsQueueFullFromISR+0x8>
    4044:	1f 92       	push	r1
    4046:	cd b7       	in	r28, 0x3d	; 61
    4048:	de b7       	in	r29, 0x3e	; 62
    404a:	9d 83       	std	Y+5, r25	; 0x05
    404c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    404e:	8c 81       	ldd	r24, Y+4	; 0x04
    4050:	9d 81       	ldd	r25, Y+5	; 0x05
    4052:	9b 83       	std	Y+3, r25	; 0x03
    4054:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4056:	8a 81       	ldd	r24, Y+2	; 0x02
    4058:	9b 81       	ldd	r25, Y+3	; 0x03
    405a:	fc 01       	movw	r30, r24
    405c:	22 8d       	ldd	r18, Z+26	; 0x1a
    405e:	8a 81       	ldd	r24, Y+2	; 0x02
    4060:	9b 81       	ldd	r25, Y+3	; 0x03
    4062:	fc 01       	movw	r30, r24
    4064:	83 8d       	ldd	r24, Z+27	; 0x1b
    4066:	28 17       	cp	r18, r24
    4068:	19 f4       	brne	.+6      	; 0x4070 <xQueueIsQueueFullFromISR+0x34>
	{
		xReturn = pdTRUE;
    406a:	81 e0       	ldi	r24, 0x01	; 1
    406c:	89 83       	std	Y+1, r24	; 0x01
    406e:	01 c0       	rjmp	.+2      	; 0x4072 <xQueueIsQueueFullFromISR+0x36>
	}
	else
	{
		xReturn = pdFALSE;
    4070:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4072:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4074:	0f 90       	pop	r0
    4076:	0f 90       	pop	r0
    4078:	0f 90       	pop	r0
    407a:	0f 90       	pop	r0
    407c:	0f 90       	pop	r0
    407e:	df 91       	pop	r29
    4080:	cf 91       	pop	r28
    4082:	08 95       	ret

00004084 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4084:	8f 92       	push	r8
    4086:	9f 92       	push	r9
    4088:	af 92       	push	r10
    408a:	bf 92       	push	r11
    408c:	cf 92       	push	r12
    408e:	df 92       	push	r13
    4090:	ef 92       	push	r14
    4092:	ff 92       	push	r15
    4094:	0f 93       	push	r16
    4096:	1f 93       	push	r17
    4098:	cf 93       	push	r28
    409a:	df 93       	push	r29
    409c:	cd b7       	in	r28, 0x3d	; 61
    409e:	de b7       	in	r29, 0x3e	; 62
    40a0:	60 97       	sbiw	r28, 0x10	; 16
    40a2:	0f b6       	in	r0, 0x3f	; 63
    40a4:	f8 94       	cli
    40a6:	de bf       	out	0x3e, r29	; 62
    40a8:	0f be       	out	0x3f, r0	; 63
    40aa:	cd bf       	out	0x3d, r28	; 61
    40ac:	9f 83       	std	Y+7, r25	; 0x07
    40ae:	8e 83       	std	Y+6, r24	; 0x06
    40b0:	79 87       	std	Y+9, r23	; 0x09
    40b2:	68 87       	std	Y+8, r22	; 0x08
    40b4:	5b 87       	std	Y+11, r21	; 0x0b
    40b6:	4a 87       	std	Y+10, r20	; 0x0a
    40b8:	3d 87       	std	Y+13, r19	; 0x0d
    40ba:	2c 87       	std	Y+12, r18	; 0x0c
    40bc:	0e 87       	std	Y+14, r16	; 0x0e
    40be:	f8 8a       	std	Y+16, r15	; 0x10
    40c0:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    40c2:	8a 85       	ldd	r24, Y+10	; 0x0a
    40c4:	9b 85       	ldd	r25, Y+11	; 0x0b
    40c6:	0e 94 b2 12 	call	0x2564	; 0x2564 <pvPortMalloc>
    40ca:	9d 83       	std	Y+5, r25	; 0x05
    40cc:	8c 83       	std	Y+4, r24	; 0x04

			if( pxStack != NULL )
    40ce:	8c 81       	ldd	r24, Y+4	; 0x04
    40d0:	9d 81       	ldd	r25, Y+5	; 0x05
    40d2:	89 2b       	or	r24, r25
    40d4:	b9 f0       	breq	.+46     	; 0x4104 <xTaskCreate+0x80>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    40d6:	88 e2       	ldi	r24, 0x28	; 40
    40d8:	90 e0       	ldi	r25, 0x00	; 0
    40da:	0e 94 b2 12 	call	0x2564	; 0x2564 <pvPortMalloc>
    40de:	9a 83       	std	Y+2, r25	; 0x02
    40e0:	89 83       	std	Y+1, r24	; 0x01

				if( pxNewTCB != NULL )
    40e2:	89 81       	ldd	r24, Y+1	; 0x01
    40e4:	9a 81       	ldd	r25, Y+2	; 0x02
    40e6:	89 2b       	or	r24, r25
    40e8:	41 f0       	breq	.+16     	; 0x40fa <xTaskCreate+0x76>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    40ea:	89 81       	ldd	r24, Y+1	; 0x01
    40ec:	9a 81       	ldd	r25, Y+2	; 0x02
    40ee:	2c 81       	ldd	r18, Y+4	; 0x04
    40f0:	3d 81       	ldd	r19, Y+5	; 0x05
    40f2:	fc 01       	movw	r30, r24
    40f4:	30 8f       	std	Z+24, r19	; 0x18
    40f6:	27 8b       	std	Z+23, r18	; 0x17
    40f8:	07 c0       	rjmp	.+14     	; 0x4108 <xTaskCreate+0x84>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    40fa:	8c 81       	ldd	r24, Y+4	; 0x04
    40fc:	9d 81       	ldd	r25, Y+5	; 0x05
    40fe:	0e 94 07 13 	call	0x260e	; 0x260e <vPortFree>
    4102:	02 c0       	rjmp	.+4      	; 0x4108 <xTaskCreate+0x84>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4104:	1a 82       	std	Y+2, r1	; 0x02
    4106:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4108:	89 81       	ldd	r24, Y+1	; 0x01
    410a:	9a 81       	ldd	r25, Y+2	; 0x02
    410c:	89 2b       	or	r24, r25
    410e:	09 f1       	breq	.+66     	; 0x4152 <xTaskCreate+0xce>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4110:	8a 85       	ldd	r24, Y+10	; 0x0a
    4112:	9b 85       	ldd	r25, Y+11	; 0x0b
    4114:	cc 01       	movw	r24, r24
    4116:	a0 e0       	ldi	r26, 0x00	; 0
    4118:	b0 e0       	ldi	r27, 0x00	; 0
    411a:	09 81       	ldd	r16, Y+1	; 0x01
    411c:	1a 81       	ldd	r17, Y+2	; 0x02
    411e:	4f 85       	ldd	r20, Y+15	; 0x0f
    4120:	58 89       	ldd	r21, Y+16	; 0x10
    4122:	2c 85       	ldd	r18, Y+12	; 0x0c
    4124:	3d 85       	ldd	r19, Y+13	; 0x0d
    4126:	68 85       	ldd	r22, Y+8	; 0x08
    4128:	79 85       	ldd	r23, Y+9	; 0x09
    412a:	ee 81       	ldd	r30, Y+6	; 0x06
    412c:	ff 81       	ldd	r31, Y+7	; 0x07
    412e:	81 2c       	mov	r8, r1
    4130:	91 2c       	mov	r9, r1
    4132:	58 01       	movw	r10, r16
    4134:	6a 01       	movw	r12, r20
    4136:	ee 84       	ldd	r14, Y+14	; 0x0e
    4138:	89 01       	movw	r16, r18
    413a:	9c 01       	movw	r18, r24
    413c:	ad 01       	movw	r20, r26
    413e:	cf 01       	movw	r24, r30
    4140:	0e 94 bf 20 	call	0x417e	; 0x417e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4144:	89 81       	ldd	r24, Y+1	; 0x01
    4146:	9a 81       	ldd	r25, Y+2	; 0x02
    4148:	0e 94 93 21 	call	0x4326	; 0x4326 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    414c:	81 e0       	ldi	r24, 0x01	; 1
    414e:	8b 83       	std	Y+3, r24	; 0x03
    4150:	02 c0       	rjmp	.+4      	; 0x4156 <xTaskCreate+0xd2>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4152:	8f ef       	ldi	r24, 0xFF	; 255
    4154:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4156:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4158:	60 96       	adiw	r28, 0x10	; 16
    415a:	0f b6       	in	r0, 0x3f	; 63
    415c:	f8 94       	cli
    415e:	de bf       	out	0x3e, r29	; 62
    4160:	0f be       	out	0x3f, r0	; 63
    4162:	cd bf       	out	0x3d, r28	; 61
    4164:	df 91       	pop	r29
    4166:	cf 91       	pop	r28
    4168:	1f 91       	pop	r17
    416a:	0f 91       	pop	r16
    416c:	ff 90       	pop	r15
    416e:	ef 90       	pop	r14
    4170:	df 90       	pop	r13
    4172:	cf 90       	pop	r12
    4174:	bf 90       	pop	r11
    4176:	af 90       	pop	r10
    4178:	9f 90       	pop	r9
    417a:	8f 90       	pop	r8
    417c:	08 95       	ret

0000417e <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    417e:	8f 92       	push	r8
    4180:	9f 92       	push	r9
    4182:	af 92       	push	r10
    4184:	bf 92       	push	r11
    4186:	cf 92       	push	r12
    4188:	df 92       	push	r13
    418a:	ef 92       	push	r14
    418c:	0f 93       	push	r16
    418e:	1f 93       	push	r17
    4190:	cf 93       	push	r28
    4192:	df 93       	push	r29
    4194:	cd b7       	in	r28, 0x3d	; 61
    4196:	de b7       	in	r29, 0x3e	; 62
    4198:	64 97       	sbiw	r28, 0x14	; 20
    419a:	0f b6       	in	r0, 0x3f	; 63
    419c:	f8 94       	cli
    419e:	de bf       	out	0x3e, r29	; 62
    41a0:	0f be       	out	0x3f, r0	; 63
    41a2:	cd bf       	out	0x3d, r28	; 61
    41a4:	9d 83       	std	Y+5, r25	; 0x05
    41a6:	8c 83       	std	Y+4, r24	; 0x04
    41a8:	7f 83       	std	Y+7, r23	; 0x07
    41aa:	6e 83       	std	Y+6, r22	; 0x06
    41ac:	28 87       	std	Y+8, r18	; 0x08
    41ae:	39 87       	std	Y+9, r19	; 0x09
    41b0:	4a 87       	std	Y+10, r20	; 0x0a
    41b2:	5b 87       	std	Y+11, r21	; 0x0b
    41b4:	1d 87       	std	Y+13, r17	; 0x0d
    41b6:	0c 87       	std	Y+12, r16	; 0x0c
    41b8:	ee 86       	std	Y+14, r14	; 0x0e
    41ba:	d8 8a       	std	Y+16, r13	; 0x10
    41bc:	cf 86       	std	Y+15, r12	; 0x0f
    41be:	ba 8a       	std	Y+18, r11	; 0x12
    41c0:	a9 8a       	std	Y+17, r10	; 0x11
    41c2:	9c 8a       	std	Y+20, r9	; 0x14
    41c4:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    41c6:	89 89       	ldd	r24, Y+17	; 0x11
    41c8:	9a 89       	ldd	r25, Y+18	; 0x12
    41ca:	fc 01       	movw	r30, r24
    41cc:	27 89       	ldd	r18, Z+23	; 0x17
    41ce:	30 8d       	ldd	r19, Z+24	; 0x18
    41d0:	88 85       	ldd	r24, Y+8	; 0x08
    41d2:	99 85       	ldd	r25, Y+9	; 0x09
    41d4:	01 97       	sbiw	r24, 0x01	; 1
    41d6:	82 0f       	add	r24, r18
    41d8:	93 1f       	adc	r25, r19
    41da:	9b 83       	std	Y+3, r25	; 0x03
    41dc:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    41de:	8e 81       	ldd	r24, Y+6	; 0x06
    41e0:	9f 81       	ldd	r25, Y+7	; 0x07
    41e2:	89 2b       	or	r24, r25
    41e4:	69 f1       	breq	.+90     	; 0x4240 <prvInitialiseNewTask+0xc2>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    41e6:	19 82       	std	Y+1, r1	; 0x01
    41e8:	21 c0       	rjmp	.+66     	; 0x422c <prvInitialiseNewTask+0xae>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    41ea:	89 81       	ldd	r24, Y+1	; 0x01
    41ec:	88 2f       	mov	r24, r24
    41ee:	90 e0       	ldi	r25, 0x00	; 0
    41f0:	29 81       	ldd	r18, Y+1	; 0x01
    41f2:	22 2f       	mov	r18, r18
    41f4:	30 e0       	ldi	r19, 0x00	; 0
    41f6:	4e 81       	ldd	r20, Y+6	; 0x06
    41f8:	5f 81       	ldd	r21, Y+7	; 0x07
    41fa:	24 0f       	add	r18, r20
    41fc:	35 1f       	adc	r19, r21
    41fe:	f9 01       	movw	r30, r18
    4200:	40 81       	ld	r20, Z
    4202:	29 89       	ldd	r18, Y+17	; 0x11
    4204:	3a 89       	ldd	r19, Y+18	; 0x12
    4206:	82 0f       	add	r24, r18
    4208:	93 1f       	adc	r25, r19
    420a:	49 96       	adiw	r24, 0x19	; 25
    420c:	fc 01       	movw	r30, r24
    420e:	40 83       	st	Z, r20

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4210:	89 81       	ldd	r24, Y+1	; 0x01
    4212:	88 2f       	mov	r24, r24
    4214:	90 e0       	ldi	r25, 0x00	; 0
    4216:	2e 81       	ldd	r18, Y+6	; 0x06
    4218:	3f 81       	ldd	r19, Y+7	; 0x07
    421a:	82 0f       	add	r24, r18
    421c:	93 1f       	adc	r25, r19
    421e:	fc 01       	movw	r30, r24
    4220:	80 81       	ld	r24, Z
    4222:	88 23       	and	r24, r24
    4224:	39 f0       	breq	.+14     	; 0x4234 <prvInitialiseNewTask+0xb6>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4226:	89 81       	ldd	r24, Y+1	; 0x01
    4228:	8f 5f       	subi	r24, 0xFF	; 255
    422a:	89 83       	std	Y+1, r24	; 0x01
    422c:	89 81       	ldd	r24, Y+1	; 0x01
    422e:	88 30       	cpi	r24, 0x08	; 8
    4230:	e0 f2       	brcs	.-72     	; 0x41ea <prvInitialiseNewTask+0x6c>
    4232:	01 c0       	rjmp	.+2      	; 0x4236 <prvInitialiseNewTask+0xb8>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
    4234:	00 00       	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4236:	89 89       	ldd	r24, Y+17	; 0x11
    4238:	9a 89       	ldd	r25, Y+18	; 0x12
    423a:	fc 01       	movw	r30, r24
    423c:	10 a2       	std	Z+32, r1	; 0x20
    423e:	04 c0       	rjmp	.+8      	; 0x4248 <prvInitialiseNewTask+0xca>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4240:	89 89       	ldd	r24, Y+17	; 0x11
    4242:	9a 89       	ldd	r25, Y+18	; 0x12
    4244:	fc 01       	movw	r30, r24
    4246:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4248:	8e 85       	ldd	r24, Y+14	; 0x0e
    424a:	85 30       	cpi	r24, 0x05	; 5
    424c:	10 f0       	brcs	.+4      	; 0x4252 <prvInitialiseNewTask+0xd4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    424e:	84 e0       	ldi	r24, 0x04	; 4
    4250:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4252:	89 89       	ldd	r24, Y+17	; 0x11
    4254:	9a 89       	ldd	r25, Y+18	; 0x12
    4256:	2e 85       	ldd	r18, Y+14	; 0x0e
    4258:	fc 01       	movw	r30, r24
    425a:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    425c:	89 89       	ldd	r24, Y+17	; 0x11
    425e:	9a 89       	ldd	r25, Y+18	; 0x12
    4260:	2e 85       	ldd	r18, Y+14	; 0x0e
    4262:	fc 01       	movw	r30, r24
    4264:	21 a3       	std	Z+33, r18	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    4266:	89 89       	ldd	r24, Y+17	; 0x11
    4268:	9a 89       	ldd	r25, Y+18	; 0x12
    426a:	fc 01       	movw	r30, r24
    426c:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    426e:	89 89       	ldd	r24, Y+17	; 0x11
    4270:	9a 89       	ldd	r25, Y+18	; 0x12
    4272:	02 96       	adiw	r24, 0x02	; 2
    4274:	0e 94 67 13 	call	0x26ce	; 0x26ce <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4278:	89 89       	ldd	r24, Y+17	; 0x11
    427a:	9a 89       	ldd	r25, Y+18	; 0x12
    427c:	0c 96       	adiw	r24, 0x0c	; 12
    427e:	0e 94 67 13 	call	0x26ce	; 0x26ce <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4282:	89 89       	ldd	r24, Y+17	; 0x11
    4284:	9a 89       	ldd	r25, Y+18	; 0x12
    4286:	29 89       	ldd	r18, Y+17	; 0x11
    4288:	3a 89       	ldd	r19, Y+18	; 0x12
    428a:	fc 01       	movw	r30, r24
    428c:	31 87       	std	Z+9, r19	; 0x09
    428e:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4290:	8e 85       	ldd	r24, Y+14	; 0x0e
    4292:	88 2f       	mov	r24, r24
    4294:	90 e0       	ldi	r25, 0x00	; 0
    4296:	25 e0       	ldi	r18, 0x05	; 5
    4298:	30 e0       	ldi	r19, 0x00	; 0
    429a:	28 1b       	sub	r18, r24
    429c:	39 0b       	sbc	r19, r25
    429e:	89 89       	ldd	r24, Y+17	; 0x11
    42a0:	9a 89       	ldd	r25, Y+18	; 0x12
    42a2:	fc 01       	movw	r30, r24
    42a4:	35 87       	std	Z+13, r19	; 0x0d
    42a6:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    42a8:	89 89       	ldd	r24, Y+17	; 0x11
    42aa:	9a 89       	ldd	r25, Y+18	; 0x12
    42ac:	29 89       	ldd	r18, Y+17	; 0x11
    42ae:	3a 89       	ldd	r19, Y+18	; 0x12
    42b0:	fc 01       	movw	r30, r24
    42b2:	33 8b       	std	Z+19, r19	; 0x13
    42b4:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    42b6:	89 89       	ldd	r24, Y+17	; 0x11
    42b8:	9a 89       	ldd	r25, Y+18	; 0x12
    42ba:	fc 01       	movw	r30, r24
    42bc:	13 a2       	std	Z+35, r1	; 0x23
    42be:	14 a2       	std	Z+36, r1	; 0x24
    42c0:	15 a2       	std	Z+37, r1	; 0x25
    42c2:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    42c4:	89 89       	ldd	r24, Y+17	; 0x11
    42c6:	9a 89       	ldd	r25, Y+18	; 0x12
    42c8:	fc 01       	movw	r30, r24
    42ca:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    42cc:	4c 85       	ldd	r20, Y+12	; 0x0c
    42ce:	5d 85       	ldd	r21, Y+13	; 0x0d
    42d0:	2c 81       	ldd	r18, Y+4	; 0x04
    42d2:	3d 81       	ldd	r19, Y+5	; 0x05
    42d4:	8a 81       	ldd	r24, Y+2	; 0x02
    42d6:	9b 81       	ldd	r25, Y+3	; 0x03
    42d8:	b9 01       	movw	r22, r18
    42da:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <pxPortInitialiseStack>
    42de:	9c 01       	movw	r18, r24
    42e0:	89 89       	ldd	r24, Y+17	; 0x11
    42e2:	9a 89       	ldd	r25, Y+18	; 0x12
    42e4:	fc 01       	movw	r30, r24
    42e6:	31 83       	std	Z+1, r19	; 0x01
    42e8:	20 83       	st	Z, r18
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    42ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    42ec:	98 89       	ldd	r25, Y+16	; 0x10
    42ee:	89 2b       	or	r24, r25
    42f0:	39 f0       	breq	.+14     	; 0x4300 <prvInitialiseNewTask+0x182>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    42f2:	8f 85       	ldd	r24, Y+15	; 0x0f
    42f4:	98 89       	ldd	r25, Y+16	; 0x10
    42f6:	29 89       	ldd	r18, Y+17	; 0x11
    42f8:	3a 89       	ldd	r19, Y+18	; 0x12
    42fa:	fc 01       	movw	r30, r24
    42fc:	31 83       	std	Z+1, r19	; 0x01
    42fe:	20 83       	st	Z, r18
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4300:	00 00       	nop
    4302:	64 96       	adiw	r28, 0x14	; 20
    4304:	0f b6       	in	r0, 0x3f	; 63
    4306:	f8 94       	cli
    4308:	de bf       	out	0x3e, r29	; 62
    430a:	0f be       	out	0x3f, r0	; 63
    430c:	cd bf       	out	0x3d, r28	; 61
    430e:	df 91       	pop	r29
    4310:	cf 91       	pop	r28
    4312:	1f 91       	pop	r17
    4314:	0f 91       	pop	r16
    4316:	ef 90       	pop	r14
    4318:	df 90       	pop	r13
    431a:	cf 90       	pop	r12
    431c:	bf 90       	pop	r11
    431e:	af 90       	pop	r10
    4320:	9f 90       	pop	r9
    4322:	8f 90       	pop	r8
    4324:	08 95       	ret

00004326 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4326:	cf 93       	push	r28
    4328:	df 93       	push	r29
    432a:	00 d0       	rcall	.+0      	; 0x432c <prvAddNewTaskToReadyList+0x6>
    432c:	cd b7       	in	r28, 0x3d	; 61
    432e:	de b7       	in	r29, 0x3e	; 62
    4330:	9a 83       	std	Y+2, r25	; 0x02
    4332:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4334:	0f b6       	in	r0, 0x3f	; 63
    4336:	f8 94       	cli
    4338:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    433a:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <uxCurrentNumberOfTasks>
    433e:	8f 5f       	subi	r24, 0xFF	; 255
    4340:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    4344:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4348:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    434c:	89 2b       	or	r24, r25
    434e:	69 f4       	brne	.+26     	; 0x436a <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4350:	89 81       	ldd	r24, Y+1	; 0x01
    4352:	9a 81       	ldd	r25, Y+2	; 0x02
    4354:	90 93 8e 06 	sts	0x068E, r25	; 0x80068e <pxCurrentTCB+0x1>
    4358:	80 93 8d 06 	sts	0x068D, r24	; 0x80068d <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    435c:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <uxCurrentNumberOfTasks>
    4360:	81 30       	cpi	r24, 0x01	; 1
    4362:	c9 f4       	brne	.+50     	; 0x4396 <prvAddNewTaskToReadyList+0x70>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4364:	0e 94 0f 29 	call	0x521e	; 0x521e <prvInitialiseTaskLists>
    4368:	16 c0       	rjmp	.+44     	; 0x4396 <prvAddNewTaskToReadyList+0x70>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    436a:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xSchedulerRunning>
    436e:	88 23       	and	r24, r24
    4370:	91 f4       	brne	.+36     	; 0x4396 <prvAddNewTaskToReadyList+0x70>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4372:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4376:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    437a:	fc 01       	movw	r30, r24
    437c:	26 89       	ldd	r18, Z+22	; 0x16
    437e:	89 81       	ldd	r24, Y+1	; 0x01
    4380:	9a 81       	ldd	r25, Y+2	; 0x02
    4382:	fc 01       	movw	r30, r24
    4384:	86 89       	ldd	r24, Z+22	; 0x16
    4386:	82 17       	cp	r24, r18
    4388:	30 f0       	brcs	.+12     	; 0x4396 <prvAddNewTaskToReadyList+0x70>
				{
					pxCurrentTCB = pxNewTCB;
    438a:	89 81       	ldd	r24, Y+1	; 0x01
    438c:	9a 81       	ldd	r25, Y+2	; 0x02
    438e:	90 93 8e 06 	sts	0x068E, r25	; 0x80068e <pxCurrentTCB+0x1>
    4392:	80 93 8d 06 	sts	0x068D, r24	; 0x80068d <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4396:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxTaskNumber>
    439a:	8f 5f       	subi	r24, 0xFF	; 255
    439c:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    43a0:	89 81       	ldd	r24, Y+1	; 0x01
    43a2:	9a 81       	ldd	r25, Y+2	; 0x02
    43a4:	fc 01       	movw	r30, r24
    43a6:	96 89       	ldd	r25, Z+22	; 0x16
    43a8:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    43ac:	89 17       	cp	r24, r25
    43ae:	30 f4       	brcc	.+12     	; 0x43bc <prvAddNewTaskToReadyList+0x96>
    43b0:	89 81       	ldd	r24, Y+1	; 0x01
    43b2:	9a 81       	ldd	r25, Y+2	; 0x02
    43b4:	fc 01       	movw	r30, r24
    43b6:	86 89       	ldd	r24, Z+22	; 0x16
    43b8:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    43bc:	89 81       	ldd	r24, Y+1	; 0x01
    43be:	9a 81       	ldd	r25, Y+2	; 0x02
    43c0:	ac 01       	movw	r20, r24
    43c2:	4e 5f       	subi	r20, 0xFE	; 254
    43c4:	5f 4f       	sbci	r21, 0xFF	; 255
    43c6:	89 81       	ldd	r24, Y+1	; 0x01
    43c8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ca:	fc 01       	movw	r30, r24
    43cc:	86 89       	ldd	r24, Z+22	; 0x16
    43ce:	28 2f       	mov	r18, r24
    43d0:	30 e0       	ldi	r19, 0x00	; 0
    43d2:	c9 01       	movw	r24, r18
    43d4:	88 0f       	add	r24, r24
    43d6:	99 1f       	adc	r25, r25
    43d8:	88 0f       	add	r24, r24
    43da:	99 1f       	adc	r25, r25
    43dc:	88 0f       	add	r24, r24
    43de:	99 1f       	adc	r25, r25
    43e0:	82 0f       	add	r24, r18
    43e2:	93 1f       	adc	r25, r19
    43e4:	81 57       	subi	r24, 0x71	; 113
    43e6:	99 4f       	sbci	r25, 0xF9	; 249
    43e8:	ba 01       	movw	r22, r20
    43ea:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    43ee:	0f 90       	pop	r0
    43f0:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    43f2:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xSchedulerRunning>
    43f6:	88 23       	and	r24, r24
    43f8:	71 f0       	breq	.+28     	; 0x4416 <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    43fa:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    43fe:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4402:	fc 01       	movw	r30, r24
    4404:	26 89       	ldd	r18, Z+22	; 0x16
    4406:	89 81       	ldd	r24, Y+1	; 0x01
    4408:	9a 81       	ldd	r25, Y+2	; 0x02
    440a:	fc 01       	movw	r30, r24
    440c:	86 89       	ldd	r24, Z+22	; 0x16
    440e:	28 17       	cp	r18, r24
    4410:	10 f4       	brcc	.+4      	; 0x4416 <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4412:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4416:	00 00       	nop
    4418:	0f 90       	pop	r0
    441a:	0f 90       	pop	r0
    441c:	df 91       	pop	r29
    441e:	cf 91       	pop	r28
    4420:	08 95       	ret

00004422 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4422:	cf 93       	push	r28
    4424:	df 93       	push	r29
    4426:	00 d0       	rcall	.+0      	; 0x4428 <vTaskDelete+0x6>
    4428:	00 d0       	rcall	.+0      	; 0x442a <vTaskDelete+0x8>
    442a:	cd b7       	in	r28, 0x3d	; 61
    442c:	de b7       	in	r29, 0x3e	; 62
    442e:	9c 83       	std	Y+4, r25	; 0x04
    4430:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4432:	0f b6       	in	r0, 0x3f	; 63
    4434:	f8 94       	cli
    4436:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4438:	8b 81       	ldd	r24, Y+3	; 0x03
    443a:	9c 81       	ldd	r25, Y+4	; 0x04
    443c:	89 2b       	or	r24, r25
    443e:	29 f4       	brne	.+10     	; 0x444a <vTaskDelete+0x28>
    4440:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4444:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4448:	02 c0       	rjmp	.+4      	; 0x444e <vTaskDelete+0x2c>
    444a:	8b 81       	ldd	r24, Y+3	; 0x03
    444c:	9c 81       	ldd	r25, Y+4	; 0x04
    444e:	9a 83       	std	Y+2, r25	; 0x02
    4450:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4452:	89 81       	ldd	r24, Y+1	; 0x01
    4454:	9a 81       	ldd	r25, Y+2	; 0x02
    4456:	02 96       	adiw	r24, 0x02	; 2
    4458:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    445c:	89 81       	ldd	r24, Y+1	; 0x01
    445e:	9a 81       	ldd	r25, Y+2	; 0x02
    4460:	fc 01       	movw	r30, r24
    4462:	84 89       	ldd	r24, Z+20	; 0x14
    4464:	95 89       	ldd	r25, Z+21	; 0x15
    4466:	89 2b       	or	r24, r25
    4468:	29 f0       	breq	.+10     	; 0x4474 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    446a:	89 81       	ldd	r24, Y+1	; 0x01
    446c:	9a 81       	ldd	r25, Y+2	; 0x02
    446e:	0c 96       	adiw	r24, 0x0c	; 12
    4470:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4474:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxTaskNumber>
    4478:	8f 5f       	subi	r24, 0xFF	; 255
    447a:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    447e:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4482:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4486:	29 81       	ldd	r18, Y+1	; 0x01
    4488:	3a 81       	ldd	r19, Y+2	; 0x02
    448a:	28 17       	cp	r18, r24
    448c:	39 07       	cpc	r19, r25
    448e:	71 f4       	brne	.+28     	; 0x44ac <vTaskDelete+0x8a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4490:	89 81       	ldd	r24, Y+1	; 0x01
    4492:	9a 81       	ldd	r25, Y+2	; 0x02
    4494:	02 96       	adiw	r24, 0x02	; 2
    4496:	bc 01       	movw	r22, r24
    4498:	8b ed       	ldi	r24, 0xDB	; 219
    449a:	96 e0       	ldi	r25, 0x06	; 6
    449c:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    44a0:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <uxDeletedTasksWaitingCleanUp>
    44a4:	8f 5f       	subi	r24, 0xFF	; 255
    44a6:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxDeletedTasksWaitingCleanUp>
    44aa:	0b c0       	rjmp	.+22     	; 0x44c2 <vTaskDelete+0xa0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    44ac:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <uxCurrentNumberOfTasks>
    44b0:	81 50       	subi	r24, 0x01	; 1
    44b2:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <uxCurrentNumberOfTasks>
				prvDeleteTCB( pxTCB );
    44b6:	89 81       	ldd	r24, Y+1	; 0x01
    44b8:	9a 81       	ldd	r25, Y+2	; 0x02
    44ba:	0e 94 82 29 	call	0x5304	; 0x5304 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    44be:	0e 94 9a 29 	call	0x5334	; 0x5334 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    44c2:	0f 90       	pop	r0
    44c4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    44c6:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xSchedulerRunning>
    44ca:	88 23       	and	r24, r24
    44cc:	59 f0       	breq	.+22     	; 0x44e4 <vTaskDelete+0xc2>
		{
			if( pxTCB == pxCurrentTCB )
    44ce:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    44d2:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    44d6:	29 81       	ldd	r18, Y+1	; 0x01
    44d8:	3a 81       	ldd	r19, Y+2	; 0x02
    44da:	28 17       	cp	r18, r24
    44dc:	39 07       	cpc	r19, r25
    44de:	11 f4       	brne	.+4      	; 0x44e4 <vTaskDelete+0xc2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    44e0:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    44e4:	00 00       	nop
    44e6:	0f 90       	pop	r0
    44e8:	0f 90       	pop	r0
    44ea:	0f 90       	pop	r0
    44ec:	0f 90       	pop	r0
    44ee:	df 91       	pop	r29
    44f0:	cf 91       	pop	r28
    44f2:	08 95       	ret

000044f4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    44f4:	cf 93       	push	r28
    44f6:	df 93       	push	r29
    44f8:	cd b7       	in	r28, 0x3d	; 61
    44fa:	de b7       	in	r29, 0x3e	; 62
    44fc:	2a 97       	sbiw	r28, 0x0a	; 10
    44fe:	0f b6       	in	r0, 0x3f	; 63
    4500:	f8 94       	cli
    4502:	de bf       	out	0x3e, r29	; 62
    4504:	0f be       	out	0x3f, r0	; 63
    4506:	cd bf       	out	0x3d, r28	; 61
    4508:	98 87       	std	Y+8, r25	; 0x08
    450a:	8f 83       	std	Y+7, r24	; 0x07
    450c:	7a 87       	std	Y+10, r23	; 0x0a
    450e:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    4510:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    4512:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    4516:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xTickCount>
    451a:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    451e:	9b 83       	std	Y+3, r25	; 0x03
    4520:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4522:	8f 81       	ldd	r24, Y+7	; 0x07
    4524:	98 85       	ldd	r25, Y+8	; 0x08
    4526:	fc 01       	movw	r30, r24
    4528:	20 81       	ld	r18, Z
    452a:	31 81       	ldd	r19, Z+1	; 0x01
    452c:	89 85       	ldd	r24, Y+9	; 0x09
    452e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4530:	82 0f       	add	r24, r18
    4532:	93 1f       	adc	r25, r19
    4534:	9d 83       	std	Y+5, r25	; 0x05
    4536:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    4538:	8f 81       	ldd	r24, Y+7	; 0x07
    453a:	98 85       	ldd	r25, Y+8	; 0x08
    453c:	fc 01       	movw	r30, r24
    453e:	20 81       	ld	r18, Z
    4540:	31 81       	ldd	r19, Z+1	; 0x01
    4542:	8a 81       	ldd	r24, Y+2	; 0x02
    4544:	9b 81       	ldd	r25, Y+3	; 0x03
    4546:	82 17       	cp	r24, r18
    4548:	93 07       	cpc	r25, r19
    454a:	a0 f4       	brcc	.+40     	; 0x4574 <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    454c:	8f 81       	ldd	r24, Y+7	; 0x07
    454e:	98 85       	ldd	r25, Y+8	; 0x08
    4550:	fc 01       	movw	r30, r24
    4552:	20 81       	ld	r18, Z
    4554:	31 81       	ldd	r19, Z+1	; 0x01
    4556:	8c 81       	ldd	r24, Y+4	; 0x04
    4558:	9d 81       	ldd	r25, Y+5	; 0x05
    455a:	82 17       	cp	r24, r18
    455c:	93 07       	cpc	r25, r19
    455e:	e8 f4       	brcc	.+58     	; 0x459a <vTaskDelayUntil+0xa6>
    4560:	2c 81       	ldd	r18, Y+4	; 0x04
    4562:	3d 81       	ldd	r19, Y+5	; 0x05
    4564:	8a 81       	ldd	r24, Y+2	; 0x02
    4566:	9b 81       	ldd	r25, Y+3	; 0x03
    4568:	82 17       	cp	r24, r18
    456a:	93 07       	cpc	r25, r19
    456c:	b0 f4       	brcc	.+44     	; 0x459a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    456e:	81 e0       	ldi	r24, 0x01	; 1
    4570:	89 83       	std	Y+1, r24	; 0x01
    4572:	13 c0       	rjmp	.+38     	; 0x459a <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4574:	8f 81       	ldd	r24, Y+7	; 0x07
    4576:	98 85       	ldd	r25, Y+8	; 0x08
    4578:	fc 01       	movw	r30, r24
    457a:	20 81       	ld	r18, Z
    457c:	31 81       	ldd	r19, Z+1	; 0x01
    457e:	8c 81       	ldd	r24, Y+4	; 0x04
    4580:	9d 81       	ldd	r25, Y+5	; 0x05
    4582:	82 17       	cp	r24, r18
    4584:	93 07       	cpc	r25, r19
    4586:	38 f0       	brcs	.+14     	; 0x4596 <vTaskDelayUntil+0xa2>
    4588:	2c 81       	ldd	r18, Y+4	; 0x04
    458a:	3d 81       	ldd	r19, Y+5	; 0x05
    458c:	8a 81       	ldd	r24, Y+2	; 0x02
    458e:	9b 81       	ldd	r25, Y+3	; 0x03
    4590:	82 17       	cp	r24, r18
    4592:	93 07       	cpc	r25, r19
    4594:	10 f4       	brcc	.+4      	; 0x459a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    4596:	81 e0       	ldi	r24, 0x01	; 1
    4598:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    459a:	8f 81       	ldd	r24, Y+7	; 0x07
    459c:	98 85       	ldd	r25, Y+8	; 0x08
    459e:	2c 81       	ldd	r18, Y+4	; 0x04
    45a0:	3d 81       	ldd	r19, Y+5	; 0x05
    45a2:	fc 01       	movw	r30, r24
    45a4:	31 83       	std	Z+1, r19	; 0x01
    45a6:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    45a8:	89 81       	ldd	r24, Y+1	; 0x01
    45aa:	88 23       	and	r24, r24
    45ac:	59 f0       	breq	.+22     	; 0x45c4 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    45ae:	2c 81       	ldd	r18, Y+4	; 0x04
    45b0:	3d 81       	ldd	r19, Y+5	; 0x05
    45b2:	8a 81       	ldd	r24, Y+2	; 0x02
    45b4:	9b 81       	ldd	r25, Y+3	; 0x03
    45b6:	a9 01       	movw	r20, r18
    45b8:	48 1b       	sub	r20, r24
    45ba:	59 0b       	sbc	r21, r25
    45bc:	ca 01       	movw	r24, r20
    45be:	60 e0       	ldi	r22, 0x00	; 0
    45c0:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    45c4:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    45c8:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    45ca:	8e 81       	ldd	r24, Y+6	; 0x06
    45cc:	88 23       	and	r24, r24
    45ce:	11 f4       	brne	.+4      	; 0x45d4 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    45d0:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    45d4:	00 00       	nop
    45d6:	2a 96       	adiw	r28, 0x0a	; 10
    45d8:	0f b6       	in	r0, 0x3f	; 63
    45da:	f8 94       	cli
    45dc:	de bf       	out	0x3e, r29	; 62
    45de:	0f be       	out	0x3f, r0	; 63
    45e0:	cd bf       	out	0x3d, r28	; 61
    45e2:	df 91       	pop	r29
    45e4:	cf 91       	pop	r28
    45e6:	08 95       	ret

000045e8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    45e8:	cf 93       	push	r28
    45ea:	df 93       	push	r29
    45ec:	00 d0       	rcall	.+0      	; 0x45ee <vTaskDelay+0x6>
    45ee:	1f 92       	push	r1
    45f0:	cd b7       	in	r28, 0x3d	; 61
    45f2:	de b7       	in	r29, 0x3e	; 62
    45f4:	9b 83       	std	Y+3, r25	; 0x03
    45f6:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    45f8:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    45fa:	8a 81       	ldd	r24, Y+2	; 0x02
    45fc:	9b 81       	ldd	r25, Y+3	; 0x03
    45fe:	89 2b       	or	r24, r25
    4600:	51 f0       	breq	.+20     	; 0x4616 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4602:	0e 94 c5 24 	call	0x498a	; 0x498a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4606:	8a 81       	ldd	r24, Y+2	; 0x02
    4608:	9b 81       	ldd	r25, Y+3	; 0x03
    460a:	60 e0       	ldi	r22, 0x00	; 0
    460c:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4610:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <xTaskResumeAll>
    4614:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4616:	89 81       	ldd	r24, Y+1	; 0x01
    4618:	88 23       	and	r24, r24
    461a:	11 f4       	brne	.+4      	; 0x4620 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    461c:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4620:	00 00       	nop
    4622:	0f 90       	pop	r0
    4624:	0f 90       	pop	r0
    4626:	0f 90       	pop	r0
    4628:	df 91       	pop	r29
    462a:	cf 91       	pop	r28
    462c:	08 95       	ret

0000462e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    462e:	cf 93       	push	r28
    4630:	df 93       	push	r29
    4632:	00 d0       	rcall	.+0      	; 0x4634 <vTaskSuspend+0x6>
    4634:	00 d0       	rcall	.+0      	; 0x4636 <vTaskSuspend+0x8>
    4636:	cd b7       	in	r28, 0x3d	; 61
    4638:	de b7       	in	r29, 0x3e	; 62
    463a:	9c 83       	std	Y+4, r25	; 0x04
    463c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    463e:	0f b6       	in	r0, 0x3f	; 63
    4640:	f8 94       	cli
    4642:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4644:	8b 81       	ldd	r24, Y+3	; 0x03
    4646:	9c 81       	ldd	r25, Y+4	; 0x04
    4648:	89 2b       	or	r24, r25
    464a:	29 f4       	brne	.+10     	; 0x4656 <vTaskSuspend+0x28>
    464c:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4650:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4654:	02 c0       	rjmp	.+4      	; 0x465a <vTaskSuspend+0x2c>
    4656:	8b 81       	ldd	r24, Y+3	; 0x03
    4658:	9c 81       	ldd	r25, Y+4	; 0x04
    465a:	9a 83       	std	Y+2, r25	; 0x02
    465c:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    465e:	89 81       	ldd	r24, Y+1	; 0x01
    4660:	9a 81       	ldd	r25, Y+2	; 0x02
    4662:	02 96       	adiw	r24, 0x02	; 2
    4664:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4668:	89 81       	ldd	r24, Y+1	; 0x01
    466a:	9a 81       	ldd	r25, Y+2	; 0x02
    466c:	fc 01       	movw	r30, r24
    466e:	84 89       	ldd	r24, Z+20	; 0x14
    4670:	95 89       	ldd	r25, Z+21	; 0x15
    4672:	89 2b       	or	r24, r25
    4674:	29 f0       	breq	.+10     	; 0x4680 <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4676:	89 81       	ldd	r24, Y+1	; 0x01
    4678:	9a 81       	ldd	r25, Y+2	; 0x02
    467a:	0c 96       	adiw	r24, 0x0c	; 12
    467c:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4680:	89 81       	ldd	r24, Y+1	; 0x01
    4682:	9a 81       	ldd	r25, Y+2	; 0x02
    4684:	02 96       	adiw	r24, 0x02	; 2
    4686:	bc 01       	movw	r22, r24
    4688:	85 ee       	ldi	r24, 0xE5	; 229
    468a:	96 e0       	ldi	r25, 0x06	; 6
    468c:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4690:	89 81       	ldd	r24, Y+1	; 0x01
    4692:	9a 81       	ldd	r25, Y+2	; 0x02
    4694:	fc 01       	movw	r30, r24
    4696:	87 a1       	ldd	r24, Z+39	; 0x27
    4698:	81 30       	cpi	r24, 0x01	; 1
    469a:	21 f4       	brne	.+8      	; 0x46a4 <vTaskSuspend+0x76>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    469c:	89 81       	ldd	r24, Y+1	; 0x01
    469e:	9a 81       	ldd	r25, Y+2	; 0x02
    46a0:	fc 01       	movw	r30, r24
    46a2:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    46a4:	0f 90       	pop	r0
    46a6:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    46a8:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xSchedulerRunning>
    46ac:	88 23       	and	r24, r24
    46ae:	39 f0       	breq	.+14     	; 0x46be <vTaskSuspend+0x90>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    46b0:	0f b6       	in	r0, 0x3f	; 63
    46b2:	f8 94       	cli
    46b4:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    46b6:	0e 94 9a 29 	call	0x5334	; 0x5334 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    46ba:	0f 90       	pop	r0
    46bc:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    46be:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    46c2:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    46c6:	29 81       	ldd	r18, Y+1	; 0x01
    46c8:	3a 81       	ldd	r19, Y+2	; 0x02
    46ca:	28 17       	cp	r18, r24
    46cc:	39 07       	cpc	r19, r25
    46ce:	a1 f4       	brne	.+40     	; 0x46f8 <vTaskSuspend+0xca>
		{
			if( xSchedulerRunning != pdFALSE )
    46d0:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xSchedulerRunning>
    46d4:	88 23       	and	r24, r24
    46d6:	19 f0       	breq	.+6      	; 0x46de <vTaskSuspend+0xb0>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    46d8:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46dc:	0d c0       	rjmp	.+26     	; 0x46f8 <vTaskSuspend+0xca>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    46de:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <xSuspendedTaskList>
    46e2:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <uxCurrentNumberOfTasks>
    46e6:	98 17       	cp	r25, r24
    46e8:	29 f4       	brne	.+10     	; 0x46f4 <vTaskSuspend+0xc6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    46ea:	10 92 8e 06 	sts	0x068E, r1	; 0x80068e <pxCurrentTCB+0x1>
    46ee:	10 92 8d 06 	sts	0x068D, r1	; 0x80068d <pxCurrentTCB>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46f2:	02 c0       	rjmp	.+4      	; 0x46f8 <vTaskSuspend+0xca>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
    46f4:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46f8:	00 00       	nop
    46fa:	0f 90       	pop	r0
    46fc:	0f 90       	pop	r0
    46fe:	0f 90       	pop	r0
    4700:	0f 90       	pop	r0
    4702:	df 91       	pop	r29
    4704:	cf 91       	pop	r28
    4706:	08 95       	ret

00004708 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4708:	cf 93       	push	r28
    470a:	df 93       	push	r29
    470c:	00 d0       	rcall	.+0      	; 0x470e <prvTaskIsTaskSuspended+0x6>
    470e:	00 d0       	rcall	.+0      	; 0x4710 <prvTaskIsTaskSuspended+0x8>
    4710:	1f 92       	push	r1
    4712:	cd b7       	in	r28, 0x3d	; 61
    4714:	de b7       	in	r29, 0x3e	; 62
    4716:	9d 83       	std	Y+5, r25	; 0x05
    4718:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    471a:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = xTask;
    471c:	8c 81       	ldd	r24, Y+4	; 0x04
    471e:	9d 81       	ldd	r25, Y+5	; 0x05
    4720:	9b 83       	std	Y+3, r25	; 0x03
    4722:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    4724:	8a 81       	ldd	r24, Y+2	; 0x02
    4726:	9b 81       	ldd	r25, Y+3	; 0x03
    4728:	fc 01       	movw	r30, r24
    472a:	82 85       	ldd	r24, Z+10	; 0x0a
    472c:	93 85       	ldd	r25, Z+11	; 0x0b
    472e:	85 5e       	subi	r24, 0xE5	; 229
    4730:	96 40       	sbci	r25, 0x06	; 6
    4732:	89 f4       	brne	.+34     	; 0x4756 <prvTaskIsTaskSuspended+0x4e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    4734:	8a 81       	ldd	r24, Y+2	; 0x02
    4736:	9b 81       	ldd	r25, Y+3	; 0x03
    4738:	fc 01       	movw	r30, r24
    473a:	84 89       	ldd	r24, Z+20	; 0x14
    473c:	95 89       	ldd	r25, Z+21	; 0x15
    473e:	82 5d       	subi	r24, 0xD2	; 210
    4740:	96 40       	sbci	r25, 0x06	; 6
    4742:	49 f0       	breq	.+18     	; 0x4756 <prvTaskIsTaskSuspended+0x4e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    4744:	8a 81       	ldd	r24, Y+2	; 0x02
    4746:	9b 81       	ldd	r25, Y+3	; 0x03
    4748:	fc 01       	movw	r30, r24
    474a:	84 89       	ldd	r24, Z+20	; 0x14
    474c:	95 89       	ldd	r25, Z+21	; 0x15
    474e:	89 2b       	or	r24, r25
    4750:	11 f4       	brne	.+4      	; 0x4756 <prvTaskIsTaskSuspended+0x4e>
				{
					xReturn = pdTRUE;
    4752:	81 e0       	ldi	r24, 0x01	; 1
    4754:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4756:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4758:	0f 90       	pop	r0
    475a:	0f 90       	pop	r0
    475c:	0f 90       	pop	r0
    475e:	0f 90       	pop	r0
    4760:	0f 90       	pop	r0
    4762:	df 91       	pop	r29
    4764:	cf 91       	pop	r28
    4766:	08 95       	ret

00004768 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4768:	cf 93       	push	r28
    476a:	df 93       	push	r29
    476c:	00 d0       	rcall	.+0      	; 0x476e <vTaskResume+0x6>
    476e:	00 d0       	rcall	.+0      	; 0x4770 <vTaskResume+0x8>
    4770:	cd b7       	in	r28, 0x3d	; 61
    4772:	de b7       	in	r29, 0x3e	; 62
    4774:	9c 83       	std	Y+4, r25	; 0x04
    4776:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4778:	8b 81       	ldd	r24, Y+3	; 0x03
    477a:	9c 81       	ldd	r25, Y+4	; 0x04
    477c:	9a 83       	std	Y+2, r25	; 0x02
    477e:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4780:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4784:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4788:	29 81       	ldd	r18, Y+1	; 0x01
    478a:	3a 81       	ldd	r19, Y+2	; 0x02
    478c:	28 17       	cp	r18, r24
    478e:	39 07       	cpc	r19, r25
    4790:	09 f4       	brne	.+2      	; 0x4794 <vTaskResume+0x2c>
    4792:	4a c0       	rjmp	.+148    	; 0x4828 <vTaskResume+0xc0>
    4794:	89 81       	ldd	r24, Y+1	; 0x01
    4796:	9a 81       	ldd	r25, Y+2	; 0x02
    4798:	89 2b       	or	r24, r25
    479a:	09 f4       	brne	.+2      	; 0x479e <vTaskResume+0x36>
    479c:	45 c0       	rjmp	.+138    	; 0x4828 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    479e:	0f b6       	in	r0, 0x3f	; 63
    47a0:	f8 94       	cli
    47a2:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    47a4:	89 81       	ldd	r24, Y+1	; 0x01
    47a6:	9a 81       	ldd	r25, Y+2	; 0x02
    47a8:	0e 94 84 23 	call	0x4708	; 0x4708 <prvTaskIsTaskSuspended>
    47ac:	88 23       	and	r24, r24
    47ae:	d1 f1       	breq	.+116    	; 0x4824 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    47b0:	89 81       	ldd	r24, Y+1	; 0x01
    47b2:	9a 81       	ldd	r25, Y+2	; 0x02
    47b4:	02 96       	adiw	r24, 0x02	; 2
    47b6:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    47ba:	89 81       	ldd	r24, Y+1	; 0x01
    47bc:	9a 81       	ldd	r25, Y+2	; 0x02
    47be:	fc 01       	movw	r30, r24
    47c0:	96 89       	ldd	r25, Z+22	; 0x16
    47c2:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    47c6:	89 17       	cp	r24, r25
    47c8:	30 f4       	brcc	.+12     	; 0x47d6 <vTaskResume+0x6e>
    47ca:	89 81       	ldd	r24, Y+1	; 0x01
    47cc:	9a 81       	ldd	r25, Y+2	; 0x02
    47ce:	fc 01       	movw	r30, r24
    47d0:	86 89       	ldd	r24, Z+22	; 0x16
    47d2:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    47d6:	89 81       	ldd	r24, Y+1	; 0x01
    47d8:	9a 81       	ldd	r25, Y+2	; 0x02
    47da:	ac 01       	movw	r20, r24
    47dc:	4e 5f       	subi	r20, 0xFE	; 254
    47de:	5f 4f       	sbci	r21, 0xFF	; 255
    47e0:	89 81       	ldd	r24, Y+1	; 0x01
    47e2:	9a 81       	ldd	r25, Y+2	; 0x02
    47e4:	fc 01       	movw	r30, r24
    47e6:	86 89       	ldd	r24, Z+22	; 0x16
    47e8:	28 2f       	mov	r18, r24
    47ea:	30 e0       	ldi	r19, 0x00	; 0
    47ec:	c9 01       	movw	r24, r18
    47ee:	88 0f       	add	r24, r24
    47f0:	99 1f       	adc	r25, r25
    47f2:	88 0f       	add	r24, r24
    47f4:	99 1f       	adc	r25, r25
    47f6:	88 0f       	add	r24, r24
    47f8:	99 1f       	adc	r25, r25
    47fa:	82 0f       	add	r24, r18
    47fc:	93 1f       	adc	r25, r19
    47fe:	81 57       	subi	r24, 0x71	; 113
    4800:	99 4f       	sbci	r25, 0xF9	; 249
    4802:	ba 01       	movw	r22, r20
    4804:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4808:	89 81       	ldd	r24, Y+1	; 0x01
    480a:	9a 81       	ldd	r25, Y+2	; 0x02
    480c:	fc 01       	movw	r30, r24
    480e:	26 89       	ldd	r18, Z+22	; 0x16
    4810:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4814:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4818:	fc 01       	movw	r30, r24
    481a:	86 89       	ldd	r24, Z+22	; 0x16
    481c:	28 17       	cp	r18, r24
    481e:	10 f0       	brcs	.+4      	; 0x4824 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4820:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4824:	0f 90       	pop	r0
    4826:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4828:	00 00       	nop
    482a:	0f 90       	pop	r0
    482c:	0f 90       	pop	r0
    482e:	0f 90       	pop	r0
    4830:	0f 90       	pop	r0
    4832:	df 91       	pop	r29
    4834:	cf 91       	pop	r28
    4836:	08 95       	ret

00004838 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4838:	cf 93       	push	r28
    483a:	df 93       	push	r29
    483c:	00 d0       	rcall	.+0      	; 0x483e <xTaskResumeFromISR+0x6>
    483e:	00 d0       	rcall	.+0      	; 0x4840 <xTaskResumeFromISR+0x8>
    4840:	00 d0       	rcall	.+0      	; 0x4842 <xTaskResumeFromISR+0xa>
    4842:	cd b7       	in	r28, 0x3d	; 61
    4844:	de b7       	in	r29, 0x3e	; 62
    4846:	9e 83       	std	Y+6, r25	; 0x06
    4848:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    484a:	19 82       	std	Y+1, r1	; 0x01
	TCB_t * const pxTCB = xTaskToResume;
    484c:	8d 81       	ldd	r24, Y+5	; 0x05
    484e:	9e 81       	ldd	r25, Y+6	; 0x06
    4850:	9b 83       	std	Y+3, r25	; 0x03
    4852:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4854:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4856:	8a 81       	ldd	r24, Y+2	; 0x02
    4858:	9b 81       	ldd	r25, Y+3	; 0x03
    485a:	0e 94 84 23 	call	0x4708	; 0x4708 <prvTaskIsTaskSuspended>
    485e:	88 23       	and	r24, r24
    4860:	09 f4       	brne	.+2      	; 0x4864 <xTaskResumeFromISR+0x2c>
    4862:	47 c0       	rjmp	.+142    	; 0x48f2 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4864:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    4868:	88 23       	and	r24, r24
    486a:	d9 f5       	brne	.+118    	; 0x48e2 <xTaskResumeFromISR+0xaa>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    486c:	8a 81       	ldd	r24, Y+2	; 0x02
    486e:	9b 81       	ldd	r25, Y+3	; 0x03
    4870:	fc 01       	movw	r30, r24
    4872:	26 89       	ldd	r18, Z+22	; 0x16
    4874:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4878:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    487c:	fc 01       	movw	r30, r24
    487e:	86 89       	ldd	r24, Z+22	; 0x16
    4880:	28 17       	cp	r18, r24
    4882:	10 f0       	brcs	.+4      	; 0x4888 <xTaskResumeFromISR+0x50>
					{
						xYieldRequired = pdTRUE;
    4884:	81 e0       	ldi	r24, 0x01	; 1
    4886:	89 83       	std	Y+1, r24	; 0x01
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4888:	8a 81       	ldd	r24, Y+2	; 0x02
    488a:	9b 81       	ldd	r25, Y+3	; 0x03
    488c:	02 96       	adiw	r24, 0x02	; 2
    488e:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4892:	8a 81       	ldd	r24, Y+2	; 0x02
    4894:	9b 81       	ldd	r25, Y+3	; 0x03
    4896:	fc 01       	movw	r30, r24
    4898:	96 89       	ldd	r25, Z+22	; 0x16
    489a:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    489e:	89 17       	cp	r24, r25
    48a0:	30 f4       	brcc	.+12     	; 0x48ae <xTaskResumeFromISR+0x76>
    48a2:	8a 81       	ldd	r24, Y+2	; 0x02
    48a4:	9b 81       	ldd	r25, Y+3	; 0x03
    48a6:	fc 01       	movw	r30, r24
    48a8:	86 89       	ldd	r24, Z+22	; 0x16
    48aa:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    48ae:	8a 81       	ldd	r24, Y+2	; 0x02
    48b0:	9b 81       	ldd	r25, Y+3	; 0x03
    48b2:	ac 01       	movw	r20, r24
    48b4:	4e 5f       	subi	r20, 0xFE	; 254
    48b6:	5f 4f       	sbci	r21, 0xFF	; 255
    48b8:	8a 81       	ldd	r24, Y+2	; 0x02
    48ba:	9b 81       	ldd	r25, Y+3	; 0x03
    48bc:	fc 01       	movw	r30, r24
    48be:	86 89       	ldd	r24, Z+22	; 0x16
    48c0:	28 2f       	mov	r18, r24
    48c2:	30 e0       	ldi	r19, 0x00	; 0
    48c4:	c9 01       	movw	r24, r18
    48c6:	88 0f       	add	r24, r24
    48c8:	99 1f       	adc	r25, r25
    48ca:	88 0f       	add	r24, r24
    48cc:	99 1f       	adc	r25, r25
    48ce:	88 0f       	add	r24, r24
    48d0:	99 1f       	adc	r25, r25
    48d2:	82 0f       	add	r24, r18
    48d4:	93 1f       	adc	r25, r19
    48d6:	81 57       	subi	r24, 0x71	; 113
    48d8:	99 4f       	sbci	r25, 0xF9	; 249
    48da:	ba 01       	movw	r22, r20
    48dc:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
    48e0:	08 c0       	rjmp	.+16     	; 0x48f2 <xTaskResumeFromISR+0xba>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    48e2:	8a 81       	ldd	r24, Y+2	; 0x02
    48e4:	9b 81       	ldd	r25, Y+3	; 0x03
    48e6:	0c 96       	adiw	r24, 0x0c	; 12
    48e8:	bc 01       	movw	r22, r24
    48ea:	82 ed       	ldi	r24, 0xD2	; 210
    48ec:	96 e0       	ldi	r25, 0x06	; 6
    48ee:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    48f2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    48f4:	26 96       	adiw	r28, 0x06	; 6
    48f6:	0f b6       	in	r0, 0x3f	; 63
    48f8:	f8 94       	cli
    48fa:	de bf       	out	0x3e, r29	; 62
    48fc:	0f be       	out	0x3f, r0	; 63
    48fe:	cd bf       	out	0x3d, r28	; 61
    4900:	df 91       	pop	r29
    4902:	cf 91       	pop	r28
    4904:	08 95       	ret

00004906 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4906:	ef 92       	push	r14
    4908:	ff 92       	push	r15
    490a:	0f 93       	push	r16
    490c:	cf 93       	push	r28
    490e:	df 93       	push	r29
    4910:	1f 92       	push	r1
    4912:	cd b7       	in	r28, 0x3d	; 61
    4914:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4916:	0f 2e       	mov	r0, r31
    4918:	f9 ef       	ldi	r31, 0xF9	; 249
    491a:	ef 2e       	mov	r14, r31
    491c:	f6 e0       	ldi	r31, 0x06	; 6
    491e:	ff 2e       	mov	r15, r31
    4920:	f0 2d       	mov	r31, r0
    4922:	00 e0       	ldi	r16, 0x00	; 0
    4924:	20 e0       	ldi	r18, 0x00	; 0
    4926:	30 e0       	ldi	r19, 0x00	; 0
    4928:	45 e5       	ldi	r20, 0x55	; 85
    492a:	50 e0       	ldi	r21, 0x00	; 0
    492c:	63 ea       	ldi	r22, 0xA3	; 163
    492e:	70 e0       	ldi	r23, 0x00	; 0
    4930:	8f ef       	ldi	r24, 0xFF	; 255
    4932:	98 e2       	ldi	r25, 0x28	; 40
    4934:	0e 94 42 20 	call	0x4084	; 0x4084 <xTaskCreate>
    4938:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    493a:	89 81       	ldd	r24, Y+1	; 0x01
    493c:	81 30       	cpi	r24, 0x01	; 1
    493e:	81 f4       	brne	.+32     	; 0x4960 <vTaskStartScheduler+0x5a>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4940:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4942:	8f ef       	ldi	r24, 0xFF	; 255
    4944:	9f ef       	ldi	r25, 0xFF	; 255
    4946:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    494a:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    494e:	81 e0       	ldi	r24, 0x01	; 1
    4950:	80 93 f2 06 	sts	0x06F2, r24	; 0x8006f2 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4954:	10 92 f0 06 	sts	0x06F0, r1	; 0x8006f0 <xTickCount+0x1>
    4958:	10 92 ef 06 	sts	0x06EF, r1	; 0x8006ef <xTickCount>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    495c:	0e 94 94 16 	call	0x2d28	; 0x2d28 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4960:	00 00       	nop
    4962:	0f 90       	pop	r0
    4964:	df 91       	pop	r29
    4966:	cf 91       	pop	r28
    4968:	0f 91       	pop	r16
    496a:	ff 90       	pop	r15
    496c:	ef 90       	pop	r14
    496e:	08 95       	ret

00004970 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4970:	cf 93       	push	r28
    4972:	df 93       	push	r29
    4974:	cd b7       	in	r28, 0x3d	; 61
    4976:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4978:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    497a:	10 92 f2 06 	sts	0x06F2, r1	; 0x8006f2 <xSchedulerRunning>
	vPortEndScheduler();
    497e:	0e 94 c9 16 	call	0x2d92	; 0x2d92 <vPortEndScheduler>
}
    4982:	00 00       	nop
    4984:	df 91       	pop	r29
    4986:	cf 91       	pop	r28
    4988:	08 95       	ret

0000498a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    498a:	cf 93       	push	r28
    498c:	df 93       	push	r29
    498e:	cd b7       	in	r28, 0x3d	; 61
    4990:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4992:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    4996:	8f 5f       	subi	r24, 0xFF	; 255
    4998:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <uxSchedulerSuspended>
	portMEMORY_BARRIER();
}
    499c:	00 00       	nop
    499e:	df 91       	pop	r29
    49a0:	cf 91       	pop	r28
    49a2:	08 95       	ret

000049a4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    49a4:	cf 93       	push	r28
    49a6:	df 93       	push	r29
    49a8:	00 d0       	rcall	.+0      	; 0x49aa <xTaskResumeAll+0x6>
    49aa:	00 d0       	rcall	.+0      	; 0x49ac <xTaskResumeAll+0x8>
    49ac:	cd b7       	in	r28, 0x3d	; 61
    49ae:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    49b0:	1a 82       	std	Y+2, r1	; 0x02
    49b2:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xAlreadyYielded = pdFALSE;
    49b4:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    49b6:	0f b6       	in	r0, 0x3f	; 63
    49b8:	f8 94       	cli
    49ba:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    49bc:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    49c0:	81 50       	subi	r24, 0x01	; 1
    49c2:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    49c6:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    49ca:	88 23       	and	r24, r24
    49cc:	09 f0       	breq	.+2      	; 0x49d0 <xTaskResumeAll+0x2c>
    49ce:	77 c0       	rjmp	.+238    	; 0x4abe <xTaskResumeAll+0x11a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    49d0:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <uxCurrentNumberOfTasks>
    49d4:	88 23       	and	r24, r24
    49d6:	09 f4       	brne	.+2      	; 0x49da <xTaskResumeAll+0x36>
    49d8:	72 c0       	rjmp	.+228    	; 0x4abe <xTaskResumeAll+0x11a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    49da:	49 c0       	rjmp	.+146    	; 0x4a6e <xTaskResumeAll+0xca>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49dc:	80 91 d7 06 	lds	r24, 0x06D7	; 0x8006d7 <xPendingReadyList+0x5>
    49e0:	90 91 d8 06 	lds	r25, 0x06D8	; 0x8006d8 <xPendingReadyList+0x6>
    49e4:	fc 01       	movw	r30, r24
    49e6:	86 81       	ldd	r24, Z+6	; 0x06
    49e8:	97 81       	ldd	r25, Z+7	; 0x07
    49ea:	9a 83       	std	Y+2, r25	; 0x02
    49ec:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    49ee:	89 81       	ldd	r24, Y+1	; 0x01
    49f0:	9a 81       	ldd	r25, Y+2	; 0x02
    49f2:	0c 96       	adiw	r24, 0x0c	; 12
    49f4:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    49f8:	89 81       	ldd	r24, Y+1	; 0x01
    49fa:	9a 81       	ldd	r25, Y+2	; 0x02
    49fc:	02 96       	adiw	r24, 0x02	; 2
    49fe:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4a02:	89 81       	ldd	r24, Y+1	; 0x01
    4a04:	9a 81       	ldd	r25, Y+2	; 0x02
    4a06:	fc 01       	movw	r30, r24
    4a08:	96 89       	ldd	r25, Z+22	; 0x16
    4a0a:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    4a0e:	89 17       	cp	r24, r25
    4a10:	30 f4       	brcc	.+12     	; 0x4a1e <xTaskResumeAll+0x7a>
    4a12:	89 81       	ldd	r24, Y+1	; 0x01
    4a14:	9a 81       	ldd	r25, Y+2	; 0x02
    4a16:	fc 01       	movw	r30, r24
    4a18:	86 89       	ldd	r24, Z+22	; 0x16
    4a1a:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    4a1e:	89 81       	ldd	r24, Y+1	; 0x01
    4a20:	9a 81       	ldd	r25, Y+2	; 0x02
    4a22:	ac 01       	movw	r20, r24
    4a24:	4e 5f       	subi	r20, 0xFE	; 254
    4a26:	5f 4f       	sbci	r21, 0xFF	; 255
    4a28:	89 81       	ldd	r24, Y+1	; 0x01
    4a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a2c:	fc 01       	movw	r30, r24
    4a2e:	86 89       	ldd	r24, Z+22	; 0x16
    4a30:	28 2f       	mov	r18, r24
    4a32:	30 e0       	ldi	r19, 0x00	; 0
    4a34:	c9 01       	movw	r24, r18
    4a36:	88 0f       	add	r24, r24
    4a38:	99 1f       	adc	r25, r25
    4a3a:	88 0f       	add	r24, r24
    4a3c:	99 1f       	adc	r25, r25
    4a3e:	88 0f       	add	r24, r24
    4a40:	99 1f       	adc	r25, r25
    4a42:	82 0f       	add	r24, r18
    4a44:	93 1f       	adc	r25, r19
    4a46:	81 57       	subi	r24, 0x71	; 113
    4a48:	99 4f       	sbci	r25, 0xF9	; 249
    4a4a:	ba 01       	movw	r22, r20
    4a4c:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4a50:	89 81       	ldd	r24, Y+1	; 0x01
    4a52:	9a 81       	ldd	r25, Y+2	; 0x02
    4a54:	fc 01       	movw	r30, r24
    4a56:	26 89       	ldd	r18, Z+22	; 0x16
    4a58:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4a5c:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4a60:	fc 01       	movw	r30, r24
    4a62:	86 89       	ldd	r24, Z+22	; 0x16
    4a64:	28 17       	cp	r18, r24
    4a66:	18 f0       	brcs	.+6      	; 0x4a6e <xTaskResumeAll+0xca>
					{
						xYieldPending = pdTRUE;
    4a68:	81 e0       	ldi	r24, 0x01	; 1
    4a6a:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4a6e:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <xPendingReadyList>
    4a72:	88 23       	and	r24, r24
    4a74:	09 f0       	breq	.+2      	; 0x4a78 <xTaskResumeAll+0xd4>
    4a76:	b2 cf       	rjmp	.-156    	; 0x49dc <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4a78:	89 81       	ldd	r24, Y+1	; 0x01
    4a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a7c:	89 2b       	or	r24, r25
    4a7e:	11 f0       	breq	.+4      	; 0x4a84 <xTaskResumeAll+0xe0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4a80:	0e 94 9a 29 	call	0x5334	; 0x5334 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4a84:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <uxPendedTicks>
    4a88:	8c 83       	std	Y+4, r24	; 0x04

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    4a8c:	88 23       	and	r24, r24
    4a8e:	79 f0       	breq	.+30     	; 0x4aae <xTaskResumeAll+0x10a>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4a90:	0e 94 bd 25 	call	0x4b7a	; 0x4b7a <xTaskIncrementTick>
    4a94:	88 23       	and	r24, r24
    4a96:	19 f0       	breq	.+6      	; 0x4a9e <xTaskResumeAll+0xfa>
							{
								xYieldPending = pdTRUE;
    4a98:	81 e0       	ldi	r24, 0x01	; 1
    4a9a:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4a9e:	8c 81       	ldd	r24, Y+4	; 0x04
    4aa0:	81 50       	subi	r24, 0x01	; 1
    4aa2:	8c 83       	std	Y+4, r24	; 0x04
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4aa4:	8c 81       	ldd	r24, Y+4	; 0x04
    4aa6:	88 23       	and	r24, r24
    4aa8:	99 f7       	brne	.-26     	; 0x4a90 <xTaskResumeAll+0xec>

						uxPendedTicks = 0;
    4aaa:	10 92 f3 06 	sts	0x06F3, r1	; 0x8006f3 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4aae:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <xYieldPending>
    4ab2:	88 23       	and	r24, r24
    4ab4:	21 f0       	breq	.+8      	; 0x4abe <xTaskResumeAll+0x11a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4ab6:	81 e0       	ldi	r24, 0x01	; 1
    4ab8:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4aba:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4abe:	0f 90       	pop	r0
    4ac0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4ac2:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4ac4:	0f 90       	pop	r0
    4ac6:	0f 90       	pop	r0
    4ac8:	0f 90       	pop	r0
    4aca:	0f 90       	pop	r0
    4acc:	df 91       	pop	r29
    4ace:	cf 91       	pop	r28
    4ad0:	08 95       	ret

00004ad2 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4ad2:	cf 93       	push	r28
    4ad4:	df 93       	push	r29
    4ad6:	00 d0       	rcall	.+0      	; 0x4ad8 <xTaskGetTickCount+0x6>
    4ad8:	cd b7       	in	r28, 0x3d	; 61
    4ada:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4adc:	0f b6       	in	r0, 0x3f	; 63
    4ade:	f8 94       	cli
    4ae0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4ae2:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xTickCount>
    4ae6:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    4aea:	9a 83       	std	Y+2, r25	; 0x02
    4aec:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4aee:	0f 90       	pop	r0
    4af0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4af2:	89 81       	ldd	r24, Y+1	; 0x01
    4af4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4af6:	0f 90       	pop	r0
    4af8:	0f 90       	pop	r0
    4afa:	df 91       	pop	r29
    4afc:	cf 91       	pop	r28
    4afe:	08 95       	ret

00004b00 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4b00:	cf 93       	push	r28
    4b02:	df 93       	push	r29
    4b04:	00 d0       	rcall	.+0      	; 0x4b06 <xTaskGetTickCountFromISR+0x6>
    4b06:	1f 92       	push	r1
    4b08:	cd b7       	in	r28, 0x3d	; 61
    4b0a:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4b0c:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4b0e:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xTickCount>
    4b12:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    4b16:	9b 83       	std	Y+3, r25	; 0x03
    4b18:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4b1a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b1c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4b1e:	0f 90       	pop	r0
    4b20:	0f 90       	pop	r0
    4b22:	0f 90       	pop	r0
    4b24:	df 91       	pop	r29
    4b26:	cf 91       	pop	r28
    4b28:	08 95       	ret

00004b2a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4b2a:	cf 93       	push	r28
    4b2c:	df 93       	push	r29
    4b2e:	cd b7       	in	r28, 0x3d	; 61
    4b30:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4b32:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <uxCurrentNumberOfTasks>
}
    4b36:	df 91       	pop	r29
    4b38:	cf 91       	pop	r28
    4b3a:	08 95       	ret

00004b3c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4b3c:	cf 93       	push	r28
    4b3e:	df 93       	push	r29
    4b40:	00 d0       	rcall	.+0      	; 0x4b42 <pcTaskGetName+0x6>
    4b42:	00 d0       	rcall	.+0      	; 0x4b44 <pcTaskGetName+0x8>
    4b44:	cd b7       	in	r28, 0x3d	; 61
    4b46:	de b7       	in	r29, 0x3e	; 62
    4b48:	9c 83       	std	Y+4, r25	; 0x04
    4b4a:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b50:	89 2b       	or	r24, r25
    4b52:	29 f4       	brne	.+10     	; 0x4b5e <pcTaskGetName+0x22>
    4b54:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4b58:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4b5c:	02 c0       	rjmp	.+4      	; 0x4b62 <pcTaskGetName+0x26>
    4b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b60:	9c 81       	ldd	r25, Y+4	; 0x04
    4b62:	9a 83       	std	Y+2, r25	; 0x02
    4b64:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4b66:	89 81       	ldd	r24, Y+1	; 0x01
    4b68:	9a 81       	ldd	r25, Y+2	; 0x02
    4b6a:	49 96       	adiw	r24, 0x19	; 25
}
    4b6c:	0f 90       	pop	r0
    4b6e:	0f 90       	pop	r0
    4b70:	0f 90       	pop	r0
    4b72:	0f 90       	pop	r0
    4b74:	df 91       	pop	r29
    4b76:	cf 91       	pop	r28
    4b78:	08 95       	ret

00004b7a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4b7a:	cf 93       	push	r28
    4b7c:	df 93       	push	r29
    4b7e:	cd b7       	in	r28, 0x3d	; 61
    4b80:	de b7       	in	r29, 0x3e	; 62
    4b82:	29 97       	sbiw	r28, 0x09	; 9
    4b84:	0f b6       	in	r0, 0x3f	; 63
    4b86:	f8 94       	cli
    4b88:	de bf       	out	0x3e, r29	; 62
    4b8a:	0f be       	out	0x3f, r0	; 63
    4b8c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4b8e:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b90:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    4b94:	88 23       	and	r24, r24
    4b96:	09 f0       	breq	.+2      	; 0x4b9a <xTaskIncrementTick+0x20>
    4b98:	c8 c0       	rjmp	.+400    	; 0x4d2a <xTaskIncrementTick+0x1b0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4b9a:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xTickCount>
    4b9e:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    4ba2:	01 96       	adiw	r24, 0x01	; 1
    4ba4:	9b 83       	std	Y+3, r25	; 0x03
    4ba6:	8a 83       	std	Y+2, r24	; 0x02

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    4baa:	9b 81       	ldd	r25, Y+3	; 0x03
    4bac:	90 93 f0 06 	sts	0x06F0, r25	; 0x8006f0 <xTickCount+0x1>
    4bb0:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    4bb6:	9b 81       	ldd	r25, Y+3	; 0x03
    4bb8:	89 2b       	or	r24, r25
    4bba:	d9 f4       	brne	.+54     	; 0x4bf2 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4bbc:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <pxDelayedTaskList>
    4bc0:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <pxDelayedTaskList+0x1>
    4bc4:	9d 83       	std	Y+5, r25	; 0x05
    4bc6:	8c 83       	std	Y+4, r24	; 0x04
    4bc8:	80 91 d0 06 	lds	r24, 0x06D0	; 0x8006d0 <pxOverflowDelayedTaskList>
    4bcc:	90 91 d1 06 	lds	r25, 0x06D1	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    4bd0:	90 93 cf 06 	sts	0x06CF, r25	; 0x8006cf <pxDelayedTaskList+0x1>
    4bd4:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <pxDelayedTaskList>
    4bd8:	8c 81       	ldd	r24, Y+4	; 0x04
    4bda:	9d 81       	ldd	r25, Y+5	; 0x05
    4bdc:	90 93 d1 06 	sts	0x06D1, r25	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    4be0:	80 93 d0 06 	sts	0x06D0, r24	; 0x8006d0 <pxOverflowDelayedTaskList>
    4be4:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <xNumOfOverflows>
    4be8:	8f 5f       	subi	r24, 0xFF	; 255
    4bea:	80 93 f5 06 	sts	0x06F5, r24	; 0x8006f5 <xNumOfOverflows>
    4bee:	0e 94 9a 29 	call	0x5334	; 0x5334 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4bf2:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <xNextTaskUnblockTime>
    4bf6:	90 91 f8 06 	lds	r25, 0x06F8	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    4bfa:	2a 81       	ldd	r18, Y+2	; 0x02
    4bfc:	3b 81       	ldd	r19, Y+3	; 0x03
    4bfe:	28 17       	cp	r18, r24
    4c00:	39 07       	cpc	r19, r25
    4c02:	08 f4       	brcc	.+2      	; 0x4c06 <xTaskIncrementTick+0x8c>
    4c04:	78 c0       	rjmp	.+240    	; 0x4cf6 <xTaskIncrementTick+0x17c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4c06:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <pxDelayedTaskList>
    4c0a:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <pxDelayedTaskList+0x1>
    4c0e:	fc 01       	movw	r30, r24
    4c10:	80 81       	ld	r24, Z
    4c12:	88 23       	and	r24, r24
    4c14:	39 f4       	brne	.+14     	; 0x4c24 <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4c16:	8f ef       	ldi	r24, 0xFF	; 255
    4c18:	9f ef       	ldi	r25, 0xFF	; 255
    4c1a:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    4c1e:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <xNextTaskUnblockTime>
					break;
    4c22:	69 c0       	rjmp	.+210    	; 0x4cf6 <xTaskIncrementTick+0x17c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4c24:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <pxDelayedTaskList>
    4c28:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <pxDelayedTaskList+0x1>
    4c2c:	fc 01       	movw	r30, r24
    4c2e:	85 81       	ldd	r24, Z+5	; 0x05
    4c30:	96 81       	ldd	r25, Z+6	; 0x06
    4c32:	fc 01       	movw	r30, r24
    4c34:	86 81       	ldd	r24, Z+6	; 0x06
    4c36:	97 81       	ldd	r25, Z+7	; 0x07
    4c38:	9f 83       	std	Y+7, r25	; 0x07
    4c3a:	8e 83       	std	Y+6, r24	; 0x06
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4c3c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c3e:	9f 81       	ldd	r25, Y+7	; 0x07
    4c40:	fc 01       	movw	r30, r24
    4c42:	82 81       	ldd	r24, Z+2	; 0x02
    4c44:	93 81       	ldd	r25, Z+3	; 0x03
    4c46:	99 87       	std	Y+9, r25	; 0x09
    4c48:	88 87       	std	Y+8, r24	; 0x08

					if( xConstTickCount < xItemValue )
    4c4a:	2a 81       	ldd	r18, Y+2	; 0x02
    4c4c:	3b 81       	ldd	r19, Y+3	; 0x03
    4c4e:	88 85       	ldd	r24, Y+8	; 0x08
    4c50:	99 85       	ldd	r25, Y+9	; 0x09
    4c52:	28 17       	cp	r18, r24
    4c54:	39 07       	cpc	r19, r25
    4c56:	38 f4       	brcc	.+14     	; 0x4c66 <xTaskIncrementTick+0xec>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4c58:	88 85       	ldd	r24, Y+8	; 0x08
    4c5a:	99 85       	ldd	r25, Y+9	; 0x09
    4c5c:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    4c60:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    4c64:	48 c0       	rjmp	.+144    	; 0x4cf6 <xTaskIncrementTick+0x17c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4c66:	8e 81       	ldd	r24, Y+6	; 0x06
    4c68:	9f 81       	ldd	r25, Y+7	; 0x07
    4c6a:	02 96       	adiw	r24, 0x02	; 2
    4c6c:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4c70:	8e 81       	ldd	r24, Y+6	; 0x06
    4c72:	9f 81       	ldd	r25, Y+7	; 0x07
    4c74:	fc 01       	movw	r30, r24
    4c76:	84 89       	ldd	r24, Z+20	; 0x14
    4c78:	95 89       	ldd	r25, Z+21	; 0x15
    4c7a:	89 2b       	or	r24, r25
    4c7c:	29 f0       	breq	.+10     	; 0x4c88 <xTaskIncrementTick+0x10e>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4c7e:	8e 81       	ldd	r24, Y+6	; 0x06
    4c80:	9f 81       	ldd	r25, Y+7	; 0x07
    4c82:	0c 96       	adiw	r24, 0x0c	; 12
    4c84:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4c88:	8e 81       	ldd	r24, Y+6	; 0x06
    4c8a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c8c:	fc 01       	movw	r30, r24
    4c8e:	96 89       	ldd	r25, Z+22	; 0x16
    4c90:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    4c94:	89 17       	cp	r24, r25
    4c96:	30 f4       	brcc	.+12     	; 0x4ca4 <xTaskIncrementTick+0x12a>
    4c98:	8e 81       	ldd	r24, Y+6	; 0x06
    4c9a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c9c:	fc 01       	movw	r30, r24
    4c9e:	86 89       	ldd	r24, Z+22	; 0x16
    4ca0:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    4ca4:	8e 81       	ldd	r24, Y+6	; 0x06
    4ca6:	9f 81       	ldd	r25, Y+7	; 0x07
    4ca8:	ac 01       	movw	r20, r24
    4caa:	4e 5f       	subi	r20, 0xFE	; 254
    4cac:	5f 4f       	sbci	r21, 0xFF	; 255
    4cae:	8e 81       	ldd	r24, Y+6	; 0x06
    4cb0:	9f 81       	ldd	r25, Y+7	; 0x07
    4cb2:	fc 01       	movw	r30, r24
    4cb4:	86 89       	ldd	r24, Z+22	; 0x16
    4cb6:	28 2f       	mov	r18, r24
    4cb8:	30 e0       	ldi	r19, 0x00	; 0
    4cba:	c9 01       	movw	r24, r18
    4cbc:	88 0f       	add	r24, r24
    4cbe:	99 1f       	adc	r25, r25
    4cc0:	88 0f       	add	r24, r24
    4cc2:	99 1f       	adc	r25, r25
    4cc4:	88 0f       	add	r24, r24
    4cc6:	99 1f       	adc	r25, r25
    4cc8:	82 0f       	add	r24, r18
    4cca:	93 1f       	adc	r25, r19
    4ccc:	81 57       	subi	r24, 0x71	; 113
    4cce:	99 4f       	sbci	r25, 0xF9	; 249
    4cd0:	ba 01       	movw	r22, r20
    4cd2:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4cd6:	8e 81       	ldd	r24, Y+6	; 0x06
    4cd8:	9f 81       	ldd	r25, Y+7	; 0x07
    4cda:	fc 01       	movw	r30, r24
    4cdc:	26 89       	ldd	r18, Z+22	; 0x16
    4cde:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4ce2:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4ce6:	fc 01       	movw	r30, r24
    4ce8:	86 89       	ldd	r24, Z+22	; 0x16
    4cea:	28 17       	cp	r18, r24
    4cec:	08 f4       	brcc	.+2      	; 0x4cf0 <xTaskIncrementTick+0x176>
    4cee:	8b cf       	rjmp	.-234    	; 0x4c06 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4cf0:	81 e0       	ldi	r24, 0x01	; 1
    4cf2:	89 83       	std	Y+1, r24	; 0x01
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    4cf4:	88 cf       	rjmp	.-240    	; 0x4c06 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4cf6:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4cfa:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4cfe:	fc 01       	movw	r30, r24
    4d00:	86 89       	ldd	r24, Z+22	; 0x16
    4d02:	28 2f       	mov	r18, r24
    4d04:	30 e0       	ldi	r19, 0x00	; 0
    4d06:	c9 01       	movw	r24, r18
    4d08:	88 0f       	add	r24, r24
    4d0a:	99 1f       	adc	r25, r25
    4d0c:	88 0f       	add	r24, r24
    4d0e:	99 1f       	adc	r25, r25
    4d10:	88 0f       	add	r24, r24
    4d12:	99 1f       	adc	r25, r25
    4d14:	82 0f       	add	r24, r18
    4d16:	93 1f       	adc	r25, r19
    4d18:	81 57       	subi	r24, 0x71	; 113
    4d1a:	99 4f       	sbci	r25, 0xF9	; 249
    4d1c:	fc 01       	movw	r30, r24
    4d1e:	80 81       	ld	r24, Z
    4d20:	82 30       	cpi	r24, 0x02	; 2
    4d22:	40 f0       	brcs	.+16     	; 0x4d34 <xTaskIncrementTick+0x1ba>
			{
				xSwitchRequired = pdTRUE;
    4d24:	81 e0       	ldi	r24, 0x01	; 1
    4d26:	89 83       	std	Y+1, r24	; 0x01
    4d28:	05 c0       	rjmp	.+10     	; 0x4d34 <xTaskIncrementTick+0x1ba>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4d2a:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <uxPendedTicks>
    4d2e:	8f 5f       	subi	r24, 0xFF	; 255
    4d30:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <uxPendedTicks>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4d34:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <xYieldPending>
    4d38:	88 23       	and	r24, r24
    4d3a:	11 f0       	breq	.+4      	; 0x4d40 <xTaskIncrementTick+0x1c6>
		{
			xSwitchRequired = pdTRUE;
    4d3c:	81 e0       	ldi	r24, 0x01	; 1
    4d3e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4d40:	89 81       	ldd	r24, Y+1	; 0x01
}
    4d42:	29 96       	adiw	r28, 0x09	; 9
    4d44:	0f b6       	in	r0, 0x3f	; 63
    4d46:	f8 94       	cli
    4d48:	de bf       	out	0x3e, r29	; 62
    4d4a:	0f be       	out	0x3f, r0	; 63
    4d4c:	cd bf       	out	0x3d, r28	; 61
    4d4e:	df 91       	pop	r29
    4d50:	cf 91       	pop	r28
    4d52:	08 95       	ret

00004d54 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4d54:	cf 93       	push	r28
    4d56:	df 93       	push	r29
    4d58:	00 d0       	rcall	.+0      	; 0x4d5a <vTaskSwitchContext+0x6>
    4d5a:	1f 92       	push	r1
    4d5c:	cd b7       	in	r28, 0x3d	; 61
    4d5e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4d60:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    4d64:	88 23       	and	r24, r24
    4d66:	21 f0       	breq	.+8      	; 0x4d70 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4d68:	81 e0       	ldi	r24, 0x01	; 1
    4d6a:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4d6e:	5f c0       	rjmp	.+190    	; 0x4e2e <vTaskSwitchContext+0xda>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    4d70:	10 92 f4 06 	sts	0x06F4, r1	; 0x8006f4 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d74:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    4d78:	89 83       	std	Y+1, r24	; 0x01
    4d7a:	03 c0       	rjmp	.+6      	; 0x4d82 <vTaskSwitchContext+0x2e>
    4d7c:	89 81       	ldd	r24, Y+1	; 0x01
    4d7e:	81 50       	subi	r24, 0x01	; 1
    4d80:	89 83       	std	Y+1, r24	; 0x01
    4d82:	89 81       	ldd	r24, Y+1	; 0x01
    4d84:	28 2f       	mov	r18, r24
    4d86:	30 e0       	ldi	r19, 0x00	; 0
    4d88:	c9 01       	movw	r24, r18
    4d8a:	88 0f       	add	r24, r24
    4d8c:	99 1f       	adc	r25, r25
    4d8e:	88 0f       	add	r24, r24
    4d90:	99 1f       	adc	r25, r25
    4d92:	88 0f       	add	r24, r24
    4d94:	99 1f       	adc	r25, r25
    4d96:	82 0f       	add	r24, r18
    4d98:	93 1f       	adc	r25, r19
    4d9a:	81 57       	subi	r24, 0x71	; 113
    4d9c:	99 4f       	sbci	r25, 0xF9	; 249
    4d9e:	fc 01       	movw	r30, r24
    4da0:	80 81       	ld	r24, Z
    4da2:	88 23       	and	r24, r24
    4da4:	59 f3       	breq	.-42     	; 0x4d7c <vTaskSwitchContext+0x28>
    4da6:	89 81       	ldd	r24, Y+1	; 0x01
    4da8:	28 2f       	mov	r18, r24
    4daa:	30 e0       	ldi	r19, 0x00	; 0
    4dac:	c9 01       	movw	r24, r18
    4dae:	88 0f       	add	r24, r24
    4db0:	99 1f       	adc	r25, r25
    4db2:	88 0f       	add	r24, r24
    4db4:	99 1f       	adc	r25, r25
    4db6:	88 0f       	add	r24, r24
    4db8:	99 1f       	adc	r25, r25
    4dba:	82 0f       	add	r24, r18
    4dbc:	93 1f       	adc	r25, r19
    4dbe:	81 57       	subi	r24, 0x71	; 113
    4dc0:	99 4f       	sbci	r25, 0xF9	; 249
    4dc2:	9b 83       	std	Y+3, r25	; 0x03
    4dc4:	8a 83       	std	Y+2, r24	; 0x02
    4dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    4dc8:	9b 81       	ldd	r25, Y+3	; 0x03
    4dca:	fc 01       	movw	r30, r24
    4dcc:	81 81       	ldd	r24, Z+1	; 0x01
    4dce:	92 81       	ldd	r25, Z+2	; 0x02
    4dd0:	fc 01       	movw	r30, r24
    4dd2:	22 81       	ldd	r18, Z+2	; 0x02
    4dd4:	33 81       	ldd	r19, Z+3	; 0x03
    4dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    4dd8:	9b 81       	ldd	r25, Y+3	; 0x03
    4dda:	fc 01       	movw	r30, r24
    4ddc:	32 83       	std	Z+2, r19	; 0x02
    4dde:	21 83       	std	Z+1, r18	; 0x01
    4de0:	8a 81       	ldd	r24, Y+2	; 0x02
    4de2:	9b 81       	ldd	r25, Y+3	; 0x03
    4de4:	fc 01       	movw	r30, r24
    4de6:	21 81       	ldd	r18, Z+1	; 0x01
    4de8:	32 81       	ldd	r19, Z+2	; 0x02
    4dea:	8a 81       	ldd	r24, Y+2	; 0x02
    4dec:	9b 81       	ldd	r25, Y+3	; 0x03
    4dee:	03 96       	adiw	r24, 0x03	; 3
    4df0:	28 17       	cp	r18, r24
    4df2:	39 07       	cpc	r19, r25
    4df4:	69 f4       	brne	.+26     	; 0x4e10 <vTaskSwitchContext+0xbc>
    4df6:	8a 81       	ldd	r24, Y+2	; 0x02
    4df8:	9b 81       	ldd	r25, Y+3	; 0x03
    4dfa:	fc 01       	movw	r30, r24
    4dfc:	81 81       	ldd	r24, Z+1	; 0x01
    4dfe:	92 81       	ldd	r25, Z+2	; 0x02
    4e00:	fc 01       	movw	r30, r24
    4e02:	22 81       	ldd	r18, Z+2	; 0x02
    4e04:	33 81       	ldd	r19, Z+3	; 0x03
    4e06:	8a 81       	ldd	r24, Y+2	; 0x02
    4e08:	9b 81       	ldd	r25, Y+3	; 0x03
    4e0a:	fc 01       	movw	r30, r24
    4e0c:	32 83       	std	Z+2, r19	; 0x02
    4e0e:	21 83       	std	Z+1, r18	; 0x01
    4e10:	8a 81       	ldd	r24, Y+2	; 0x02
    4e12:	9b 81       	ldd	r25, Y+3	; 0x03
    4e14:	fc 01       	movw	r30, r24
    4e16:	81 81       	ldd	r24, Z+1	; 0x01
    4e18:	92 81       	ldd	r25, Z+2	; 0x02
    4e1a:	fc 01       	movw	r30, r24
    4e1c:	86 81       	ldd	r24, Z+6	; 0x06
    4e1e:	97 81       	ldd	r25, Z+7	; 0x07
    4e20:	90 93 8e 06 	sts	0x068E, r25	; 0x80068e <pxCurrentTCB+0x1>
    4e24:	80 93 8d 06 	sts	0x068D, r24	; 0x80068d <pxCurrentTCB>
    4e28:	89 81       	ldd	r24, Y+1	; 0x01
    4e2a:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4e2e:	00 00       	nop
    4e30:	0f 90       	pop	r0
    4e32:	0f 90       	pop	r0
    4e34:	0f 90       	pop	r0
    4e36:	df 91       	pop	r29
    4e38:	cf 91       	pop	r28
    4e3a:	08 95       	ret

00004e3c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4e3c:	cf 93       	push	r28
    4e3e:	df 93       	push	r29
    4e40:	00 d0       	rcall	.+0      	; 0x4e42 <vTaskPlaceOnEventList+0x6>
    4e42:	00 d0       	rcall	.+0      	; 0x4e44 <vTaskPlaceOnEventList+0x8>
    4e44:	cd b7       	in	r28, 0x3d	; 61
    4e46:	de b7       	in	r29, 0x3e	; 62
    4e48:	9a 83       	std	Y+2, r25	; 0x02
    4e4a:	89 83       	std	Y+1, r24	; 0x01
    4e4c:	7c 83       	std	Y+4, r23	; 0x04
    4e4e:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4e50:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4e54:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4e58:	9c 01       	movw	r18, r24
    4e5a:	24 5f       	subi	r18, 0xF4	; 244
    4e5c:	3f 4f       	sbci	r19, 0xFF	; 255
    4e5e:	89 81       	ldd	r24, Y+1	; 0x01
    4e60:	9a 81       	ldd	r25, Y+2	; 0x02
    4e62:	b9 01       	movw	r22, r18
    4e64:	0e 94 c8 13 	call	0x2790	; 0x2790 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e68:	8b 81       	ldd	r24, Y+3	; 0x03
    4e6a:	9c 81       	ldd	r25, Y+4	; 0x04
    4e6c:	61 e0       	ldi	r22, 0x01	; 1
    4e6e:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <prvAddCurrentTaskToDelayedList>
}
    4e72:	00 00       	nop
    4e74:	0f 90       	pop	r0
    4e76:	0f 90       	pop	r0
    4e78:	0f 90       	pop	r0
    4e7a:	0f 90       	pop	r0
    4e7c:	df 91       	pop	r29
    4e7e:	cf 91       	pop	r28
    4e80:	08 95       	ret

00004e82 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4e82:	cf 93       	push	r28
    4e84:	df 93       	push	r29
    4e86:	00 d0       	rcall	.+0      	; 0x4e88 <vTaskPlaceOnUnorderedEventList+0x6>
    4e88:	00 d0       	rcall	.+0      	; 0x4e8a <vTaskPlaceOnUnorderedEventList+0x8>
    4e8a:	00 d0       	rcall	.+0      	; 0x4e8c <vTaskPlaceOnUnorderedEventList+0xa>
    4e8c:	cd b7       	in	r28, 0x3d	; 61
    4e8e:	de b7       	in	r29, 0x3e	; 62
    4e90:	9a 83       	std	Y+2, r25	; 0x02
    4e92:	89 83       	std	Y+1, r24	; 0x01
    4e94:	7c 83       	std	Y+4, r23	; 0x04
    4e96:	6b 83       	std	Y+3, r22	; 0x03
    4e98:	5e 83       	std	Y+6, r21	; 0x06
    4e9a:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4e9c:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4ea0:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4ea4:	2b 81       	ldd	r18, Y+3	; 0x03
    4ea6:	3c 81       	ldd	r19, Y+4	; 0x04
    4ea8:	30 68       	ori	r19, 0x80	; 128
    4eaa:	fc 01       	movw	r30, r24
    4eac:	35 87       	std	Z+13, r19	; 0x0d
    4eae:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4eb0:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4eb4:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4eb8:	9c 01       	movw	r18, r24
    4eba:	24 5f       	subi	r18, 0xF4	; 244
    4ebc:	3f 4f       	sbci	r19, 0xFF	; 255
    4ebe:	89 81       	ldd	r24, Y+1	; 0x01
    4ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ec2:	b9 01       	movw	r22, r18
    4ec4:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4ec8:	8d 81       	ldd	r24, Y+5	; 0x05
    4eca:	9e 81       	ldd	r25, Y+6	; 0x06
    4ecc:	61 e0       	ldi	r22, 0x01	; 1
    4ece:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <prvAddCurrentTaskToDelayedList>
}
    4ed2:	00 00       	nop
    4ed4:	26 96       	adiw	r28, 0x06	; 6
    4ed6:	0f b6       	in	r0, 0x3f	; 63
    4ed8:	f8 94       	cli
    4eda:	de bf       	out	0x3e, r29	; 62
    4edc:	0f be       	out	0x3f, r0	; 63
    4ede:	cd bf       	out	0x3d, r28	; 61
    4ee0:	df 91       	pop	r29
    4ee2:	cf 91       	pop	r28
    4ee4:	08 95       	ret

00004ee6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4ee6:	cf 93       	push	r28
    4ee8:	df 93       	push	r29
    4eea:	00 d0       	rcall	.+0      	; 0x4eec <xTaskRemoveFromEventList+0x6>
    4eec:	00 d0       	rcall	.+0      	; 0x4eee <xTaskRemoveFromEventList+0x8>
    4eee:	1f 92       	push	r1
    4ef0:	cd b7       	in	r28, 0x3d	; 61
    4ef2:	de b7       	in	r29, 0x3e	; 62
    4ef4:	9d 83       	std	Y+5, r25	; 0x05
    4ef6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ef8:	8c 81       	ldd	r24, Y+4	; 0x04
    4efa:	9d 81       	ldd	r25, Y+5	; 0x05
    4efc:	fc 01       	movw	r30, r24
    4efe:	85 81       	ldd	r24, Z+5	; 0x05
    4f00:	96 81       	ldd	r25, Z+6	; 0x06
    4f02:	fc 01       	movw	r30, r24
    4f04:	86 81       	ldd	r24, Z+6	; 0x06
    4f06:	97 81       	ldd	r25, Z+7	; 0x07
    4f08:	9b 83       	std	Y+3, r25	; 0x03
    4f0a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4f0c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f0e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f10:	0c 96       	adiw	r24, 0x0c	; 12
    4f12:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f16:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    4f1a:	88 23       	and	r24, r24
    4f1c:	69 f5       	brne	.+90     	; 0x4f78 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4f1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4f20:	9b 81       	ldd	r25, Y+3	; 0x03
    4f22:	02 96       	adiw	r24, 0x02	; 2
    4f24:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4f28:	8a 81       	ldd	r24, Y+2	; 0x02
    4f2a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f2c:	fc 01       	movw	r30, r24
    4f2e:	96 89       	ldd	r25, Z+22	; 0x16
    4f30:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    4f34:	89 17       	cp	r24, r25
    4f36:	30 f4       	brcc	.+12     	; 0x4f44 <xTaskRemoveFromEventList+0x5e>
    4f38:	8a 81       	ldd	r24, Y+2	; 0x02
    4f3a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f3c:	fc 01       	movw	r30, r24
    4f3e:	86 89       	ldd	r24, Z+22	; 0x16
    4f40:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    4f44:	8a 81       	ldd	r24, Y+2	; 0x02
    4f46:	9b 81       	ldd	r25, Y+3	; 0x03
    4f48:	ac 01       	movw	r20, r24
    4f4a:	4e 5f       	subi	r20, 0xFE	; 254
    4f4c:	5f 4f       	sbci	r21, 0xFF	; 255
    4f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    4f50:	9b 81       	ldd	r25, Y+3	; 0x03
    4f52:	fc 01       	movw	r30, r24
    4f54:	86 89       	ldd	r24, Z+22	; 0x16
    4f56:	28 2f       	mov	r18, r24
    4f58:	30 e0       	ldi	r19, 0x00	; 0
    4f5a:	c9 01       	movw	r24, r18
    4f5c:	88 0f       	add	r24, r24
    4f5e:	99 1f       	adc	r25, r25
    4f60:	88 0f       	add	r24, r24
    4f62:	99 1f       	adc	r25, r25
    4f64:	88 0f       	add	r24, r24
    4f66:	99 1f       	adc	r25, r25
    4f68:	82 0f       	add	r24, r18
    4f6a:	93 1f       	adc	r25, r19
    4f6c:	81 57       	subi	r24, 0x71	; 113
    4f6e:	99 4f       	sbci	r25, 0xF9	; 249
    4f70:	ba 01       	movw	r22, r20
    4f72:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
    4f76:	08 c0       	rjmp	.+16     	; 0x4f88 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4f78:	8a 81       	ldd	r24, Y+2	; 0x02
    4f7a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f7c:	0c 96       	adiw	r24, 0x0c	; 12
    4f7e:	bc 01       	movw	r22, r24
    4f80:	82 ed       	ldi	r24, 0xD2	; 210
    4f82:	96 e0       	ldi	r25, 0x06	; 6
    4f84:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f88:	8a 81       	ldd	r24, Y+2	; 0x02
    4f8a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f8c:	fc 01       	movw	r30, r24
    4f8e:	26 89       	ldd	r18, Z+22	; 0x16
    4f90:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    4f94:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    4f98:	fc 01       	movw	r30, r24
    4f9a:	86 89       	ldd	r24, Z+22	; 0x16
    4f9c:	82 17       	cp	r24, r18
    4f9e:	30 f4       	brcc	.+12     	; 0x4fac <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4fa0:	81 e0       	ldi	r24, 0x01	; 1
    4fa2:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4fa4:	81 e0       	ldi	r24, 0x01	; 1
    4fa6:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
    4faa:	01 c0       	rjmp	.+2      	; 0x4fae <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    4fac:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4fae:	89 81       	ldd	r24, Y+1	; 0x01
}
    4fb0:	0f 90       	pop	r0
    4fb2:	0f 90       	pop	r0
    4fb4:	0f 90       	pop	r0
    4fb6:	0f 90       	pop	r0
    4fb8:	0f 90       	pop	r0
    4fba:	df 91       	pop	r29
    4fbc:	cf 91       	pop	r28
    4fbe:	08 95       	ret

00004fc0 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4fc0:	cf 93       	push	r28
    4fc2:	df 93       	push	r29
    4fc4:	00 d0       	rcall	.+0      	; 0x4fc6 <vTaskRemoveFromUnorderedEventList+0x6>
    4fc6:	00 d0       	rcall	.+0      	; 0x4fc8 <vTaskRemoveFromUnorderedEventList+0x8>
    4fc8:	00 d0       	rcall	.+0      	; 0x4fca <vTaskRemoveFromUnorderedEventList+0xa>
    4fca:	cd b7       	in	r28, 0x3d	; 61
    4fcc:	de b7       	in	r29, 0x3e	; 62
    4fce:	9c 83       	std	Y+4, r25	; 0x04
    4fd0:	8b 83       	std	Y+3, r24	; 0x03
    4fd2:	7e 83       	std	Y+6, r23	; 0x06
    4fd4:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4fd6:	8d 81       	ldd	r24, Y+5	; 0x05
    4fd8:	9e 81       	ldd	r25, Y+6	; 0x06
    4fda:	9c 01       	movw	r18, r24
    4fdc:	30 68       	ori	r19, 0x80	; 128
    4fde:	8b 81       	ldd	r24, Y+3	; 0x03
    4fe0:	9c 81       	ldd	r25, Y+4	; 0x04
    4fe2:	fc 01       	movw	r30, r24
    4fe4:	31 83       	std	Z+1, r19	; 0x01
    4fe6:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    4fea:	9c 81       	ldd	r25, Y+4	; 0x04
    4fec:	fc 01       	movw	r30, r24
    4fee:	86 81       	ldd	r24, Z+6	; 0x06
    4ff0:	97 81       	ldd	r25, Z+7	; 0x07
    4ff2:	9a 83       	std	Y+2, r25	; 0x02
    4ff4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    4ffa:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4ffe:	89 81       	ldd	r24, Y+1	; 0x01
    5000:	9a 81       	ldd	r25, Y+2	; 0x02
    5002:	02 96       	adiw	r24, 0x02	; 2
    5004:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5008:	89 81       	ldd	r24, Y+1	; 0x01
    500a:	9a 81       	ldd	r25, Y+2	; 0x02
    500c:	fc 01       	movw	r30, r24
    500e:	96 89       	ldd	r25, Z+22	; 0x16
    5010:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    5014:	89 17       	cp	r24, r25
    5016:	30 f4       	brcc	.+12     	; 0x5024 <vTaskRemoveFromUnorderedEventList+0x64>
    5018:	89 81       	ldd	r24, Y+1	; 0x01
    501a:	9a 81       	ldd	r25, Y+2	; 0x02
    501c:	fc 01       	movw	r30, r24
    501e:	86 89       	ldd	r24, Z+22	; 0x16
    5020:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    5024:	89 81       	ldd	r24, Y+1	; 0x01
    5026:	9a 81       	ldd	r25, Y+2	; 0x02
    5028:	ac 01       	movw	r20, r24
    502a:	4e 5f       	subi	r20, 0xFE	; 254
    502c:	5f 4f       	sbci	r21, 0xFF	; 255
    502e:	89 81       	ldd	r24, Y+1	; 0x01
    5030:	9a 81       	ldd	r25, Y+2	; 0x02
    5032:	fc 01       	movw	r30, r24
    5034:	86 89       	ldd	r24, Z+22	; 0x16
    5036:	28 2f       	mov	r18, r24
    5038:	30 e0       	ldi	r19, 0x00	; 0
    503a:	c9 01       	movw	r24, r18
    503c:	88 0f       	add	r24, r24
    503e:	99 1f       	adc	r25, r25
    5040:	88 0f       	add	r24, r24
    5042:	99 1f       	adc	r25, r25
    5044:	88 0f       	add	r24, r24
    5046:	99 1f       	adc	r25, r25
    5048:	82 0f       	add	r24, r18
    504a:	93 1f       	adc	r25, r19
    504c:	81 57       	subi	r24, 0x71	; 113
    504e:	99 4f       	sbci	r25, 0xF9	; 249
    5050:	ba 01       	movw	r22, r20
    5052:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5056:	89 81       	ldd	r24, Y+1	; 0x01
    5058:	9a 81       	ldd	r25, Y+2	; 0x02
    505a:	fc 01       	movw	r30, r24
    505c:	26 89       	ldd	r18, Z+22	; 0x16
    505e:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5062:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5066:	fc 01       	movw	r30, r24
    5068:	86 89       	ldd	r24, Z+22	; 0x16
    506a:	82 17       	cp	r24, r18
    506c:	18 f4       	brcc	.+6      	; 0x5074 <vTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    506e:	81 e0       	ldi	r24, 0x01	; 1
    5070:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
	}
}
    5074:	00 00       	nop
    5076:	26 96       	adiw	r28, 0x06	; 6
    5078:	0f b6       	in	r0, 0x3f	; 63
    507a:	f8 94       	cli
    507c:	de bf       	out	0x3e, r29	; 62
    507e:	0f be       	out	0x3f, r0	; 63
    5080:	cd bf       	out	0x3d, r28	; 61
    5082:	df 91       	pop	r29
    5084:	cf 91       	pop	r28
    5086:	08 95       	ret

00005088 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5088:	cf 93       	push	r28
    508a:	df 93       	push	r29
    508c:	00 d0       	rcall	.+0      	; 0x508e <vTaskSetTimeOutState+0x6>
    508e:	cd b7       	in	r28, 0x3d	; 61
    5090:	de b7       	in	r29, 0x3e	; 62
    5092:	9a 83       	std	Y+2, r25	; 0x02
    5094:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5096:	0f b6       	in	r0, 0x3f	; 63
    5098:	f8 94       	cli
    509a:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    509c:	20 91 f5 06 	lds	r18, 0x06F5	; 0x8006f5 <xNumOfOverflows>
    50a0:	89 81       	ldd	r24, Y+1	; 0x01
    50a2:	9a 81       	ldd	r25, Y+2	; 0x02
    50a4:	fc 01       	movw	r30, r24
    50a6:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    50a8:	20 91 ef 06 	lds	r18, 0x06EF	; 0x8006ef <xTickCount>
    50ac:	30 91 f0 06 	lds	r19, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    50b0:	89 81       	ldd	r24, Y+1	; 0x01
    50b2:	9a 81       	ldd	r25, Y+2	; 0x02
    50b4:	fc 01       	movw	r30, r24
    50b6:	32 83       	std	Z+2, r19	; 0x02
    50b8:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    50ba:	0f 90       	pop	r0
    50bc:	0f be       	out	0x3f, r0	; 63
}
    50be:	00 00       	nop
    50c0:	0f 90       	pop	r0
    50c2:	0f 90       	pop	r0
    50c4:	df 91       	pop	r29
    50c6:	cf 91       	pop	r28
    50c8:	08 95       	ret

000050ca <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    50ca:	cf 93       	push	r28
    50cc:	df 93       	push	r29
    50ce:	00 d0       	rcall	.+0      	; 0x50d0 <vTaskInternalSetTimeOutState+0x6>
    50d0:	cd b7       	in	r28, 0x3d	; 61
    50d2:	de b7       	in	r29, 0x3e	; 62
    50d4:	9a 83       	std	Y+2, r25	; 0x02
    50d6:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    50d8:	20 91 f5 06 	lds	r18, 0x06F5	; 0x8006f5 <xNumOfOverflows>
    50dc:	89 81       	ldd	r24, Y+1	; 0x01
    50de:	9a 81       	ldd	r25, Y+2	; 0x02
    50e0:	fc 01       	movw	r30, r24
    50e2:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    50e4:	20 91 ef 06 	lds	r18, 0x06EF	; 0x8006ef <xTickCount>
    50e8:	30 91 f0 06 	lds	r19, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    50ec:	89 81       	ldd	r24, Y+1	; 0x01
    50ee:	9a 81       	ldd	r25, Y+2	; 0x02
    50f0:	fc 01       	movw	r30, r24
    50f2:	32 83       	std	Z+2, r19	; 0x02
    50f4:	21 83       	std	Z+1, r18	; 0x01
}
    50f6:	00 00       	nop
    50f8:	0f 90       	pop	r0
    50fa:	0f 90       	pop	r0
    50fc:	df 91       	pop	r29
    50fe:	cf 91       	pop	r28
    5100:	08 95       	ret

00005102 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5102:	cf 93       	push	r28
    5104:	df 93       	push	r29
    5106:	cd b7       	in	r28, 0x3d	; 61
    5108:	de b7       	in	r29, 0x3e	; 62
    510a:	29 97       	sbiw	r28, 0x09	; 9
    510c:	0f b6       	in	r0, 0x3f	; 63
    510e:	f8 94       	cli
    5110:	de bf       	out	0x3e, r29	; 62
    5112:	0f be       	out	0x3f, r0	; 63
    5114:	cd bf       	out	0x3d, r28	; 61
    5116:	9f 83       	std	Y+7, r25	; 0x07
    5118:	8e 83       	std	Y+6, r24	; 0x06
    511a:	79 87       	std	Y+9, r23	; 0x09
    511c:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    511e:	0f b6       	in	r0, 0x3f	; 63
    5120:	f8 94       	cli
    5122:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5124:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xTickCount>
    5128:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    512c:	9b 83       	std	Y+3, r25	; 0x03
    512e:	8a 83       	std	Y+2, r24	; 0x02
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5130:	8e 81       	ldd	r24, Y+6	; 0x06
    5132:	9f 81       	ldd	r25, Y+7	; 0x07
    5134:	fc 01       	movw	r30, r24
    5136:	81 81       	ldd	r24, Z+1	; 0x01
    5138:	92 81       	ldd	r25, Z+2	; 0x02
    513a:	2a 81       	ldd	r18, Y+2	; 0x02
    513c:	3b 81       	ldd	r19, Y+3	; 0x03
    513e:	a9 01       	movw	r20, r18
    5140:	48 1b       	sub	r20, r24
    5142:	59 0b       	sbc	r21, r25
    5144:	ca 01       	movw	r24, r20
    5146:	9d 83       	std	Y+5, r25	; 0x05
    5148:	8c 83       	std	Y+4, r24	; 0x04
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    514a:	88 85       	ldd	r24, Y+8	; 0x08
    514c:	99 85       	ldd	r25, Y+9	; 0x09
    514e:	fc 01       	movw	r30, r24
    5150:	80 81       	ld	r24, Z
    5152:	91 81       	ldd	r25, Z+1	; 0x01
    5154:	01 96       	adiw	r24, 0x01	; 1
    5156:	11 f4       	brne	.+4      	; 0x515c <xTaskCheckForTimeOut+0x5a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5158:	19 82       	std	Y+1, r1	; 0x01
    515a:	3a c0       	rjmp	.+116    	; 0x51d0 <xTaskCheckForTimeOut+0xce>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    515c:	8e 81       	ldd	r24, Y+6	; 0x06
    515e:	9f 81       	ldd	r25, Y+7	; 0x07
    5160:	fc 01       	movw	r30, r24
    5162:	90 81       	ld	r25, Z
    5164:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <xNumOfOverflows>
    5168:	98 17       	cp	r25, r24
    516a:	69 f0       	breq	.+26     	; 0x5186 <xTaskCheckForTimeOut+0x84>
    516c:	8e 81       	ldd	r24, Y+6	; 0x06
    516e:	9f 81       	ldd	r25, Y+7	; 0x07
    5170:	fc 01       	movw	r30, r24
    5172:	21 81       	ldd	r18, Z+1	; 0x01
    5174:	32 81       	ldd	r19, Z+2	; 0x02
    5176:	8a 81       	ldd	r24, Y+2	; 0x02
    5178:	9b 81       	ldd	r25, Y+3	; 0x03
    517a:	82 17       	cp	r24, r18
    517c:	93 07       	cpc	r25, r19
    517e:	18 f0       	brcs	.+6      	; 0x5186 <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5180:	81 e0       	ldi	r24, 0x01	; 1
    5182:	89 83       	std	Y+1, r24	; 0x01
    5184:	25 c0       	rjmp	.+74     	; 0x51d0 <xTaskCheckForTimeOut+0xce>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5186:	88 85       	ldd	r24, Y+8	; 0x08
    5188:	99 85       	ldd	r25, Y+9	; 0x09
    518a:	fc 01       	movw	r30, r24
    518c:	20 81       	ld	r18, Z
    518e:	31 81       	ldd	r19, Z+1	; 0x01
    5190:	8c 81       	ldd	r24, Y+4	; 0x04
    5192:	9d 81       	ldd	r25, Y+5	; 0x05
    5194:	82 17       	cp	r24, r18
    5196:	93 07       	cpc	r25, r19
    5198:	a0 f4       	brcc	.+40     	; 0x51c2 <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    519a:	88 85       	ldd	r24, Y+8	; 0x08
    519c:	99 85       	ldd	r25, Y+9	; 0x09
    519e:	fc 01       	movw	r30, r24
    51a0:	20 81       	ld	r18, Z
    51a2:	31 81       	ldd	r19, Z+1	; 0x01
    51a4:	8c 81       	ldd	r24, Y+4	; 0x04
    51a6:	9d 81       	ldd	r25, Y+5	; 0x05
    51a8:	28 1b       	sub	r18, r24
    51aa:	39 0b       	sbc	r19, r25
    51ac:	88 85       	ldd	r24, Y+8	; 0x08
    51ae:	99 85       	ldd	r25, Y+9	; 0x09
    51b0:	fc 01       	movw	r30, r24
    51b2:	31 83       	std	Z+1, r19	; 0x01
    51b4:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    51b6:	8e 81       	ldd	r24, Y+6	; 0x06
    51b8:	9f 81       	ldd	r25, Y+7	; 0x07
    51ba:	0e 94 65 28 	call	0x50ca	; 0x50ca <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    51be:	19 82       	std	Y+1, r1	; 0x01
    51c0:	07 c0       	rjmp	.+14     	; 0x51d0 <xTaskCheckForTimeOut+0xce>
		}
		else
		{
			*pxTicksToWait = 0;
    51c2:	88 85       	ldd	r24, Y+8	; 0x08
    51c4:	99 85       	ldd	r25, Y+9	; 0x09
    51c6:	fc 01       	movw	r30, r24
    51c8:	11 82       	std	Z+1, r1	; 0x01
    51ca:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    51cc:	81 e0       	ldi	r24, 0x01	; 1
    51ce:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    51d0:	0f 90       	pop	r0
    51d2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    51d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    51d6:	29 96       	adiw	r28, 0x09	; 9
    51d8:	0f b6       	in	r0, 0x3f	; 63
    51da:	f8 94       	cli
    51dc:	de bf       	out	0x3e, r29	; 62
    51de:	0f be       	out	0x3f, r0	; 63
    51e0:	cd bf       	out	0x3d, r28	; 61
    51e2:	df 91       	pop	r29
    51e4:	cf 91       	pop	r28
    51e6:	08 95       	ret

000051e8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    51e8:	cf 93       	push	r28
    51ea:	df 93       	push	r29
    51ec:	cd b7       	in	r28, 0x3d	; 61
    51ee:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    51f0:	81 e0       	ldi	r24, 0x01	; 1
    51f2:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
}
    51f6:	00 00       	nop
    51f8:	df 91       	pop	r29
    51fa:	cf 91       	pop	r28
    51fc:	08 95       	ret

000051fe <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    51fe:	cf 93       	push	r28
    5200:	df 93       	push	r29
    5202:	00 d0       	rcall	.+0      	; 0x5204 <prvIdleTask+0x6>
    5204:	cd b7       	in	r28, 0x3d	; 61
    5206:	de b7       	in	r29, 0x3e	; 62
    5208:	9a 83       	std	Y+2, r25	; 0x02
    520a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    520c:	0e 94 51 29 	call	0x52a2	; 0x52a2 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5210:	80 91 8f 06 	lds	r24, 0x068F	; 0x80068f <pxReadyTasksLists>
    5214:	82 30       	cpi	r24, 0x02	; 2
    5216:	d0 f3       	brcs	.-12     	; 0x520c <prvIdleTask+0xe>
			{
				taskYIELD();
    5218:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    521c:	f7 cf       	rjmp	.-18     	; 0x520c <prvIdleTask+0xe>

0000521e <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    521e:	cf 93       	push	r28
    5220:	df 93       	push	r29
    5222:	1f 92       	push	r1
    5224:	cd b7       	in	r28, 0x3d	; 61
    5226:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5228:	19 82       	std	Y+1, r1	; 0x01
    522a:	13 c0       	rjmp	.+38     	; 0x5252 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    522c:	89 81       	ldd	r24, Y+1	; 0x01
    522e:	28 2f       	mov	r18, r24
    5230:	30 e0       	ldi	r19, 0x00	; 0
    5232:	c9 01       	movw	r24, r18
    5234:	88 0f       	add	r24, r24
    5236:	99 1f       	adc	r25, r25
    5238:	88 0f       	add	r24, r24
    523a:	99 1f       	adc	r25, r25
    523c:	88 0f       	add	r24, r24
    523e:	99 1f       	adc	r25, r25
    5240:	82 0f       	add	r24, r18
    5242:	93 1f       	adc	r25, r19
    5244:	81 57       	subi	r24, 0x71	; 113
    5246:	99 4f       	sbci	r25, 0xF9	; 249
    5248:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    524c:	89 81       	ldd	r24, Y+1	; 0x01
    524e:	8f 5f       	subi	r24, 0xFF	; 255
    5250:	89 83       	std	Y+1, r24	; 0x01
    5252:	89 81       	ldd	r24, Y+1	; 0x01
    5254:	85 30       	cpi	r24, 0x05	; 5
    5256:	50 f3       	brcs	.-44     	; 0x522c <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5258:	8c eb       	ldi	r24, 0xBC	; 188
    525a:	96 e0       	ldi	r25, 0x06	; 6
    525c:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5260:	85 ec       	ldi	r24, 0xC5	; 197
    5262:	96 e0       	ldi	r25, 0x06	; 6
    5264:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5268:	82 ed       	ldi	r24, 0xD2	; 210
    526a:	96 e0       	ldi	r25, 0x06	; 6
    526c:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5270:	8b ed       	ldi	r24, 0xDB	; 219
    5272:	96 e0       	ldi	r25, 0x06	; 6
    5274:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5278:	85 ee       	ldi	r24, 0xE5	; 229
    527a:	96 e0       	ldi	r25, 0x06	; 6
    527c:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5280:	8c eb       	ldi	r24, 0xBC	; 188
    5282:	96 e0       	ldi	r25, 0x06	; 6
    5284:	90 93 cf 06 	sts	0x06CF, r25	; 0x8006cf <pxDelayedTaskList+0x1>
    5288:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    528c:	85 ec       	ldi	r24, 0xC5	; 197
    528e:	96 e0       	ldi	r25, 0x06	; 6
    5290:	90 93 d1 06 	sts	0x06D1, r25	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    5294:	80 93 d0 06 	sts	0x06D0, r24	; 0x8006d0 <pxOverflowDelayedTaskList>
}
    5298:	00 00       	nop
    529a:	0f 90       	pop	r0
    529c:	df 91       	pop	r29
    529e:	cf 91       	pop	r28
    52a0:	08 95       	ret

000052a2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    52a2:	cf 93       	push	r28
    52a4:	df 93       	push	r29
    52a6:	00 d0       	rcall	.+0      	; 0x52a8 <prvCheckTasksWaitingTermination+0x6>
    52a8:	cd b7       	in	r28, 0x3d	; 61
    52aa:	de b7       	in	r29, 0x3e	; 62
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    52ac:	21 c0       	rjmp	.+66     	; 0x52f0 <prvCheckTasksWaitingTermination+0x4e>
		{
			taskENTER_CRITICAL();
    52ae:	0f b6       	in	r0, 0x3f	; 63
    52b0:	f8 94       	cli
    52b2:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    52b4:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <xTasksWaitingTermination+0x5>
    52b8:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <xTasksWaitingTermination+0x6>
    52bc:	fc 01       	movw	r30, r24
    52be:	86 81       	ldd	r24, Z+6	; 0x06
    52c0:	97 81       	ldd	r25, Z+7	; 0x07
    52c2:	9a 83       	std	Y+2, r25	; 0x02
    52c4:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    52c6:	89 81       	ldd	r24, Y+1	; 0x01
    52c8:	9a 81       	ldd	r25, Y+2	; 0x02
    52ca:	02 96       	adiw	r24, 0x02	; 2
    52cc:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
				--uxCurrentNumberOfTasks;
    52d0:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <uxCurrentNumberOfTasks>
    52d4:	81 50       	subi	r24, 0x01	; 1
    52d6:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
    52da:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <uxDeletedTasksWaitingCleanUp>
    52de:	81 50       	subi	r24, 0x01	; 1
    52e0:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
    52e4:	0f 90       	pop	r0
    52e6:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    52e8:	89 81       	ldd	r24, Y+1	; 0x01
    52ea:	9a 81       	ldd	r25, Y+2	; 0x02
    52ec:	0e 94 82 29 	call	0x5304	; 0x5304 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    52f0:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <uxDeletedTasksWaitingCleanUp>
    52f4:	88 23       	and	r24, r24
    52f6:	d9 f6       	brne	.-74     	; 0x52ae <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    52f8:	00 00       	nop
    52fa:	0f 90       	pop	r0
    52fc:	0f 90       	pop	r0
    52fe:	df 91       	pop	r29
    5300:	cf 91       	pop	r28
    5302:	08 95       	ret

00005304 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5304:	cf 93       	push	r28
    5306:	df 93       	push	r29
    5308:	00 d0       	rcall	.+0      	; 0x530a <prvDeleteTCB+0x6>
    530a:	cd b7       	in	r28, 0x3d	; 61
    530c:	de b7       	in	r29, 0x3e	; 62
    530e:	9a 83       	std	Y+2, r25	; 0x02
    5310:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5312:	89 81       	ldd	r24, Y+1	; 0x01
    5314:	9a 81       	ldd	r25, Y+2	; 0x02
    5316:	fc 01       	movw	r30, r24
    5318:	87 89       	ldd	r24, Z+23	; 0x17
    531a:	90 8d       	ldd	r25, Z+24	; 0x18
    531c:	0e 94 07 13 	call	0x260e	; 0x260e <vPortFree>
			vPortFree( pxTCB );
    5320:	89 81       	ldd	r24, Y+1	; 0x01
    5322:	9a 81       	ldd	r25, Y+2	; 0x02
    5324:	0e 94 07 13 	call	0x260e	; 0x260e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5328:	00 00       	nop
    532a:	0f 90       	pop	r0
    532c:	0f 90       	pop	r0
    532e:	df 91       	pop	r29
    5330:	cf 91       	pop	r28
    5332:	08 95       	ret

00005334 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5334:	cf 93       	push	r28
    5336:	df 93       	push	r29
    5338:	00 d0       	rcall	.+0      	; 0x533a <prvResetNextTaskUnblockTime+0x6>
    533a:	cd b7       	in	r28, 0x3d	; 61
    533c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    533e:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <pxDelayedTaskList>
    5342:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <pxDelayedTaskList+0x1>
    5346:	fc 01       	movw	r30, r24
    5348:	80 81       	ld	r24, Z
    534a:	88 23       	and	r24, r24
    534c:	39 f4       	brne	.+14     	; 0x535c <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    534e:	8f ef       	ldi	r24, 0xFF	; 255
    5350:	9f ef       	ldi	r25, 0xFF	; 255
    5352:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    5356:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <xNextTaskUnblockTime>
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
    535a:	15 c0       	rjmp	.+42     	; 0x5386 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    535c:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <pxDelayedTaskList>
    5360:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <pxDelayedTaskList+0x1>
    5364:	fc 01       	movw	r30, r24
    5366:	85 81       	ldd	r24, Z+5	; 0x05
    5368:	96 81       	ldd	r25, Z+6	; 0x06
    536a:	fc 01       	movw	r30, r24
    536c:	86 81       	ldd	r24, Z+6	; 0x06
    536e:	97 81       	ldd	r25, Z+7	; 0x07
    5370:	9a 83       	std	Y+2, r25	; 0x02
    5372:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5374:	89 81       	ldd	r24, Y+1	; 0x01
    5376:	9a 81       	ldd	r25, Y+2	; 0x02
    5378:	fc 01       	movw	r30, r24
    537a:	82 81       	ldd	r24, Z+2	; 0x02
    537c:	93 81       	ldd	r25, Z+3	; 0x03
    537e:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    5382:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <xNextTaskUnblockTime>
	}
}
    5386:	00 00       	nop
    5388:	0f 90       	pop	r0
    538a:	0f 90       	pop	r0
    538c:	df 91       	pop	r29
    538e:	cf 91       	pop	r28
    5390:	08 95       	ret

00005392 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5392:	cf 93       	push	r28
    5394:	df 93       	push	r29
    5396:	00 d0       	rcall	.+0      	; 0x5398 <xTaskGetCurrentTaskHandle+0x6>
    5398:	cd b7       	in	r28, 0x3d	; 61
    539a:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    539c:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    53a0:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    53a4:	9a 83       	std	Y+2, r25	; 0x02
    53a6:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    53a8:	89 81       	ldd	r24, Y+1	; 0x01
    53aa:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    53ac:	0f 90       	pop	r0
    53ae:	0f 90       	pop	r0
    53b0:	df 91       	pop	r29
    53b2:	cf 91       	pop	r28
    53b4:	08 95       	ret

000053b6 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    53b6:	cf 93       	push	r28
    53b8:	df 93       	push	r29
    53ba:	00 d0       	rcall	.+0      	; 0x53bc <xTaskPriorityInherit+0x6>
    53bc:	00 d0       	rcall	.+0      	; 0x53be <xTaskPriorityInherit+0x8>
    53be:	1f 92       	push	r1
    53c0:	cd b7       	in	r28, 0x3d	; 61
    53c2:	de b7       	in	r29, 0x3e	; 62
    53c4:	9d 83       	std	Y+5, r25	; 0x05
    53c6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    53c8:	8c 81       	ldd	r24, Y+4	; 0x04
    53ca:	9d 81       	ldd	r25, Y+5	; 0x05
    53cc:	9b 83       	std	Y+3, r25	; 0x03
    53ce:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    53d0:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    53d2:	8c 81       	ldd	r24, Y+4	; 0x04
    53d4:	9d 81       	ldd	r25, Y+5	; 0x05
    53d6:	89 2b       	or	r24, r25
    53d8:	09 f4       	brne	.+2      	; 0x53dc <xTaskPriorityInherit+0x26>
    53da:	90 c0       	rjmp	.+288    	; 0x54fc <xTaskPriorityInherit+0x146>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    53dc:	8a 81       	ldd	r24, Y+2	; 0x02
    53de:	9b 81       	ldd	r25, Y+3	; 0x03
    53e0:	fc 01       	movw	r30, r24
    53e2:	26 89       	ldd	r18, Z+22	; 0x16
    53e4:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    53e8:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    53ec:	fc 01       	movw	r30, r24
    53ee:	86 89       	ldd	r24, Z+22	; 0x16
    53f0:	28 17       	cp	r18, r24
    53f2:	08 f0       	brcs	.+2      	; 0x53f6 <xTaskPriorityInherit+0x40>
    53f4:	75 c0       	rjmp	.+234    	; 0x54e0 <xTaskPriorityInherit+0x12a>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    53f6:	8a 81       	ldd	r24, Y+2	; 0x02
    53f8:	9b 81       	ldd	r25, Y+3	; 0x03
    53fa:	fc 01       	movw	r30, r24
    53fc:	84 85       	ldd	r24, Z+12	; 0x0c
    53fe:	95 85       	ldd	r25, Z+13	; 0x0d
    5400:	99 23       	and	r25, r25
    5402:	8c f0       	brlt	.+34     	; 0x5426 <xTaskPriorityInherit+0x70>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5404:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5408:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    540c:	fc 01       	movw	r30, r24
    540e:	86 89       	ldd	r24, Z+22	; 0x16
    5410:	88 2f       	mov	r24, r24
    5412:	90 e0       	ldi	r25, 0x00	; 0
    5414:	25 e0       	ldi	r18, 0x05	; 5
    5416:	30 e0       	ldi	r19, 0x00	; 0
    5418:	28 1b       	sub	r18, r24
    541a:	39 0b       	sbc	r19, r25
    541c:	8a 81       	ldd	r24, Y+2	; 0x02
    541e:	9b 81       	ldd	r25, Y+3	; 0x03
    5420:	fc 01       	movw	r30, r24
    5422:	35 87       	std	Z+13, r19	; 0x0d
    5424:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    5426:	8a 81       	ldd	r24, Y+2	; 0x02
    5428:	9b 81       	ldd	r25, Y+3	; 0x03
    542a:	fc 01       	movw	r30, r24
    542c:	42 85       	ldd	r20, Z+10	; 0x0a
    542e:	53 85       	ldd	r21, Z+11	; 0x0b
    5430:	8a 81       	ldd	r24, Y+2	; 0x02
    5432:	9b 81       	ldd	r25, Y+3	; 0x03
    5434:	fc 01       	movw	r30, r24
    5436:	86 89       	ldd	r24, Z+22	; 0x16
    5438:	28 2f       	mov	r18, r24
    543a:	30 e0       	ldi	r19, 0x00	; 0
    543c:	c9 01       	movw	r24, r18
    543e:	88 0f       	add	r24, r24
    5440:	99 1f       	adc	r25, r25
    5442:	88 0f       	add	r24, r24
    5444:	99 1f       	adc	r25, r25
    5446:	88 0f       	add	r24, r24
    5448:	99 1f       	adc	r25, r25
    544a:	82 0f       	add	r24, r18
    544c:	93 1f       	adc	r25, r19
    544e:	81 57       	subi	r24, 0x71	; 113
    5450:	99 4f       	sbci	r25, 0xF9	; 249
    5452:	48 17       	cp	r20, r24
    5454:	59 07       	cpc	r21, r25
    5456:	b9 f5       	brne	.+110    	; 0x54c6 <xTaskPriorityInherit+0x110>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5458:	8a 81       	ldd	r24, Y+2	; 0x02
    545a:	9b 81       	ldd	r25, Y+3	; 0x03
    545c:	02 96       	adiw	r24, 0x02	; 2
    545e:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    5462:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5466:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    546a:	fc 01       	movw	r30, r24
    546c:	26 89       	ldd	r18, Z+22	; 0x16
    546e:	8a 81       	ldd	r24, Y+2	; 0x02
    5470:	9b 81       	ldd	r25, Y+3	; 0x03
    5472:	fc 01       	movw	r30, r24
    5474:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    5476:	8a 81       	ldd	r24, Y+2	; 0x02
    5478:	9b 81       	ldd	r25, Y+3	; 0x03
    547a:	fc 01       	movw	r30, r24
    547c:	96 89       	ldd	r25, Z+22	; 0x16
    547e:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    5482:	89 17       	cp	r24, r25
    5484:	30 f4       	brcc	.+12     	; 0x5492 <xTaskPriorityInherit+0xdc>
    5486:	8a 81       	ldd	r24, Y+2	; 0x02
    5488:	9b 81       	ldd	r25, Y+3	; 0x03
    548a:	fc 01       	movw	r30, r24
    548c:	86 89       	ldd	r24, Z+22	; 0x16
    548e:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    5492:	8a 81       	ldd	r24, Y+2	; 0x02
    5494:	9b 81       	ldd	r25, Y+3	; 0x03
    5496:	ac 01       	movw	r20, r24
    5498:	4e 5f       	subi	r20, 0xFE	; 254
    549a:	5f 4f       	sbci	r21, 0xFF	; 255
    549c:	8a 81       	ldd	r24, Y+2	; 0x02
    549e:	9b 81       	ldd	r25, Y+3	; 0x03
    54a0:	fc 01       	movw	r30, r24
    54a2:	86 89       	ldd	r24, Z+22	; 0x16
    54a4:	28 2f       	mov	r18, r24
    54a6:	30 e0       	ldi	r19, 0x00	; 0
    54a8:	c9 01       	movw	r24, r18
    54aa:	88 0f       	add	r24, r24
    54ac:	99 1f       	adc	r25, r25
    54ae:	88 0f       	add	r24, r24
    54b0:	99 1f       	adc	r25, r25
    54b2:	88 0f       	add	r24, r24
    54b4:	99 1f       	adc	r25, r25
    54b6:	82 0f       	add	r24, r18
    54b8:	93 1f       	adc	r25, r19
    54ba:	81 57       	subi	r24, 0x71	; 113
    54bc:	99 4f       	sbci	r25, 0xF9	; 249
    54be:	ba 01       	movw	r22, r20
    54c0:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
    54c4:	0a c0       	rjmp	.+20     	; 0x54da <xTaskPriorityInherit+0x124>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    54c6:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    54ca:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    54ce:	fc 01       	movw	r30, r24
    54d0:	26 89       	ldd	r18, Z+22	; 0x16
    54d2:	8a 81       	ldd	r24, Y+2	; 0x02
    54d4:	9b 81       	ldd	r25, Y+3	; 0x03
    54d6:	fc 01       	movw	r30, r24
    54d8:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    54da:	81 e0       	ldi	r24, 0x01	; 1
    54dc:	89 83       	std	Y+1, r24	; 0x01
    54de:	0e c0       	rjmp	.+28     	; 0x54fc <xTaskPriorityInherit+0x146>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    54e0:	8a 81       	ldd	r24, Y+2	; 0x02
    54e2:	9b 81       	ldd	r25, Y+3	; 0x03
    54e4:	fc 01       	movw	r30, r24
    54e6:	21 a1       	ldd	r18, Z+33	; 0x21
    54e8:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    54ec:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    54f0:	fc 01       	movw	r30, r24
    54f2:	86 89       	ldd	r24, Z+22	; 0x16
    54f4:	28 17       	cp	r18, r24
    54f6:	10 f4       	brcc	.+4      	; 0x54fc <xTaskPriorityInherit+0x146>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    54f8:	81 e0       	ldi	r24, 0x01	; 1
    54fa:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    54fc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    54fe:	0f 90       	pop	r0
    5500:	0f 90       	pop	r0
    5502:	0f 90       	pop	r0
    5504:	0f 90       	pop	r0
    5506:	0f 90       	pop	r0
    5508:	df 91       	pop	r29
    550a:	cf 91       	pop	r28
    550c:	08 95       	ret

0000550e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    550e:	cf 93       	push	r28
    5510:	df 93       	push	r29
    5512:	00 d0       	rcall	.+0      	; 0x5514 <xTaskPriorityDisinherit+0x6>
    5514:	00 d0       	rcall	.+0      	; 0x5516 <xTaskPriorityDisinherit+0x8>
    5516:	1f 92       	push	r1
    5518:	cd b7       	in	r28, 0x3d	; 61
    551a:	de b7       	in	r29, 0x3e	; 62
    551c:	9d 83       	std	Y+5, r25	; 0x05
    551e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    5520:	8c 81       	ldd	r24, Y+4	; 0x04
    5522:	9d 81       	ldd	r25, Y+5	; 0x05
    5524:	9b 83       	std	Y+3, r25	; 0x03
    5526:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    5528:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    552a:	8c 81       	ldd	r24, Y+4	; 0x04
    552c:	9d 81       	ldd	r25, Y+5	; 0x05
    552e:	89 2b       	or	r24, r25
    5530:	09 f4       	brne	.+2      	; 0x5534 <xTaskPriorityDisinherit+0x26>
    5532:	61 c0       	rjmp	.+194    	; 0x55f6 <xTaskPriorityDisinherit+0xe8>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    5534:	8a 81       	ldd	r24, Y+2	; 0x02
    5536:	9b 81       	ldd	r25, Y+3	; 0x03
    5538:	fc 01       	movw	r30, r24
    553a:	82 a1       	ldd	r24, Z+34	; 0x22
    553c:	2f ef       	ldi	r18, 0xFF	; 255
    553e:	28 0f       	add	r18, r24
    5540:	8a 81       	ldd	r24, Y+2	; 0x02
    5542:	9b 81       	ldd	r25, Y+3	; 0x03
    5544:	fc 01       	movw	r30, r24
    5546:	22 a3       	std	Z+34, r18	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    5548:	8a 81       	ldd	r24, Y+2	; 0x02
    554a:	9b 81       	ldd	r25, Y+3	; 0x03
    554c:	fc 01       	movw	r30, r24
    554e:	26 89       	ldd	r18, Z+22	; 0x16
    5550:	8a 81       	ldd	r24, Y+2	; 0x02
    5552:	9b 81       	ldd	r25, Y+3	; 0x03
    5554:	fc 01       	movw	r30, r24
    5556:	81 a1       	ldd	r24, Z+33	; 0x21
    5558:	28 17       	cp	r18, r24
    555a:	09 f4       	brne	.+2      	; 0x555e <xTaskPriorityDisinherit+0x50>
    555c:	4c c0       	rjmp	.+152    	; 0x55f6 <xTaskPriorityDisinherit+0xe8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    555e:	8a 81       	ldd	r24, Y+2	; 0x02
    5560:	9b 81       	ldd	r25, Y+3	; 0x03
    5562:	fc 01       	movw	r30, r24
    5564:	82 a1       	ldd	r24, Z+34	; 0x22
    5566:	88 23       	and	r24, r24
    5568:	09 f0       	breq	.+2      	; 0x556c <xTaskPriorityDisinherit+0x5e>
    556a:	45 c0       	rjmp	.+138    	; 0x55f6 <xTaskPriorityDisinherit+0xe8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    556c:	8a 81       	ldd	r24, Y+2	; 0x02
    556e:	9b 81       	ldd	r25, Y+3	; 0x03
    5570:	02 96       	adiw	r24, 0x02	; 2
    5572:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    5576:	8a 81       	ldd	r24, Y+2	; 0x02
    5578:	9b 81       	ldd	r25, Y+3	; 0x03
    557a:	fc 01       	movw	r30, r24
    557c:	21 a1       	ldd	r18, Z+33	; 0x21
    557e:	8a 81       	ldd	r24, Y+2	; 0x02
    5580:	9b 81       	ldd	r25, Y+3	; 0x03
    5582:	fc 01       	movw	r30, r24
    5584:	26 8b       	std	Z+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5586:	8a 81       	ldd	r24, Y+2	; 0x02
    5588:	9b 81       	ldd	r25, Y+3	; 0x03
    558a:	fc 01       	movw	r30, r24
    558c:	86 89       	ldd	r24, Z+22	; 0x16
    558e:	88 2f       	mov	r24, r24
    5590:	90 e0       	ldi	r25, 0x00	; 0
    5592:	25 e0       	ldi	r18, 0x05	; 5
    5594:	30 e0       	ldi	r19, 0x00	; 0
    5596:	28 1b       	sub	r18, r24
    5598:	39 0b       	sbc	r19, r25
    559a:	8a 81       	ldd	r24, Y+2	; 0x02
    559c:	9b 81       	ldd	r25, Y+3	; 0x03
    559e:	fc 01       	movw	r30, r24
    55a0:	35 87       	std	Z+13, r19	; 0x0d
    55a2:	24 87       	std	Z+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    55a4:	8a 81       	ldd	r24, Y+2	; 0x02
    55a6:	9b 81       	ldd	r25, Y+3	; 0x03
    55a8:	fc 01       	movw	r30, r24
    55aa:	96 89       	ldd	r25, Z+22	; 0x16
    55ac:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    55b0:	89 17       	cp	r24, r25
    55b2:	30 f4       	brcc	.+12     	; 0x55c0 <xTaskPriorityDisinherit+0xb2>
    55b4:	8a 81       	ldd	r24, Y+2	; 0x02
    55b6:	9b 81       	ldd	r25, Y+3	; 0x03
    55b8:	fc 01       	movw	r30, r24
    55ba:	86 89       	ldd	r24, Z+22	; 0x16
    55bc:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    55c0:	8a 81       	ldd	r24, Y+2	; 0x02
    55c2:	9b 81       	ldd	r25, Y+3	; 0x03
    55c4:	ac 01       	movw	r20, r24
    55c6:	4e 5f       	subi	r20, 0xFE	; 254
    55c8:	5f 4f       	sbci	r21, 0xFF	; 255
    55ca:	8a 81       	ldd	r24, Y+2	; 0x02
    55cc:	9b 81       	ldd	r25, Y+3	; 0x03
    55ce:	fc 01       	movw	r30, r24
    55d0:	86 89       	ldd	r24, Z+22	; 0x16
    55d2:	28 2f       	mov	r18, r24
    55d4:	30 e0       	ldi	r19, 0x00	; 0
    55d6:	c9 01       	movw	r24, r18
    55d8:	88 0f       	add	r24, r24
    55da:	99 1f       	adc	r25, r25
    55dc:	88 0f       	add	r24, r24
    55de:	99 1f       	adc	r25, r25
    55e0:	88 0f       	add	r24, r24
    55e2:	99 1f       	adc	r25, r25
    55e4:	82 0f       	add	r24, r18
    55e6:	93 1f       	adc	r25, r19
    55e8:	81 57       	subi	r24, 0x71	; 113
    55ea:	99 4f       	sbci	r25, 0xF9	; 249
    55ec:	ba 01       	movw	r22, r20
    55ee:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    55f2:	81 e0       	ldi	r24, 0x01	; 1
    55f4:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    55f6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    55f8:	0f 90       	pop	r0
    55fa:	0f 90       	pop	r0
    55fc:	0f 90       	pop	r0
    55fe:	0f 90       	pop	r0
    5600:	0f 90       	pop	r0
    5602:	df 91       	pop	r29
    5604:	cf 91       	pop	r28
    5606:	08 95       	ret

00005608 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    5608:	cf 93       	push	r28
    560a:	df 93       	push	r29
    560c:	cd b7       	in	r28, 0x3d	; 61
    560e:	de b7       	in	r29, 0x3e	; 62
    5610:	28 97       	sbiw	r28, 0x08	; 8
    5612:	0f b6       	in	r0, 0x3f	; 63
    5614:	f8 94       	cli
    5616:	de bf       	out	0x3e, r29	; 62
    5618:	0f be       	out	0x3f, r0	; 63
    561a:	cd bf       	out	0x3d, r28	; 61
    561c:	9f 83       	std	Y+7, r25	; 0x07
    561e:	8e 83       	std	Y+6, r24	; 0x06
    5620:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    5622:	8e 81       	ldd	r24, Y+6	; 0x06
    5624:	9f 81       	ldd	r25, Y+7	; 0x07
    5626:	9b 83       	std	Y+3, r25	; 0x03
    5628:	8a 83       	std	Y+2, r24	; 0x02
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    562a:	81 e0       	ldi	r24, 0x01	; 1
    562c:	8c 83       	std	Y+4, r24	; 0x04

		if( pxMutexHolder != NULL )
    562e:	8e 81       	ldd	r24, Y+6	; 0x06
    5630:	9f 81       	ldd	r25, Y+7	; 0x07
    5632:	89 2b       	or	r24, r25
    5634:	09 f4       	brne	.+2      	; 0x5638 <vTaskPriorityDisinheritAfterTimeout+0x30>
    5636:	7e c0       	rjmp	.+252    	; 0x5734 <vTaskPriorityDisinheritAfterTimeout+0x12c>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    5638:	8a 81       	ldd	r24, Y+2	; 0x02
    563a:	9b 81       	ldd	r25, Y+3	; 0x03
    563c:	fc 01       	movw	r30, r24
    563e:	91 a1       	ldd	r25, Z+33	; 0x21
    5640:	88 85       	ldd	r24, Y+8	; 0x08
    5642:	98 17       	cp	r25, r24
    5644:	18 f4       	brcc	.+6      	; 0x564c <vTaskPriorityDisinheritAfterTimeout+0x44>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    5646:	88 85       	ldd	r24, Y+8	; 0x08
    5648:	89 83       	std	Y+1, r24	; 0x01
    564a:	05 c0       	rjmp	.+10     	; 0x5656 <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    564c:	8a 81       	ldd	r24, Y+2	; 0x02
    564e:	9b 81       	ldd	r25, Y+3	; 0x03
    5650:	fc 01       	movw	r30, r24
    5652:	81 a1       	ldd	r24, Z+33	; 0x21
    5654:	89 83       	std	Y+1, r24	; 0x01
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    5656:	8a 81       	ldd	r24, Y+2	; 0x02
    5658:	9b 81       	ldd	r25, Y+3	; 0x03
    565a:	fc 01       	movw	r30, r24
    565c:	96 89       	ldd	r25, Z+22	; 0x16
    565e:	89 81       	ldd	r24, Y+1	; 0x01
    5660:	98 17       	cp	r25, r24
    5662:	09 f4       	brne	.+2      	; 0x5666 <vTaskPriorityDisinheritAfterTimeout+0x5e>
    5664:	67 c0       	rjmp	.+206    	; 0x5734 <vTaskPriorityDisinheritAfterTimeout+0x12c>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    5666:	8a 81       	ldd	r24, Y+2	; 0x02
    5668:	9b 81       	ldd	r25, Y+3	; 0x03
    566a:	fc 01       	movw	r30, r24
    566c:	92 a1       	ldd	r25, Z+34	; 0x22
    566e:	8c 81       	ldd	r24, Y+4	; 0x04
    5670:	98 17       	cp	r25, r24
    5672:	09 f0       	breq	.+2      	; 0x5676 <vTaskPriorityDisinheritAfterTimeout+0x6e>
    5674:	5f c0       	rjmp	.+190    	; 0x5734 <vTaskPriorityDisinheritAfterTimeout+0x12c>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    5676:	8a 81       	ldd	r24, Y+2	; 0x02
    5678:	9b 81       	ldd	r25, Y+3	; 0x03
    567a:	fc 01       	movw	r30, r24
    567c:	86 89       	ldd	r24, Z+22	; 0x16
    567e:	8d 83       	std	Y+5, r24	; 0x05
					pxTCB->uxPriority = uxPriorityToUse;
    5680:	8a 81       	ldd	r24, Y+2	; 0x02
    5682:	9b 81       	ldd	r25, Y+3	; 0x03
    5684:	29 81       	ldd	r18, Y+1	; 0x01
    5686:	fc 01       	movw	r30, r24
    5688:	26 8b       	std	Z+22, r18	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    568a:	8a 81       	ldd	r24, Y+2	; 0x02
    568c:	9b 81       	ldd	r25, Y+3	; 0x03
    568e:	fc 01       	movw	r30, r24
    5690:	84 85       	ldd	r24, Z+12	; 0x0c
    5692:	95 85       	ldd	r25, Z+13	; 0x0d
    5694:	99 23       	and	r25, r25
    5696:	64 f0       	brlt	.+24     	; 0x56b0 <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5698:	89 81       	ldd	r24, Y+1	; 0x01
    569a:	88 2f       	mov	r24, r24
    569c:	90 e0       	ldi	r25, 0x00	; 0
    569e:	25 e0       	ldi	r18, 0x05	; 5
    56a0:	30 e0       	ldi	r19, 0x00	; 0
    56a2:	28 1b       	sub	r18, r24
    56a4:	39 0b       	sbc	r19, r25
    56a6:	8a 81       	ldd	r24, Y+2	; 0x02
    56a8:	9b 81       	ldd	r25, Y+3	; 0x03
    56aa:	fc 01       	movw	r30, r24
    56ac:	35 87       	std	Z+13, r19	; 0x0d
    56ae:	24 87       	std	Z+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    56b0:	8a 81       	ldd	r24, Y+2	; 0x02
    56b2:	9b 81       	ldd	r25, Y+3	; 0x03
    56b4:	fc 01       	movw	r30, r24
    56b6:	42 85       	ldd	r20, Z+10	; 0x0a
    56b8:	53 85       	ldd	r21, Z+11	; 0x0b
    56ba:	8d 81       	ldd	r24, Y+5	; 0x05
    56bc:	28 2f       	mov	r18, r24
    56be:	30 e0       	ldi	r19, 0x00	; 0
    56c0:	c9 01       	movw	r24, r18
    56c2:	88 0f       	add	r24, r24
    56c4:	99 1f       	adc	r25, r25
    56c6:	88 0f       	add	r24, r24
    56c8:	99 1f       	adc	r25, r25
    56ca:	88 0f       	add	r24, r24
    56cc:	99 1f       	adc	r25, r25
    56ce:	82 0f       	add	r24, r18
    56d0:	93 1f       	adc	r25, r19
    56d2:	81 57       	subi	r24, 0x71	; 113
    56d4:	99 4f       	sbci	r25, 0xF9	; 249
    56d6:	48 17       	cp	r20, r24
    56d8:	59 07       	cpc	r21, r25
    56da:	61 f5       	brne	.+88     	; 0x5734 <vTaskPriorityDisinheritAfterTimeout+0x12c>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    56dc:	8a 81       	ldd	r24, Y+2	; 0x02
    56de:	9b 81       	ldd	r25, Y+3	; 0x03
    56e0:	02 96       	adiw	r24, 0x02	; 2
    56e2:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    56e6:	8a 81       	ldd	r24, Y+2	; 0x02
    56e8:	9b 81       	ldd	r25, Y+3	; 0x03
    56ea:	fc 01       	movw	r30, r24
    56ec:	96 89       	ldd	r25, Z+22	; 0x16
    56ee:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    56f2:	89 17       	cp	r24, r25
    56f4:	30 f4       	brcc	.+12     	; 0x5702 <vTaskPriorityDisinheritAfterTimeout+0xfa>
    56f6:	8a 81       	ldd	r24, Y+2	; 0x02
    56f8:	9b 81       	ldd	r25, Y+3	; 0x03
    56fa:	fc 01       	movw	r30, r24
    56fc:	86 89       	ldd	r24, Z+22	; 0x16
    56fe:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    5702:	8a 81       	ldd	r24, Y+2	; 0x02
    5704:	9b 81       	ldd	r25, Y+3	; 0x03
    5706:	ac 01       	movw	r20, r24
    5708:	4e 5f       	subi	r20, 0xFE	; 254
    570a:	5f 4f       	sbci	r21, 0xFF	; 255
    570c:	8a 81       	ldd	r24, Y+2	; 0x02
    570e:	9b 81       	ldd	r25, Y+3	; 0x03
    5710:	fc 01       	movw	r30, r24
    5712:	86 89       	ldd	r24, Z+22	; 0x16
    5714:	28 2f       	mov	r18, r24
    5716:	30 e0       	ldi	r19, 0x00	; 0
    5718:	c9 01       	movw	r24, r18
    571a:	88 0f       	add	r24, r24
    571c:	99 1f       	adc	r25, r25
    571e:	88 0f       	add	r24, r24
    5720:	99 1f       	adc	r25, r25
    5722:	88 0f       	add	r24, r24
    5724:	99 1f       	adc	r25, r25
    5726:	82 0f       	add	r24, r18
    5728:	93 1f       	adc	r25, r19
    572a:	81 57       	subi	r24, 0x71	; 113
    572c:	99 4f       	sbci	r25, 0xF9	; 249
    572e:	ba 01       	movw	r22, r20
    5730:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5734:	00 00       	nop
    5736:	28 96       	adiw	r28, 0x08	; 8
    5738:	0f b6       	in	r0, 0x3f	; 63
    573a:	f8 94       	cli
    573c:	de bf       	out	0x3e, r29	; 62
    573e:	0f be       	out	0x3f, r0	; 63
    5740:	cd bf       	out	0x3d, r28	; 61
    5742:	df 91       	pop	r29
    5744:	cf 91       	pop	r28
    5746:	08 95       	ret

00005748 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5748:	cf 93       	push	r28
    574a:	df 93       	push	r29
    574c:	00 d0       	rcall	.+0      	; 0x574e <uxTaskResetEventItemValue+0x6>
    574e:	cd b7       	in	r28, 0x3d	; 61
    5750:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5752:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5756:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    575a:	fc 01       	movw	r30, r24
    575c:	84 85       	ldd	r24, Z+12	; 0x0c
    575e:	95 85       	ldd	r25, Z+13	; 0x0d
    5760:	9a 83       	std	Y+2, r25	; 0x02
    5762:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5764:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5768:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    576c:	20 91 8d 06 	lds	r18, 0x068D	; 0x80068d <pxCurrentTCB>
    5770:	30 91 8e 06 	lds	r19, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5774:	f9 01       	movw	r30, r18
    5776:	26 89       	ldd	r18, Z+22	; 0x16
    5778:	22 2f       	mov	r18, r18
    577a:	30 e0       	ldi	r19, 0x00	; 0
    577c:	45 e0       	ldi	r20, 0x05	; 5
    577e:	50 e0       	ldi	r21, 0x00	; 0
    5780:	ba 01       	movw	r22, r20
    5782:	62 1b       	sub	r22, r18
    5784:	73 0b       	sbc	r23, r19
    5786:	9b 01       	movw	r18, r22
    5788:	fc 01       	movw	r30, r24
    578a:	35 87       	std	Z+13, r19	; 0x0d
    578c:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    578e:	89 81       	ldd	r24, Y+1	; 0x01
    5790:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5792:	0f 90       	pop	r0
    5794:	0f 90       	pop	r0
    5796:	df 91       	pop	r29
    5798:	cf 91       	pop	r28
    579a:	08 95       	ret

0000579c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    579c:	cf 93       	push	r28
    579e:	df 93       	push	r29
    57a0:	cd b7       	in	r28, 0x3d	; 61
    57a2:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    57a4:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    57a8:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    57ac:	89 2b       	or	r24, r25
    57ae:	49 f0       	breq	.+18     	; 0x57c2 <pvTaskIncrementMutexHeldCount+0x26>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    57b0:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    57b4:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    57b8:	fc 01       	movw	r30, r24
    57ba:	22 a1       	ldd	r18, Z+34	; 0x22
    57bc:	2f 5f       	subi	r18, 0xFF	; 255
    57be:	fc 01       	movw	r30, r24
    57c0:	22 a3       	std	Z+34, r18	; 0x22
		}

		return pxCurrentTCB;
    57c2:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    57c6:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
	}
    57ca:	df 91       	pop	r29
    57cc:	cf 91       	pop	r28
    57ce:	08 95       	ret

000057d0 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    57d0:	cf 93       	push	r28
    57d2:	df 93       	push	r29
    57d4:	cd b7       	in	r28, 0x3d	; 61
    57d6:	de b7       	in	r29, 0x3e	; 62
    57d8:	27 97       	sbiw	r28, 0x07	; 7
    57da:	0f b6       	in	r0, 0x3f	; 63
    57dc:	f8 94       	cli
    57de:	de bf       	out	0x3e, r29	; 62
    57e0:	0f be       	out	0x3f, r0	; 63
    57e2:	cd bf       	out	0x3d, r28	; 61
    57e4:	8d 83       	std	Y+5, r24	; 0x05
    57e6:	7f 83       	std	Y+7, r23	; 0x07
    57e8:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    57ea:	0f b6       	in	r0, 0x3f	; 63
    57ec:	f8 94       	cli
    57ee:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    57f0:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    57f4:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    57f8:	fc 01       	movw	r30, r24
    57fa:	83 a1       	ldd	r24, Z+35	; 0x23
    57fc:	94 a1       	ldd	r25, Z+36	; 0x24
    57fe:	a5 a1       	ldd	r26, Z+37	; 0x25
    5800:	b6 a1       	ldd	r27, Z+38	; 0x26
    5802:	89 2b       	or	r24, r25
    5804:	8a 2b       	or	r24, r26
    5806:	8b 2b       	or	r24, r27
    5808:	91 f4       	brne	.+36     	; 0x582e <ulTaskNotifyTake+0x5e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    580a:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    580e:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5812:	21 e0       	ldi	r18, 0x01	; 1
    5814:	fc 01       	movw	r30, r24
    5816:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5818:	8e 81       	ldd	r24, Y+6	; 0x06
    581a:	9f 81       	ldd	r25, Y+7	; 0x07
    581c:	89 2b       	or	r24, r25
    581e:	39 f0       	breq	.+14     	; 0x582e <ulTaskNotifyTake+0x5e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5820:	8e 81       	ldd	r24, Y+6	; 0x06
    5822:	9f 81       	ldd	r25, Y+7	; 0x07
    5824:	61 e0       	ldi	r22, 0x01	; 1
    5826:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    582a:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    582e:	0f 90       	pop	r0
    5830:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5832:	0f b6       	in	r0, 0x3f	; 63
    5834:	f8 94       	cli
    5836:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5838:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    583c:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5840:	fc 01       	movw	r30, r24
    5842:	83 a1       	ldd	r24, Z+35	; 0x23
    5844:	94 a1       	ldd	r25, Z+36	; 0x24
    5846:	a5 a1       	ldd	r26, Z+37	; 0x25
    5848:	b6 a1       	ldd	r27, Z+38	; 0x26
    584a:	89 83       	std	Y+1, r24	; 0x01
    584c:	9a 83       	std	Y+2, r25	; 0x02
    584e:	ab 83       	std	Y+3, r26	; 0x03
    5850:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5852:	89 81       	ldd	r24, Y+1	; 0x01
    5854:	9a 81       	ldd	r25, Y+2	; 0x02
    5856:	ab 81       	ldd	r26, Y+3	; 0x03
    5858:	bc 81       	ldd	r27, Y+4	; 0x04
    585a:	89 2b       	or	r24, r25
    585c:	8a 2b       	or	r24, r26
    585e:	8b 2b       	or	r24, r27
    5860:	e9 f0       	breq	.+58     	; 0x589c <ulTaskNotifyTake+0xcc>
			{
				if( xClearCountOnExit != pdFALSE )
    5862:	8d 81       	ldd	r24, Y+5	; 0x05
    5864:	88 23       	and	r24, r24
    5866:	51 f0       	breq	.+20     	; 0x587c <ulTaskNotifyTake+0xac>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5868:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    586c:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5870:	fc 01       	movw	r30, r24
    5872:	13 a2       	std	Z+35, r1	; 0x23
    5874:	14 a2       	std	Z+36, r1	; 0x24
    5876:	15 a2       	std	Z+37, r1	; 0x25
    5878:	16 a2       	std	Z+38, r1	; 0x26
    587a:	10 c0       	rjmp	.+32     	; 0x589c <ulTaskNotifyTake+0xcc>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    587c:	20 91 8d 06 	lds	r18, 0x068D	; 0x80068d <pxCurrentTCB>
    5880:	30 91 8e 06 	lds	r19, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5884:	89 81       	ldd	r24, Y+1	; 0x01
    5886:	9a 81       	ldd	r25, Y+2	; 0x02
    5888:	ab 81       	ldd	r26, Y+3	; 0x03
    588a:	bc 81       	ldd	r27, Y+4	; 0x04
    588c:	01 97       	sbiw	r24, 0x01	; 1
    588e:	a1 09       	sbc	r26, r1
    5890:	b1 09       	sbc	r27, r1
    5892:	f9 01       	movw	r30, r18
    5894:	83 a3       	std	Z+35, r24	; 0x23
    5896:	94 a3       	std	Z+36, r25	; 0x24
    5898:	a5 a3       	std	Z+37, r26	; 0x25
    589a:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    589c:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    58a0:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    58a4:	fc 01       	movw	r30, r24
    58a6:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    58a8:	0f 90       	pop	r0
    58aa:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    58ac:	89 81       	ldd	r24, Y+1	; 0x01
    58ae:	9a 81       	ldd	r25, Y+2	; 0x02
    58b0:	ab 81       	ldd	r26, Y+3	; 0x03
    58b2:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    58b4:	bc 01       	movw	r22, r24
    58b6:	cd 01       	movw	r24, r26
    58b8:	27 96       	adiw	r28, 0x07	; 7
    58ba:	0f b6       	in	r0, 0x3f	; 63
    58bc:	f8 94       	cli
    58be:	de bf       	out	0x3e, r29	; 62
    58c0:	0f be       	out	0x3f, r0	; 63
    58c2:	cd bf       	out	0x3d, r28	; 61
    58c4:	df 91       	pop	r29
    58c6:	cf 91       	pop	r28
    58c8:	08 95       	ret

000058ca <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    58ca:	ef 92       	push	r14
    58cc:	ff 92       	push	r15
    58ce:	0f 93       	push	r16
    58d0:	1f 93       	push	r17
    58d2:	cf 93       	push	r28
    58d4:	df 93       	push	r29
    58d6:	cd b7       	in	r28, 0x3d	; 61
    58d8:	de b7       	in	r29, 0x3e	; 62
    58da:	2d 97       	sbiw	r28, 0x0d	; 13
    58dc:	0f b6       	in	r0, 0x3f	; 63
    58de:	f8 94       	cli
    58e0:	de bf       	out	0x3e, r29	; 62
    58e2:	0f be       	out	0x3f, r0	; 63
    58e4:	cd bf       	out	0x3d, r28	; 61
    58e6:	6a 83       	std	Y+2, r22	; 0x02
    58e8:	7b 83       	std	Y+3, r23	; 0x03
    58ea:	8c 83       	std	Y+4, r24	; 0x04
    58ec:	9d 83       	std	Y+5, r25	; 0x05
    58ee:	2e 83       	std	Y+6, r18	; 0x06
    58f0:	3f 83       	std	Y+7, r19	; 0x07
    58f2:	48 87       	std	Y+8, r20	; 0x08
    58f4:	59 87       	std	Y+9, r21	; 0x09
    58f6:	1b 87       	std	Y+11, r17	; 0x0b
    58f8:	0a 87       	std	Y+10, r16	; 0x0a
    58fa:	fd 86       	std	Y+13, r15	; 0x0d
    58fc:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    58fe:	0f b6       	in	r0, 0x3f	; 63
    5900:	f8 94       	cli
    5902:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5904:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5908:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    590c:	fc 01       	movw	r30, r24
    590e:	87 a1       	ldd	r24, Z+39	; 0x27
    5910:	82 30       	cpi	r24, 0x02	; 2
    5912:	61 f1       	breq	.+88     	; 0x596c <xTaskNotifyWait+0xa2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5914:	60 91 8d 06 	lds	r22, 0x068D	; 0x80068d <pxCurrentTCB>
    5918:	70 91 8e 06 	lds	r23, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    591c:	fb 01       	movw	r30, r22
    591e:	23 a1       	ldd	r18, Z+35	; 0x23
    5920:	34 a1       	ldd	r19, Z+36	; 0x24
    5922:	45 a1       	ldd	r20, Z+37	; 0x25
    5924:	56 a1       	ldd	r21, Z+38	; 0x26
    5926:	8a 81       	ldd	r24, Y+2	; 0x02
    5928:	9b 81       	ldd	r25, Y+3	; 0x03
    592a:	ac 81       	ldd	r26, Y+4	; 0x04
    592c:	bd 81       	ldd	r27, Y+5	; 0x05
    592e:	80 95       	com	r24
    5930:	90 95       	com	r25
    5932:	a0 95       	com	r26
    5934:	b0 95       	com	r27
    5936:	82 23       	and	r24, r18
    5938:	93 23       	and	r25, r19
    593a:	a4 23       	and	r26, r20
    593c:	b5 23       	and	r27, r21
    593e:	fb 01       	movw	r30, r22
    5940:	83 a3       	std	Z+35, r24	; 0x23
    5942:	94 a3       	std	Z+36, r25	; 0x24
    5944:	a5 a3       	std	Z+37, r26	; 0x25
    5946:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5948:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    594c:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5950:	21 e0       	ldi	r18, 0x01	; 1
    5952:	fc 01       	movw	r30, r24
    5954:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5956:	8c 85       	ldd	r24, Y+12	; 0x0c
    5958:	9d 85       	ldd	r25, Y+13	; 0x0d
    595a:	89 2b       	or	r24, r25
    595c:	39 f0       	breq	.+14     	; 0x596c <xTaskNotifyWait+0xa2>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    595e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5960:	9d 85       	ldd	r25, Y+13	; 0x0d
    5962:	61 e0       	ldi	r22, 0x01	; 1
    5964:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5968:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    596c:	0f 90       	pop	r0
    596e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5970:	0f b6       	in	r0, 0x3f	; 63
    5972:	f8 94       	cli
    5974:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5976:	8a 85       	ldd	r24, Y+10	; 0x0a
    5978:	9b 85       	ldd	r25, Y+11	; 0x0b
    597a:	89 2b       	or	r24, r25
    597c:	81 f0       	breq	.+32     	; 0x599e <xTaskNotifyWait+0xd4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    597e:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5982:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5986:	fc 01       	movw	r30, r24
    5988:	83 a1       	ldd	r24, Z+35	; 0x23
    598a:	94 a1       	ldd	r25, Z+36	; 0x24
    598c:	a5 a1       	ldd	r26, Z+37	; 0x25
    598e:	b6 a1       	ldd	r27, Z+38	; 0x26
    5990:	2a 85       	ldd	r18, Y+10	; 0x0a
    5992:	3b 85       	ldd	r19, Y+11	; 0x0b
    5994:	f9 01       	movw	r30, r18
    5996:	80 83       	st	Z, r24
    5998:	91 83       	std	Z+1, r25	; 0x01
    599a:	a2 83       	std	Z+2, r26	; 0x02
    599c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    599e:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    59a2:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    59a6:	fc 01       	movw	r30, r24
    59a8:	87 a1       	ldd	r24, Z+39	; 0x27
    59aa:	82 30       	cpi	r24, 0x02	; 2
    59ac:	11 f0       	breq	.+4      	; 0x59b2 <xTaskNotifyWait+0xe8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    59ae:	19 82       	std	Y+1, r1	; 0x01
    59b0:	1c c0       	rjmp	.+56     	; 0x59ea <xTaskNotifyWait+0x120>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    59b2:	60 91 8d 06 	lds	r22, 0x068D	; 0x80068d <pxCurrentTCB>
    59b6:	70 91 8e 06 	lds	r23, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    59ba:	fb 01       	movw	r30, r22
    59bc:	23 a1       	ldd	r18, Z+35	; 0x23
    59be:	34 a1       	ldd	r19, Z+36	; 0x24
    59c0:	45 a1       	ldd	r20, Z+37	; 0x25
    59c2:	56 a1       	ldd	r21, Z+38	; 0x26
    59c4:	8e 81       	ldd	r24, Y+6	; 0x06
    59c6:	9f 81       	ldd	r25, Y+7	; 0x07
    59c8:	a8 85       	ldd	r26, Y+8	; 0x08
    59ca:	b9 85       	ldd	r27, Y+9	; 0x09
    59cc:	80 95       	com	r24
    59ce:	90 95       	com	r25
    59d0:	a0 95       	com	r26
    59d2:	b0 95       	com	r27
    59d4:	82 23       	and	r24, r18
    59d6:	93 23       	and	r25, r19
    59d8:	a4 23       	and	r26, r20
    59da:	b5 23       	and	r27, r21
    59dc:	fb 01       	movw	r30, r22
    59de:	83 a3       	std	Z+35, r24	; 0x23
    59e0:	94 a3       	std	Z+36, r25	; 0x24
    59e2:	a5 a3       	std	Z+37, r26	; 0x25
    59e4:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    59e6:	81 e0       	ldi	r24, 0x01	; 1
    59e8:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    59ea:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    59ee:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    59f2:	fc 01       	movw	r30, r24
    59f4:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    59f6:	0f 90       	pop	r0
    59f8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    59fa:	89 81       	ldd	r24, Y+1	; 0x01
	}
    59fc:	2d 96       	adiw	r28, 0x0d	; 13
    59fe:	0f b6       	in	r0, 0x3f	; 63
    5a00:	f8 94       	cli
    5a02:	de bf       	out	0x3e, r29	; 62
    5a04:	0f be       	out	0x3f, r0	; 63
    5a06:	cd bf       	out	0x3d, r28	; 61
    5a08:	df 91       	pop	r29
    5a0a:	cf 91       	pop	r28
    5a0c:	1f 91       	pop	r17
    5a0e:	0f 91       	pop	r16
    5a10:	ff 90       	pop	r15
    5a12:	ef 90       	pop	r14
    5a14:	08 95       	ret

00005a16 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5a16:	0f 93       	push	r16
    5a18:	1f 93       	push	r17
    5a1a:	cf 93       	push	r28
    5a1c:	df 93       	push	r29
    5a1e:	cd b7       	in	r28, 0x3d	; 61
    5a20:	de b7       	in	r29, 0x3e	; 62
    5a22:	2d 97       	sbiw	r28, 0x0d	; 13
    5a24:	0f b6       	in	r0, 0x3f	; 63
    5a26:	f8 94       	cli
    5a28:	de bf       	out	0x3e, r29	; 62
    5a2a:	0f be       	out	0x3f, r0	; 63
    5a2c:	cd bf       	out	0x3d, r28	; 61
    5a2e:	9e 83       	std	Y+6, r25	; 0x06
    5a30:	8d 83       	std	Y+5, r24	; 0x05
    5a32:	4f 83       	std	Y+7, r20	; 0x07
    5a34:	58 87       	std	Y+8, r21	; 0x08
    5a36:	69 87       	std	Y+9, r22	; 0x09
    5a38:	7a 87       	std	Y+10, r23	; 0x0a
    5a3a:	2b 87       	std	Y+11, r18	; 0x0b
    5a3c:	1d 87       	std	Y+13, r17	; 0x0d
    5a3e:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5a40:	81 e0       	ldi	r24, 0x01	; 1
    5a42:	89 83       	std	Y+1, r24	; 0x01
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5a44:	8d 81       	ldd	r24, Y+5	; 0x05
    5a46:	9e 81       	ldd	r25, Y+6	; 0x06
    5a48:	9b 83       	std	Y+3, r25	; 0x03
    5a4a:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5a4c:	0f b6       	in	r0, 0x3f	; 63
    5a4e:	f8 94       	cli
    5a50:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5a52:	8c 85       	ldd	r24, Y+12	; 0x0c
    5a54:	9d 85       	ldd	r25, Y+13	; 0x0d
    5a56:	89 2b       	or	r24, r25
    5a58:	71 f0       	breq	.+28     	; 0x5a76 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    5a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    5a5e:	fc 01       	movw	r30, r24
    5a60:	83 a1       	ldd	r24, Z+35	; 0x23
    5a62:	94 a1       	ldd	r25, Z+36	; 0x24
    5a64:	a5 a1       	ldd	r26, Z+37	; 0x25
    5a66:	b6 a1       	ldd	r27, Z+38	; 0x26
    5a68:	2c 85       	ldd	r18, Y+12	; 0x0c
    5a6a:	3d 85       	ldd	r19, Y+13	; 0x0d
    5a6c:	f9 01       	movw	r30, r18
    5a6e:	80 83       	st	Z, r24
    5a70:	91 83       	std	Z+1, r25	; 0x01
    5a72:	a2 83       	std	Z+2, r26	; 0x02
    5a74:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5a76:	8a 81       	ldd	r24, Y+2	; 0x02
    5a78:	9b 81       	ldd	r25, Y+3	; 0x03
    5a7a:	fc 01       	movw	r30, r24
    5a7c:	87 a1       	ldd	r24, Z+39	; 0x27
    5a7e:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5a80:	8a 81       	ldd	r24, Y+2	; 0x02
    5a82:	9b 81       	ldd	r25, Y+3	; 0x03
    5a84:	22 e0       	ldi	r18, 0x02	; 2
    5a86:	fc 01       	movw	r30, r24
    5a88:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5a8a:	8b 85       	ldd	r24, Y+11	; 0x0b
    5a8c:	88 2f       	mov	r24, r24
    5a8e:	90 e0       	ldi	r25, 0x00	; 0
    5a90:	82 30       	cpi	r24, 0x02	; 2
    5a92:	91 05       	cpc	r25, r1
    5a94:	31 f1       	breq	.+76     	; 0x5ae2 <xTaskGenericNotify+0xcc>
    5a96:	83 30       	cpi	r24, 0x03	; 3
    5a98:	91 05       	cpc	r25, r1
    5a9a:	34 f4       	brge	.+12     	; 0x5aa8 <xTaskGenericNotify+0x92>
    5a9c:	00 97       	sbiw	r24, 0x00	; 0
    5a9e:	09 f4       	brne	.+2      	; 0x5aa2 <xTaskGenericNotify+0x8c>
    5aa0:	4f c0       	rjmp	.+158    	; 0x5b40 <xTaskGenericNotify+0x12a>
    5aa2:	01 97       	sbiw	r24, 0x01	; 1
    5aa4:	39 f0       	breq	.+14     	; 0x5ab4 <xTaskGenericNotify+0x9e>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5aa6:	4d c0       	rjmp	.+154    	; 0x5b42 <xTaskGenericNotify+0x12c>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5aa8:	83 30       	cpi	r24, 0x03	; 3
    5aaa:	91 05       	cpc	r25, r1
    5aac:	61 f1       	breq	.+88     	; 0x5b06 <xTaskGenericNotify+0xf0>
    5aae:	04 97       	sbiw	r24, 0x04	; 4
    5ab0:	b1 f1       	breq	.+108    	; 0x5b1e <xTaskGenericNotify+0x108>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5ab2:	47 c0       	rjmp	.+142    	; 0x5b42 <xTaskGenericNotify+0x12c>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5ab4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ab6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ab8:	fc 01       	movw	r30, r24
    5aba:	23 a1       	ldd	r18, Z+35	; 0x23
    5abc:	34 a1       	ldd	r19, Z+36	; 0x24
    5abe:	45 a1       	ldd	r20, Z+37	; 0x25
    5ac0:	56 a1       	ldd	r21, Z+38	; 0x26
    5ac2:	8f 81       	ldd	r24, Y+7	; 0x07
    5ac4:	98 85       	ldd	r25, Y+8	; 0x08
    5ac6:	a9 85       	ldd	r26, Y+9	; 0x09
    5ac8:	ba 85       	ldd	r27, Y+10	; 0x0a
    5aca:	82 2b       	or	r24, r18
    5acc:	93 2b       	or	r25, r19
    5ace:	a4 2b       	or	r26, r20
    5ad0:	b5 2b       	or	r27, r21
    5ad2:	2a 81       	ldd	r18, Y+2	; 0x02
    5ad4:	3b 81       	ldd	r19, Y+3	; 0x03
    5ad6:	f9 01       	movw	r30, r18
    5ad8:	83 a3       	std	Z+35, r24	; 0x23
    5ada:	94 a3       	std	Z+36, r25	; 0x24
    5adc:	a5 a3       	std	Z+37, r26	; 0x25
    5ade:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5ae0:	30 c0       	rjmp	.+96     	; 0x5b42 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5ae2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ae4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ae6:	fc 01       	movw	r30, r24
    5ae8:	83 a1       	ldd	r24, Z+35	; 0x23
    5aea:	94 a1       	ldd	r25, Z+36	; 0x24
    5aec:	a5 a1       	ldd	r26, Z+37	; 0x25
    5aee:	b6 a1       	ldd	r27, Z+38	; 0x26
    5af0:	01 96       	adiw	r24, 0x01	; 1
    5af2:	a1 1d       	adc	r26, r1
    5af4:	b1 1d       	adc	r27, r1
    5af6:	2a 81       	ldd	r18, Y+2	; 0x02
    5af8:	3b 81       	ldd	r19, Y+3	; 0x03
    5afa:	f9 01       	movw	r30, r18
    5afc:	83 a3       	std	Z+35, r24	; 0x23
    5afe:	94 a3       	std	Z+36, r25	; 0x24
    5b00:	a5 a3       	std	Z+37, r26	; 0x25
    5b02:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5b04:	1e c0       	rjmp	.+60     	; 0x5b42 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5b06:	2a 81       	ldd	r18, Y+2	; 0x02
    5b08:	3b 81       	ldd	r19, Y+3	; 0x03
    5b0a:	8f 81       	ldd	r24, Y+7	; 0x07
    5b0c:	98 85       	ldd	r25, Y+8	; 0x08
    5b0e:	a9 85       	ldd	r26, Y+9	; 0x09
    5b10:	ba 85       	ldd	r27, Y+10	; 0x0a
    5b12:	f9 01       	movw	r30, r18
    5b14:	83 a3       	std	Z+35, r24	; 0x23
    5b16:	94 a3       	std	Z+36, r25	; 0x24
    5b18:	a5 a3       	std	Z+37, r26	; 0x25
    5b1a:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5b1c:	12 c0       	rjmp	.+36     	; 0x5b42 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5b1e:	8c 81       	ldd	r24, Y+4	; 0x04
    5b20:	82 30       	cpi	r24, 0x02	; 2
    5b22:	61 f0       	breq	.+24     	; 0x5b3c <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5b24:	2a 81       	ldd	r18, Y+2	; 0x02
    5b26:	3b 81       	ldd	r19, Y+3	; 0x03
    5b28:	8f 81       	ldd	r24, Y+7	; 0x07
    5b2a:	98 85       	ldd	r25, Y+8	; 0x08
    5b2c:	a9 85       	ldd	r26, Y+9	; 0x09
    5b2e:	ba 85       	ldd	r27, Y+10	; 0x0a
    5b30:	f9 01       	movw	r30, r18
    5b32:	83 a3       	std	Z+35, r24	; 0x23
    5b34:	94 a3       	std	Z+36, r25	; 0x24
    5b36:	a5 a3       	std	Z+37, r26	; 0x25
    5b38:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5b3a:	03 c0       	rjmp	.+6      	; 0x5b42 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5b3c:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5b3e:	01 c0       	rjmp	.+2      	; 0x5b42 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    5b40:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5b42:	8c 81       	ldd	r24, Y+4	; 0x04
    5b44:	81 30       	cpi	r24, 0x01	; 1
    5b46:	d1 f5       	brne	.+116    	; 0x5bbc <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5b48:	8a 81       	ldd	r24, Y+2	; 0x02
    5b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    5b4c:	02 96       	adiw	r24, 0x02	; 2
    5b4e:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5b52:	8a 81       	ldd	r24, Y+2	; 0x02
    5b54:	9b 81       	ldd	r25, Y+3	; 0x03
    5b56:	fc 01       	movw	r30, r24
    5b58:	96 89       	ldd	r25, Z+22	; 0x16
    5b5a:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    5b5e:	89 17       	cp	r24, r25
    5b60:	30 f4       	brcc	.+12     	; 0x5b6e <xTaskGenericNotify+0x158>
    5b62:	8a 81       	ldd	r24, Y+2	; 0x02
    5b64:	9b 81       	ldd	r25, Y+3	; 0x03
    5b66:	fc 01       	movw	r30, r24
    5b68:	86 89       	ldd	r24, Z+22	; 0x16
    5b6a:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    5b6e:	8a 81       	ldd	r24, Y+2	; 0x02
    5b70:	9b 81       	ldd	r25, Y+3	; 0x03
    5b72:	ac 01       	movw	r20, r24
    5b74:	4e 5f       	subi	r20, 0xFE	; 254
    5b76:	5f 4f       	sbci	r21, 0xFF	; 255
    5b78:	8a 81       	ldd	r24, Y+2	; 0x02
    5b7a:	9b 81       	ldd	r25, Y+3	; 0x03
    5b7c:	fc 01       	movw	r30, r24
    5b7e:	86 89       	ldd	r24, Z+22	; 0x16
    5b80:	28 2f       	mov	r18, r24
    5b82:	30 e0       	ldi	r19, 0x00	; 0
    5b84:	c9 01       	movw	r24, r18
    5b86:	88 0f       	add	r24, r24
    5b88:	99 1f       	adc	r25, r25
    5b8a:	88 0f       	add	r24, r24
    5b8c:	99 1f       	adc	r25, r25
    5b8e:	88 0f       	add	r24, r24
    5b90:	99 1f       	adc	r25, r25
    5b92:	82 0f       	add	r24, r18
    5b94:	93 1f       	adc	r25, r19
    5b96:	81 57       	subi	r24, 0x71	; 113
    5b98:	99 4f       	sbci	r25, 0xF9	; 249
    5b9a:	ba 01       	movw	r22, r20
    5b9c:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ba0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ba2:	9b 81       	ldd	r25, Y+3	; 0x03
    5ba4:	fc 01       	movw	r30, r24
    5ba6:	26 89       	ldd	r18, Z+22	; 0x16
    5ba8:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5bac:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5bb0:	fc 01       	movw	r30, r24
    5bb2:	86 89       	ldd	r24, Z+22	; 0x16
    5bb4:	82 17       	cp	r24, r18
    5bb6:	10 f4       	brcc	.+4      	; 0x5bbc <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5bb8:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5bbc:	0f 90       	pop	r0
    5bbe:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5bc0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5bc2:	2d 96       	adiw	r28, 0x0d	; 13
    5bc4:	0f b6       	in	r0, 0x3f	; 63
    5bc6:	f8 94       	cli
    5bc8:	de bf       	out	0x3e, r29	; 62
    5bca:	0f be       	out	0x3f, r0	; 63
    5bcc:	cd bf       	out	0x3d, r28	; 61
    5bce:	df 91       	pop	r29
    5bd0:	cf 91       	pop	r28
    5bd2:	1f 91       	pop	r17
    5bd4:	0f 91       	pop	r16
    5bd6:	08 95       	ret

00005bd8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5bd8:	ef 92       	push	r14
    5bda:	ff 92       	push	r15
    5bdc:	0f 93       	push	r16
    5bde:	1f 93       	push	r17
    5be0:	cf 93       	push	r28
    5be2:	df 93       	push	r29
    5be4:	cd b7       	in	r28, 0x3d	; 61
    5be6:	de b7       	in	r29, 0x3e	; 62
    5be8:	60 97       	sbiw	r28, 0x10	; 16
    5bea:	0f b6       	in	r0, 0x3f	; 63
    5bec:	f8 94       	cli
    5bee:	de bf       	out	0x3e, r29	; 62
    5bf0:	0f be       	out	0x3f, r0	; 63
    5bf2:	cd bf       	out	0x3d, r28	; 61
    5bf4:	9f 83       	std	Y+7, r25	; 0x07
    5bf6:	8e 83       	std	Y+6, r24	; 0x06
    5bf8:	48 87       	std	Y+8, r20	; 0x08
    5bfa:	59 87       	std	Y+9, r21	; 0x09
    5bfc:	6a 87       	std	Y+10, r22	; 0x0a
    5bfe:	7b 87       	std	Y+11, r23	; 0x0b
    5c00:	2c 87       	std	Y+12, r18	; 0x0c
    5c02:	1e 87       	std	Y+14, r17	; 0x0e
    5c04:	0d 87       	std	Y+13, r16	; 0x0d
    5c06:	f8 8a       	std	Y+16, r15	; 0x10
    5c08:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5c0a:	81 e0       	ldi	r24, 0x01	; 1
    5c0c:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5c0e:	8e 81       	ldd	r24, Y+6	; 0x06
    5c10:	9f 81       	ldd	r25, Y+7	; 0x07
    5c12:	9b 83       	std	Y+3, r25	; 0x03
    5c14:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5c16:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    5c18:	8d 85       	ldd	r24, Y+13	; 0x0d
    5c1a:	9e 85       	ldd	r25, Y+14	; 0x0e
    5c1c:	89 2b       	or	r24, r25
    5c1e:	71 f0       	breq	.+28     	; 0x5c3c <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5c20:	8a 81       	ldd	r24, Y+2	; 0x02
    5c22:	9b 81       	ldd	r25, Y+3	; 0x03
    5c24:	fc 01       	movw	r30, r24
    5c26:	83 a1       	ldd	r24, Z+35	; 0x23
    5c28:	94 a1       	ldd	r25, Z+36	; 0x24
    5c2a:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c2c:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c2e:	2d 85       	ldd	r18, Y+13	; 0x0d
    5c30:	3e 85       	ldd	r19, Y+14	; 0x0e
    5c32:	f9 01       	movw	r30, r18
    5c34:	80 83       	st	Z, r24
    5c36:	91 83       	std	Z+1, r25	; 0x01
    5c38:	a2 83       	std	Z+2, r26	; 0x02
    5c3a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5c3c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c3e:	9b 81       	ldd	r25, Y+3	; 0x03
    5c40:	fc 01       	movw	r30, r24
    5c42:	87 a1       	ldd	r24, Z+39	; 0x27
    5c44:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5c46:	8a 81       	ldd	r24, Y+2	; 0x02
    5c48:	9b 81       	ldd	r25, Y+3	; 0x03
    5c4a:	22 e0       	ldi	r18, 0x02	; 2
    5c4c:	fc 01       	movw	r30, r24
    5c4e:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5c50:	8c 85       	ldd	r24, Y+12	; 0x0c
    5c52:	88 2f       	mov	r24, r24
    5c54:	90 e0       	ldi	r25, 0x00	; 0
    5c56:	82 30       	cpi	r24, 0x02	; 2
    5c58:	91 05       	cpc	r25, r1
    5c5a:	31 f1       	breq	.+76     	; 0x5ca8 <xTaskGenericNotifyFromISR+0xd0>
    5c5c:	83 30       	cpi	r24, 0x03	; 3
    5c5e:	91 05       	cpc	r25, r1
    5c60:	34 f4       	brge	.+12     	; 0x5c6e <xTaskGenericNotifyFromISR+0x96>
    5c62:	00 97       	sbiw	r24, 0x00	; 0
    5c64:	09 f4       	brne	.+2      	; 0x5c68 <xTaskGenericNotifyFromISR+0x90>
    5c66:	4f c0       	rjmp	.+158    	; 0x5d06 <xTaskGenericNotifyFromISR+0x12e>
    5c68:	01 97       	sbiw	r24, 0x01	; 1
    5c6a:	39 f0       	breq	.+14     	; 0x5c7a <xTaskGenericNotifyFromISR+0xa2>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5c6c:	4d c0       	rjmp	.+154    	; 0x5d08 <xTaskGenericNotifyFromISR+0x130>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5c6e:	83 30       	cpi	r24, 0x03	; 3
    5c70:	91 05       	cpc	r25, r1
    5c72:	61 f1       	breq	.+88     	; 0x5ccc <xTaskGenericNotifyFromISR+0xf4>
    5c74:	04 97       	sbiw	r24, 0x04	; 4
    5c76:	b1 f1       	breq	.+108    	; 0x5ce4 <xTaskGenericNotifyFromISR+0x10c>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5c78:	47 c0       	rjmp	.+142    	; 0x5d08 <xTaskGenericNotifyFromISR+0x130>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    5c7c:	9b 81       	ldd	r25, Y+3	; 0x03
    5c7e:	fc 01       	movw	r30, r24
    5c80:	23 a1       	ldd	r18, Z+35	; 0x23
    5c82:	34 a1       	ldd	r19, Z+36	; 0x24
    5c84:	45 a1       	ldd	r20, Z+37	; 0x25
    5c86:	56 a1       	ldd	r21, Z+38	; 0x26
    5c88:	88 85       	ldd	r24, Y+8	; 0x08
    5c8a:	99 85       	ldd	r25, Y+9	; 0x09
    5c8c:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c8e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c90:	82 2b       	or	r24, r18
    5c92:	93 2b       	or	r25, r19
    5c94:	a4 2b       	or	r26, r20
    5c96:	b5 2b       	or	r27, r21
    5c98:	2a 81       	ldd	r18, Y+2	; 0x02
    5c9a:	3b 81       	ldd	r19, Y+3	; 0x03
    5c9c:	f9 01       	movw	r30, r18
    5c9e:	83 a3       	std	Z+35, r24	; 0x23
    5ca0:	94 a3       	std	Z+36, r25	; 0x24
    5ca2:	a5 a3       	std	Z+37, r26	; 0x25
    5ca4:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5ca6:	30 c0       	rjmp	.+96     	; 0x5d08 <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    5caa:	9b 81       	ldd	r25, Y+3	; 0x03
    5cac:	fc 01       	movw	r30, r24
    5cae:	83 a1       	ldd	r24, Z+35	; 0x23
    5cb0:	94 a1       	ldd	r25, Z+36	; 0x24
    5cb2:	a5 a1       	ldd	r26, Z+37	; 0x25
    5cb4:	b6 a1       	ldd	r27, Z+38	; 0x26
    5cb6:	01 96       	adiw	r24, 0x01	; 1
    5cb8:	a1 1d       	adc	r26, r1
    5cba:	b1 1d       	adc	r27, r1
    5cbc:	2a 81       	ldd	r18, Y+2	; 0x02
    5cbe:	3b 81       	ldd	r19, Y+3	; 0x03
    5cc0:	f9 01       	movw	r30, r18
    5cc2:	83 a3       	std	Z+35, r24	; 0x23
    5cc4:	94 a3       	std	Z+36, r25	; 0x24
    5cc6:	a5 a3       	std	Z+37, r26	; 0x25
    5cc8:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5cca:	1e c0       	rjmp	.+60     	; 0x5d08 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5ccc:	2a 81       	ldd	r18, Y+2	; 0x02
    5cce:	3b 81       	ldd	r19, Y+3	; 0x03
    5cd0:	88 85       	ldd	r24, Y+8	; 0x08
    5cd2:	99 85       	ldd	r25, Y+9	; 0x09
    5cd4:	aa 85       	ldd	r26, Y+10	; 0x0a
    5cd6:	bb 85       	ldd	r27, Y+11	; 0x0b
    5cd8:	f9 01       	movw	r30, r18
    5cda:	83 a3       	std	Z+35, r24	; 0x23
    5cdc:	94 a3       	std	Z+36, r25	; 0x24
    5cde:	a5 a3       	std	Z+37, r26	; 0x25
    5ce0:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5ce2:	12 c0       	rjmp	.+36     	; 0x5d08 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5ce4:	8d 81       	ldd	r24, Y+5	; 0x05
    5ce6:	82 30       	cpi	r24, 0x02	; 2
    5ce8:	61 f0       	breq	.+24     	; 0x5d02 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5cea:	2a 81       	ldd	r18, Y+2	; 0x02
    5cec:	3b 81       	ldd	r19, Y+3	; 0x03
    5cee:	88 85       	ldd	r24, Y+8	; 0x08
    5cf0:	99 85       	ldd	r25, Y+9	; 0x09
    5cf2:	aa 85       	ldd	r26, Y+10	; 0x0a
    5cf4:	bb 85       	ldd	r27, Y+11	; 0x0b
    5cf6:	f9 01       	movw	r30, r18
    5cf8:	83 a3       	std	Z+35, r24	; 0x23
    5cfa:	94 a3       	std	Z+36, r25	; 0x24
    5cfc:	a5 a3       	std	Z+37, r26	; 0x25
    5cfe:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5d00:	03 c0       	rjmp	.+6      	; 0x5d08 <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5d02:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5d04:	01 c0       	rjmp	.+2      	; 0x5d08 <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    5d06:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5d08:	8d 81       	ldd	r24, Y+5	; 0x05
    5d0a:	81 30       	cpi	r24, 0x01	; 1
    5d0c:	09 f0       	breq	.+2      	; 0x5d10 <xTaskGenericNotifyFromISR+0x138>
    5d0e:	51 c0       	rjmp	.+162    	; 0x5db2 <xTaskGenericNotifyFromISR+0x1da>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5d10:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    5d14:	88 23       	and	r24, r24
    5d16:	69 f5       	brne	.+90     	; 0x5d72 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5d18:	8a 81       	ldd	r24, Y+2	; 0x02
    5d1a:	9b 81       	ldd	r25, Y+3	; 0x03
    5d1c:	02 96       	adiw	r24, 0x02	; 2
    5d1e:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5d22:	8a 81       	ldd	r24, Y+2	; 0x02
    5d24:	9b 81       	ldd	r25, Y+3	; 0x03
    5d26:	fc 01       	movw	r30, r24
    5d28:	96 89       	ldd	r25, Z+22	; 0x16
    5d2a:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    5d2e:	89 17       	cp	r24, r25
    5d30:	30 f4       	brcc	.+12     	; 0x5d3e <xTaskGenericNotifyFromISR+0x166>
    5d32:	8a 81       	ldd	r24, Y+2	; 0x02
    5d34:	9b 81       	ldd	r25, Y+3	; 0x03
    5d36:	fc 01       	movw	r30, r24
    5d38:	86 89       	ldd	r24, Z+22	; 0x16
    5d3a:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    5d3e:	8a 81       	ldd	r24, Y+2	; 0x02
    5d40:	9b 81       	ldd	r25, Y+3	; 0x03
    5d42:	ac 01       	movw	r20, r24
    5d44:	4e 5f       	subi	r20, 0xFE	; 254
    5d46:	5f 4f       	sbci	r21, 0xFF	; 255
    5d48:	8a 81       	ldd	r24, Y+2	; 0x02
    5d4a:	9b 81       	ldd	r25, Y+3	; 0x03
    5d4c:	fc 01       	movw	r30, r24
    5d4e:	86 89       	ldd	r24, Z+22	; 0x16
    5d50:	28 2f       	mov	r18, r24
    5d52:	30 e0       	ldi	r19, 0x00	; 0
    5d54:	c9 01       	movw	r24, r18
    5d56:	88 0f       	add	r24, r24
    5d58:	99 1f       	adc	r25, r25
    5d5a:	88 0f       	add	r24, r24
    5d5c:	99 1f       	adc	r25, r25
    5d5e:	88 0f       	add	r24, r24
    5d60:	99 1f       	adc	r25, r25
    5d62:	82 0f       	add	r24, r18
    5d64:	93 1f       	adc	r25, r19
    5d66:	81 57       	subi	r24, 0x71	; 113
    5d68:	99 4f       	sbci	r25, 0xF9	; 249
    5d6a:	ba 01       	movw	r22, r20
    5d6c:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
    5d70:	08 c0       	rjmp	.+16     	; 0x5d82 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5d72:	8a 81       	ldd	r24, Y+2	; 0x02
    5d74:	9b 81       	ldd	r25, Y+3	; 0x03
    5d76:	0c 96       	adiw	r24, 0x0c	; 12
    5d78:	bc 01       	movw	r22, r24
    5d7a:	82 ed       	ldi	r24, 0xD2	; 210
    5d7c:	96 e0       	ldi	r25, 0x06	; 6
    5d7e:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5d82:	8a 81       	ldd	r24, Y+2	; 0x02
    5d84:	9b 81       	ldd	r25, Y+3	; 0x03
    5d86:	fc 01       	movw	r30, r24
    5d88:	26 89       	ldd	r18, Z+22	; 0x16
    5d8a:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5d8e:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5d92:	fc 01       	movw	r30, r24
    5d94:	86 89       	ldd	r24, Z+22	; 0x16
    5d96:	82 17       	cp	r24, r18
    5d98:	60 f4       	brcc	.+24     	; 0x5db2 <xTaskGenericNotifyFromISR+0x1da>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5d9a:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d9c:	98 89       	ldd	r25, Y+16	; 0x10
    5d9e:	89 2b       	or	r24, r25
    5da0:	29 f0       	breq	.+10     	; 0x5dac <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5da2:	8f 85       	ldd	r24, Y+15	; 0x0f
    5da4:	98 89       	ldd	r25, Y+16	; 0x10
    5da6:	21 e0       	ldi	r18, 0x01	; 1
    5da8:	fc 01       	movw	r30, r24
    5daa:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5dac:	81 e0       	ldi	r24, 0x01	; 1
    5dae:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5db2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5db4:	60 96       	adiw	r28, 0x10	; 16
    5db6:	0f b6       	in	r0, 0x3f	; 63
    5db8:	f8 94       	cli
    5dba:	de bf       	out	0x3e, r29	; 62
    5dbc:	0f be       	out	0x3f, r0	; 63
    5dbe:	cd bf       	out	0x3d, r28	; 61
    5dc0:	df 91       	pop	r29
    5dc2:	cf 91       	pop	r28
    5dc4:	1f 91       	pop	r17
    5dc6:	0f 91       	pop	r16
    5dc8:	ff 90       	pop	r15
    5dca:	ef 90       	pop	r14
    5dcc:	08 95       	ret

00005dce <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5dce:	cf 93       	push	r28
    5dd0:	df 93       	push	r29
    5dd2:	cd b7       	in	r28, 0x3d	; 61
    5dd4:	de b7       	in	r29, 0x3e	; 62
    5dd6:	28 97       	sbiw	r28, 0x08	; 8
    5dd8:	0f b6       	in	r0, 0x3f	; 63
    5dda:	f8 94       	cli
    5ddc:	de bf       	out	0x3e, r29	; 62
    5dde:	0f be       	out	0x3f, r0	; 63
    5de0:	cd bf       	out	0x3d, r28	; 61
    5de2:	9e 83       	std	Y+6, r25	; 0x06
    5de4:	8d 83       	std	Y+5, r24	; 0x05
    5de6:	78 87       	std	Y+8, r23	; 0x08
    5de8:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5dea:	8d 81       	ldd	r24, Y+5	; 0x05
    5dec:	9e 81       	ldd	r25, Y+6	; 0x06
    5dee:	9a 83       	std	Y+2, r25	; 0x02
    5df0:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5df2:	1b 82       	std	Y+3, r1	; 0x03
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5df4:	89 81       	ldd	r24, Y+1	; 0x01
    5df6:	9a 81       	ldd	r25, Y+2	; 0x02
    5df8:	fc 01       	movw	r30, r24
    5dfa:	87 a1       	ldd	r24, Z+39	; 0x27
    5dfc:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5dfe:	89 81       	ldd	r24, Y+1	; 0x01
    5e00:	9a 81       	ldd	r25, Y+2	; 0x02
    5e02:	22 e0       	ldi	r18, 0x02	; 2
    5e04:	fc 01       	movw	r30, r24
    5e06:	27 a3       	std	Z+39, r18	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5e08:	89 81       	ldd	r24, Y+1	; 0x01
    5e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e0c:	fc 01       	movw	r30, r24
    5e0e:	83 a1       	ldd	r24, Z+35	; 0x23
    5e10:	94 a1       	ldd	r25, Z+36	; 0x24
    5e12:	a5 a1       	ldd	r26, Z+37	; 0x25
    5e14:	b6 a1       	ldd	r27, Z+38	; 0x26
    5e16:	01 96       	adiw	r24, 0x01	; 1
    5e18:	a1 1d       	adc	r26, r1
    5e1a:	b1 1d       	adc	r27, r1
    5e1c:	29 81       	ldd	r18, Y+1	; 0x01
    5e1e:	3a 81       	ldd	r19, Y+2	; 0x02
    5e20:	f9 01       	movw	r30, r18
    5e22:	83 a3       	std	Z+35, r24	; 0x23
    5e24:	94 a3       	std	Z+36, r25	; 0x24
    5e26:	a5 a3       	std	Z+37, r26	; 0x25
    5e28:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5e2a:	8c 81       	ldd	r24, Y+4	; 0x04
    5e2c:	81 30       	cpi	r24, 0x01	; 1
    5e2e:	09 f0       	breq	.+2      	; 0x5e32 <vTaskNotifyGiveFromISR+0x64>
    5e30:	51 c0       	rjmp	.+162    	; 0x5ed4 <vTaskNotifyGiveFromISR+0x106>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5e32:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <uxSchedulerSuspended>
    5e36:	88 23       	and	r24, r24
    5e38:	69 f5       	brne	.+90     	; 0x5e94 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5e3a:	89 81       	ldd	r24, Y+1	; 0x01
    5e3c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e3e:	02 96       	adiw	r24, 0x02	; 2
    5e40:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5e44:	89 81       	ldd	r24, Y+1	; 0x01
    5e46:	9a 81       	ldd	r25, Y+2	; 0x02
    5e48:	fc 01       	movw	r30, r24
    5e4a:	96 89       	ldd	r25, Z+22	; 0x16
    5e4c:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTopReadyPriority>
    5e50:	89 17       	cp	r24, r25
    5e52:	30 f4       	brcc	.+12     	; 0x5e60 <vTaskNotifyGiveFromISR+0x92>
    5e54:	89 81       	ldd	r24, Y+1	; 0x01
    5e56:	9a 81       	ldd	r25, Y+2	; 0x02
    5e58:	fc 01       	movw	r30, r24
    5e5a:	86 89       	ldd	r24, Z+22	; 0x16
    5e5c:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTopReadyPriority>
    5e60:	89 81       	ldd	r24, Y+1	; 0x01
    5e62:	9a 81       	ldd	r25, Y+2	; 0x02
    5e64:	ac 01       	movw	r20, r24
    5e66:	4e 5f       	subi	r20, 0xFE	; 254
    5e68:	5f 4f       	sbci	r21, 0xFF	; 255
    5e6a:	89 81       	ldd	r24, Y+1	; 0x01
    5e6c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e6e:	fc 01       	movw	r30, r24
    5e70:	86 89       	ldd	r24, Z+22	; 0x16
    5e72:	28 2f       	mov	r18, r24
    5e74:	30 e0       	ldi	r19, 0x00	; 0
    5e76:	c9 01       	movw	r24, r18
    5e78:	88 0f       	add	r24, r24
    5e7a:	99 1f       	adc	r25, r25
    5e7c:	88 0f       	add	r24, r24
    5e7e:	99 1f       	adc	r25, r25
    5e80:	88 0f       	add	r24, r24
    5e82:	99 1f       	adc	r25, r25
    5e84:	82 0f       	add	r24, r18
    5e86:	93 1f       	adc	r25, r19
    5e88:	81 57       	subi	r24, 0x71	; 113
    5e8a:	99 4f       	sbci	r25, 0xF9	; 249
    5e8c:	ba 01       	movw	r22, r20
    5e8e:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
    5e92:	08 c0       	rjmp	.+16     	; 0x5ea4 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5e94:	89 81       	ldd	r24, Y+1	; 0x01
    5e96:	9a 81       	ldd	r25, Y+2	; 0x02
    5e98:	0c 96       	adiw	r24, 0x0c	; 12
    5e9a:	bc 01       	movw	r22, r24
    5e9c:	82 ed       	ldi	r24, 0xD2	; 210
    5e9e:	96 e0       	ldi	r25, 0x06	; 6
    5ea0:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ea4:	89 81       	ldd	r24, Y+1	; 0x01
    5ea6:	9a 81       	ldd	r25, Y+2	; 0x02
    5ea8:	fc 01       	movw	r30, r24
    5eaa:	26 89       	ldd	r18, Z+22	; 0x16
    5eac:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5eb0:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5eb4:	fc 01       	movw	r30, r24
    5eb6:	86 89       	ldd	r24, Z+22	; 0x16
    5eb8:	82 17       	cp	r24, r18
    5eba:	60 f4       	brcc	.+24     	; 0x5ed4 <vTaskNotifyGiveFromISR+0x106>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5ebc:	8f 81       	ldd	r24, Y+7	; 0x07
    5ebe:	98 85       	ldd	r25, Y+8	; 0x08
    5ec0:	89 2b       	or	r24, r25
    5ec2:	29 f0       	breq	.+10     	; 0x5ece <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5ec4:	8f 81       	ldd	r24, Y+7	; 0x07
    5ec6:	98 85       	ldd	r25, Y+8	; 0x08
    5ec8:	21 e0       	ldi	r18, 0x01	; 1
    5eca:	fc 01       	movw	r30, r24
    5ecc:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5ece:	81 e0       	ldi	r24, 0x01	; 1
    5ed0:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5ed4:	00 00       	nop
    5ed6:	28 96       	adiw	r28, 0x08	; 8
    5ed8:	0f b6       	in	r0, 0x3f	; 63
    5eda:	f8 94       	cli
    5edc:	de bf       	out	0x3e, r29	; 62
    5ede:	0f be       	out	0x3f, r0	; 63
    5ee0:	cd bf       	out	0x3d, r28	; 61
    5ee2:	df 91       	pop	r29
    5ee4:	cf 91       	pop	r28
    5ee6:	08 95       	ret

00005ee8 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5ee8:	cf 93       	push	r28
    5eea:	df 93       	push	r29
    5eec:	00 d0       	rcall	.+0      	; 0x5eee <xTaskNotifyStateClear+0x6>
    5eee:	00 d0       	rcall	.+0      	; 0x5ef0 <xTaskNotifyStateClear+0x8>
    5ef0:	1f 92       	push	r1
    5ef2:	cd b7       	in	r28, 0x3d	; 61
    5ef4:	de b7       	in	r29, 0x3e	; 62
    5ef6:	9d 83       	std	Y+5, r25	; 0x05
    5ef8:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5efa:	8c 81       	ldd	r24, Y+4	; 0x04
    5efc:	9d 81       	ldd	r25, Y+5	; 0x05
    5efe:	89 2b       	or	r24, r25
    5f00:	29 f4       	brne	.+10     	; 0x5f0c <xTaskNotifyStateClear+0x24>
    5f02:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5f06:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5f0a:	02 c0       	rjmp	.+4      	; 0x5f10 <xTaskNotifyStateClear+0x28>
    5f0c:	8c 81       	ldd	r24, Y+4	; 0x04
    5f0e:	9d 81       	ldd	r25, Y+5	; 0x05
    5f10:	9b 83       	std	Y+3, r25	; 0x03
    5f12:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5f14:	0f b6       	in	r0, 0x3f	; 63
    5f16:	f8 94       	cli
    5f18:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f1c:	9b 81       	ldd	r25, Y+3	; 0x03
    5f1e:	fc 01       	movw	r30, r24
    5f20:	87 a1       	ldd	r24, Z+39	; 0x27
    5f22:	82 30       	cpi	r24, 0x02	; 2
    5f24:	39 f4       	brne	.+14     	; 0x5f34 <xTaskNotifyStateClear+0x4c>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5f26:	8a 81       	ldd	r24, Y+2	; 0x02
    5f28:	9b 81       	ldd	r25, Y+3	; 0x03
    5f2a:	fc 01       	movw	r30, r24
    5f2c:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5f2e:	81 e0       	ldi	r24, 0x01	; 1
    5f30:	89 83       	std	Y+1, r24	; 0x01
    5f32:	01 c0       	rjmp	.+2      	; 0x5f36 <xTaskNotifyStateClear+0x4e>
			}
			else
			{
				xReturn = pdFAIL;
    5f34:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5f36:	0f 90       	pop	r0
    5f38:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5f3a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5f3c:	0f 90       	pop	r0
    5f3e:	0f 90       	pop	r0
    5f40:	0f 90       	pop	r0
    5f42:	0f 90       	pop	r0
    5f44:	0f 90       	pop	r0
    5f46:	df 91       	pop	r29
    5f48:	cf 91       	pop	r28
    5f4a:	08 95       	ret

00005f4c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5f4c:	cf 93       	push	r28
    5f4e:	df 93       	push	r29
    5f50:	cd b7       	in	r28, 0x3d	; 61
    5f52:	de b7       	in	r29, 0x3e	; 62
    5f54:	27 97       	sbiw	r28, 0x07	; 7
    5f56:	0f b6       	in	r0, 0x3f	; 63
    5f58:	f8 94       	cli
    5f5a:	de bf       	out	0x3e, r29	; 62
    5f5c:	0f be       	out	0x3f, r0	; 63
    5f5e:	cd bf       	out	0x3d, r28	; 61
    5f60:	9e 83       	std	Y+6, r25	; 0x06
    5f62:	8d 83       	std	Y+5, r24	; 0x05
    5f64:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5f66:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xTickCount>
    5f6a:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xTickCount+0x1>
    5f6e:	9a 83       	std	Y+2, r25	; 0x02
    5f70:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5f72:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5f76:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5f7a:	02 96       	adiw	r24, 0x02	; 2
    5f7c:	0e 94 40 14 	call	0x2880	; 0x2880 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5f80:	8d 81       	ldd	r24, Y+5	; 0x05
    5f82:	9e 81       	ldd	r25, Y+6	; 0x06
    5f84:	01 96       	adiw	r24, 0x01	; 1
    5f86:	71 f4       	brne	.+28     	; 0x5fa4 <prvAddCurrentTaskToDelayedList+0x58>
    5f88:	8f 81       	ldd	r24, Y+7	; 0x07
    5f8a:	88 23       	and	r24, r24
    5f8c:	59 f0       	breq	.+22     	; 0x5fa4 <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5f8e:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5f92:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5f96:	02 96       	adiw	r24, 0x02	; 2
    5f98:	bc 01       	movw	r22, r24
    5f9a:	85 ee       	ldi	r24, 0xE5	; 229
    5f9c:	96 e0       	ldi	r25, 0x06	; 6
    5f9e:	0e 94 79 13 	call	0x26f2	; 0x26f2 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5fa2:	44 c0       	rjmp	.+136    	; 0x602c <prvAddCurrentTaskToDelayedList+0xe0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    5fa4:	29 81       	ldd	r18, Y+1	; 0x01
    5fa6:	3a 81       	ldd	r19, Y+2	; 0x02
    5fa8:	8d 81       	ldd	r24, Y+5	; 0x05
    5faa:	9e 81       	ldd	r25, Y+6	; 0x06
    5fac:	82 0f       	add	r24, r18
    5fae:	93 1f       	adc	r25, r19
    5fb0:	9c 83       	std	Y+4, r25	; 0x04
    5fb2:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5fb4:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5fb8:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5fbc:	2b 81       	ldd	r18, Y+3	; 0x03
    5fbe:	3c 81       	ldd	r19, Y+4	; 0x04
    5fc0:	fc 01       	movw	r30, r24
    5fc2:	33 83       	std	Z+3, r19	; 0x03
    5fc4:	22 83       	std	Z+2, r18	; 0x02

			if( xTimeToWake < xConstTickCount )
    5fc6:	2b 81       	ldd	r18, Y+3	; 0x03
    5fc8:	3c 81       	ldd	r19, Y+4	; 0x04
    5fca:	89 81       	ldd	r24, Y+1	; 0x01
    5fcc:	9a 81       	ldd	r25, Y+2	; 0x02
    5fce:	28 17       	cp	r18, r24
    5fd0:	39 07       	cpc	r19, r25
    5fd2:	78 f4       	brcc	.+30     	; 0x5ff2 <prvAddCurrentTaskToDelayedList+0xa6>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5fd4:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5fd8:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5fdc:	9c 01       	movw	r18, r24
    5fde:	2e 5f       	subi	r18, 0xFE	; 254
    5fe0:	3f 4f       	sbci	r19, 0xFF	; 255
    5fe2:	80 91 d0 06 	lds	r24, 0x06D0	; 0x8006d0 <pxOverflowDelayedTaskList>
    5fe6:	90 91 d1 06 	lds	r25, 0x06D1	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    5fea:	b9 01       	movw	r22, r18
    5fec:	0e 94 c8 13 	call	0x2790	; 0x2790 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5ff0:	1d c0       	rjmp	.+58     	; 0x602c <prvAddCurrentTaskToDelayedList+0xe0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5ff2:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <pxCurrentTCB>
    5ff6:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <pxCurrentTCB+0x1>
    5ffa:	9c 01       	movw	r18, r24
    5ffc:	2e 5f       	subi	r18, 0xFE	; 254
    5ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    6000:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <pxDelayedTaskList>
    6004:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <pxDelayedTaskList+0x1>
    6008:	b9 01       	movw	r22, r18
    600a:	0e 94 c8 13 	call	0x2790	; 0x2790 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    600e:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <xNextTaskUnblockTime>
    6012:	90 91 f8 06 	lds	r25, 0x06F8	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    6016:	2b 81       	ldd	r18, Y+3	; 0x03
    6018:	3c 81       	ldd	r19, Y+4	; 0x04
    601a:	28 17       	cp	r18, r24
    601c:	39 07       	cpc	r19, r25
    601e:	30 f4       	brcc	.+12     	; 0x602c <prvAddCurrentTaskToDelayedList+0xe0>
				{
					xNextTaskUnblockTime = xTimeToWake;
    6020:	8b 81       	ldd	r24, Y+3	; 0x03
    6022:	9c 81       	ldd	r25, Y+4	; 0x04
    6024:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <xNextTaskUnblockTime+0x1>
    6028:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    602c:	00 00       	nop
    602e:	27 96       	adiw	r28, 0x07	; 7
    6030:	0f b6       	in	r0, 0x3f	; 63
    6032:	f8 94       	cli
    6034:	de bf       	out	0x3e, r29	; 62
    6036:	0f be       	out	0x3f, r0	; 63
    6038:	cd bf       	out	0x3d, r28	; 61
    603a:	df 91       	pop	r29
    603c:	cf 91       	pop	r28
    603e:	08 95       	ret

00006040 <__umulhisi3>:
    6040:	a2 9f       	mul	r26, r18
    6042:	b0 01       	movw	r22, r0
    6044:	b3 9f       	mul	r27, r19
    6046:	c0 01       	movw	r24, r0
    6048:	a3 9f       	mul	r26, r19
    604a:	70 0d       	add	r23, r0
    604c:	81 1d       	adc	r24, r1
    604e:	11 24       	eor	r1, r1
    6050:	91 1d       	adc	r25, r1
    6052:	b2 9f       	mul	r27, r18
    6054:	70 0d       	add	r23, r0
    6056:	81 1d       	adc	r24, r1
    6058:	11 24       	eor	r1, r1
    605a:	91 1d       	adc	r25, r1
    605c:	08 95       	ret

0000605e <__subsf3>:
    605e:	50 58       	subi	r21, 0x80	; 128

00006060 <__addsf3>:
    6060:	bb 27       	eor	r27, r27
    6062:	aa 27       	eor	r26, r26
    6064:	0e 94 47 30 	call	0x608e	; 0x608e <__addsf3x>
    6068:	0c 94 7d 31 	jmp	0x62fa	; 0x62fa <__fp_round>
    606c:	0e 94 6f 31 	call	0x62de	; 0x62de <__fp_pscA>
    6070:	38 f0       	brcs	.+14     	; 0x6080 <__addsf3+0x20>
    6072:	0e 94 76 31 	call	0x62ec	; 0x62ec <__fp_pscB>
    6076:	20 f0       	brcs	.+8      	; 0x6080 <__addsf3+0x20>
    6078:	39 f4       	brne	.+14     	; 0x6088 <__addsf3+0x28>
    607a:	9f 3f       	cpi	r25, 0xFF	; 255
    607c:	19 f4       	brne	.+6      	; 0x6084 <__addsf3+0x24>
    607e:	26 f4       	brtc	.+8      	; 0x6088 <__addsf3+0x28>
    6080:	0c 94 6c 31 	jmp	0x62d8	; 0x62d8 <__fp_nan>
    6084:	0e f4       	brtc	.+2      	; 0x6088 <__addsf3+0x28>
    6086:	e0 95       	com	r30
    6088:	e7 fb       	bst	r30, 7
    608a:	0c 94 66 31 	jmp	0x62cc	; 0x62cc <__fp_inf>

0000608e <__addsf3x>:
    608e:	e9 2f       	mov	r30, r25
    6090:	0e 94 8e 31 	call	0x631c	; 0x631c <__fp_split3>
    6094:	58 f3       	brcs	.-42     	; 0x606c <__addsf3+0xc>
    6096:	ba 17       	cp	r27, r26
    6098:	62 07       	cpc	r22, r18
    609a:	73 07       	cpc	r23, r19
    609c:	84 07       	cpc	r24, r20
    609e:	95 07       	cpc	r25, r21
    60a0:	20 f0       	brcs	.+8      	; 0x60aa <__addsf3x+0x1c>
    60a2:	79 f4       	brne	.+30     	; 0x60c2 <__addsf3x+0x34>
    60a4:	a6 f5       	brtc	.+104    	; 0x610e <__addsf3x+0x80>
    60a6:	0c 94 b0 31 	jmp	0x6360	; 0x6360 <__fp_zero>
    60aa:	0e f4       	brtc	.+2      	; 0x60ae <__addsf3x+0x20>
    60ac:	e0 95       	com	r30
    60ae:	0b 2e       	mov	r0, r27
    60b0:	ba 2f       	mov	r27, r26
    60b2:	a0 2d       	mov	r26, r0
    60b4:	0b 01       	movw	r0, r22
    60b6:	b9 01       	movw	r22, r18
    60b8:	90 01       	movw	r18, r0
    60ba:	0c 01       	movw	r0, r24
    60bc:	ca 01       	movw	r24, r20
    60be:	a0 01       	movw	r20, r0
    60c0:	11 24       	eor	r1, r1
    60c2:	ff 27       	eor	r31, r31
    60c4:	59 1b       	sub	r21, r25
    60c6:	99 f0       	breq	.+38     	; 0x60ee <__addsf3x+0x60>
    60c8:	59 3f       	cpi	r21, 0xF9	; 249
    60ca:	50 f4       	brcc	.+20     	; 0x60e0 <__addsf3x+0x52>
    60cc:	50 3e       	cpi	r21, 0xE0	; 224
    60ce:	68 f1       	brcs	.+90     	; 0x612a <__addsf3x+0x9c>
    60d0:	1a 16       	cp	r1, r26
    60d2:	f0 40       	sbci	r31, 0x00	; 0
    60d4:	a2 2f       	mov	r26, r18
    60d6:	23 2f       	mov	r18, r19
    60d8:	34 2f       	mov	r19, r20
    60da:	44 27       	eor	r20, r20
    60dc:	58 5f       	subi	r21, 0xF8	; 248
    60de:	f3 cf       	rjmp	.-26     	; 0x60c6 <__addsf3x+0x38>
    60e0:	46 95       	lsr	r20
    60e2:	37 95       	ror	r19
    60e4:	27 95       	ror	r18
    60e6:	a7 95       	ror	r26
    60e8:	f0 40       	sbci	r31, 0x00	; 0
    60ea:	53 95       	inc	r21
    60ec:	c9 f7       	brne	.-14     	; 0x60e0 <__addsf3x+0x52>
    60ee:	7e f4       	brtc	.+30     	; 0x610e <__addsf3x+0x80>
    60f0:	1f 16       	cp	r1, r31
    60f2:	ba 0b       	sbc	r27, r26
    60f4:	62 0b       	sbc	r22, r18
    60f6:	73 0b       	sbc	r23, r19
    60f8:	84 0b       	sbc	r24, r20
    60fa:	ba f0       	brmi	.+46     	; 0x612a <__addsf3x+0x9c>
    60fc:	91 50       	subi	r25, 0x01	; 1
    60fe:	a1 f0       	breq	.+40     	; 0x6128 <__addsf3x+0x9a>
    6100:	ff 0f       	add	r31, r31
    6102:	bb 1f       	adc	r27, r27
    6104:	66 1f       	adc	r22, r22
    6106:	77 1f       	adc	r23, r23
    6108:	88 1f       	adc	r24, r24
    610a:	c2 f7       	brpl	.-16     	; 0x60fc <__addsf3x+0x6e>
    610c:	0e c0       	rjmp	.+28     	; 0x612a <__addsf3x+0x9c>
    610e:	ba 0f       	add	r27, r26
    6110:	62 1f       	adc	r22, r18
    6112:	73 1f       	adc	r23, r19
    6114:	84 1f       	adc	r24, r20
    6116:	48 f4       	brcc	.+18     	; 0x612a <__addsf3x+0x9c>
    6118:	87 95       	ror	r24
    611a:	77 95       	ror	r23
    611c:	67 95       	ror	r22
    611e:	b7 95       	ror	r27
    6120:	f7 95       	ror	r31
    6122:	9e 3f       	cpi	r25, 0xFE	; 254
    6124:	08 f0       	brcs	.+2      	; 0x6128 <__addsf3x+0x9a>
    6126:	b0 cf       	rjmp	.-160    	; 0x6088 <__addsf3+0x28>
    6128:	93 95       	inc	r25
    612a:	88 0f       	add	r24, r24
    612c:	08 f0       	brcs	.+2      	; 0x6130 <__addsf3x+0xa2>
    612e:	99 27       	eor	r25, r25
    6130:	ee 0f       	add	r30, r30
    6132:	97 95       	ror	r25
    6134:	87 95       	ror	r24
    6136:	08 95       	ret

00006138 <__cmpsf2>:
    6138:	0e 94 42 31 	call	0x6284	; 0x6284 <__fp_cmp>
    613c:	08 f4       	brcc	.+2      	; 0x6140 <__cmpsf2+0x8>
    613e:	81 e0       	ldi	r24, 0x01	; 1
    6140:	08 95       	ret

00006142 <__divsf3>:
    6142:	0e 94 b5 30 	call	0x616a	; 0x616a <__divsf3x>
    6146:	0c 94 7d 31 	jmp	0x62fa	; 0x62fa <__fp_round>
    614a:	0e 94 76 31 	call	0x62ec	; 0x62ec <__fp_pscB>
    614e:	58 f0       	brcs	.+22     	; 0x6166 <__divsf3+0x24>
    6150:	0e 94 6f 31 	call	0x62de	; 0x62de <__fp_pscA>
    6154:	40 f0       	brcs	.+16     	; 0x6166 <__divsf3+0x24>
    6156:	29 f4       	brne	.+10     	; 0x6162 <__divsf3+0x20>
    6158:	5f 3f       	cpi	r21, 0xFF	; 255
    615a:	29 f0       	breq	.+10     	; 0x6166 <__divsf3+0x24>
    615c:	0c 94 66 31 	jmp	0x62cc	; 0x62cc <__fp_inf>
    6160:	51 11       	cpse	r21, r1
    6162:	0c 94 b1 31 	jmp	0x6362	; 0x6362 <__fp_szero>
    6166:	0c 94 6c 31 	jmp	0x62d8	; 0x62d8 <__fp_nan>

0000616a <__divsf3x>:
    616a:	0e 94 8e 31 	call	0x631c	; 0x631c <__fp_split3>
    616e:	68 f3       	brcs	.-38     	; 0x614a <__divsf3+0x8>

00006170 <__divsf3_pse>:
    6170:	99 23       	and	r25, r25
    6172:	b1 f3       	breq	.-20     	; 0x6160 <__divsf3+0x1e>
    6174:	55 23       	and	r21, r21
    6176:	91 f3       	breq	.-28     	; 0x615c <__divsf3+0x1a>
    6178:	95 1b       	sub	r25, r21
    617a:	55 0b       	sbc	r21, r21
    617c:	bb 27       	eor	r27, r27
    617e:	aa 27       	eor	r26, r26
    6180:	62 17       	cp	r22, r18
    6182:	73 07       	cpc	r23, r19
    6184:	84 07       	cpc	r24, r20
    6186:	38 f0       	brcs	.+14     	; 0x6196 <__divsf3_pse+0x26>
    6188:	9f 5f       	subi	r25, 0xFF	; 255
    618a:	5f 4f       	sbci	r21, 0xFF	; 255
    618c:	22 0f       	add	r18, r18
    618e:	33 1f       	adc	r19, r19
    6190:	44 1f       	adc	r20, r20
    6192:	aa 1f       	adc	r26, r26
    6194:	a9 f3       	breq	.-22     	; 0x6180 <__divsf3_pse+0x10>
    6196:	35 d0       	rcall	.+106    	; 0x6202 <__divsf3_pse+0x92>
    6198:	0e 2e       	mov	r0, r30
    619a:	3a f0       	brmi	.+14     	; 0x61aa <__divsf3_pse+0x3a>
    619c:	e0 e8       	ldi	r30, 0x80	; 128
    619e:	32 d0       	rcall	.+100    	; 0x6204 <__divsf3_pse+0x94>
    61a0:	91 50       	subi	r25, 0x01	; 1
    61a2:	50 40       	sbci	r21, 0x00	; 0
    61a4:	e6 95       	lsr	r30
    61a6:	00 1c       	adc	r0, r0
    61a8:	ca f7       	brpl	.-14     	; 0x619c <__divsf3_pse+0x2c>
    61aa:	2b d0       	rcall	.+86     	; 0x6202 <__divsf3_pse+0x92>
    61ac:	fe 2f       	mov	r31, r30
    61ae:	29 d0       	rcall	.+82     	; 0x6202 <__divsf3_pse+0x92>
    61b0:	66 0f       	add	r22, r22
    61b2:	77 1f       	adc	r23, r23
    61b4:	88 1f       	adc	r24, r24
    61b6:	bb 1f       	adc	r27, r27
    61b8:	26 17       	cp	r18, r22
    61ba:	37 07       	cpc	r19, r23
    61bc:	48 07       	cpc	r20, r24
    61be:	ab 07       	cpc	r26, r27
    61c0:	b0 e8       	ldi	r27, 0x80	; 128
    61c2:	09 f0       	breq	.+2      	; 0x61c6 <__divsf3_pse+0x56>
    61c4:	bb 0b       	sbc	r27, r27
    61c6:	80 2d       	mov	r24, r0
    61c8:	bf 01       	movw	r22, r30
    61ca:	ff 27       	eor	r31, r31
    61cc:	93 58       	subi	r25, 0x83	; 131
    61ce:	5f 4f       	sbci	r21, 0xFF	; 255
    61d0:	3a f0       	brmi	.+14     	; 0x61e0 <__divsf3_pse+0x70>
    61d2:	9e 3f       	cpi	r25, 0xFE	; 254
    61d4:	51 05       	cpc	r21, r1
    61d6:	78 f0       	brcs	.+30     	; 0x61f6 <__divsf3_pse+0x86>
    61d8:	0c 94 66 31 	jmp	0x62cc	; 0x62cc <__fp_inf>
    61dc:	0c 94 b1 31 	jmp	0x6362	; 0x6362 <__fp_szero>
    61e0:	5f 3f       	cpi	r21, 0xFF	; 255
    61e2:	e4 f3       	brlt	.-8      	; 0x61dc <__divsf3_pse+0x6c>
    61e4:	98 3e       	cpi	r25, 0xE8	; 232
    61e6:	d4 f3       	brlt	.-12     	; 0x61dc <__divsf3_pse+0x6c>
    61e8:	86 95       	lsr	r24
    61ea:	77 95       	ror	r23
    61ec:	67 95       	ror	r22
    61ee:	b7 95       	ror	r27
    61f0:	f7 95       	ror	r31
    61f2:	9f 5f       	subi	r25, 0xFF	; 255
    61f4:	c9 f7       	brne	.-14     	; 0x61e8 <__divsf3_pse+0x78>
    61f6:	88 0f       	add	r24, r24
    61f8:	91 1d       	adc	r25, r1
    61fa:	96 95       	lsr	r25
    61fc:	87 95       	ror	r24
    61fe:	97 f9       	bld	r25, 7
    6200:	08 95       	ret
    6202:	e1 e0       	ldi	r30, 0x01	; 1
    6204:	66 0f       	add	r22, r22
    6206:	77 1f       	adc	r23, r23
    6208:	88 1f       	adc	r24, r24
    620a:	bb 1f       	adc	r27, r27
    620c:	62 17       	cp	r22, r18
    620e:	73 07       	cpc	r23, r19
    6210:	84 07       	cpc	r24, r20
    6212:	ba 07       	cpc	r27, r26
    6214:	20 f0       	brcs	.+8      	; 0x621e <__divsf3_pse+0xae>
    6216:	62 1b       	sub	r22, r18
    6218:	73 0b       	sbc	r23, r19
    621a:	84 0b       	sbc	r24, r20
    621c:	ba 0b       	sbc	r27, r26
    621e:	ee 1f       	adc	r30, r30
    6220:	88 f7       	brcc	.-30     	; 0x6204 <__divsf3_pse+0x94>
    6222:	e0 95       	com	r30
    6224:	08 95       	ret

00006226 <__fixunssfsi>:
    6226:	0e 94 96 31 	call	0x632c	; 0x632c <__fp_splitA>
    622a:	88 f0       	brcs	.+34     	; 0x624e <__fixunssfsi+0x28>
    622c:	9f 57       	subi	r25, 0x7F	; 127
    622e:	98 f0       	brcs	.+38     	; 0x6256 <__fixunssfsi+0x30>
    6230:	b9 2f       	mov	r27, r25
    6232:	99 27       	eor	r25, r25
    6234:	b7 51       	subi	r27, 0x17	; 23
    6236:	b0 f0       	brcs	.+44     	; 0x6264 <__fixunssfsi+0x3e>
    6238:	e1 f0       	breq	.+56     	; 0x6272 <__fixunssfsi+0x4c>
    623a:	66 0f       	add	r22, r22
    623c:	77 1f       	adc	r23, r23
    623e:	88 1f       	adc	r24, r24
    6240:	99 1f       	adc	r25, r25
    6242:	1a f0       	brmi	.+6      	; 0x624a <__fixunssfsi+0x24>
    6244:	ba 95       	dec	r27
    6246:	c9 f7       	brne	.-14     	; 0x623a <__fixunssfsi+0x14>
    6248:	14 c0       	rjmp	.+40     	; 0x6272 <__fixunssfsi+0x4c>
    624a:	b1 30       	cpi	r27, 0x01	; 1
    624c:	91 f0       	breq	.+36     	; 0x6272 <__fixunssfsi+0x4c>
    624e:	0e 94 b0 31 	call	0x6360	; 0x6360 <__fp_zero>
    6252:	b1 e0       	ldi	r27, 0x01	; 1
    6254:	08 95       	ret
    6256:	0c 94 b0 31 	jmp	0x6360	; 0x6360 <__fp_zero>
    625a:	67 2f       	mov	r22, r23
    625c:	78 2f       	mov	r23, r24
    625e:	88 27       	eor	r24, r24
    6260:	b8 5f       	subi	r27, 0xF8	; 248
    6262:	39 f0       	breq	.+14     	; 0x6272 <__fixunssfsi+0x4c>
    6264:	b9 3f       	cpi	r27, 0xF9	; 249
    6266:	cc f3       	brlt	.-14     	; 0x625a <__fixunssfsi+0x34>
    6268:	86 95       	lsr	r24
    626a:	77 95       	ror	r23
    626c:	67 95       	ror	r22
    626e:	b3 95       	inc	r27
    6270:	d9 f7       	brne	.-10     	; 0x6268 <__fixunssfsi+0x42>
    6272:	3e f4       	brtc	.+14     	; 0x6282 <__fixunssfsi+0x5c>
    6274:	90 95       	com	r25
    6276:	80 95       	com	r24
    6278:	70 95       	com	r23
    627a:	61 95       	neg	r22
    627c:	7f 4f       	sbci	r23, 0xFF	; 255
    627e:	8f 4f       	sbci	r24, 0xFF	; 255
    6280:	9f 4f       	sbci	r25, 0xFF	; 255
    6282:	08 95       	ret

00006284 <__fp_cmp>:
    6284:	99 0f       	add	r25, r25
    6286:	00 08       	sbc	r0, r0
    6288:	55 0f       	add	r21, r21
    628a:	aa 0b       	sbc	r26, r26
    628c:	e0 e8       	ldi	r30, 0x80	; 128
    628e:	fe ef       	ldi	r31, 0xFE	; 254
    6290:	16 16       	cp	r1, r22
    6292:	17 06       	cpc	r1, r23
    6294:	e8 07       	cpc	r30, r24
    6296:	f9 07       	cpc	r31, r25
    6298:	c0 f0       	brcs	.+48     	; 0x62ca <__fp_cmp+0x46>
    629a:	12 16       	cp	r1, r18
    629c:	13 06       	cpc	r1, r19
    629e:	e4 07       	cpc	r30, r20
    62a0:	f5 07       	cpc	r31, r21
    62a2:	98 f0       	brcs	.+38     	; 0x62ca <__fp_cmp+0x46>
    62a4:	62 1b       	sub	r22, r18
    62a6:	73 0b       	sbc	r23, r19
    62a8:	84 0b       	sbc	r24, r20
    62aa:	95 0b       	sbc	r25, r21
    62ac:	39 f4       	brne	.+14     	; 0x62bc <__fp_cmp+0x38>
    62ae:	0a 26       	eor	r0, r26
    62b0:	61 f0       	breq	.+24     	; 0x62ca <__fp_cmp+0x46>
    62b2:	23 2b       	or	r18, r19
    62b4:	24 2b       	or	r18, r20
    62b6:	25 2b       	or	r18, r21
    62b8:	21 f4       	brne	.+8      	; 0x62c2 <__fp_cmp+0x3e>
    62ba:	08 95       	ret
    62bc:	0a 26       	eor	r0, r26
    62be:	09 f4       	brne	.+2      	; 0x62c2 <__fp_cmp+0x3e>
    62c0:	a1 40       	sbci	r26, 0x01	; 1
    62c2:	a6 95       	lsr	r26
    62c4:	8f ef       	ldi	r24, 0xFF	; 255
    62c6:	81 1d       	adc	r24, r1
    62c8:	81 1d       	adc	r24, r1
    62ca:	08 95       	ret

000062cc <__fp_inf>:
    62cc:	97 f9       	bld	r25, 7
    62ce:	9f 67       	ori	r25, 0x7F	; 127
    62d0:	80 e8       	ldi	r24, 0x80	; 128
    62d2:	70 e0       	ldi	r23, 0x00	; 0
    62d4:	60 e0       	ldi	r22, 0x00	; 0
    62d6:	08 95       	ret

000062d8 <__fp_nan>:
    62d8:	9f ef       	ldi	r25, 0xFF	; 255
    62da:	80 ec       	ldi	r24, 0xC0	; 192
    62dc:	08 95       	ret

000062de <__fp_pscA>:
    62de:	00 24       	eor	r0, r0
    62e0:	0a 94       	dec	r0
    62e2:	16 16       	cp	r1, r22
    62e4:	17 06       	cpc	r1, r23
    62e6:	18 06       	cpc	r1, r24
    62e8:	09 06       	cpc	r0, r25
    62ea:	08 95       	ret

000062ec <__fp_pscB>:
    62ec:	00 24       	eor	r0, r0
    62ee:	0a 94       	dec	r0
    62f0:	12 16       	cp	r1, r18
    62f2:	13 06       	cpc	r1, r19
    62f4:	14 06       	cpc	r1, r20
    62f6:	05 06       	cpc	r0, r21
    62f8:	08 95       	ret

000062fa <__fp_round>:
    62fa:	09 2e       	mov	r0, r25
    62fc:	03 94       	inc	r0
    62fe:	00 0c       	add	r0, r0
    6300:	11 f4       	brne	.+4      	; 0x6306 <__fp_round+0xc>
    6302:	88 23       	and	r24, r24
    6304:	52 f0       	brmi	.+20     	; 0x631a <__fp_round+0x20>
    6306:	bb 0f       	add	r27, r27
    6308:	40 f4       	brcc	.+16     	; 0x631a <__fp_round+0x20>
    630a:	bf 2b       	or	r27, r31
    630c:	11 f4       	brne	.+4      	; 0x6312 <__fp_round+0x18>
    630e:	60 ff       	sbrs	r22, 0
    6310:	04 c0       	rjmp	.+8      	; 0x631a <__fp_round+0x20>
    6312:	6f 5f       	subi	r22, 0xFF	; 255
    6314:	7f 4f       	sbci	r23, 0xFF	; 255
    6316:	8f 4f       	sbci	r24, 0xFF	; 255
    6318:	9f 4f       	sbci	r25, 0xFF	; 255
    631a:	08 95       	ret

0000631c <__fp_split3>:
    631c:	57 fd       	sbrc	r21, 7
    631e:	90 58       	subi	r25, 0x80	; 128
    6320:	44 0f       	add	r20, r20
    6322:	55 1f       	adc	r21, r21
    6324:	59 f0       	breq	.+22     	; 0x633c <__fp_splitA+0x10>
    6326:	5f 3f       	cpi	r21, 0xFF	; 255
    6328:	71 f0       	breq	.+28     	; 0x6346 <__fp_splitA+0x1a>
    632a:	47 95       	ror	r20

0000632c <__fp_splitA>:
    632c:	88 0f       	add	r24, r24
    632e:	97 fb       	bst	r25, 7
    6330:	99 1f       	adc	r25, r25
    6332:	61 f0       	breq	.+24     	; 0x634c <__fp_splitA+0x20>
    6334:	9f 3f       	cpi	r25, 0xFF	; 255
    6336:	79 f0       	breq	.+30     	; 0x6356 <__fp_splitA+0x2a>
    6338:	87 95       	ror	r24
    633a:	08 95       	ret
    633c:	12 16       	cp	r1, r18
    633e:	13 06       	cpc	r1, r19
    6340:	14 06       	cpc	r1, r20
    6342:	55 1f       	adc	r21, r21
    6344:	f2 cf       	rjmp	.-28     	; 0x632a <__fp_split3+0xe>
    6346:	46 95       	lsr	r20
    6348:	f1 df       	rcall	.-30     	; 0x632c <__fp_splitA>
    634a:	08 c0       	rjmp	.+16     	; 0x635c <__fp_splitA+0x30>
    634c:	16 16       	cp	r1, r22
    634e:	17 06       	cpc	r1, r23
    6350:	18 06       	cpc	r1, r24
    6352:	99 1f       	adc	r25, r25
    6354:	f1 cf       	rjmp	.-30     	; 0x6338 <__fp_splitA+0xc>
    6356:	86 95       	lsr	r24
    6358:	71 05       	cpc	r23, r1
    635a:	61 05       	cpc	r22, r1
    635c:	08 94       	sec
    635e:	08 95       	ret

00006360 <__fp_zero>:
    6360:	e8 94       	clt

00006362 <__fp_szero>:
    6362:	bb 27       	eor	r27, r27
    6364:	66 27       	eor	r22, r22
    6366:	77 27       	eor	r23, r23
    6368:	cb 01       	movw	r24, r22
    636a:	97 f9       	bld	r25, 7
    636c:	08 95       	ret

0000636e <__gesf2>:
    636e:	0e 94 42 31 	call	0x6284	; 0x6284 <__fp_cmp>
    6372:	08 f4       	brcc	.+2      	; 0x6376 <__gesf2+0x8>
    6374:	8f ef       	ldi	r24, 0xFF	; 255
    6376:	08 95       	ret

00006378 <__mulsf3>:
    6378:	0e 94 cf 31 	call	0x639e	; 0x639e <__mulsf3x>
    637c:	0c 94 7d 31 	jmp	0x62fa	; 0x62fa <__fp_round>
    6380:	0e 94 6f 31 	call	0x62de	; 0x62de <__fp_pscA>
    6384:	38 f0       	brcs	.+14     	; 0x6394 <__mulsf3+0x1c>
    6386:	0e 94 76 31 	call	0x62ec	; 0x62ec <__fp_pscB>
    638a:	20 f0       	brcs	.+8      	; 0x6394 <__mulsf3+0x1c>
    638c:	95 23       	and	r25, r21
    638e:	11 f0       	breq	.+4      	; 0x6394 <__mulsf3+0x1c>
    6390:	0c 94 66 31 	jmp	0x62cc	; 0x62cc <__fp_inf>
    6394:	0c 94 6c 31 	jmp	0x62d8	; 0x62d8 <__fp_nan>
    6398:	11 24       	eor	r1, r1
    639a:	0c 94 b1 31 	jmp	0x6362	; 0x6362 <__fp_szero>

0000639e <__mulsf3x>:
    639e:	0e 94 8e 31 	call	0x631c	; 0x631c <__fp_split3>
    63a2:	70 f3       	brcs	.-36     	; 0x6380 <__mulsf3+0x8>

000063a4 <__mulsf3_pse>:
    63a4:	95 9f       	mul	r25, r21
    63a6:	c1 f3       	breq	.-16     	; 0x6398 <__mulsf3+0x20>
    63a8:	95 0f       	add	r25, r21
    63aa:	50 e0       	ldi	r21, 0x00	; 0
    63ac:	55 1f       	adc	r21, r21
    63ae:	62 9f       	mul	r22, r18
    63b0:	f0 01       	movw	r30, r0
    63b2:	72 9f       	mul	r23, r18
    63b4:	bb 27       	eor	r27, r27
    63b6:	f0 0d       	add	r31, r0
    63b8:	b1 1d       	adc	r27, r1
    63ba:	63 9f       	mul	r22, r19
    63bc:	aa 27       	eor	r26, r26
    63be:	f0 0d       	add	r31, r0
    63c0:	b1 1d       	adc	r27, r1
    63c2:	aa 1f       	adc	r26, r26
    63c4:	64 9f       	mul	r22, r20
    63c6:	66 27       	eor	r22, r22
    63c8:	b0 0d       	add	r27, r0
    63ca:	a1 1d       	adc	r26, r1
    63cc:	66 1f       	adc	r22, r22
    63ce:	82 9f       	mul	r24, r18
    63d0:	22 27       	eor	r18, r18
    63d2:	b0 0d       	add	r27, r0
    63d4:	a1 1d       	adc	r26, r1
    63d6:	62 1f       	adc	r22, r18
    63d8:	73 9f       	mul	r23, r19
    63da:	b0 0d       	add	r27, r0
    63dc:	a1 1d       	adc	r26, r1
    63de:	62 1f       	adc	r22, r18
    63e0:	83 9f       	mul	r24, r19
    63e2:	a0 0d       	add	r26, r0
    63e4:	61 1d       	adc	r22, r1
    63e6:	22 1f       	adc	r18, r18
    63e8:	74 9f       	mul	r23, r20
    63ea:	33 27       	eor	r19, r19
    63ec:	a0 0d       	add	r26, r0
    63ee:	61 1d       	adc	r22, r1
    63f0:	23 1f       	adc	r18, r19
    63f2:	84 9f       	mul	r24, r20
    63f4:	60 0d       	add	r22, r0
    63f6:	21 1d       	adc	r18, r1
    63f8:	82 2f       	mov	r24, r18
    63fa:	76 2f       	mov	r23, r22
    63fc:	6a 2f       	mov	r22, r26
    63fe:	11 24       	eor	r1, r1
    6400:	9f 57       	subi	r25, 0x7F	; 127
    6402:	50 40       	sbci	r21, 0x00	; 0
    6404:	9a f0       	brmi	.+38     	; 0x642c <__mulsf3_pse+0x88>
    6406:	f1 f0       	breq	.+60     	; 0x6444 <__mulsf3_pse+0xa0>
    6408:	88 23       	and	r24, r24
    640a:	4a f0       	brmi	.+18     	; 0x641e <__mulsf3_pse+0x7a>
    640c:	ee 0f       	add	r30, r30
    640e:	ff 1f       	adc	r31, r31
    6410:	bb 1f       	adc	r27, r27
    6412:	66 1f       	adc	r22, r22
    6414:	77 1f       	adc	r23, r23
    6416:	88 1f       	adc	r24, r24
    6418:	91 50       	subi	r25, 0x01	; 1
    641a:	50 40       	sbci	r21, 0x00	; 0
    641c:	a9 f7       	brne	.-22     	; 0x6408 <__mulsf3_pse+0x64>
    641e:	9e 3f       	cpi	r25, 0xFE	; 254
    6420:	51 05       	cpc	r21, r1
    6422:	80 f0       	brcs	.+32     	; 0x6444 <__mulsf3_pse+0xa0>
    6424:	0c 94 66 31 	jmp	0x62cc	; 0x62cc <__fp_inf>
    6428:	0c 94 b1 31 	jmp	0x6362	; 0x6362 <__fp_szero>
    642c:	5f 3f       	cpi	r21, 0xFF	; 255
    642e:	e4 f3       	brlt	.-8      	; 0x6428 <__mulsf3_pse+0x84>
    6430:	98 3e       	cpi	r25, 0xE8	; 232
    6432:	d4 f3       	brlt	.-12     	; 0x6428 <__mulsf3_pse+0x84>
    6434:	86 95       	lsr	r24
    6436:	77 95       	ror	r23
    6438:	67 95       	ror	r22
    643a:	b7 95       	ror	r27
    643c:	f7 95       	ror	r31
    643e:	e7 95       	ror	r30
    6440:	9f 5f       	subi	r25, 0xFF	; 255
    6442:	c1 f7       	brne	.-16     	; 0x6434 <__mulsf3_pse+0x90>
    6444:	fe 2b       	or	r31, r30
    6446:	88 0f       	add	r24, r24
    6448:	91 1d       	adc	r25, r1
    644a:	96 95       	lsr	r25
    644c:	87 95       	ror	r24
    644e:	97 f9       	bld	r25, 7
    6450:	08 95       	ret

00006452 <memcpy>:
    6452:	fb 01       	movw	r30, r22
    6454:	dc 01       	movw	r26, r24
    6456:	02 c0       	rjmp	.+4      	; 0x645c <memcpy+0xa>
    6458:	01 90       	ld	r0, Z+
    645a:	0d 92       	st	X+, r0
    645c:	41 50       	subi	r20, 0x01	; 1
    645e:	50 40       	sbci	r21, 0x00	; 0
    6460:	d8 f7       	brcc	.-10     	; 0x6458 <memcpy+0x6>
    6462:	08 95       	ret

00006464 <_exit>:
    6464:	f8 94       	cli

00006466 <__stop_program>:
    6466:	ff cf       	rjmp	.-2      	; 0x6466 <__stop_program>

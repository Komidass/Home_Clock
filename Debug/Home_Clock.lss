
Home_Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000063d8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000072  00800060  000063d8  0000646c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000065e  008000d2  008000d2  000064de  2**0
                  ALLOC
  3 .stab         0000adc4  00000000  00000000  000064e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004d8f  00000000  00000000  000112a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00016033  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00016044  2**2
                  CONTENTS, READONLY
  7 .debug_info   000004e6  00000000  00000000  00016080  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004a3  00000000  00000000  00016566  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00016a09  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000196  00000000  00000000  00016a23  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a3 17 	jmp	0x2f46	; 0x2f46 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ed       	ldi	r30, 0xD8	; 216
      68:	f3 e6       	ldi	r31, 0x63	; 99
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3d       	cpi	r26, 0xD2	; 210
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a2 ed       	ldi	r26, 0xD2	; 210
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 33       	cpi	r26, 0x30	; 48
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 4f 14 	call	0x289e	; 0x289e <main>
      8a:	0c 94 ea 31 	jmp	0x63d4	; 0x63d4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Clock_Print_Default_Interface>:
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	80 e0       	ldi	r24, 0x00	; 0
      9c:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
      a0:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Hours>
      a4:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <LCD_Void_Write_Number_2>
      a8:	82 e0       	ldi	r24, 0x02	; 2
      aa:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
      ae:	8a e3       	ldi	r24, 0x3A	; 58
      b0:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
      b4:	80 91 d3 00 	lds	r24, 0x00D3	; 0x8000d3 <Minutes>
      b8:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <LCD_Void_Write_Number_2>
      bc:	85 e0       	ldi	r24, 0x05	; 5
      be:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
      c2:	8a e3       	ldi	r24, 0x3A	; 58
      c4:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
      c8:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <__data_end>
      cc:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <LCD_Void_Write_Number_2>
      d0:	00 00       	nop
      d2:	df 91       	pop	r29
      d4:	cf 91       	pop	r28
      d6:	08 95       	ret

000000d8 <Clock_Second>:
	LCD_Void_Write_Number_2(Seconds);

}

void Clock_Second(void *pvParameters)
{
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	00 d0       	rcall	.+0      	; 0xde <Clock_Second+0x6>
      de:	00 d0       	rcall	.+0      	; 0xe0 <Clock_Second+0x8>
      e0:	cd b7       	in	r28, 0x3d	; 61
      e2:	de b7       	in	r29, 0x3e	; 62
      e4:	9c 83       	std	Y+4, r25	; 0x04
      e6:	8b 83       	std	Y+3, r24	; 0x03
	LCD = xSemaphoreCreateMutex();
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <xQueueCreateMutex>
      ee:	90 93 27 07 	sts	0x0727, r25	; 0x800727 <LCD+0x1>
      f2:	80 93 26 07 	sts	0x0726, r24	; 0x800726 <LCD>
	TickType_t MyLastUnblockS;
	MyLastUnblockS = xTaskGetTickCount();
      f6:	0e 94 21 25 	call	0x4a42	; 0x4a42 <xTaskGetTickCount>
      fa:	9a 83       	std	Y+2, r25	; 0x02
      fc:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
      fe:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     102:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     106:	6a e0       	ldi	r22, 0x0A	; 10
     108:	70 e0       	ldi	r23, 0x00	; 0
     10a:	0e 94 2d 1b 	call	0x365a	; 0x365a <xQueueSemaphoreTake>
     10e:	88 23       	and	r24, r24
     110:	91 f0       	breq	.+36     	; 0x136 <Clock_Second+0x5e>
		{
			LCD_Set_Block(seconds_position);
     112:	86 e0       	ldi	r24, 0x06	; 6
     114:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
			LCD_Void_Write_Number_2(Seconds);
     118:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <__data_end>
     11c:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     120:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     124:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     128:	20 e0       	ldi	r18, 0x00	; 0
     12a:	40 e0       	ldi	r20, 0x00	; 0
     12c:	50 e0       	ldi	r21, 0x00	; 0
     12e:	60 e0       	ldi	r22, 0x00	; 0
     130:	70 e0       	ldi	r23, 0x00	; 0
     132:	0e 94 12 19 	call	0x3224	; 0x3224 <xQueueGenericSend>
		}
		vTaskDelayUntil(&MyLastUnblockS,seconds_frequency);
     136:	64 e0       	ldi	r22, 0x04	; 4
     138:	70 e0       	ldi	r23, 0x00	; 0
     13a:	ce 01       	movw	r24, r28
     13c:	01 96       	adiw	r24, 0x01	; 1
     13e:	0e 94 32 22 	call	0x4464	; 0x4464 <vTaskDelayUntil>
		Seconds++;
     142:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <__data_end>
     146:	8f 5f       	subi	r24, 0xFF	; 255
     148:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__data_end>
		Seconds %= 60;
     14c:	90 91 d2 00 	lds	r25, 0x00D2	; 0x8000d2 <__data_end>
     150:	89 e8       	ldi	r24, 0x89	; 137
     152:	98 9f       	mul	r25, r24
     154:	81 2d       	mov	r24, r1
     156:	11 24       	eor	r1, r1
     158:	82 95       	swap	r24
     15a:	86 95       	lsr	r24
     15c:	87 70       	andi	r24, 0x07	; 7
     15e:	2c e3       	ldi	r18, 0x3C	; 60
     160:	82 9f       	mul	r24, r18
     162:	80 2d       	mov	r24, r0
     164:	11 24       	eor	r1, r1
     166:	29 2f       	mov	r18, r25
     168:	28 1b       	sub	r18, r24
     16a:	82 2f       	mov	r24, r18
     16c:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__data_end>
	}
     170:	c6 cf       	rjmp	.-116    	; 0xfe <Clock_Second+0x26>

00000172 <Clock_Minute>:
}

void Clock_Minute(void *pvParameters)
{
     172:	cf 93       	push	r28
     174:	df 93       	push	r29
     176:	00 d0       	rcall	.+0      	; 0x178 <Clock_Minute+0x6>
     178:	00 d0       	rcall	.+0      	; 0x17a <Clock_Minute+0x8>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9c 83       	std	Y+4, r25	; 0x04
     180:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockM;
	MyLastUnblockM = xTaskGetTickCount();
     182:	0e 94 21 25 	call	0x4a42	; 0x4a42 <xTaskGetTickCount>
     186:	9a 83       	std	Y+2, r25	; 0x02
     188:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     18a:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     18e:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     192:	6a e0       	ldi	r22, 0x0A	; 10
     194:	70 e0       	ldi	r23, 0x00	; 0
     196:	0e 94 2d 1b 	call	0x365a	; 0x365a <xQueueSemaphoreTake>
     19a:	88 23       	and	r24, r24
     19c:	91 f0       	breq	.+36     	; 0x1c2 <Clock_Minute+0x50>
		{
			LCD_Set_Block(minutes_position);
     19e:	83 e0       	ldi	r24, 0x03	; 3
     1a0:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
			LCD_Void_Write_Number_2(Minutes);
     1a4:	80 91 d3 00 	lds	r24, 0x00D3	; 0x8000d3 <Minutes>
     1a8:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     1ac:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     1b0:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     1b4:	20 e0       	ldi	r18, 0x00	; 0
     1b6:	40 e0       	ldi	r20, 0x00	; 0
     1b8:	50 e0       	ldi	r21, 0x00	; 0
     1ba:	60 e0       	ldi	r22, 0x00	; 0
     1bc:	70 e0       	ldi	r23, 0x00	; 0
     1be:	0e 94 12 19 	call	0x3224	; 0x3224 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockM,minutes_frequency);
     1c2:	60 ef       	ldi	r22, 0xF0	; 240
     1c4:	70 e0       	ldi	r23, 0x00	; 0
     1c6:	ce 01       	movw	r24, r28
     1c8:	01 96       	adiw	r24, 0x01	; 1
     1ca:	0e 94 32 22 	call	0x4464	; 0x4464 <vTaskDelayUntil>
		Minutes++;
     1ce:	80 91 d3 00 	lds	r24, 0x00D3	; 0x8000d3 <Minutes>
     1d2:	8f 5f       	subi	r24, 0xFF	; 255
     1d4:	80 93 d3 00 	sts	0x00D3, r24	; 0x8000d3 <Minutes>
		Minutes %= 60;
     1d8:	90 91 d3 00 	lds	r25, 0x00D3	; 0x8000d3 <Minutes>
     1dc:	89 e8       	ldi	r24, 0x89	; 137
     1de:	98 9f       	mul	r25, r24
     1e0:	81 2d       	mov	r24, r1
     1e2:	11 24       	eor	r1, r1
     1e4:	82 95       	swap	r24
     1e6:	86 95       	lsr	r24
     1e8:	87 70       	andi	r24, 0x07	; 7
     1ea:	2c e3       	ldi	r18, 0x3C	; 60
     1ec:	82 9f       	mul	r24, r18
     1ee:	80 2d       	mov	r24, r0
     1f0:	11 24       	eor	r1, r1
     1f2:	29 2f       	mov	r18, r25
     1f4:	28 1b       	sub	r18, r24
     1f6:	82 2f       	mov	r24, r18
     1f8:	80 93 d3 00 	sts	0x00D3, r24	; 0x8000d3 <Minutes>
	}
     1fc:	c6 cf       	rjmp	.-116    	; 0x18a <Clock_Minute+0x18>

000001fe <Clock_Hours>:
}
void Clock_Hours(void *pvParameters)
{
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	00 d0       	rcall	.+0      	; 0x204 <Clock_Hours+0x6>
     204:	00 d0       	rcall	.+0      	; 0x206 <Clock_Hours+0x8>
     206:	cd b7       	in	r28, 0x3d	; 61
     208:	de b7       	in	r29, 0x3e	; 62
     20a:	9c 83       	std	Y+4, r25	; 0x04
     20c:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockH;
	MyLastUnblockH = xTaskGetTickCount();
     20e:	0e 94 21 25 	call	0x4a42	; 0x4a42 <xTaskGetTickCount>
     212:	9a 83       	std	Y+2, r25	; 0x02
     214:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     216:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     21a:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     21e:	6a e0       	ldi	r22, 0x0A	; 10
     220:	70 e0       	ldi	r23, 0x00	; 0
     222:	0e 94 2d 1b 	call	0x365a	; 0x365a <xQueueSemaphoreTake>
     226:	88 23       	and	r24, r24
     228:	19 f1       	breq	.+70     	; 0x270 <Clock_Hours+0x72>
		{
			LCD_Set_Block(hours_position);
     22a:	80 e0       	ldi	r24, 0x00	; 0
     22c:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
			LCD_Void_Write_Number_2((Hours%12)+1);
     230:	20 91 d4 00 	lds	r18, 0x00D4	; 0x8000d4 <Hours>
     234:	8b ea       	ldi	r24, 0xAB	; 171
     236:	28 9f       	mul	r18, r24
     238:	81 2d       	mov	r24, r1
     23a:	11 24       	eor	r1, r1
     23c:	98 2f       	mov	r25, r24
     23e:	96 95       	lsr	r25
     240:	96 95       	lsr	r25
     242:	96 95       	lsr	r25
     244:	89 2f       	mov	r24, r25
     246:	88 0f       	add	r24, r24
     248:	89 0f       	add	r24, r25
     24a:	88 0f       	add	r24, r24
     24c:	88 0f       	add	r24, r24
     24e:	92 2f       	mov	r25, r18
     250:	98 1b       	sub	r25, r24
     252:	81 e0       	ldi	r24, 0x01	; 1
     254:	89 0f       	add	r24, r25
     256:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     25a:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     25e:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     262:	20 e0       	ldi	r18, 0x00	; 0
     264:	40 e0       	ldi	r20, 0x00	; 0
     266:	50 e0       	ldi	r21, 0x00	; 0
     268:	60 e0       	ldi	r22, 0x00	; 0
     26a:	70 e0       	ldi	r23, 0x00	; 0
     26c:	0e 94 12 19 	call	0x3224	; 0x3224 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockH,hours_frequency);
     270:	60 e4       	ldi	r22, 0x40	; 64
     272:	78 e3       	ldi	r23, 0x38	; 56
     274:	ce 01       	movw	r24, r28
     276:	01 96       	adiw	r24, 0x01	; 1
     278:	0e 94 32 22 	call	0x4464	; 0x4464 <vTaskDelayUntil>
		Hours++;
     27c:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Hours>
     280:	8f 5f       	subi	r24, 0xFF	; 255
     282:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <Hours>
		Hours %= 24;
     286:	90 91 d4 00 	lds	r25, 0x00D4	; 0x8000d4 <Hours>
     28a:	8b ea       	ldi	r24, 0xAB	; 171
     28c:	98 9f       	mul	r25, r24
     28e:	81 2d       	mov	r24, r1
     290:	11 24       	eor	r1, r1
     292:	82 95       	swap	r24
     294:	8f 70       	andi	r24, 0x0F	; 15
     296:	28 e1       	ldi	r18, 0x18	; 24
     298:	82 9f       	mul	r24, r18
     29a:	80 2d       	mov	r24, r0
     29c:	11 24       	eor	r1, r1
     29e:	29 2f       	mov	r18, r25
     2a0:	28 1b       	sub	r18, r24
     2a2:	82 2f       	mov	r24, r18
     2a4:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <Hours>
	}
     2a8:	b6 cf       	rjmp	.-148    	; 0x216 <Clock_Hours+0x18>

000002aa <Clock_Check_KPD>:
}

void Clock_Check_KPD(void *pvParameters)
{
     2aa:	cf 93       	push	r28
     2ac:	df 93       	push	r29
     2ae:	cd b7       	in	r28, 0x3d	; 61
     2b0:	de b7       	in	r29, 0x3e	; 62
     2b2:	65 97       	sbiw	r28, 0x15	; 21
     2b4:	0f b6       	in	r0, 0x3f	; 63
     2b6:	f8 94       	cli
     2b8:	de bf       	out	0x3e, r29	; 62
     2ba:	0f be       	out	0x3f, r0	; 63
     2bc:	cd bf       	out	0x3d, r28	; 61
     2be:	9d 8b       	std	Y+21, r25	; 0x15
     2c0:	8c 8b       	std	Y+20, r24	; 0x14
	KPD_input = xQueueCreate(1,sizeof(u8));
     2c2:	40 e0       	ldi	r20, 0x00	; 0
     2c4:	61 e0       	ldi	r22, 0x01	; 1
     2c6:	81 e0       	ldi	r24, 0x01	; 1
     2c8:	0e 94 3a 18 	call	0x3074	; 0x3074 <xQueueGenericCreate>
     2cc:	90 93 d6 00 	sts	0x00D6, r25	; 0x8000d6 <KPD_input+0x1>
     2d0:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <KPD_input>
	TickType_t MyLastUnblockKPD;
	MyLastUnblockKPD = xTaskGetTickCount();
     2d4:	0e 94 21 25 	call	0x4a42	; 0x4a42 <xTaskGetTickCount>
     2d8:	9a 83       	std	Y+2, r25	; 0x02
     2da:	89 83       	std	Y+1, r24	; 0x01
	u8 keys[16];
	u8 pressed;
	while(1)
	{	pressed = KBD_u8GetKeyPadState(keys);
     2dc:	ce 01       	movw	r24, r28
     2de:	03 96       	adiw	r24, 0x03	; 3
     2e0:	0e 94 48 05 	call	0xa90	; 0xa90 <KBD_u8GetKeyPadState>
     2e4:	8b 8b       	std	Y+19, r24	; 0x13
		if(pressed != 0xff)
     2e6:	8b 89       	ldd	r24, Y+19	; 0x13
     2e8:	8f 3f       	cpi	r24, 0xFF	; 255
     2ea:	61 f0       	breq	.+24     	; 0x304 <Clock_Check_KPD+0x5a>
		{
			xQueueSend(KPD_input,&pressed,10);
     2ec:	80 91 d5 00 	lds	r24, 0x00D5	; 0x8000d5 <KPD_input>
     2f0:	90 91 d6 00 	lds	r25, 0x00D6	; 0x8000d6 <KPD_input+0x1>
     2f4:	be 01       	movw	r22, r28
     2f6:	6d 5e       	subi	r22, 0xED	; 237
     2f8:	7f 4f       	sbci	r23, 0xFF	; 255
     2fa:	20 e0       	ldi	r18, 0x00	; 0
     2fc:	4a e0       	ldi	r20, 0x0A	; 10
     2fe:	50 e0       	ldi	r21, 0x00	; 0
     300:	0e 94 12 19 	call	0x3224	; 0x3224 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockKPD,KPD_Check_frequency);
     304:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <KPD_Check_frequency>
     308:	88 2f       	mov	r24, r24
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	bc 01       	movw	r22, r24
     30e:	ce 01       	movw	r24, r28
     310:	01 96       	adiw	r24, 0x01	; 1
     312:	0e 94 32 22 	call	0x4464	; 0x4464 <vTaskDelayUntil>
	}
     316:	e2 cf       	rjmp	.-60     	; 0x2dc <Clock_Check_KPD+0x32>

00000318 <Clock_Enter_Typing_Mode>:
}

void Clock_Enter_Typing_Mode(void *pvParameters)
{
     318:	cf 93       	push	r28
     31a:	df 93       	push	r29
     31c:	00 d0       	rcall	.+0      	; 0x31e <Clock_Enter_Typing_Mode+0x6>
     31e:	00 d0       	rcall	.+0      	; 0x320 <Clock_Enter_Typing_Mode+0x8>
     320:	cd b7       	in	r28, 0x3d	; 61
     322:	de b7       	in	r29, 0x3e	; 62
     324:	9c 83       	std	Y+4, r25	; 0x04
     326:	8b 83       	std	Y+3, r24	; 0x03
	u8 pressed  = 0xff;
     328:	8f ef       	ldi	r24, 0xFF	; 255
     32a:	8a 83       	std	Y+2, r24	; 0x02
	u8 take_lach = 0;
     32c:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		if(xQueueReceive(KPD_input,&pressed,10))
     32e:	80 91 d5 00 	lds	r24, 0x00D5	; 0x8000d5 <KPD_input>
     332:	90 91 d6 00 	lds	r25, 0x00D6	; 0x8000d6 <KPD_input+0x1>
     336:	9e 01       	movw	r18, r28
     338:	2e 5f       	subi	r18, 0xFE	; 254
     33a:	3f 4f       	sbci	r19, 0xFF	; 255
     33c:	4a e0       	ldi	r20, 0x0A	; 10
     33e:	50 e0       	ldi	r21, 0x00	; 0
     340:	b9 01       	movw	r22, r18
     342:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <xQueueReceive>
     346:	88 23       	and	r24, r24
     348:	91 f3       	breq	.-28     	; 0x32e <Clock_Enter_Typing_Mode+0x16>
		{
			if((take_lach)&&(pressed != '#'))
     34a:	89 81       	ldd	r24, Y+1	; 0x01
     34c:	88 23       	and	r24, r24
     34e:	51 f0       	breq	.+20     	; 0x364 <Clock_Enter_Typing_Mode+0x4c>
     350:	8a 81       	ldd	r24, Y+2	; 0x02
     352:	83 32       	cpi	r24, 0x23	; 35
     354:	39 f0       	breq	.+14     	; 0x364 <Clock_Enter_Typing_Mode+0x4c>
			{
				LCD_Set_Block(16);
     356:	80 e1       	ldi	r24, 0x10	; 16
     358:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
				LCD_Void_Write_Data(pressed);
     35c:	8a 81       	ldd	r24, Y+2	; 0x02
     35e:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
				continue;
     362:	39 c0       	rjmp	.+114    	; 0x3d6 <Clock_Enter_Typing_Mode+0xbe>
			}
			switch (pressed)
     364:	8a 81       	ldd	r24, Y+2	; 0x02
     366:	88 2f       	mov	r24, r24
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	83 32       	cpi	r24, 0x23	; 35
     36c:	91 05       	cpc	r25, r1
     36e:	c9 f0       	breq	.+50     	; 0x3a2 <Clock_Enter_Typing_Mode+0x8a>
     370:	8a 97       	sbiw	r24, 0x2a	; 42
     372:	89 f5       	brne	.+98     	; 0x3d6 <Clock_Enter_Typing_Mode+0xbe>
			{
			case '*':
				if(xSemaphoreTake(LCD,10))
     374:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     378:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     37c:	6a e0       	ldi	r22, 0x0A	; 10
     37e:	70 e0       	ldi	r23, 0x00	; 0
     380:	0e 94 2d 1b 	call	0x365a	; 0x365a <xQueueSemaphoreTake>
     384:	88 23       	and	r24, r24
     386:	31 f1       	breq	.+76     	; 0x3d4 <Clock_Enter_Typing_Mode+0xbc>
				{
					LCD_Set_Block(16);
     388:	80 e1       	ldi	r24, 0x10	; 16
     38a:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
					LCD_Void_Write_String("taken  ");
     38e:	81 e7       	ldi	r24, 0x71	; 113
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <LCD_Void_Write_String>
					KPD_Check_frequency = 1;
     396:	81 e0       	ldi	r24, 0x01	; 1
     398:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
					take_lach = 1;
     39c:	81 e0       	ldi	r24, 0x01	; 1
     39e:	89 83       	std	Y+1, r24	; 0x01
				}
				break;
     3a0:	19 c0       	rjmp	.+50     	; 0x3d4 <Clock_Enter_Typing_Mode+0xbc>
			case '#':
				xSemaphoreGive(LCD);
     3a2:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <LCD>
     3a6:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <LCD+0x1>
     3aa:	20 e0       	ldi	r18, 0x00	; 0
     3ac:	40 e0       	ldi	r20, 0x00	; 0
     3ae:	50 e0       	ldi	r21, 0x00	; 0
     3b0:	60 e0       	ldi	r22, 0x00	; 0
     3b2:	70 e0       	ldi	r23, 0x00	; 0
     3b4:	0e 94 12 19 	call	0x3224	; 0x3224 <xQueueGenericSend>
				LCD_Set_Block(16);
     3b8:	80 e1       	ldi	r24, 0x10	; 16
     3ba:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
				LCD_Void_Write_String("released");
     3be:	89 e7       	ldi	r24, 0x79	; 121
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <LCD_Void_Write_String>
				take_lach = 0;
     3c6:	19 82       	std	Y+1, r1	; 0x01
				Clock_Print_Default_Interface();
     3c8:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
				KPD_Check_frequency = configTICK_RATE_HZ*2;
     3cc:	88 e0       	ldi	r24, 0x08	; 8
     3ce:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
				break;
     3d2:	01 c0       	rjmp	.+2      	; 0x3d6 <Clock_Enter_Typing_Mode+0xbe>
					LCD_Set_Block(16);
					LCD_Void_Write_String("taken  ");
					KPD_Check_frequency = 1;
					take_lach = 1;
				}
				break;
     3d4:	00 00       	nop

			}

		}

	}
     3d6:	ab cf       	rjmp	.-170    	; 0x32e <Clock_Enter_Typing_Mode+0x16>

000003d8 <DIO_voidInitialize>:

/* Description: This function shall initialize the     */
/*              direction and initial value for DIO    */
/*              pins                                   */
void DIO_voidInitialize(void)
{
     3d8:	cf 93       	push	r28
     3da:	df 93       	push	r29
     3dc:	cd b7       	in	r28, 0x3d	; 61
     3de:	de b7       	in	r29, 0x3e	; 62
	DIO_u8_DDRA->ByteAccess = CONC_8BIT(DIO_u8_PIN0_DIR,
     3e0:	8a e3       	ldi	r24, 0x3A	; 58
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	fc 01       	movw	r30, r24
     3e6:	10 82       	st	Z, r1
										DIO_u8_PIN4_DIR,
										DIO_u8_PIN5_DIR,
										DIO_u8_PIN6_DIR,
										DIO_u8_PIN7_DIR);

	DIO_u8_DDRB->ByteAccess = CONC_8BIT(DIO_u8_PIN8_DIR,
     3e8:	87 e3       	ldi	r24, 0x37	; 55
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	fc 01       	movw	r30, r24
     3ee:	10 82       	st	Z, r1
										DIO_u8_PIN12_DIR,
										DIO_u8_PIN13_DIR,
										DIO_u8_PIN14_DIR,
										DIO_u8_PIN15_DIR);

	DIO_u8_DDRC->ByteAccess = CONC_8BIT(DIO_u8_PIN16_DIR,
     3f0:	84 e3       	ldi	r24, 0x34	; 52
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	fc 01       	movw	r30, r24
     3f6:	10 82       	st	Z, r1
										DIO_u8_PIN20_DIR,
										DIO_u8_PIN21_DIR,
										DIO_u8_PIN22_DIR,
										DIO_u8_PIN23_DIR);

	DIO_u8_DDRD->ByteAccess = CONC_8BIT(DIO_u8_PIN24_DIR,
     3f8:	81 e3       	ldi	r24, 0x31	; 49
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	fc 01       	movw	r30, r24
     3fe:	10 82       	st	Z, r1
										DIO_u8_PIN27_DIR,
										DIO_u8_PIN28_DIR,
										DIO_u8_PIN29_DIR,
										DIO_u8_PIN30_DIR,
										DIO_u8_PIN31_DIR);
}
     400:	00 00       	nop
     402:	df 91       	pop	r29
     404:	cf 91       	pop	r28
     406:	08 95       	ret

00000408 <DIO_u8SetPinDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_pin           */
u8 DIO_u8SetPinDirection(u8 Copy_u8PinNB, u8 Copy_u8PinDirection)
{
     408:	cf 93       	push	r28
     40a:	df 93       	push	r29
     40c:	00 d0       	rcall	.+0      	; 0x40e <DIO_u8SetPinDirection+0x6>
     40e:	00 d0       	rcall	.+0      	; 0x410 <DIO_u8SetPinDirection+0x8>
     410:	1f 92       	push	r1
     412:	cd b7       	in	r28, 0x3d	; 61
     414:	de b7       	in	r29, 0x3e	; 62
     416:	8c 83       	std	Y+4, r24	; 0x04
     418:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     41a:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     41c:	8c 81       	ldd	r24, Y+4	; 0x04
     41e:	80 32       	cpi	r24, 0x20	; 32
     420:	18 f0       	brcs	.+6      	; 0x428 <DIO_u8SetPinDirection+0x20>
	{
		u8ErrorState = 1;
     422:	81 e0       	ldi	r24, 0x01	; 1
     424:	89 83       	std	Y+1, r24	; 0x01
     426:	dd c0       	rjmp	.+442    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
	}else if ((Copy_u8PinDirection != DIO_u8_INPUT) && (Copy_u8PinDirection != DIO_u8_OUTPUT))
     428:	8d 81       	ldd	r24, Y+5	; 0x05
     42a:	88 23       	and	r24, r24
     42c:	31 f0       	breq	.+12     	; 0x43a <DIO_u8SetPinDirection+0x32>
     42e:	8d 81       	ldd	r24, Y+5	; 0x05
     430:	81 30       	cpi	r24, 0x01	; 1
     432:	19 f0       	breq	.+6      	; 0x43a <DIO_u8SetPinDirection+0x32>
	{
		u8ErrorState = 1;
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	89 83       	std	Y+1, r24	; 0x01
     438:	d4 c0       	rjmp	.+424    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     43a:	8c 81       	ldd	r24, Y+4	; 0x04
     43c:	86 95       	lsr	r24
     43e:	86 95       	lsr	r24
     440:	86 95       	lsr	r24
     442:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     444:	8c 81       	ldd	r24, Y+4	; 0x04
     446:	87 70       	andi	r24, 0x07	; 7
     448:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     44a:	8a 81       	ldd	r24, Y+2	; 0x02
     44c:	88 2f       	mov	r24, r24
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	81 30       	cpi	r24, 0x01	; 1
     452:	91 05       	cpc	r25, r1
     454:	e1 f1       	breq	.+120    	; 0x4ce <DIO_u8SetPinDirection+0xc6>
     456:	82 30       	cpi	r24, 0x02	; 2
     458:	91 05       	cpc	r25, r1
     45a:	1c f4       	brge	.+6      	; 0x462 <DIO_u8SetPinDirection+0x5a>
     45c:	89 2b       	or	r24, r25
     45e:	49 f0       	breq	.+18     	; 0x472 <DIO_u8SetPinDirection+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     460:	c0 c0       	rjmp	.+384    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     462:	82 30       	cpi	r24, 0x02	; 2
     464:	91 05       	cpc	r25, r1
     466:	09 f4       	brne	.+2      	; 0x46a <DIO_u8SetPinDirection+0x62>
     468:	60 c0       	rjmp	.+192    	; 0x52a <DIO_u8SetPinDirection+0x122>
     46a:	03 97       	sbiw	r24, 0x03	; 3
     46c:	09 f4       	brne	.+2      	; 0x470 <DIO_u8SetPinDirection+0x68>
     46e:	8b c0       	rjmp	.+278    	; 0x586 <DIO_u8SetPinDirection+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     470:	b8 c0       	rjmp	.+368    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     472:	8d 81       	ldd	r24, Y+5	; 0x05
     474:	81 30       	cpi	r24, 0x01	; 1
     476:	a9 f4       	brne	.+42     	; 0x4a2 <DIO_u8SetPinDirection+0x9a>
     478:	8a e3       	ldi	r24, 0x3A	; 58
     47a:	90 e0       	ldi	r25, 0x00	; 0
     47c:	2a e3       	ldi	r18, 0x3A	; 58
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	f9 01       	movw	r30, r18
     482:	20 81       	ld	r18, Z
     484:	62 2f       	mov	r22, r18
     486:	2b 81       	ldd	r18, Y+3	; 0x03
     488:	42 2f       	mov	r20, r18
     48a:	50 e0       	ldi	r21, 0x00	; 0
     48c:	21 e0       	ldi	r18, 0x01	; 1
     48e:	30 e0       	ldi	r19, 0x00	; 0
     490:	02 c0       	rjmp	.+4      	; 0x496 <DIO_u8SetPinDirection+0x8e>
     492:	22 0f       	add	r18, r18
     494:	33 1f       	adc	r19, r19
     496:	4a 95       	dec	r20
     498:	e2 f7       	brpl	.-8      	; 0x492 <DIO_u8SetPinDirection+0x8a>
     49a:	26 2b       	or	r18, r22
     49c:	fc 01       	movw	r30, r24
     49e:	20 83       	st	Z, r18
			break;
     4a0:	a0 c0       	rjmp	.+320    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     4a2:	8a e3       	ldi	r24, 0x3A	; 58
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	2a e3       	ldi	r18, 0x3A	; 58
     4a8:	30 e0       	ldi	r19, 0x00	; 0
     4aa:	f9 01       	movw	r30, r18
     4ac:	20 81       	ld	r18, Z
     4ae:	62 2f       	mov	r22, r18
     4b0:	2b 81       	ldd	r18, Y+3	; 0x03
     4b2:	42 2f       	mov	r20, r18
     4b4:	50 e0       	ldi	r21, 0x00	; 0
     4b6:	21 e0       	ldi	r18, 0x01	; 1
     4b8:	30 e0       	ldi	r19, 0x00	; 0
     4ba:	02 c0       	rjmp	.+4      	; 0x4c0 <DIO_u8SetPinDirection+0xb8>
     4bc:	22 0f       	add	r18, r18
     4be:	33 1f       	adc	r19, r19
     4c0:	4a 95       	dec	r20
     4c2:	e2 f7       	brpl	.-8      	; 0x4bc <DIO_u8SetPinDirection+0xb4>
     4c4:	20 95       	com	r18
     4c6:	26 23       	and	r18, r22
     4c8:	fc 01       	movw	r30, r24
     4ca:	20 83       	st	Z, r18
			break;
     4cc:	8a c0       	rjmp	.+276    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
		case GROUP_B :
			if(Copy_u8PinDirection == DIO_u8_INPUT)
     4ce:	8d 81       	ldd	r24, Y+5	; 0x05
     4d0:	88 23       	and	r24, r24
     4d2:	b1 f4       	brne	.+44     	; 0x500 <DIO_u8SetPinDirection+0xf8>
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     4d4:	87 e3       	ldi	r24, 0x37	; 55
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	27 e3       	ldi	r18, 0x37	; 55
     4da:	30 e0       	ldi	r19, 0x00	; 0
     4dc:	f9 01       	movw	r30, r18
     4de:	20 81       	ld	r18, Z
     4e0:	62 2f       	mov	r22, r18
     4e2:	2b 81       	ldd	r18, Y+3	; 0x03
     4e4:	42 2f       	mov	r20, r18
     4e6:	50 e0       	ldi	r21, 0x00	; 0
     4e8:	21 e0       	ldi	r18, 0x01	; 1
     4ea:	30 e0       	ldi	r19, 0x00	; 0
     4ec:	02 c0       	rjmp	.+4      	; 0x4f2 <DIO_u8SetPinDirection+0xea>
     4ee:	22 0f       	add	r18, r18
     4f0:	33 1f       	adc	r19, r19
     4f2:	4a 95       	dec	r20
     4f4:	e2 f7       	brpl	.-8      	; 0x4ee <DIO_u8SetPinDirection+0xe6>
     4f6:	20 95       	com	r18
     4f8:	26 23       	and	r18, r22
     4fa:	fc 01       	movw	r30, r24
     4fc:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
     4fe:	71 c0       	rjmp	.+226    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
			if(Copy_u8PinDirection == DIO_u8_INPUT)
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     500:	87 e3       	ldi	r24, 0x37	; 55
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	27 e3       	ldi	r18, 0x37	; 55
     506:	30 e0       	ldi	r19, 0x00	; 0
     508:	f9 01       	movw	r30, r18
     50a:	20 81       	ld	r18, Z
     50c:	62 2f       	mov	r22, r18
     50e:	2b 81       	ldd	r18, Y+3	; 0x03
     510:	42 2f       	mov	r20, r18
     512:	50 e0       	ldi	r21, 0x00	; 0
     514:	21 e0       	ldi	r18, 0x01	; 1
     516:	30 e0       	ldi	r19, 0x00	; 0
     518:	02 c0       	rjmp	.+4      	; 0x51e <DIO_u8SetPinDirection+0x116>
     51a:	22 0f       	add	r18, r18
     51c:	33 1f       	adc	r19, r19
     51e:	4a 95       	dec	r20
     520:	e2 f7       	brpl	.-8      	; 0x51a <DIO_u8SetPinDirection+0x112>
     522:	26 2b       	or	r18, r22
     524:	fc 01       	movw	r30, r24
     526:	20 83       	st	Z, r18
			}
			break;
     528:	5c c0       	rjmp	.+184    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     52a:	8d 81       	ldd	r24, Y+5	; 0x05
     52c:	81 30       	cpi	r24, 0x01	; 1
     52e:	a9 f4       	brne	.+42     	; 0x55a <DIO_u8SetPinDirection+0x152>
     530:	84 e3       	ldi	r24, 0x34	; 52
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	24 e3       	ldi	r18, 0x34	; 52
     536:	30 e0       	ldi	r19, 0x00	; 0
     538:	f9 01       	movw	r30, r18
     53a:	20 81       	ld	r18, Z
     53c:	62 2f       	mov	r22, r18
     53e:	2b 81       	ldd	r18, Y+3	; 0x03
     540:	42 2f       	mov	r20, r18
     542:	50 e0       	ldi	r21, 0x00	; 0
     544:	21 e0       	ldi	r18, 0x01	; 1
     546:	30 e0       	ldi	r19, 0x00	; 0
     548:	02 c0       	rjmp	.+4      	; 0x54e <DIO_u8SetPinDirection+0x146>
     54a:	22 0f       	add	r18, r18
     54c:	33 1f       	adc	r19, r19
     54e:	4a 95       	dec	r20
     550:	e2 f7       	brpl	.-8      	; 0x54a <DIO_u8SetPinDirection+0x142>
     552:	26 2b       	or	r18, r22
     554:	fc 01       	movw	r30, r24
     556:	20 83       	st	Z, r18
			break;
     558:	44 c0       	rjmp	.+136    	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     55a:	84 e3       	ldi	r24, 0x34	; 52
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	24 e3       	ldi	r18, 0x34	; 52
     560:	30 e0       	ldi	r19, 0x00	; 0
     562:	f9 01       	movw	r30, r18
     564:	20 81       	ld	r18, Z
     566:	62 2f       	mov	r22, r18
     568:	2b 81       	ldd	r18, Y+3	; 0x03
     56a:	42 2f       	mov	r20, r18
     56c:	50 e0       	ldi	r21, 0x00	; 0
     56e:	21 e0       	ldi	r18, 0x01	; 1
     570:	30 e0       	ldi	r19, 0x00	; 0
     572:	02 c0       	rjmp	.+4      	; 0x578 <DIO_u8SetPinDirection+0x170>
     574:	22 0f       	add	r18, r18
     576:	33 1f       	adc	r19, r19
     578:	4a 95       	dec	r20
     57a:	e2 f7       	brpl	.-8      	; 0x574 <DIO_u8SetPinDirection+0x16c>
     57c:	20 95       	com	r18
     57e:	26 23       	and	r18, r22
     580:	fc 01       	movw	r30, r24
     582:	20 83       	st	Z, r18
			break;
     584:	2e c0       	rjmp	.+92     	; 0x5e2 <DIO_u8SetPinDirection+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     586:	8d 81       	ldd	r24, Y+5	; 0x05
     588:	81 30       	cpi	r24, 0x01	; 1
     58a:	a9 f4       	brne	.+42     	; 0x5b6 <DIO_u8SetPinDirection+0x1ae>
     58c:	81 e3       	ldi	r24, 0x31	; 49
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	21 e3       	ldi	r18, 0x31	; 49
     592:	30 e0       	ldi	r19, 0x00	; 0
     594:	f9 01       	movw	r30, r18
     596:	20 81       	ld	r18, Z
     598:	62 2f       	mov	r22, r18
     59a:	2b 81       	ldd	r18, Y+3	; 0x03
     59c:	42 2f       	mov	r20, r18
     59e:	50 e0       	ldi	r21, 0x00	; 0
     5a0:	21 e0       	ldi	r18, 0x01	; 1
     5a2:	30 e0       	ldi	r19, 0x00	; 0
     5a4:	02 c0       	rjmp	.+4      	; 0x5aa <DIO_u8SetPinDirection+0x1a2>
     5a6:	22 0f       	add	r18, r18
     5a8:	33 1f       	adc	r19, r19
     5aa:	4a 95       	dec	r20
     5ac:	e2 f7       	brpl	.-8      	; 0x5a6 <DIO_u8SetPinDirection+0x19e>
     5ae:	26 2b       	or	r18, r22
     5b0:	fc 01       	movw	r30, r24
     5b2:	20 83       	st	Z, r18
			break;
     5b4:	15 c0       	rjmp	.+42     	; 0x5e0 <DIO_u8SetPinDirection+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     5b6:	81 e3       	ldi	r24, 0x31	; 49
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	21 e3       	ldi	r18, 0x31	; 49
     5bc:	30 e0       	ldi	r19, 0x00	; 0
     5be:	f9 01       	movw	r30, r18
     5c0:	20 81       	ld	r18, Z
     5c2:	62 2f       	mov	r22, r18
     5c4:	2b 81       	ldd	r18, Y+3	; 0x03
     5c6:	42 2f       	mov	r20, r18
     5c8:	50 e0       	ldi	r21, 0x00	; 0
     5ca:	21 e0       	ldi	r18, 0x01	; 1
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	02 c0       	rjmp	.+4      	; 0x5d4 <DIO_u8SetPinDirection+0x1cc>
     5d0:	22 0f       	add	r18, r18
     5d2:	33 1f       	adc	r19, r19
     5d4:	4a 95       	dec	r20
     5d6:	e2 f7       	brpl	.-8      	; 0x5d0 <DIO_u8SetPinDirection+0x1c8>
     5d8:	20 95       	com	r18
     5da:	26 23       	and	r18, r22
     5dc:	fc 01       	movw	r30, r24
     5de:	20 83       	st	Z, r18
			break;
     5e0:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     5e2:	89 81       	ldd	r24, Y+1	; 0x01
}
     5e4:	0f 90       	pop	r0
     5e6:	0f 90       	pop	r0
     5e8:	0f 90       	pop	r0
     5ea:	0f 90       	pop	r0
     5ec:	0f 90       	pop	r0
     5ee:	df 91       	pop	r29
     5f0:	cf 91       	pop	r28
     5f2:	08 95       	ret

000005f4 <DIO_u8SetPinValue>:
/* Description: This function shall set certain value  */
/*              to certain DIO pin                     */
u8 DIO_u8SetPinValue(u8 Copy_u8PinNB, u8 Copy_u8PinValue)
{
     5f4:	cf 93       	push	r28
     5f6:	df 93       	push	r29
     5f8:	00 d0       	rcall	.+0      	; 0x5fa <DIO_u8SetPinValue+0x6>
     5fa:	00 d0       	rcall	.+0      	; 0x5fc <DIO_u8SetPinValue+0x8>
     5fc:	1f 92       	push	r1
     5fe:	cd b7       	in	r28, 0x3d	; 61
     600:	de b7       	in	r29, 0x3e	; 62
     602:	8c 83       	std	Y+4, r24	; 0x04
     604:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     606:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     608:	8c 81       	ldd	r24, Y+4	; 0x04
     60a:	80 32       	cpi	r24, 0x20	; 32
     60c:	18 f0       	brcs	.+6      	; 0x614 <DIO_u8SetPinValue+0x20>
	{
		u8ErrorState = 1;
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	89 83       	std	Y+1, r24	; 0x01
     612:	dd c0       	rjmp	.+442    	; 0x7ce <DIO_u8SetPinValue+0x1da>
	}else if ((Copy_u8PinValue != DIO_u8_HIGH) && (Copy_u8PinValue != DIO_u8_LOW))
     614:	8d 81       	ldd	r24, Y+5	; 0x05
     616:	81 30       	cpi	r24, 0x01	; 1
     618:	31 f0       	breq	.+12     	; 0x626 <DIO_u8SetPinValue+0x32>
     61a:	8d 81       	ldd	r24, Y+5	; 0x05
     61c:	88 23       	and	r24, r24
     61e:	19 f0       	breq	.+6      	; 0x626 <DIO_u8SetPinValue+0x32>
	{
		u8ErrorState = 1;
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	89 83       	std	Y+1, r24	; 0x01
     624:	d4 c0       	rjmp	.+424    	; 0x7ce <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     626:	8c 81       	ldd	r24, Y+4	; 0x04
     628:	86 95       	lsr	r24
     62a:	86 95       	lsr	r24
     62c:	86 95       	lsr	r24
     62e:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     630:	8c 81       	ldd	r24, Y+4	; 0x04
     632:	87 70       	andi	r24, 0x07	; 7
     634:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     636:	8a 81       	ldd	r24, Y+2	; 0x02
     638:	88 2f       	mov	r24, r24
     63a:	90 e0       	ldi	r25, 0x00	; 0
     63c:	81 30       	cpi	r24, 0x01	; 1
     63e:	91 05       	cpc	r25, r1
     640:	e1 f1       	breq	.+120    	; 0x6ba <DIO_u8SetPinValue+0xc6>
     642:	82 30       	cpi	r24, 0x02	; 2
     644:	91 05       	cpc	r25, r1
     646:	1c f4       	brge	.+6      	; 0x64e <DIO_u8SetPinValue+0x5a>
     648:	89 2b       	or	r24, r25
     64a:	49 f0       	breq	.+18     	; 0x65e <DIO_u8SetPinValue+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     64c:	c0 c0       	rjmp	.+384    	; 0x7ce <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     64e:	82 30       	cpi	r24, 0x02	; 2
     650:	91 05       	cpc	r25, r1
     652:	09 f4       	brne	.+2      	; 0x656 <DIO_u8SetPinValue+0x62>
     654:	60 c0       	rjmp	.+192    	; 0x716 <DIO_u8SetPinValue+0x122>
     656:	03 97       	sbiw	r24, 0x03	; 3
     658:	09 f4       	brne	.+2      	; 0x65c <DIO_u8SetPinValue+0x68>
     65a:	8b c0       	rjmp	.+278    	; 0x772 <DIO_u8SetPinValue+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     65c:	b8 c0       	rjmp	.+368    	; 0x7ce <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     65e:	8d 81       	ldd	r24, Y+5	; 0x05
     660:	81 30       	cpi	r24, 0x01	; 1
     662:	a9 f4       	brne	.+42     	; 0x68e <DIO_u8SetPinValue+0x9a>
     664:	8b e3       	ldi	r24, 0x3B	; 59
     666:	90 e0       	ldi	r25, 0x00	; 0
     668:	2b e3       	ldi	r18, 0x3B	; 59
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	f9 01       	movw	r30, r18
     66e:	20 81       	ld	r18, Z
     670:	62 2f       	mov	r22, r18
     672:	2b 81       	ldd	r18, Y+3	; 0x03
     674:	42 2f       	mov	r20, r18
     676:	50 e0       	ldi	r21, 0x00	; 0
     678:	21 e0       	ldi	r18, 0x01	; 1
     67a:	30 e0       	ldi	r19, 0x00	; 0
     67c:	02 c0       	rjmp	.+4      	; 0x682 <DIO_u8SetPinValue+0x8e>
     67e:	22 0f       	add	r18, r18
     680:	33 1f       	adc	r19, r19
     682:	4a 95       	dec	r20
     684:	e2 f7       	brpl	.-8      	; 0x67e <DIO_u8SetPinValue+0x8a>
     686:	26 2b       	or	r18, r22
     688:	fc 01       	movw	r30, r24
     68a:	20 83       	st	Z, r18
			break;
     68c:	a0 c0       	rjmp	.+320    	; 0x7ce <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     68e:	8b e3       	ldi	r24, 0x3B	; 59
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	2b e3       	ldi	r18, 0x3B	; 59
     694:	30 e0       	ldi	r19, 0x00	; 0
     696:	f9 01       	movw	r30, r18
     698:	20 81       	ld	r18, Z
     69a:	62 2f       	mov	r22, r18
     69c:	2b 81       	ldd	r18, Y+3	; 0x03
     69e:	42 2f       	mov	r20, r18
     6a0:	50 e0       	ldi	r21, 0x00	; 0
     6a2:	21 e0       	ldi	r18, 0x01	; 1
     6a4:	30 e0       	ldi	r19, 0x00	; 0
     6a6:	02 c0       	rjmp	.+4      	; 0x6ac <DIO_u8SetPinValue+0xb8>
     6a8:	22 0f       	add	r18, r18
     6aa:	33 1f       	adc	r19, r19
     6ac:	4a 95       	dec	r20
     6ae:	e2 f7       	brpl	.-8      	; 0x6a8 <DIO_u8SetPinValue+0xb4>
     6b0:	20 95       	com	r18
     6b2:	26 23       	and	r18, r22
     6b4:	fc 01       	movw	r30, r24
     6b6:	20 83       	st	Z, r18
			break;
     6b8:	8a c0       	rjmp	.+276    	; 0x7ce <DIO_u8SetPinValue+0x1da>
		case GROUP_B :
			if(Copy_u8PinValue == DIO_u8_LOW)
     6ba:	8d 81       	ldd	r24, Y+5	; 0x05
     6bc:	88 23       	and	r24, r24
     6be:	b1 f4       	brne	.+44     	; 0x6ec <DIO_u8SetPinValue+0xf8>
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     6c0:	88 e3       	ldi	r24, 0x38	; 56
     6c2:	90 e0       	ldi	r25, 0x00	; 0
     6c4:	28 e3       	ldi	r18, 0x38	; 56
     6c6:	30 e0       	ldi	r19, 0x00	; 0
     6c8:	f9 01       	movw	r30, r18
     6ca:	20 81       	ld	r18, Z
     6cc:	62 2f       	mov	r22, r18
     6ce:	2b 81       	ldd	r18, Y+3	; 0x03
     6d0:	42 2f       	mov	r20, r18
     6d2:	50 e0       	ldi	r21, 0x00	; 0
     6d4:	21 e0       	ldi	r18, 0x01	; 1
     6d6:	30 e0       	ldi	r19, 0x00	; 0
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <DIO_u8SetPinValue+0xea>
     6da:	22 0f       	add	r18, r18
     6dc:	33 1f       	adc	r19, r19
     6de:	4a 95       	dec	r20
     6e0:	e2 f7       	brpl	.-8      	; 0x6da <DIO_u8SetPinValue+0xe6>
     6e2:	20 95       	com	r18
     6e4:	26 23       	and	r18, r22
     6e6:	fc 01       	movw	r30, r24
     6e8:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
     6ea:	71 c0       	rjmp	.+226    	; 0x7ce <DIO_u8SetPinValue+0x1da>
			if(Copy_u8PinValue == DIO_u8_LOW)
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     6ec:	88 e3       	ldi	r24, 0x38	; 56
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	28 e3       	ldi	r18, 0x38	; 56
     6f2:	30 e0       	ldi	r19, 0x00	; 0
     6f4:	f9 01       	movw	r30, r18
     6f6:	20 81       	ld	r18, Z
     6f8:	62 2f       	mov	r22, r18
     6fa:	2b 81       	ldd	r18, Y+3	; 0x03
     6fc:	42 2f       	mov	r20, r18
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	21 e0       	ldi	r18, 0x01	; 1
     702:	30 e0       	ldi	r19, 0x00	; 0
     704:	02 c0       	rjmp	.+4      	; 0x70a <DIO_u8SetPinValue+0x116>
     706:	22 0f       	add	r18, r18
     708:	33 1f       	adc	r19, r19
     70a:	4a 95       	dec	r20
     70c:	e2 f7       	brpl	.-8      	; 0x706 <DIO_u8SetPinValue+0x112>
     70e:	26 2b       	or	r18, r22
     710:	fc 01       	movw	r30, r24
     712:	20 83       	st	Z, r18
			}
			break;
     714:	5c c0       	rjmp	.+184    	; 0x7ce <DIO_u8SetPinValue+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     716:	8d 81       	ldd	r24, Y+5	; 0x05
     718:	81 30       	cpi	r24, 0x01	; 1
     71a:	a9 f4       	brne	.+42     	; 0x746 <DIO_u8SetPinValue+0x152>
     71c:	85 e3       	ldi	r24, 0x35	; 53
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	25 e3       	ldi	r18, 0x35	; 53
     722:	30 e0       	ldi	r19, 0x00	; 0
     724:	f9 01       	movw	r30, r18
     726:	20 81       	ld	r18, Z
     728:	62 2f       	mov	r22, r18
     72a:	2b 81       	ldd	r18, Y+3	; 0x03
     72c:	42 2f       	mov	r20, r18
     72e:	50 e0       	ldi	r21, 0x00	; 0
     730:	21 e0       	ldi	r18, 0x01	; 1
     732:	30 e0       	ldi	r19, 0x00	; 0
     734:	02 c0       	rjmp	.+4      	; 0x73a <DIO_u8SetPinValue+0x146>
     736:	22 0f       	add	r18, r18
     738:	33 1f       	adc	r19, r19
     73a:	4a 95       	dec	r20
     73c:	e2 f7       	brpl	.-8      	; 0x736 <DIO_u8SetPinValue+0x142>
     73e:	26 2b       	or	r18, r22
     740:	fc 01       	movw	r30, r24
     742:	20 83       	st	Z, r18
			break;
     744:	44 c0       	rjmp	.+136    	; 0x7ce <DIO_u8SetPinValue+0x1da>
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     746:	85 e3       	ldi	r24, 0x35	; 53
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	25 e3       	ldi	r18, 0x35	; 53
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	f9 01       	movw	r30, r18
     750:	20 81       	ld	r18, Z
     752:	62 2f       	mov	r22, r18
     754:	2b 81       	ldd	r18, Y+3	; 0x03
     756:	42 2f       	mov	r20, r18
     758:	50 e0       	ldi	r21, 0x00	; 0
     75a:	21 e0       	ldi	r18, 0x01	; 1
     75c:	30 e0       	ldi	r19, 0x00	; 0
     75e:	02 c0       	rjmp	.+4      	; 0x764 <DIO_u8SetPinValue+0x170>
     760:	22 0f       	add	r18, r18
     762:	33 1f       	adc	r19, r19
     764:	4a 95       	dec	r20
     766:	e2 f7       	brpl	.-8      	; 0x760 <DIO_u8SetPinValue+0x16c>
     768:	20 95       	com	r18
     76a:	26 23       	and	r18, r22
     76c:	fc 01       	movw	r30, r24
     76e:	20 83       	st	Z, r18
			break;
     770:	2e c0       	rjmp	.+92     	; 0x7ce <DIO_u8SetPinValue+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     772:	8d 81       	ldd	r24, Y+5	; 0x05
     774:	81 30       	cpi	r24, 0x01	; 1
     776:	a9 f4       	brne	.+42     	; 0x7a2 <DIO_u8SetPinValue+0x1ae>
     778:	82 e3       	ldi	r24, 0x32	; 50
     77a:	90 e0       	ldi	r25, 0x00	; 0
     77c:	22 e3       	ldi	r18, 0x32	; 50
     77e:	30 e0       	ldi	r19, 0x00	; 0
     780:	f9 01       	movw	r30, r18
     782:	20 81       	ld	r18, Z
     784:	62 2f       	mov	r22, r18
     786:	2b 81       	ldd	r18, Y+3	; 0x03
     788:	42 2f       	mov	r20, r18
     78a:	50 e0       	ldi	r21, 0x00	; 0
     78c:	21 e0       	ldi	r18, 0x01	; 1
     78e:	30 e0       	ldi	r19, 0x00	; 0
     790:	02 c0       	rjmp	.+4      	; 0x796 <DIO_u8SetPinValue+0x1a2>
     792:	22 0f       	add	r18, r18
     794:	33 1f       	adc	r19, r19
     796:	4a 95       	dec	r20
     798:	e2 f7       	brpl	.-8      	; 0x792 <DIO_u8SetPinValue+0x19e>
     79a:	26 2b       	or	r18, r22
     79c:	fc 01       	movw	r30, r24
     79e:	20 83       	st	Z, r18
			break;
     7a0:	15 c0       	rjmp	.+42     	; 0x7cc <DIO_u8SetPinValue+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     7a2:	82 e3       	ldi	r24, 0x32	; 50
     7a4:	90 e0       	ldi	r25, 0x00	; 0
     7a6:	22 e3       	ldi	r18, 0x32	; 50
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	f9 01       	movw	r30, r18
     7ac:	20 81       	ld	r18, Z
     7ae:	62 2f       	mov	r22, r18
     7b0:	2b 81       	ldd	r18, Y+3	; 0x03
     7b2:	42 2f       	mov	r20, r18
     7b4:	50 e0       	ldi	r21, 0x00	; 0
     7b6:	21 e0       	ldi	r18, 0x01	; 1
     7b8:	30 e0       	ldi	r19, 0x00	; 0
     7ba:	02 c0       	rjmp	.+4      	; 0x7c0 <DIO_u8SetPinValue+0x1cc>
     7bc:	22 0f       	add	r18, r18
     7be:	33 1f       	adc	r19, r19
     7c0:	4a 95       	dec	r20
     7c2:	e2 f7       	brpl	.-8      	; 0x7bc <DIO_u8SetPinValue+0x1c8>
     7c4:	20 95       	com	r18
     7c6:	26 23       	and	r18, r22
     7c8:	fc 01       	movw	r30, r24
     7ca:	20 83       	st	Z, r18
			break;
     7cc:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     7ce:	89 81       	ldd	r24, Y+1	; 0x01
}
     7d0:	0f 90       	pop	r0
     7d2:	0f 90       	pop	r0
     7d4:	0f 90       	pop	r0
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	df 91       	pop	r29
     7dc:	cf 91       	pop	r28
     7de:	08 95       	ret

000007e0 <DIO_u8SetPortDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_port          */
u8 DIO_u8SetPortDirection(u8 Copy_u8PortNB, u8 Copy_u8PortDirection)
{
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	00 d0       	rcall	.+0      	; 0x7e6 <DIO_u8SetPortDirection+0x6>
     7e6:	1f 92       	push	r1
     7e8:	cd b7       	in	r28, 0x3d	; 61
     7ea:	de b7       	in	r29, 0x3e	; 62
     7ec:	8a 83       	std	Y+2, r24	; 0x02
     7ee:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     7f0:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
		if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     7f2:	8a 81       	ldd	r24, Y+2	; 0x02
     7f4:	84 30       	cpi	r24, 0x04	; 4
     7f6:	18 f0       	brcs	.+6      	; 0x7fe <DIO_u8SetPortDirection+0x1e>
		{
			u8ErrorState = 1;
     7f8:	81 e0       	ldi	r24, 0x01	; 1
     7fa:	89 83       	std	Y+1, r24	; 0x01
     7fc:	2a c0       	rjmp	.+84     	; 0x852 <DIO_u8SetPortDirection+0x72>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     7fe:	8a 81       	ldd	r24, Y+2	; 0x02
     800:	88 2f       	mov	r24, r24
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	81 30       	cpi	r24, 0x01	; 1
     806:	91 05       	cpc	r25, r1
     808:	91 f0       	breq	.+36     	; 0x82e <DIO_u8SetPortDirection+0x4e>
     80a:	82 30       	cpi	r24, 0x02	; 2
     80c:	91 05       	cpc	r25, r1
     80e:	1c f4       	brge	.+6      	; 0x816 <DIO_u8SetPortDirection+0x36>
     810:	89 2b       	or	r24, r25
     812:	39 f0       	breq	.+14     	; 0x822 <DIO_u8SetPortDirection+0x42>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     814:	1e c0       	rjmp	.+60     	; 0x852 <DIO_u8SetPortDirection+0x72>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     816:	82 30       	cpi	r24, 0x02	; 2
     818:	91 05       	cpc	r25, r1
     81a:	79 f0       	breq	.+30     	; 0x83a <DIO_u8SetPortDirection+0x5a>
     81c:	03 97       	sbiw	r24, 0x03	; 3
     81e:	99 f0       	breq	.+38     	; 0x846 <DIO_u8SetPortDirection+0x66>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     820:	18 c0       	rjmp	.+48     	; 0x852 <DIO_u8SetPortDirection+0x72>
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
			{
			case GROUP_A :
				DIO_u8_DDRA->ByteAccess = Copy_u8PortDirection;
     822:	8a e3       	ldi	r24, 0x3A	; 58
     824:	90 e0       	ldi	r25, 0x00	; 0
     826:	2b 81       	ldd	r18, Y+3	; 0x03
     828:	fc 01       	movw	r30, r24
     82a:	20 83       	st	Z, r18
				break;
     82c:	12 c0       	rjmp	.+36     	; 0x852 <DIO_u8SetPortDirection+0x72>
			case GROUP_B :
				DIO_u8_DDRB->ByteAccess = Copy_u8PortDirection;
     82e:	87 e3       	ldi	r24, 0x37	; 55
     830:	90 e0       	ldi	r25, 0x00	; 0
     832:	2b 81       	ldd	r18, Y+3	; 0x03
     834:	fc 01       	movw	r30, r24
     836:	20 83       	st	Z, r18
				break;
     838:	0c c0       	rjmp	.+24     	; 0x852 <DIO_u8SetPortDirection+0x72>
			case GROUP_C :
				DIO_u8_DDRC->ByteAccess = Copy_u8PortDirection;
     83a:	84 e3       	ldi	r24, 0x34	; 52
     83c:	90 e0       	ldi	r25, 0x00	; 0
     83e:	2b 81       	ldd	r18, Y+3	; 0x03
     840:	fc 01       	movw	r30, r24
     842:	20 83       	st	Z, r18
				break;
     844:	06 c0       	rjmp	.+12     	; 0x852 <DIO_u8SetPortDirection+0x72>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
     846:	81 e3       	ldi	r24, 0x31	; 49
     848:	90 e0       	ldi	r25, 0x00	; 0
     84a:	2b 81       	ldd	r18, Y+3	; 0x03
     84c:	fc 01       	movw	r30, r24
     84e:	20 83       	st	Z, r18
				break;
     850:	00 00       	nop

				break;
			}
		}
	/*Function return*/
	return u8ErrorState;
     852:	89 81       	ldd	r24, Y+1	; 0x01
}
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	0f 90       	pop	r0
     85a:	df 91       	pop	r29
     85c:	cf 91       	pop	r28
     85e:	08 95       	ret

00000860 <DIO_u8SetPortValue>:

/* Description: This function shall set certain        */
/*              value to certain DIO_port              */
u8 DIO_u8SetPortValue(u8 Copy_u8PortNB, u8 Copy_u8PortValue)
{
     860:	cf 93       	push	r28
     862:	df 93       	push	r29
     864:	00 d0       	rcall	.+0      	; 0x866 <DIO_u8SetPortValue+0x6>
     866:	1f 92       	push	r1
     868:	cd b7       	in	r28, 0x3d	; 61
     86a:	de b7       	in	r29, 0x3e	; 62
     86c:	8a 83       	std	Y+2, r24	; 0x02
     86e:	6b 83       	std	Y+3, r22	; 0x03
		/*Local variables*/
		u8 u8ErrorState = 0;
     870:	19 82       	std	Y+1, r1	; 0x01

		/*validate inputs*/
			if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     872:	8a 81       	ldd	r24, Y+2	; 0x02
     874:	84 30       	cpi	r24, 0x04	; 4
     876:	18 f0       	brcs	.+6      	; 0x87e <DIO_u8SetPortValue+0x1e>
			{
				u8ErrorState = 1;
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	89 83       	std	Y+1, r24	; 0x01
     87c:	2a c0       	rjmp	.+84     	; 0x8d2 <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     87e:	8a 81       	ldd	r24, Y+2	; 0x02
     880:	88 2f       	mov	r24, r24
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	81 30       	cpi	r24, 0x01	; 1
     886:	91 05       	cpc	r25, r1
     888:	91 f0       	breq	.+36     	; 0x8ae <DIO_u8SetPortValue+0x4e>
     88a:	82 30       	cpi	r24, 0x02	; 2
     88c:	91 05       	cpc	r25, r1
     88e:	1c f4       	brge	.+6      	; 0x896 <DIO_u8SetPortValue+0x36>
     890:	89 2b       	or	r24, r25
     892:	39 f0       	breq	.+14     	; 0x8a2 <DIO_u8SetPortValue+0x42>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     894:	1e c0       	rjmp	.+60     	; 0x8d2 <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     896:	82 30       	cpi	r24, 0x02	; 2
     898:	91 05       	cpc	r25, r1
     89a:	79 f0       	breq	.+30     	; 0x8ba <DIO_u8SetPortValue+0x5a>
     89c:	03 97       	sbiw	r24, 0x03	; 3
     89e:	99 f0       	breq	.+38     	; 0x8c6 <DIO_u8SetPortValue+0x66>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     8a0:	18 c0       	rjmp	.+48     	; 0x8d2 <DIO_u8SetPortValue+0x72>
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
				{
				case GROUP_A :
					DIO_u8_PORTA->ByteAccess = Copy_u8PortValue;
     8a2:	8b e3       	ldi	r24, 0x3B	; 59
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	2b 81       	ldd	r18, Y+3	; 0x03
     8a8:	fc 01       	movw	r30, r24
     8aa:	20 83       	st	Z, r18
					break;
     8ac:	12 c0       	rjmp	.+36     	; 0x8d2 <DIO_u8SetPortValue+0x72>
				case GROUP_B :
					DIO_u8_PORTB->ByteAccess = Copy_u8PortValue;
     8ae:	88 e3       	ldi	r24, 0x38	; 56
     8b0:	90 e0       	ldi	r25, 0x00	; 0
     8b2:	2b 81       	ldd	r18, Y+3	; 0x03
     8b4:	fc 01       	movw	r30, r24
     8b6:	20 83       	st	Z, r18
					break;
     8b8:	0c c0       	rjmp	.+24     	; 0x8d2 <DIO_u8SetPortValue+0x72>
				case GROUP_C :
					DIO_u8_PORTC->ByteAccess = Copy_u8PortValue;
     8ba:	85 e3       	ldi	r24, 0x35	; 53
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	2b 81       	ldd	r18, Y+3	; 0x03
     8c0:	fc 01       	movw	r30, r24
     8c2:	20 83       	st	Z, r18
					break;
     8c4:	06 c0       	rjmp	.+12     	; 0x8d2 <DIO_u8SetPortValue+0x72>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
     8c6:	82 e3       	ldi	r24, 0x32	; 50
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	2b 81       	ldd	r18, Y+3	; 0x03
     8cc:	fc 01       	movw	r30, r24
     8ce:	20 83       	st	Z, r18
					break;
     8d0:	00 00       	nop

					break;
				}
			}
		/*Function return*/
		return u8ErrorState;
     8d2:	89 81       	ldd	r24, Y+1	; 0x01
}
     8d4:	0f 90       	pop	r0
     8d6:	0f 90       	pop	r0
     8d8:	0f 90       	pop	r0
     8da:	df 91       	pop	r29
     8dc:	cf 91       	pop	r28
     8de:	08 95       	ret

000008e0 <DIO_u8GetPinValue>:

/* */
/* */
u8 DIO_u8GetPinValue(u8 Copy_u8PinNB, u8 *Copy_u8PinValue)
{
     8e0:	cf 93       	push	r28
     8e2:	df 93       	push	r29
     8e4:	00 d0       	rcall	.+0      	; 0x8e6 <DIO_u8GetPinValue+0x6>
     8e6:	00 d0       	rcall	.+0      	; 0x8e8 <DIO_u8GetPinValue+0x8>
     8e8:	00 d0       	rcall	.+0      	; 0x8ea <DIO_u8GetPinValue+0xa>
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
     8ee:	8c 83       	std	Y+4, r24	; 0x04
     8f0:	7e 83       	std	Y+6, r23	; 0x06
     8f2:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     8f4:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     8f6:	8c 81       	ldd	r24, Y+4	; 0x04
     8f8:	80 32       	cpi	r24, 0x20	; 32
     8fa:	18 f0       	brcs	.+6      	; 0x902 <DIO_u8GetPinValue+0x22>
	{
		u8ErrorState = 1;
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	89 83       	std	Y+1, r24	; 0x01
     900:	6f c0       	rjmp	.+222    	; 0x9e0 <DIO_u8GetPinValue+0x100>
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     902:	8c 81       	ldd	r24, Y+4	; 0x04
     904:	86 95       	lsr	r24
     906:	86 95       	lsr	r24
     908:	86 95       	lsr	r24
     90a:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     90c:	8c 81       	ldd	r24, Y+4	; 0x04
     90e:	87 70       	andi	r24, 0x07	; 7
     910:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     912:	8a 81       	ldd	r24, Y+2	; 0x02
     914:	88 2f       	mov	r24, r24
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	81 30       	cpi	r24, 0x01	; 1
     91a:	91 05       	cpc	r25, r1
     91c:	11 f1       	breq	.+68     	; 0x962 <DIO_u8GetPinValue+0x82>
     91e:	82 30       	cpi	r24, 0x02	; 2
     920:	91 05       	cpc	r25, r1
     922:	1c f4       	brge	.+6      	; 0x92a <DIO_u8GetPinValue+0x4a>
     924:	89 2b       	or	r24, r25
     926:	41 f0       	breq	.+16     	; 0x938 <DIO_u8GetPinValue+0x58>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     928:	5b c0       	rjmp	.+182    	; 0x9e0 <DIO_u8GetPinValue+0x100>
		u8ErrorState = 1;
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     92a:	82 30       	cpi	r24, 0x02	; 2
     92c:	91 05       	cpc	r25, r1
     92e:	71 f1       	breq	.+92     	; 0x98c <DIO_u8GetPinValue+0xac>
     930:	03 97       	sbiw	r24, 0x03	; 3
     932:	09 f4       	brne	.+2      	; 0x936 <DIO_u8GetPinValue+0x56>
     934:	40 c0       	rjmp	.+128    	; 0x9b6 <DIO_u8GetPinValue+0xd6>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     936:	54 c0       	rjmp	.+168    	; 0x9e0 <DIO_u8GetPinValue+0x100>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINA -> ByteAccess, u8PIN_ID);
     938:	89 e3       	ldi	r24, 0x39	; 57
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	fc 01       	movw	r30, r24
     93e:	80 81       	ld	r24, Z
     940:	88 2f       	mov	r24, r24
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	2b 81       	ldd	r18, Y+3	; 0x03
     946:	22 2f       	mov	r18, r18
     948:	30 e0       	ldi	r19, 0x00	; 0
     94a:	02 c0       	rjmp	.+4      	; 0x950 <DIO_u8GetPinValue+0x70>
     94c:	95 95       	asr	r25
     94e:	87 95       	ror	r24
     950:	2a 95       	dec	r18
     952:	e2 f7       	brpl	.-8      	; 0x94c <DIO_u8GetPinValue+0x6c>
     954:	28 2f       	mov	r18, r24
     956:	21 70       	andi	r18, 0x01	; 1
     958:	8d 81       	ldd	r24, Y+5	; 0x05
     95a:	9e 81       	ldd	r25, Y+6	; 0x06
     95c:	fc 01       	movw	r30, r24
     95e:	20 83       	st	Z, r18
			break;
     960:	3f c0       	rjmp	.+126    	; 0x9e0 <DIO_u8GetPinValue+0x100>
		case GROUP_B :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINB -> ByteAccess, u8PIN_ID);
     962:	86 e3       	ldi	r24, 0x36	; 54
     964:	90 e0       	ldi	r25, 0x00	; 0
     966:	fc 01       	movw	r30, r24
     968:	80 81       	ld	r24, Z
     96a:	88 2f       	mov	r24, r24
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	2b 81       	ldd	r18, Y+3	; 0x03
     970:	22 2f       	mov	r18, r18
     972:	30 e0       	ldi	r19, 0x00	; 0
     974:	02 c0       	rjmp	.+4      	; 0x97a <DIO_u8GetPinValue+0x9a>
     976:	95 95       	asr	r25
     978:	87 95       	ror	r24
     97a:	2a 95       	dec	r18
     97c:	e2 f7       	brpl	.-8      	; 0x976 <DIO_u8GetPinValue+0x96>
     97e:	28 2f       	mov	r18, r24
     980:	21 70       	andi	r18, 0x01	; 1
     982:	8d 81       	ldd	r24, Y+5	; 0x05
     984:	9e 81       	ldd	r25, Y+6	; 0x06
     986:	fc 01       	movw	r30, r24
     988:	20 83       	st	Z, r18
			break;
     98a:	2a c0       	rjmp	.+84     	; 0x9e0 <DIO_u8GetPinValue+0x100>
		case GROUP_C :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINC -> ByteAccess, u8PIN_ID);
     98c:	83 e3       	ldi	r24, 0x33	; 51
     98e:	90 e0       	ldi	r25, 0x00	; 0
     990:	fc 01       	movw	r30, r24
     992:	80 81       	ld	r24, Z
     994:	88 2f       	mov	r24, r24
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	2b 81       	ldd	r18, Y+3	; 0x03
     99a:	22 2f       	mov	r18, r18
     99c:	30 e0       	ldi	r19, 0x00	; 0
     99e:	02 c0       	rjmp	.+4      	; 0x9a4 <DIO_u8GetPinValue+0xc4>
     9a0:	95 95       	asr	r25
     9a2:	87 95       	ror	r24
     9a4:	2a 95       	dec	r18
     9a6:	e2 f7       	brpl	.-8      	; 0x9a0 <DIO_u8GetPinValue+0xc0>
     9a8:	28 2f       	mov	r18, r24
     9aa:	21 70       	andi	r18, 0x01	; 1
     9ac:	8d 81       	ldd	r24, Y+5	; 0x05
     9ae:	9e 81       	ldd	r25, Y+6	; 0x06
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 83       	st	Z, r18
			break;
     9b4:	15 c0       	rjmp	.+42     	; 0x9e0 <DIO_u8GetPinValue+0x100>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
     9b6:	80 e3       	ldi	r24, 0x30	; 48
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	fc 01       	movw	r30, r24
     9bc:	80 81       	ld	r24, Z
     9be:	88 2f       	mov	r24, r24
     9c0:	90 e0       	ldi	r25, 0x00	; 0
     9c2:	2b 81       	ldd	r18, Y+3	; 0x03
     9c4:	22 2f       	mov	r18, r18
     9c6:	30 e0       	ldi	r19, 0x00	; 0
     9c8:	02 c0       	rjmp	.+4      	; 0x9ce <DIO_u8GetPinValue+0xee>
     9ca:	95 95       	asr	r25
     9cc:	87 95       	ror	r24
     9ce:	2a 95       	dec	r18
     9d0:	e2 f7       	brpl	.-8      	; 0x9ca <DIO_u8GetPinValue+0xea>
     9d2:	28 2f       	mov	r18, r24
     9d4:	21 70       	andi	r18, 0x01	; 1
     9d6:	8d 81       	ldd	r24, Y+5	; 0x05
     9d8:	9e 81       	ldd	r25, Y+6	; 0x06
     9da:	fc 01       	movw	r30, r24
     9dc:	20 83       	st	Z, r18
			break;
     9de:	00 00       	nop

			break;
		}
	}
	/*Function return*/
	return u8ErrorState;
     9e0:	89 81       	ldd	r24, Y+1	; 0x01
}
     9e2:	26 96       	adiw	r28, 0x06	; 6
     9e4:	0f b6       	in	r0, 0x3f	; 63
     9e6:	f8 94       	cli
     9e8:	de bf       	out	0x3e, r29	; 62
     9ea:	0f be       	out	0x3f, r0	; 63
     9ec:	cd bf       	out	0x3d, r28	; 61
     9ee:	df 91       	pop	r29
     9f0:	cf 91       	pop	r28
     9f2:	08 95       	ret

000009f4 <DIO_u8GetPortValue>:

/* */
/* */
u8 DIO_u8GetPortValue(u8 Copy_u8PortNB, u8 *Copy_u8PortValue)
{
     9f4:	cf 93       	push	r28
     9f6:	df 93       	push	r29
     9f8:	00 d0       	rcall	.+0      	; 0x9fa <DIO_u8GetPortValue+0x6>
     9fa:	00 d0       	rcall	.+0      	; 0x9fc <DIO_u8GetPortValue+0x8>
     9fc:	cd b7       	in	r28, 0x3d	; 61
     9fe:	de b7       	in	r29, 0x3e	; 62
     a00:	8a 83       	std	Y+2, r24	; 0x02
     a02:	7c 83       	std	Y+4, r23	; 0x04
     a04:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     a06:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
	if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     a08:	8a 81       	ldd	r24, Y+2	; 0x02
     a0a:	84 30       	cpi	r24, 0x04	; 4
     a0c:	18 f0       	brcs	.+6      	; 0xa14 <DIO_u8GetPortValue+0x20>
	{
		u8ErrorState = 1;
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	89 83       	std	Y+1, r24	; 0x01
     a12:	36 c0       	rjmp	.+108    	; 0xa80 <DIO_u8GetPortValue+0x8c>
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a14:	8a 81       	ldd	r24, Y+2	; 0x02
     a16:	88 2f       	mov	r24, r24
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	81 30       	cpi	r24, 0x01	; 1
     a1c:	91 05       	cpc	r25, r1
     a1e:	a9 f0       	breq	.+42     	; 0xa4a <DIO_u8GetPortValue+0x56>
     a20:	82 30       	cpi	r24, 0x02	; 2
     a22:	91 05       	cpc	r25, r1
     a24:	1c f4       	brge	.+6      	; 0xa2c <DIO_u8GetPortValue+0x38>
     a26:	89 2b       	or	r24, r25
     a28:	39 f0       	breq	.+14     	; 0xa38 <DIO_u8GetPortValue+0x44>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     a2a:	2a c0       	rjmp	.+84     	; 0xa80 <DIO_u8GetPortValue+0x8c>
		u8ErrorState = 1;
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a2c:	82 30       	cpi	r24, 0x02	; 2
     a2e:	91 05       	cpc	r25, r1
     a30:	a9 f0       	breq	.+42     	; 0xa5c <DIO_u8GetPortValue+0x68>
     a32:	03 97       	sbiw	r24, 0x03	; 3
     a34:	e1 f0       	breq	.+56     	; 0xa6e <DIO_u8GetPortValue+0x7a>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     a36:	24 c0       	rjmp	.+72     	; 0xa80 <DIO_u8GetPortValue+0x8c>
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
		{
			case GROUP_A :
				*Copy_u8PortValue = DIO_u8_PINA->ByteAccess;
     a38:	89 e3       	ldi	r24, 0x39	; 57
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	fc 01       	movw	r30, r24
     a3e:	20 81       	ld	r18, Z
     a40:	8b 81       	ldd	r24, Y+3	; 0x03
     a42:	9c 81       	ldd	r25, Y+4	; 0x04
     a44:	fc 01       	movw	r30, r24
     a46:	20 83       	st	Z, r18
				break;
     a48:	1b c0       	rjmp	.+54     	; 0xa80 <DIO_u8GetPortValue+0x8c>
			case GROUP_B :
				*Copy_u8PortValue = DIO_u8_PINB->ByteAccess;
     a4a:	86 e3       	ldi	r24, 0x36	; 54
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	fc 01       	movw	r30, r24
     a50:	20 81       	ld	r18, Z
     a52:	8b 81       	ldd	r24, Y+3	; 0x03
     a54:	9c 81       	ldd	r25, Y+4	; 0x04
     a56:	fc 01       	movw	r30, r24
     a58:	20 83       	st	Z, r18
				break;
     a5a:	12 c0       	rjmp	.+36     	; 0xa80 <DIO_u8GetPortValue+0x8c>
			case GROUP_C :
				*Copy_u8PortValue = DIO_u8_PINC->ByteAccess;
     a5c:	83 e3       	ldi	r24, 0x33	; 51
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	fc 01       	movw	r30, r24
     a62:	20 81       	ld	r18, Z
     a64:	8b 81       	ldd	r24, Y+3	; 0x03
     a66:	9c 81       	ldd	r25, Y+4	; 0x04
     a68:	fc 01       	movw	r30, r24
     a6a:	20 83       	st	Z, r18
				break;
     a6c:	09 c0       	rjmp	.+18     	; 0xa80 <DIO_u8GetPortValue+0x8c>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
     a6e:	80 e3       	ldi	r24, 0x30	; 48
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	fc 01       	movw	r30, r24
     a74:	20 81       	ld	r18, Z
     a76:	8b 81       	ldd	r24, Y+3	; 0x03
     a78:	9c 81       	ldd	r25, Y+4	; 0x04
     a7a:	fc 01       	movw	r30, r24
     a7c:	20 83       	st	Z, r18
				break;
     a7e:	00 00       	nop
				break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     a80:	89 81       	ldd	r24, Y+1	; 0x01
}
     a82:	0f 90       	pop	r0
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	0f 90       	pop	r0
     a8a:	df 91       	pop	r29
     a8c:	cf 91       	pop	r28
     a8e:	08 95       	ret

00000a90 <KBD_u8GetKeyPadState>:
#include "KBD_interface.h"
#include "KBD_private.h"


u8 KBD_u8GetKeyPadState(u8* Copy_Au8KeysState/*[KBD_u8_KEYS_NB]*/)
{
     a90:	cf 93       	push	r28
     a92:	df 93       	push	r29
     a94:	cd b7       	in	r28, 0x3d	; 61
     a96:	de b7       	in	r29, 0x3e	; 62
     a98:	27 97       	sbiw	r28, 0x07	; 7
     a9a:	0f b6       	in	r0, 0x3f	; 63
     a9c:	f8 94       	cli
     a9e:	de bf       	out	0x3e, r29	; 62
     aa0:	0f be       	out	0x3f, r0	; 63
     aa2:	cd bf       	out	0x3d, r28	; 61
     aa4:	9f 83       	std	Y+7, r25	; 0x07
     aa6:	8e 83       	std	Y+6, r24	; 0x06
	u8 LOCAL_u8ColIndex = 0;
     aa8:	19 82       	std	Y+1, r1	; 0x01
	u8 LOCAL_u8RowIndex = 0;
     aaa:	1a 82       	std	Y+2, r1	; 0x02
	
	u8 Local_u8CurrentPinValue=0;
     aac:	1d 82       	std	Y+5, r1	; 0x05
	u8 Local_u8KeyIndex=0;
     aae:	1c 82       	std	Y+4, r1	; 0x04
	u8 pressed = 0xff;
     ab0:	8f ef       	ldi	r24, 0xFF	; 255
     ab2:	8b 83       	std	Y+3, r24	; 0x03
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     ab4:	19 82       	std	Y+1, r1	; 0x01
     ab6:	52 c0       	rjmp	.+164    	; 0xb5c <KBD_u8GetKeyPadState+0xcc>
		{
			//activate current col
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
     ab8:	89 81       	ldd	r24, Y+1	; 0x01
     aba:	88 2f       	mov	r24, r24
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	88 5d       	subi	r24, 0xD8	; 216
     ac0:	98 4f       	sbci	r25, 0xF8	; 248
     ac2:	fc 01       	movw	r30, r24
     ac4:	80 81       	ld	r24, Z
     ac6:	60 e0       	ldi	r22, 0x00	; 0
     ac8:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     acc:	1a 82       	std	Y+2, r1	; 0x02
     ace:	36 c0       	rjmp	.+108    	; 0xb3c <KBD_u8GetKeyPadState+0xac>
			{
				DIO_u8GetPinValue(KBD_Au8RowsPins[LOCAL_u8RowIndex], &Local_u8CurrentPinValue);
     ad0:	8a 81       	ldd	r24, Y+2	; 0x02
     ad2:	88 2f       	mov	r24, r24
     ad4:	90 e0       	ldi	r25, 0x00	; 0
     ad6:	84 5d       	subi	r24, 0xD4	; 212
     ad8:	98 4f       	sbci	r25, 0xF8	; 248
     ada:	fc 01       	movw	r30, r24
     adc:	20 81       	ld	r18, Z
     ade:	ce 01       	movw	r24, r28
     ae0:	05 96       	adiw	r24, 0x05	; 5
     ae2:	bc 01       	movw	r22, r24
     ae4:	82 2f       	mov	r24, r18
     ae6:	0e 94 70 04 	call	0x8e0	; 0x8e0 <DIO_u8GetPinValue>
				
				Local_u8KeyIndex = LOCAL_u8ColIndex + (LOCAL_u8RowIndex*KBD_u8_COL);
     aea:	8a 81       	ldd	r24, Y+2	; 0x02
     aec:	98 2f       	mov	r25, r24
     aee:	99 0f       	add	r25, r25
     af0:	99 0f       	add	r25, r25
     af2:	89 81       	ldd	r24, Y+1	; 0x01
     af4:	89 0f       	add	r24, r25
     af6:	8c 83       	std	Y+4, r24	; 0x04
				
				if(Local_u8CurrentPinValue == DIO_u8_HIGH)
     af8:	8d 81       	ldd	r24, Y+5	; 0x05
     afa:	81 30       	cpi	r24, 0x01	; 1
     afc:	51 f4       	brne	.+20     	; 0xb12 <KBD_u8GetKeyPadState+0x82>
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Not Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
     afe:	8c 81       	ldd	r24, Y+4	; 0x04
     b00:	88 2f       	mov	r24, r24
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	2e 81       	ldd	r18, Y+6	; 0x06
     b06:	3f 81       	ldd	r19, Y+7	; 0x07
     b08:	82 0f       	add	r24, r18
     b0a:	93 1f       	adc	r25, r19
     b0c:	fc 01       	movw	r30, r24
     b0e:	10 82       	st	Z, r1
     b10:	12 c0       	rjmp	.+36     	; 0xb36 <KBD_u8GetKeyPadState+0xa6>
					#endif
				}else
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_PRESSED;
     b12:	8c 81       	ldd	r24, Y+4	; 0x04
     b14:	88 2f       	mov	r24, r24
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	2e 81       	ldd	r18, Y+6	; 0x06
     b1a:	3f 81       	ldd	r19, Y+7	; 0x07
     b1c:	82 0f       	add	r24, r18
     b1e:	93 1f       	adc	r25, r19
     b20:	21 e0       	ldi	r18, 0x01	; 1
     b22:	fc 01       	movw	r30, r24
     b24:	20 83       	st	Z, r18
						pressed = key_map[Local_u8KeyIndex];
     b26:	8c 81       	ldd	r24, Y+4	; 0x04
     b28:	88 2f       	mov	r24, r24
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	8f 59       	subi	r24, 0x9F	; 159
     b2e:	9f 4f       	sbci	r25, 0xFF	; 255
     b30:	fc 01       	movw	r30, r24
     b32:	80 81       	ld	r24, Z
     b34:	8b 83       	std	Y+3, r24	; 0x03
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     b36:	8a 81       	ldd	r24, Y+2	; 0x02
     b38:	8f 5f       	subi	r24, 0xFF	; 255
     b3a:	8a 83       	std	Y+2, r24	; 0x02
     b3c:	8a 81       	ldd	r24, Y+2	; 0x02
     b3e:	84 30       	cpi	r24, 0x04	; 4
     b40:	38 f2       	brcs	.-114    	; 0xad0 <KBD_u8GetKeyPadState+0x40>
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
					#endif
				}
			}
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
     b42:	89 81       	ldd	r24, Y+1	; 0x01
     b44:	88 2f       	mov	r24, r24
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	88 5d       	subi	r24, 0xD8	; 216
     b4a:	98 4f       	sbci	r25, 0xF8	; 248
     b4c:	fc 01       	movw	r30, r24
     b4e:	80 81       	ld	r24, Z
     b50:	61 e0       	ldi	r22, 0x01	; 1
     b52:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	u8 Local_u8CurrentPinValue=0;
	u8 Local_u8KeyIndex=0;
	u8 pressed = 0xff;
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     b56:	89 81       	ldd	r24, Y+1	; 0x01
     b58:	8f 5f       	subi	r24, 0xFF	; 255
     b5a:	89 83       	std	Y+1, r24	; 0x01
     b5c:	89 81       	ldd	r24, Y+1	; 0x01
     b5e:	84 30       	cpi	r24, 0x04	; 4
     b60:	08 f4       	brcc	.+2      	; 0xb64 <KBD_u8GetKeyPadState+0xd4>
     b62:	aa cf       	rjmp	.-172    	; 0xab8 <KBD_u8GetKeyPadState+0x28>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#else
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
			#endif
		}
		return pressed;
     b64:	8b 81       	ldd	r24, Y+3	; 0x03
			#endif
		}

	#endif

}
     b66:	27 96       	adiw	r28, 0x07	; 7
     b68:	0f b6       	in	r0, 0x3f	; 63
     b6a:	f8 94       	cli
     b6c:	de bf       	out	0x3e, r29	; 62
     b6e:	0f be       	out	0x3f, r0	; 63
     b70:	cd bf       	out	0x3d, r28	; 61
     b72:	df 91       	pop	r29
     b74:	cf 91       	pop	r28
     b76:	08 95       	ret

00000b78 <KBD_u8Initialize>:
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
     b7c:	cd b7       	in	r28, 0x3d	; 61
     b7e:	de b7       	in	r29, 0x3e	; 62
     b80:	29 97       	sbiw	r28, 0x09	; 9
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	de bf       	out	0x3e, r29	; 62
     b88:	0f be       	out	0x3f, r0	; 63
     b8a:	cd bf       	out	0x3d, r28	; 61
     b8c:	89 87       	std	Y+9, r24	; 0x09
		switch (group_nb)
     b8e:	89 85       	ldd	r24, Y+9	; 0x09
     b90:	88 2f       	mov	r24, r24
     b92:	90 e0       	ldi	r25, 0x00	; 0
     b94:	81 30       	cpi	r24, 0x01	; 1
     b96:	91 05       	cpc	r25, r1
     b98:	09 f4       	brne	.+2      	; 0xb9c <KBD_u8Initialize+0x24>
     b9a:	42 c0       	rjmp	.+132    	; 0xc20 <KBD_u8Initialize+0xa8>
     b9c:	82 30       	cpi	r24, 0x02	; 2
     b9e:	91 05       	cpc	r25, r1
     ba0:	1c f4       	brge	.+6      	; 0xba8 <KBD_u8Initialize+0x30>
     ba2:	89 2b       	or	r24, r25
     ba4:	49 f0       	breq	.+18     	; 0xbb8 <KBD_u8Initialize+0x40>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     ba6:	d8 c0       	rjmp	.+432    	; 0xd58 <KBD_u8Initialize+0x1e0>
	#endif

}
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
     ba8:	82 30       	cpi	r24, 0x02	; 2
     baa:	91 05       	cpc	r25, r1
     bac:	09 f4       	brne	.+2      	; 0xbb0 <KBD_u8Initialize+0x38>
     bae:	6c c0       	rjmp	.+216    	; 0xc88 <KBD_u8Initialize+0x110>
     bb0:	03 97       	sbiw	r24, 0x03	; 3
     bb2:	09 f4       	brne	.+2      	; 0xbb6 <KBD_u8Initialize+0x3e>
     bb4:	9d c0       	rjmp	.+314    	; 0xcf0 <KBD_u8Initialize+0x178>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     bb6:	d0 c0       	rjmp	.+416    	; 0xd58 <KBD_u8Initialize+0x1e0>
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
		{
		case 0:
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
     bb8:	6f e0       	ldi	r22, 0x0F	; 15
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(A4,1);
     bc0:	61 e0       	ldi	r22, 0x01	; 1
     bc2:	84 e0       	ldi	r24, 0x04	; 4
     bc4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A5,1);
     bc8:	61 e0       	ldi	r22, 0x01	; 1
     bca:	85 e0       	ldi	r24, 0x05	; 5
     bcc:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A6,1);
     bd0:	61 e0       	ldi	r22, 0x01	; 1
     bd2:	86 e0       	ldi	r24, 0x06	; 6
     bd4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A7,1);
     bd8:	61 e0       	ldi	r22, 0x01	; 1
     bda:	87 e0       	ldi	r24, 0x07	; 7
     bdc:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     be0:	1a 82       	std	Y+2, r1	; 0x02
     be2:	19 82       	std	Y+1, r1	; 0x01
     be4:	18 c0       	rjmp	.+48     	; 0xc16 <KBD_u8Initialize+0x9e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
     be6:	89 81       	ldd	r24, Y+1	; 0x01
     be8:	24 e0       	ldi	r18, 0x04	; 4
     bea:	28 0f       	add	r18, r24
     bec:	89 81       	ldd	r24, Y+1	; 0x01
     bee:	9a 81       	ldd	r25, Y+2	; 0x02
     bf0:	84 5d       	subi	r24, 0xD4	; 212
     bf2:	98 4f       	sbci	r25, 0xF8	; 248
     bf4:	fc 01       	movw	r30, r24
     bf6:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = A3 - i;
     bf8:	89 81       	ldd	r24, Y+1	; 0x01
     bfa:	93 e0       	ldi	r25, 0x03	; 3
     bfc:	29 2f       	mov	r18, r25
     bfe:	28 1b       	sub	r18, r24
     c00:	89 81       	ldd	r24, Y+1	; 0x01
     c02:	9a 81       	ldd	r25, Y+2	; 0x02
     c04:	88 5d       	subi	r24, 0xD8	; 216
     c06:	98 4f       	sbci	r25, 0xF8	; 248
     c08:	fc 01       	movw	r30, r24
     c0a:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
			DIO_u8SetPinValue(A4,1);
			DIO_u8SetPinValue(A5,1);
			DIO_u8SetPinValue(A6,1);
			DIO_u8SetPinValue(A7,1);
			for (int i=0;i<4;i++)
     c0c:	89 81       	ldd	r24, Y+1	; 0x01
     c0e:	9a 81       	ldd	r25, Y+2	; 0x02
     c10:	01 96       	adiw	r24, 0x01	; 1
     c12:	9a 83       	std	Y+2, r25	; 0x02
     c14:	89 83       	std	Y+1, r24	; 0x01
     c16:	89 81       	ldd	r24, Y+1	; 0x01
     c18:	9a 81       	ldd	r25, Y+2	; 0x02
     c1a:	04 97       	sbiw	r24, 0x04	; 4
     c1c:	24 f3       	brlt	.-56     	; 0xbe6 <KBD_u8Initialize+0x6e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
				KBD_Au8ColsPins[i] = A3 - i;
			}
			break;
     c1e:	9c c0       	rjmp	.+312    	; 0xd58 <KBD_u8Initialize+0x1e0>
		case 1:
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
     c20:	6f e0       	ldi	r22, 0x0F	; 15
     c22:	81 e0       	ldi	r24, 0x01	; 1
     c24:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(B4,1);
     c28:	61 e0       	ldi	r22, 0x01	; 1
     c2a:	8c e0       	ldi	r24, 0x0C	; 12
     c2c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B5,1);
     c30:	61 e0       	ldi	r22, 0x01	; 1
     c32:	8d e0       	ldi	r24, 0x0D	; 13
     c34:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B6,1);
     c38:	61 e0       	ldi	r22, 0x01	; 1
     c3a:	8e e0       	ldi	r24, 0x0E	; 14
     c3c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B7,1);
     c40:	61 e0       	ldi	r22, 0x01	; 1
     c42:	8f e0       	ldi	r24, 0x0F	; 15
     c44:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c48:	1c 82       	std	Y+4, r1	; 0x04
     c4a:	1b 82       	std	Y+3, r1	; 0x03
     c4c:	18 c0       	rjmp	.+48     	; 0xc7e <KBD_u8Initialize+0x106>
			{
				KBD_Au8RowsPins[i] = B4 + i;
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	2c e0       	ldi	r18, 0x0C	; 12
     c52:	28 0f       	add	r18, r24
     c54:	8b 81       	ldd	r24, Y+3	; 0x03
     c56:	9c 81       	ldd	r25, Y+4	; 0x04
     c58:	84 5d       	subi	r24, 0xD4	; 212
     c5a:	98 4f       	sbci	r25, 0xF8	; 248
     c5c:	fc 01       	movw	r30, r24
     c5e:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = B3 - i;
     c60:	8b 81       	ldd	r24, Y+3	; 0x03
     c62:	9b e0       	ldi	r25, 0x0B	; 11
     c64:	29 2f       	mov	r18, r25
     c66:	28 1b       	sub	r18, r24
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	88 5d       	subi	r24, 0xD8	; 216
     c6e:	98 4f       	sbci	r25, 0xF8	; 248
     c70:	fc 01       	movw	r30, r24
     c72:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
			DIO_u8SetPinValue(B4,1);
			DIO_u8SetPinValue(B5,1);
			DIO_u8SetPinValue(B6,1);
			DIO_u8SetPinValue(B7,1);
			for (int i=0;i<4;i++)
     c74:	8b 81       	ldd	r24, Y+3	; 0x03
     c76:	9c 81       	ldd	r25, Y+4	; 0x04
     c78:	01 96       	adiw	r24, 0x01	; 1
     c7a:	9c 83       	std	Y+4, r25	; 0x04
     c7c:	8b 83       	std	Y+3, r24	; 0x03
     c7e:	8b 81       	ldd	r24, Y+3	; 0x03
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	04 97       	sbiw	r24, 0x04	; 4
     c84:	24 f3       	brlt	.-56     	; 0xc4e <KBD_u8Initialize+0xd6>
			{
				KBD_Au8RowsPins[i] = B4 + i;
				KBD_Au8ColsPins[i] = B3 - i;
			}
			break;
     c86:	68 c0       	rjmp	.+208    	; 0xd58 <KBD_u8Initialize+0x1e0>
		case 2:
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
     c88:	6f e0       	ldi	r22, 0x0F	; 15
     c8a:	82 e0       	ldi	r24, 0x02	; 2
     c8c:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(C4,1);
     c90:	61 e0       	ldi	r22, 0x01	; 1
     c92:	84 e1       	ldi	r24, 0x14	; 20
     c94:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C5,1);
     c98:	61 e0       	ldi	r22, 0x01	; 1
     c9a:	85 e1       	ldi	r24, 0x15	; 21
     c9c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C6,1);
     ca0:	61 e0       	ldi	r22, 0x01	; 1
     ca2:	86 e1       	ldi	r24, 0x16	; 22
     ca4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C7,1);
     ca8:	61 e0       	ldi	r22, 0x01	; 1
     caa:	87 e1       	ldi	r24, 0x17	; 23
     cac:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     cb0:	1e 82       	std	Y+6, r1	; 0x06
     cb2:	1d 82       	std	Y+5, r1	; 0x05
     cb4:	18 c0       	rjmp	.+48     	; 0xce6 <KBD_u8Initialize+0x16e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
     cb6:	8d 81       	ldd	r24, Y+5	; 0x05
     cb8:	24 e1       	ldi	r18, 0x14	; 20
     cba:	28 0f       	add	r18, r24
     cbc:	8d 81       	ldd	r24, Y+5	; 0x05
     cbe:	9e 81       	ldd	r25, Y+6	; 0x06
     cc0:	84 5d       	subi	r24, 0xD4	; 212
     cc2:	98 4f       	sbci	r25, 0xF8	; 248
     cc4:	fc 01       	movw	r30, r24
     cc6:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = C3 - i;
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	93 e1       	ldi	r25, 0x13	; 19
     ccc:	29 2f       	mov	r18, r25
     cce:	28 1b       	sub	r18, r24
     cd0:	8d 81       	ldd	r24, Y+5	; 0x05
     cd2:	9e 81       	ldd	r25, Y+6	; 0x06
     cd4:	88 5d       	subi	r24, 0xD8	; 216
     cd6:	98 4f       	sbci	r25, 0xF8	; 248
     cd8:	fc 01       	movw	r30, r24
     cda:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
			DIO_u8SetPinValue(C4,1);
			DIO_u8SetPinValue(C5,1);
			DIO_u8SetPinValue(C6,1);
			DIO_u8SetPinValue(C7,1);
			for (int i=0;i<4;i++)
     cdc:	8d 81       	ldd	r24, Y+5	; 0x05
     cde:	9e 81       	ldd	r25, Y+6	; 0x06
     ce0:	01 96       	adiw	r24, 0x01	; 1
     ce2:	9e 83       	std	Y+6, r25	; 0x06
     ce4:	8d 83       	std	Y+5, r24	; 0x05
     ce6:	8d 81       	ldd	r24, Y+5	; 0x05
     ce8:	9e 81       	ldd	r25, Y+6	; 0x06
     cea:	04 97       	sbiw	r24, 0x04	; 4
     cec:	24 f3       	brlt	.-56     	; 0xcb6 <KBD_u8Initialize+0x13e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
				KBD_Au8ColsPins[i] = C3 - i;
			}
			break;
     cee:	34 c0       	rjmp	.+104    	; 0xd58 <KBD_u8Initialize+0x1e0>
		case 3:
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
     cf0:	6f e0       	ldi	r22, 0x0F	; 15
     cf2:	83 e0       	ldi	r24, 0x03	; 3
     cf4:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(D4,1);
     cf8:	61 e0       	ldi	r22, 0x01	; 1
     cfa:	8c e1       	ldi	r24, 0x1C	; 28
     cfc:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D5,1);
     d00:	61 e0       	ldi	r22, 0x01	; 1
     d02:	8d e1       	ldi	r24, 0x1D	; 29
     d04:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D6,1);
     d08:	61 e0       	ldi	r22, 0x01	; 1
     d0a:	8e e1       	ldi	r24, 0x1E	; 30
     d0c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D7,1);
     d10:	61 e0       	ldi	r22, 0x01	; 1
     d12:	8f e1       	ldi	r24, 0x1F	; 31
     d14:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     d18:	18 86       	std	Y+8, r1	; 0x08
     d1a:	1f 82       	std	Y+7, r1	; 0x07
     d1c:	18 c0       	rjmp	.+48     	; 0xd4e <KBD_u8Initialize+0x1d6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
     d1e:	8f 81       	ldd	r24, Y+7	; 0x07
     d20:	2c e1       	ldi	r18, 0x1C	; 28
     d22:	28 0f       	add	r18, r24
     d24:	8f 81       	ldd	r24, Y+7	; 0x07
     d26:	98 85       	ldd	r25, Y+8	; 0x08
     d28:	84 5d       	subi	r24, 0xD4	; 212
     d2a:	98 4f       	sbci	r25, 0xF8	; 248
     d2c:	fc 01       	movw	r30, r24
     d2e:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = D3 - i;
     d30:	8f 81       	ldd	r24, Y+7	; 0x07
     d32:	9b e1       	ldi	r25, 0x1B	; 27
     d34:	29 2f       	mov	r18, r25
     d36:	28 1b       	sub	r18, r24
     d38:	8f 81       	ldd	r24, Y+7	; 0x07
     d3a:	98 85       	ldd	r25, Y+8	; 0x08
     d3c:	88 5d       	subi	r24, 0xD8	; 216
     d3e:	98 4f       	sbci	r25, 0xF8	; 248
     d40:	fc 01       	movw	r30, r24
     d42:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
			DIO_u8SetPinValue(D4,1);
			DIO_u8SetPinValue(D5,1);
			DIO_u8SetPinValue(D6,1);
			DIO_u8SetPinValue(D7,1);
			for (int i=0;i<4;i++)
     d44:	8f 81       	ldd	r24, Y+7	; 0x07
     d46:	98 85       	ldd	r25, Y+8	; 0x08
     d48:	01 96       	adiw	r24, 0x01	; 1
     d4a:	98 87       	std	Y+8, r25	; 0x08
     d4c:	8f 83       	std	Y+7, r24	; 0x07
     d4e:	8f 81       	ldd	r24, Y+7	; 0x07
     d50:	98 85       	ldd	r25, Y+8	; 0x08
     d52:	04 97       	sbiw	r24, 0x04	; 4
     d54:	24 f3       	brlt	.-56     	; 0xd1e <KBD_u8Initialize+0x1a6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
     d56:	00 00       	nop
		}
	}
     d58:	00 00       	nop
     d5a:	29 96       	adiw	r28, 0x09	; 9
     d5c:	0f b6       	in	r0, 0x3f	; 63
     d5e:	f8 94       	cli
     d60:	de bf       	out	0x3e, r29	; 62
     d62:	0f be       	out	0x3f, r0	; 63
     d64:	cd bf       	out	0x3d, r28	; 61
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret

00000d6c <KBD_keys_map>:
u8 KBD_keys_map(u8* keys)
{
     d6c:	cf 93       	push	r28
     d6e:	df 93       	push	r29
     d70:	00 d0       	rcall	.+0      	; 0xd72 <KBD_keys_map+0x6>
     d72:	1f 92       	push	r1
     d74:	cd b7       	in	r28, 0x3d	; 61
     d76:	de b7       	in	r29, 0x3e	; 62
     d78:	9b 83       	std	Y+3, r25	; 0x03
     d7a:	8a 83       	std	Y+2, r24	; 0x02
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     d7c:	19 82       	std	Y+1, r1	; 0x01
     d7e:	16 c0       	rjmp	.+44     	; 0xdac <KBD_keys_map+0x40>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
     d80:	89 81       	ldd	r24, Y+1	; 0x01
     d82:	88 2f       	mov	r24, r24
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	2a 81       	ldd	r18, Y+2	; 0x02
     d88:	3b 81       	ldd	r19, Y+3	; 0x03
     d8a:	82 0f       	add	r24, r18
     d8c:	93 1f       	adc	r25, r19
     d8e:	fc 01       	movw	r30, r24
     d90:	80 81       	ld	r24, Z
     d92:	81 30       	cpi	r24, 0x01	; 1
     d94:	41 f4       	brne	.+16     	; 0xda6 <KBD_keys_map+0x3a>
     d96:	89 81       	ldd	r24, Y+1	; 0x01
     d98:	88 2f       	mov	r24, r24
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	8f 59       	subi	r24, 0x9F	; 159
     d9e:	9f 4f       	sbci	r25, 0xFF	; 255
     da0:	fc 01       	movw	r30, r24
     da2:	80 81       	ld	r24, Z
     da4:	07 c0       	rjmp	.+14     	; 0xdb4 <KBD_keys_map+0x48>
		}
	}
u8 KBD_keys_map(u8* keys)
{
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     da6:	89 81       	ldd	r24, Y+1	; 0x01
     da8:	8f 5f       	subi	r24, 0xFF	; 255
     daa:	89 83       	std	Y+1, r24	; 0x01
     dac:	89 81       	ldd	r24, Y+1	; 0x01
     dae:	80 31       	cpi	r24, 0x10	; 16
     db0:	38 f3       	brcs	.-50     	; 0xd80 <KBD_keys_map+0x14>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
    }
    return 0xff;
     db2:	8f ef       	ldi	r24, 0xFF	; 255
}
     db4:	0f 90       	pop	r0
     db6:	0f 90       	pop	r0
     db8:	0f 90       	pop	r0
     dba:	df 91       	pop	r29
     dbc:	cf 91       	pop	r28
     dbe:	08 95       	ret

00000dc0 <LCD_Void_Write>:
#define F_CPU 8000000
#include "avr/delay.h"

static void LCD_Void_Write(u8 copy_u8_value) // the user wont use this func because only other functions will use it so the prototype will be in private.h
//and to make this func visible only in this file not on the whole project we will put static in front of it
{
     dc0:	cf 93       	push	r28
     dc2:	df 93       	push	r29
     dc4:	cd b7       	in	r28, 0x3d	; 61
     dc6:	de b7       	in	r29, 0x3e	; 62
     dc8:	2f 97       	sbiw	r28, 0x0f	; 15
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	de bf       	out	0x3e, r29	; 62
     dd0:	0f be       	out	0x3f, r0	; 63
     dd2:	cd bf       	out	0x3d, r28	; 61
     dd4:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_u8SetPinValue(LCD_u8_RW_Pin,DIO_u8_LOW);
     dd6:	60 e0       	ldi	r22, 0x00	; 0
     dd8:	81 e1       	ldi	r24, 0x11	; 17
     dda:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D0_Pin,Get_Bit(copy_u8_value,0));
     dde:	8f 85       	ldd	r24, Y+15	; 0x0f
     de0:	81 70       	andi	r24, 0x01	; 1
     de2:	68 2f       	mov	r22, r24
     de4:	87 e0       	ldi	r24, 0x07	; 7
     de6:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D1_Pin,Get_Bit(copy_u8_value,1));
     dea:	8f 85       	ldd	r24, Y+15	; 0x0f
     dec:	86 95       	lsr	r24
     dee:	81 70       	andi	r24, 0x01	; 1
     df0:	68 2f       	mov	r22, r24
     df2:	86 e0       	ldi	r24, 0x06	; 6
     df4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D2_Pin,Get_Bit(copy_u8_value,2));
     df8:	8f 85       	ldd	r24, Y+15	; 0x0f
     dfa:	86 95       	lsr	r24
     dfc:	86 95       	lsr	r24
     dfe:	81 70       	andi	r24, 0x01	; 1
     e00:	68 2f       	mov	r22, r24
     e02:	85 e0       	ldi	r24, 0x05	; 5
     e04:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D3_Pin,Get_Bit(copy_u8_value,3));
     e08:	8f 85       	ldd	r24, Y+15	; 0x0f
     e0a:	86 95       	lsr	r24
     e0c:	86 95       	lsr	r24
     e0e:	86 95       	lsr	r24
     e10:	81 70       	andi	r24, 0x01	; 1
     e12:	68 2f       	mov	r22, r24
     e14:	84 e0       	ldi	r24, 0x04	; 4
     e16:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D4_Pin,Get_Bit(copy_u8_value,4));
     e1a:	8f 85       	ldd	r24, Y+15	; 0x0f
     e1c:	82 95       	swap	r24
     e1e:	8f 70       	andi	r24, 0x0F	; 15
     e20:	81 70       	andi	r24, 0x01	; 1
     e22:	68 2f       	mov	r22, r24
     e24:	83 e0       	ldi	r24, 0x03	; 3
     e26:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D5_Pin,Get_Bit(copy_u8_value,5));
     e2a:	8f 85       	ldd	r24, Y+15	; 0x0f
     e2c:	82 95       	swap	r24
     e2e:	86 95       	lsr	r24
     e30:	87 70       	andi	r24, 0x07	; 7
     e32:	81 70       	andi	r24, 0x01	; 1
     e34:	68 2f       	mov	r22, r24
     e36:	82 e0       	ldi	r24, 0x02	; 2
     e38:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D6_Pin,Get_Bit(copy_u8_value,6));
     e3c:	8f 85       	ldd	r24, Y+15	; 0x0f
     e3e:	82 95       	swap	r24
     e40:	86 95       	lsr	r24
     e42:	86 95       	lsr	r24
     e44:	83 70       	andi	r24, 0x03	; 3
     e46:	81 70       	andi	r24, 0x01	; 1
     e48:	68 2f       	mov	r22, r24
     e4a:	81 e0       	ldi	r24, 0x01	; 1
     e4c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D7_Pin,Get_Bit(copy_u8_value,7));
     e50:	8f 85       	ldd	r24, Y+15	; 0x0f
     e52:	88 1f       	adc	r24, r24
     e54:	88 27       	eor	r24, r24
     e56:	88 1f       	adc	r24, r24
     e58:	68 2f       	mov	r22, r24
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_HIGH);
     e60:	61 e0       	ldi	r22, 0x01	; 1
     e62:	82 e1       	ldi	r24, 0x12	; 18
     e64:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
     e68:	80 e0       	ldi	r24, 0x00	; 0
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	a0 e8       	ldi	r26, 0x80	; 128
     e6e:	bf e3       	ldi	r27, 0x3F	; 63
     e70:	89 83       	std	Y+1, r24	; 0x01
     e72:	9a 83       	std	Y+2, r25	; 0x02
     e74:	ab 83       	std	Y+3, r26	; 0x03
     e76:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     e78:	20 e0       	ldi	r18, 0x00	; 0
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	4a ef       	ldi	r20, 0xFA	; 250
     e7e:	54 e4       	ldi	r21, 0x44	; 68
     e80:	69 81       	ldd	r22, Y+1	; 0x01
     e82:	7a 81       	ldd	r23, Y+2	; 0x02
     e84:	8b 81       	ldd	r24, Y+3	; 0x03
     e86:	9c 81       	ldd	r25, Y+4	; 0x04
     e88:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
     e8c:	dc 01       	movw	r26, r24
     e8e:	cb 01       	movw	r24, r22
     e90:	8d 83       	std	Y+5, r24	; 0x05
     e92:	9e 83       	std	Y+6, r25	; 0x06
     e94:	af 83       	std	Y+7, r26	; 0x07
     e96:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     e98:	20 e0       	ldi	r18, 0x00	; 0
     e9a:	30 e0       	ldi	r19, 0x00	; 0
     e9c:	40 e8       	ldi	r20, 0x80	; 128
     e9e:	5f e3       	ldi	r21, 0x3F	; 63
     ea0:	6d 81       	ldd	r22, Y+5	; 0x05
     ea2:	7e 81       	ldd	r23, Y+6	; 0x06
     ea4:	8f 81       	ldd	r24, Y+7	; 0x07
     ea6:	98 85       	ldd	r25, Y+8	; 0x08
     ea8:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
     eac:	88 23       	and	r24, r24
     eae:	2c f4       	brge	.+10     	; 0xeba <LCD_Void_Write+0xfa>
		__ticks = 1;
     eb0:	81 e0       	ldi	r24, 0x01	; 1
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	9a 87       	std	Y+10, r25	; 0x0a
     eb6:	89 87       	std	Y+9, r24	; 0x09
     eb8:	3f c0       	rjmp	.+126    	; 0xf38 <LCD_Void_Write+0x178>
	else if (__tmp > 65535)
     eba:	20 e0       	ldi	r18, 0x00	; 0
     ebc:	3f ef       	ldi	r19, 0xFF	; 255
     ebe:	4f e7       	ldi	r20, 0x7F	; 127
     ec0:	57 e4       	ldi	r21, 0x47	; 71
     ec2:	6d 81       	ldd	r22, Y+5	; 0x05
     ec4:	7e 81       	ldd	r23, Y+6	; 0x06
     ec6:	8f 81       	ldd	r24, Y+7	; 0x07
     ec8:	98 85       	ldd	r25, Y+8	; 0x08
     eca:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
     ece:	18 16       	cp	r1, r24
     ed0:	4c f5       	brge	.+82     	; 0xf24 <LCD_Void_Write+0x164>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ed2:	20 e0       	ldi	r18, 0x00	; 0
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	40 e2       	ldi	r20, 0x20	; 32
     ed8:	51 e4       	ldi	r21, 0x41	; 65
     eda:	69 81       	ldd	r22, Y+1	; 0x01
     edc:	7a 81       	ldd	r23, Y+2	; 0x02
     ede:	8b 81       	ldd	r24, Y+3	; 0x03
     ee0:	9c 81       	ldd	r25, Y+4	; 0x04
     ee2:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
     ee6:	dc 01       	movw	r26, r24
     ee8:	cb 01       	movw	r24, r22
     eea:	bc 01       	movw	r22, r24
     eec:	cd 01       	movw	r24, r26
     eee:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
     ef2:	dc 01       	movw	r26, r24
     ef4:	cb 01       	movw	r24, r22
     ef6:	9a 87       	std	Y+10, r25	; 0x0a
     ef8:	89 87       	std	Y+9, r24	; 0x09
     efa:	0f c0       	rjmp	.+30     	; 0xf1a <LCD_Void_Write+0x15a>
     efc:	88 ec       	ldi	r24, 0xC8	; 200
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	9c 87       	std	Y+12, r25	; 0x0c
     f02:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     f04:	8b 85       	ldd	r24, Y+11	; 0x0b
     f06:	9c 85       	ldd	r25, Y+12	; 0x0c
     f08:	01 97       	sbiw	r24, 0x01	; 1
     f0a:	f1 f7       	brne	.-4      	; 0xf08 <LCD_Void_Write+0x148>
     f0c:	9c 87       	std	Y+12, r25	; 0x0c
     f0e:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f10:	89 85       	ldd	r24, Y+9	; 0x09
     f12:	9a 85       	ldd	r25, Y+10	; 0x0a
     f14:	01 97       	sbiw	r24, 0x01	; 1
     f16:	9a 87       	std	Y+10, r25	; 0x0a
     f18:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f1a:	89 85       	ldd	r24, Y+9	; 0x09
     f1c:	9a 85       	ldd	r25, Y+10	; 0x0a
     f1e:	89 2b       	or	r24, r25
     f20:	69 f7       	brne	.-38     	; 0xefc <LCD_Void_Write+0x13c>
     f22:	14 c0       	rjmp	.+40     	; 0xf4c <LCD_Void_Write+0x18c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f24:	6d 81       	ldd	r22, Y+5	; 0x05
     f26:	7e 81       	ldd	r23, Y+6	; 0x06
     f28:	8f 81       	ldd	r24, Y+7	; 0x07
     f2a:	98 85       	ldd	r25, Y+8	; 0x08
     f2c:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
     f30:	dc 01       	movw	r26, r24
     f32:	cb 01       	movw	r24, r22
     f34:	9a 87       	std	Y+10, r25	; 0x0a
     f36:	89 87       	std	Y+9, r24	; 0x09
     f38:	89 85       	ldd	r24, Y+9	; 0x09
     f3a:	9a 85       	ldd	r25, Y+10	; 0x0a
     f3c:	9e 87       	std	Y+14, r25	; 0x0e
     f3e:	8d 87       	std	Y+13, r24	; 0x0d
     f40:	8d 85       	ldd	r24, Y+13	; 0x0d
     f42:	9e 85       	ldd	r25, Y+14	; 0x0e
     f44:	01 97       	sbiw	r24, 0x01	; 1
     f46:	f1 f7       	brne	.-4      	; 0xf44 <LCD_Void_Write+0x184>
     f48:	9e 87       	std	Y+14, r25	; 0x0e
     f4a:	8d 87       	std	Y+13, r24	; 0x0d
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_LOW);
     f4c:	60 e0       	ldi	r22, 0x00	; 0
     f4e:	82 e1       	ldi	r24, 0x12	; 18
     f50:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
}
     f54:	00 00       	nop
     f56:	2f 96       	adiw	r28, 0x0f	; 15
     f58:	0f b6       	in	r0, 0x3f	; 63
     f5a:	f8 94       	cli
     f5c:	de bf       	out	0x3e, r29	; 62
     f5e:	0f be       	out	0x3f, r0	; 63
     f60:	cd bf       	out	0x3d, r28	; 61
     f62:	df 91       	pop	r29
     f64:	cf 91       	pop	r28
     f66:	08 95       	ret

00000f68 <LCD_Void_Write_Cmd>:

void LCD_Void_Write_Cmd(u8 copy_u8_cmd)
{
     f68:	cf 93       	push	r28
     f6a:	df 93       	push	r29
     f6c:	1f 92       	push	r1
     f6e:	cd b7       	in	r28, 0x3d	; 61
     f70:	de b7       	in	r29, 0x3e	; 62
     f72:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue (LCD_u8_RS_Pin,DIO_u8_LOW);
     f74:	60 e0       	ldi	r22, 0x00	; 0
     f76:	80 e1       	ldi	r24, 0x10	; 16
     f78:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_cmd);
     f7c:	89 81       	ldd	r24, Y+1	; 0x01
     f7e:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <LCD_Void_Write>
}
     f82:	00 00       	nop
     f84:	0f 90       	pop	r0
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	08 95       	ret

00000f8c <LCD_Void_Write_Data>:

void LCD_Void_Write_Data(u8 copy_u8_data)
{
     f8c:	cf 93       	push	r28
     f8e:	df 93       	push	r29
     f90:	1f 92       	push	r1
     f92:	cd b7       	in	r28, 0x3d	; 61
     f94:	de b7       	in	r29, 0x3e	; 62
     f96:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue(LCD_u8_RS_Pin,DIO_u8_HIGH);
     f98:	61 e0       	ldi	r22, 0x01	; 1
     f9a:	80 e1       	ldi	r24, 0x10	; 16
     f9c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_data);
     fa0:	89 81       	ldd	r24, Y+1	; 0x01
     fa2:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <LCD_Void_Write>
}
     fa6:	00 00       	nop
     fa8:	0f 90       	pop	r0
     faa:	df 91       	pop	r29
     fac:	cf 91       	pop	r28
     fae:	08 95       	ret

00000fb0 <LCD_initialize>:


void LCD_initialize(void)
{
     fb0:	0f 93       	push	r16
     fb2:	1f 93       	push	r17
     fb4:	cf 93       	push	r28
     fb6:	df 93       	push	r29
     fb8:	cd b7       	in	r28, 0x3d	; 61
     fba:	de b7       	in	r29, 0x3e	; 62
     fbc:	ca 56       	subi	r28, 0x6A	; 106
     fbe:	d1 09       	sbc	r29, r1
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	f8 94       	cli
     fc4:	de bf       	out	0x3e, r29	; 62
     fc6:	0f be       	out	0x3f, r0	; 63
     fc8:	cd bf       	out	0x3d, r28	; 61
	DIO_u8SetPinDirection(LCD_u8_RS_Pin,1);
     fca:	61 e0       	ldi	r22, 0x01	; 1
     fcc:	80 e1       	ldi	r24, 0x10	; 16
     fce:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_RW_Pin,1);
     fd2:	61 e0       	ldi	r22, 0x01	; 1
     fd4:	81 e1       	ldi	r24, 0x11	; 17
     fd6:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_E_Pin,1);
     fda:	61 e0       	ldi	r22, 0x01	; 1
     fdc:	82 e1       	ldi	r24, 0x12	; 18
     fde:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D0_Pin,1);
     fe2:	61 e0       	ldi	r22, 0x01	; 1
     fe4:	87 e0       	ldi	r24, 0x07	; 7
     fe6:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D1_Pin,1);
     fea:	61 e0       	ldi	r22, 0x01	; 1
     fec:	86 e0       	ldi	r24, 0x06	; 6
     fee:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D2_Pin,1);
     ff2:	61 e0       	ldi	r22, 0x01	; 1
     ff4:	85 e0       	ldi	r24, 0x05	; 5
     ff6:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D3_Pin,1);
     ffa:	61 e0       	ldi	r22, 0x01	; 1
     ffc:	84 e0       	ldi	r24, 0x04	; 4
     ffe:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D4_Pin,1);
    1002:	61 e0       	ldi	r22, 0x01	; 1
    1004:	83 e0       	ldi	r24, 0x03	; 3
    1006:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D5_Pin,1);
    100a:	61 e0       	ldi	r22, 0x01	; 1
    100c:	82 e0       	ldi	r24, 0x02	; 2
    100e:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D6_Pin,1);
    1012:	61 e0       	ldi	r22, 0x01	; 1
    1014:	81 e0       	ldi	r24, 0x01	; 1
    1016:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D7_Pin,1);
    101a:	61 e0       	ldi	r22, 0x01	; 1
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	0e 94 04 02 	call	0x408	; 0x408 <DIO_u8SetPinDirection>
    1022:	80 e0       	ldi	r24, 0x00	; 0
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	a8 e4       	ldi	r26, 0x48	; 72
    1028:	b2 e4       	ldi	r27, 0x42	; 66
    102a:	89 83       	std	Y+1, r24	; 0x01
    102c:	9a 83       	std	Y+2, r25	; 0x02
    102e:	ab 83       	std	Y+3, r26	; 0x03
    1030:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1032:	8e 01       	movw	r16, r28
    1034:	0f 59       	subi	r16, 0x9F	; 159
    1036:	1f 4f       	sbci	r17, 0xFF	; 255
    1038:	20 e0       	ldi	r18, 0x00	; 0
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	4a ef       	ldi	r20, 0xFA	; 250
    103e:	54 e4       	ldi	r21, 0x44	; 68
    1040:	69 81       	ldd	r22, Y+1	; 0x01
    1042:	7a 81       	ldd	r23, Y+2	; 0x02
    1044:	8b 81       	ldd	r24, Y+3	; 0x03
    1046:	9c 81       	ldd	r25, Y+4	; 0x04
    1048:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    104c:	dc 01       	movw	r26, r24
    104e:	cb 01       	movw	r24, r22
    1050:	f8 01       	movw	r30, r16
    1052:	80 83       	st	Z, r24
    1054:	91 83       	std	Z+1, r25	; 0x01
    1056:	a2 83       	std	Z+2, r26	; 0x02
    1058:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    105a:	ce 01       	movw	r24, r28
    105c:	8f 59       	subi	r24, 0x9F	; 159
    105e:	9f 4f       	sbci	r25, 0xFF	; 255
    1060:	20 e0       	ldi	r18, 0x00	; 0
    1062:	30 e0       	ldi	r19, 0x00	; 0
    1064:	40 e8       	ldi	r20, 0x80	; 128
    1066:	5f e3       	ldi	r21, 0x3F	; 63
    1068:	fc 01       	movw	r30, r24
    106a:	60 81       	ld	r22, Z
    106c:	71 81       	ldd	r23, Z+1	; 0x01
    106e:	82 81       	ldd	r24, Z+2	; 0x02
    1070:	93 81       	ldd	r25, Z+3	; 0x03
    1072:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    1076:	88 23       	and	r24, r24
    1078:	4c f4       	brge	.+18     	; 0x108c <LCD_initialize+0xdc>
		__ticks = 1;
    107a:	ce 01       	movw	r24, r28
    107c:	8b 59       	subi	r24, 0x9B	; 155
    107e:	9f 4f       	sbci	r25, 0xFF	; 255
    1080:	21 e0       	ldi	r18, 0x01	; 1
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	fc 01       	movw	r30, r24
    1086:	31 83       	std	Z+1, r19	; 0x01
    1088:	20 83       	st	Z, r18
    108a:	69 c0       	rjmp	.+210    	; 0x115e <LCD_initialize+0x1ae>
	else if (__tmp > 65535)
    108c:	ce 01       	movw	r24, r28
    108e:	8f 59       	subi	r24, 0x9F	; 159
    1090:	9f 4f       	sbci	r25, 0xFF	; 255
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	3f ef       	ldi	r19, 0xFF	; 255
    1096:	4f e7       	ldi	r20, 0x7F	; 127
    1098:	57 e4       	ldi	r21, 0x47	; 71
    109a:	fc 01       	movw	r30, r24
    109c:	60 81       	ld	r22, Z
    109e:	71 81       	ldd	r23, Z+1	; 0x01
    10a0:	82 81       	ldd	r24, Z+2	; 0x02
    10a2:	93 81       	ldd	r25, Z+3	; 0x03
    10a4:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    10a8:	18 16       	cp	r1, r24
    10aa:	0c f0       	brlt	.+2      	; 0x10ae <LCD_initialize+0xfe>
    10ac:	46 c0       	rjmp	.+140    	; 0x113a <LCD_initialize+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10ae:	20 e0       	ldi	r18, 0x00	; 0
    10b0:	30 e0       	ldi	r19, 0x00	; 0
    10b2:	40 e2       	ldi	r20, 0x20	; 32
    10b4:	51 e4       	ldi	r21, 0x41	; 65
    10b6:	69 81       	ldd	r22, Y+1	; 0x01
    10b8:	7a 81       	ldd	r23, Y+2	; 0x02
    10ba:	8b 81       	ldd	r24, Y+3	; 0x03
    10bc:	9c 81       	ldd	r25, Y+4	; 0x04
    10be:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    10c2:	dc 01       	movw	r26, r24
    10c4:	cb 01       	movw	r24, r22
    10c6:	8e 01       	movw	r16, r28
    10c8:	0b 59       	subi	r16, 0x9B	; 155
    10ca:	1f 4f       	sbci	r17, 0xFF	; 255
    10cc:	bc 01       	movw	r22, r24
    10ce:	cd 01       	movw	r24, r26
    10d0:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    10d4:	dc 01       	movw	r26, r24
    10d6:	cb 01       	movw	r24, r22
    10d8:	f8 01       	movw	r30, r16
    10da:	91 83       	std	Z+1, r25	; 0x01
    10dc:	80 83       	st	Z, r24
    10de:	24 c0       	rjmp	.+72     	; 0x1128 <LCD_initialize+0x178>
    10e0:	ce 01       	movw	r24, r28
    10e2:	89 59       	subi	r24, 0x99	; 153
    10e4:	9f 4f       	sbci	r25, 0xFF	; 255
    10e6:	28 ec       	ldi	r18, 0xC8	; 200
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	fc 01       	movw	r30, r24
    10ec:	31 83       	std	Z+1, r19	; 0x01
    10ee:	20 83       	st	Z, r18
    10f0:	ce 01       	movw	r24, r28
    10f2:	89 59       	subi	r24, 0x99	; 153
    10f4:	9f 4f       	sbci	r25, 0xFF	; 255
    10f6:	fc 01       	movw	r30, r24
    10f8:	80 81       	ld	r24, Z
    10fa:	91 81       	ldd	r25, Z+1	; 0x01
    10fc:	01 97       	sbiw	r24, 0x01	; 1
    10fe:	f1 f7       	brne	.-4      	; 0x10fc <LCD_initialize+0x14c>
    1100:	9e 01       	movw	r18, r28
    1102:	29 59       	subi	r18, 0x99	; 153
    1104:	3f 4f       	sbci	r19, 0xFF	; 255
    1106:	f9 01       	movw	r30, r18
    1108:	91 83       	std	Z+1, r25	; 0x01
    110a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    110c:	ce 01       	movw	r24, r28
    110e:	8b 59       	subi	r24, 0x9B	; 155
    1110:	9f 4f       	sbci	r25, 0xFF	; 255
    1112:	9e 01       	movw	r18, r28
    1114:	2b 59       	subi	r18, 0x9B	; 155
    1116:	3f 4f       	sbci	r19, 0xFF	; 255
    1118:	f9 01       	movw	r30, r18
    111a:	20 81       	ld	r18, Z
    111c:	31 81       	ldd	r19, Z+1	; 0x01
    111e:	21 50       	subi	r18, 0x01	; 1
    1120:	31 09       	sbc	r19, r1
    1122:	fc 01       	movw	r30, r24
    1124:	31 83       	std	Z+1, r19	; 0x01
    1126:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1128:	ce 01       	movw	r24, r28
    112a:	8b 59       	subi	r24, 0x9B	; 155
    112c:	9f 4f       	sbci	r25, 0xFF	; 255
    112e:	fc 01       	movw	r30, r24
    1130:	80 81       	ld	r24, Z
    1132:	91 81       	ldd	r25, Z+1	; 0x01
    1134:	89 2b       	or	r24, r25
    1136:	a1 f6       	brne	.-88     	; 0x10e0 <LCD_initialize+0x130>
    1138:	2c c0       	rjmp	.+88     	; 0x1192 <LCD_initialize+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    113a:	8e 01       	movw	r16, r28
    113c:	0b 59       	subi	r16, 0x9B	; 155
    113e:	1f 4f       	sbci	r17, 0xFF	; 255
    1140:	ce 01       	movw	r24, r28
    1142:	8f 59       	subi	r24, 0x9F	; 159
    1144:	9f 4f       	sbci	r25, 0xFF	; 255
    1146:	fc 01       	movw	r30, r24
    1148:	60 81       	ld	r22, Z
    114a:	71 81       	ldd	r23, Z+1	; 0x01
    114c:	82 81       	ldd	r24, Z+2	; 0x02
    114e:	93 81       	ldd	r25, Z+3	; 0x03
    1150:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1154:	dc 01       	movw	r26, r24
    1156:	cb 01       	movw	r24, r22
    1158:	f8 01       	movw	r30, r16
    115a:	91 83       	std	Z+1, r25	; 0x01
    115c:	80 83       	st	Z, r24
    115e:	ce 01       	movw	r24, r28
    1160:	87 59       	subi	r24, 0x97	; 151
    1162:	9f 4f       	sbci	r25, 0xFF	; 255
    1164:	9e 01       	movw	r18, r28
    1166:	2b 59       	subi	r18, 0x9B	; 155
    1168:	3f 4f       	sbci	r19, 0xFF	; 255
    116a:	f9 01       	movw	r30, r18
    116c:	20 81       	ld	r18, Z
    116e:	31 81       	ldd	r19, Z+1	; 0x01
    1170:	fc 01       	movw	r30, r24
    1172:	31 83       	std	Z+1, r19	; 0x01
    1174:	20 83       	st	Z, r18
    1176:	ce 01       	movw	r24, r28
    1178:	87 59       	subi	r24, 0x97	; 151
    117a:	9f 4f       	sbci	r25, 0xFF	; 255
    117c:	fc 01       	movw	r30, r24
    117e:	80 81       	ld	r24, Z
    1180:	91 81       	ldd	r25, Z+1	; 0x01
    1182:	01 97       	sbiw	r24, 0x01	; 1
    1184:	f1 f7       	brne	.-4      	; 0x1182 <LCD_initialize+0x1d2>
    1186:	9e 01       	movw	r18, r28
    1188:	27 59       	subi	r18, 0x97	; 151
    118a:	3f 4f       	sbci	r19, 0xFF	; 255
    118c:	f9 01       	movw	r30, r18
    118e:	91 83       	std	Z+1, r25	; 0x01
    1190:	80 83       	st	Z, r24
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	90 e0       	ldi	r25, 0x00	; 0
    1196:	a0 e2       	ldi	r26, 0x20	; 32
    1198:	b2 e4       	ldi	r27, 0x42	; 66
    119a:	8d 83       	std	Y+5, r24	; 0x05
    119c:	9e 83       	std	Y+6, r25	; 0x06
    119e:	af 83       	std	Y+7, r26	; 0x07
    11a0:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    11a2:	8e 01       	movw	r16, r28
    11a4:	09 5a       	subi	r16, 0xA9	; 169
    11a6:	1f 4f       	sbci	r17, 0xFF	; 255
    11a8:	20 e0       	ldi	r18, 0x00	; 0
    11aa:	30 e0       	ldi	r19, 0x00	; 0
    11ac:	4a ef       	ldi	r20, 0xFA	; 250
    11ae:	54 e4       	ldi	r21, 0x44	; 68
    11b0:	6d 81       	ldd	r22, Y+5	; 0x05
    11b2:	7e 81       	ldd	r23, Y+6	; 0x06
    11b4:	8f 81       	ldd	r24, Y+7	; 0x07
    11b6:	98 85       	ldd	r25, Y+8	; 0x08
    11b8:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    11bc:	dc 01       	movw	r26, r24
    11be:	cb 01       	movw	r24, r22
    11c0:	f8 01       	movw	r30, r16
    11c2:	80 83       	st	Z, r24
    11c4:	91 83       	std	Z+1, r25	; 0x01
    11c6:	a2 83       	std	Z+2, r26	; 0x02
    11c8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    11ca:	ce 01       	movw	r24, r28
    11cc:	89 5a       	subi	r24, 0xA9	; 169
    11ce:	9f 4f       	sbci	r25, 0xFF	; 255
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	30 e0       	ldi	r19, 0x00	; 0
    11d4:	40 e8       	ldi	r20, 0x80	; 128
    11d6:	5f e3       	ldi	r21, 0x3F	; 63
    11d8:	fc 01       	movw	r30, r24
    11da:	60 81       	ld	r22, Z
    11dc:	71 81       	ldd	r23, Z+1	; 0x01
    11de:	82 81       	ldd	r24, Z+2	; 0x02
    11e0:	93 81       	ldd	r25, Z+3	; 0x03
    11e2:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    11e6:	88 23       	and	r24, r24
    11e8:	4c f4       	brge	.+18     	; 0x11fc <LCD_initialize+0x24c>
		__ticks = 1;
    11ea:	ce 01       	movw	r24, r28
    11ec:	85 5a       	subi	r24, 0xA5	; 165
    11ee:	9f 4f       	sbci	r25, 0xFF	; 255
    11f0:	21 e0       	ldi	r18, 0x01	; 1
    11f2:	30 e0       	ldi	r19, 0x00	; 0
    11f4:	fc 01       	movw	r30, r24
    11f6:	31 83       	std	Z+1, r19	; 0x01
    11f8:	20 83       	st	Z, r18
    11fa:	69 c0       	rjmp	.+210    	; 0x12ce <LCD_initialize+0x31e>
	else if (__tmp > 65535)
    11fc:	ce 01       	movw	r24, r28
    11fe:	89 5a       	subi	r24, 0xA9	; 169
    1200:	9f 4f       	sbci	r25, 0xFF	; 255
    1202:	20 e0       	ldi	r18, 0x00	; 0
    1204:	3f ef       	ldi	r19, 0xFF	; 255
    1206:	4f e7       	ldi	r20, 0x7F	; 127
    1208:	57 e4       	ldi	r21, 0x47	; 71
    120a:	fc 01       	movw	r30, r24
    120c:	60 81       	ld	r22, Z
    120e:	71 81       	ldd	r23, Z+1	; 0x01
    1210:	82 81       	ldd	r24, Z+2	; 0x02
    1212:	93 81       	ldd	r25, Z+3	; 0x03
    1214:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    1218:	18 16       	cp	r1, r24
    121a:	0c f0       	brlt	.+2      	; 0x121e <LCD_initialize+0x26e>
    121c:	46 c0       	rjmp	.+140    	; 0x12aa <LCD_initialize+0x2fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    121e:	20 e0       	ldi	r18, 0x00	; 0
    1220:	30 e0       	ldi	r19, 0x00	; 0
    1222:	40 e2       	ldi	r20, 0x20	; 32
    1224:	51 e4       	ldi	r21, 0x41	; 65
    1226:	6d 81       	ldd	r22, Y+5	; 0x05
    1228:	7e 81       	ldd	r23, Y+6	; 0x06
    122a:	8f 81       	ldd	r24, Y+7	; 0x07
    122c:	98 85       	ldd	r25, Y+8	; 0x08
    122e:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1232:	dc 01       	movw	r26, r24
    1234:	cb 01       	movw	r24, r22
    1236:	8e 01       	movw	r16, r28
    1238:	05 5a       	subi	r16, 0xA5	; 165
    123a:	1f 4f       	sbci	r17, 0xFF	; 255
    123c:	bc 01       	movw	r22, r24
    123e:	cd 01       	movw	r24, r26
    1240:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1244:	dc 01       	movw	r26, r24
    1246:	cb 01       	movw	r24, r22
    1248:	f8 01       	movw	r30, r16
    124a:	91 83       	std	Z+1, r25	; 0x01
    124c:	80 83       	st	Z, r24
    124e:	24 c0       	rjmp	.+72     	; 0x1298 <LCD_initialize+0x2e8>
    1250:	ce 01       	movw	r24, r28
    1252:	83 5a       	subi	r24, 0xA3	; 163
    1254:	9f 4f       	sbci	r25, 0xFF	; 255
    1256:	28 ec       	ldi	r18, 0xC8	; 200
    1258:	30 e0       	ldi	r19, 0x00	; 0
    125a:	fc 01       	movw	r30, r24
    125c:	31 83       	std	Z+1, r19	; 0x01
    125e:	20 83       	st	Z, r18
    1260:	ce 01       	movw	r24, r28
    1262:	83 5a       	subi	r24, 0xA3	; 163
    1264:	9f 4f       	sbci	r25, 0xFF	; 255
    1266:	fc 01       	movw	r30, r24
    1268:	80 81       	ld	r24, Z
    126a:	91 81       	ldd	r25, Z+1	; 0x01
    126c:	01 97       	sbiw	r24, 0x01	; 1
    126e:	f1 f7       	brne	.-4      	; 0x126c <LCD_initialize+0x2bc>
    1270:	9e 01       	movw	r18, r28
    1272:	23 5a       	subi	r18, 0xA3	; 163
    1274:	3f 4f       	sbci	r19, 0xFF	; 255
    1276:	f9 01       	movw	r30, r18
    1278:	91 83       	std	Z+1, r25	; 0x01
    127a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    127c:	ce 01       	movw	r24, r28
    127e:	85 5a       	subi	r24, 0xA5	; 165
    1280:	9f 4f       	sbci	r25, 0xFF	; 255
    1282:	9e 01       	movw	r18, r28
    1284:	25 5a       	subi	r18, 0xA5	; 165
    1286:	3f 4f       	sbci	r19, 0xFF	; 255
    1288:	f9 01       	movw	r30, r18
    128a:	20 81       	ld	r18, Z
    128c:	31 81       	ldd	r19, Z+1	; 0x01
    128e:	21 50       	subi	r18, 0x01	; 1
    1290:	31 09       	sbc	r19, r1
    1292:	fc 01       	movw	r30, r24
    1294:	31 83       	std	Z+1, r19	; 0x01
    1296:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1298:	ce 01       	movw	r24, r28
    129a:	85 5a       	subi	r24, 0xA5	; 165
    129c:	9f 4f       	sbci	r25, 0xFF	; 255
    129e:	fc 01       	movw	r30, r24
    12a0:	80 81       	ld	r24, Z
    12a2:	91 81       	ldd	r25, Z+1	; 0x01
    12a4:	89 2b       	or	r24, r25
    12a6:	a1 f6       	brne	.-88     	; 0x1250 <LCD_initialize+0x2a0>
    12a8:	2c c0       	rjmp	.+88     	; 0x1302 <LCD_initialize+0x352>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    12aa:	8e 01       	movw	r16, r28
    12ac:	05 5a       	subi	r16, 0xA5	; 165
    12ae:	1f 4f       	sbci	r17, 0xFF	; 255
    12b0:	ce 01       	movw	r24, r28
    12b2:	89 5a       	subi	r24, 0xA9	; 169
    12b4:	9f 4f       	sbci	r25, 0xFF	; 255
    12b6:	fc 01       	movw	r30, r24
    12b8:	60 81       	ld	r22, Z
    12ba:	71 81       	ldd	r23, Z+1	; 0x01
    12bc:	82 81       	ldd	r24, Z+2	; 0x02
    12be:	93 81       	ldd	r25, Z+3	; 0x03
    12c0:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    12c4:	dc 01       	movw	r26, r24
    12c6:	cb 01       	movw	r24, r22
    12c8:	f8 01       	movw	r30, r16
    12ca:	91 83       	std	Z+1, r25	; 0x01
    12cc:	80 83       	st	Z, r24
    12ce:	ce 01       	movw	r24, r28
    12d0:	81 5a       	subi	r24, 0xA1	; 161
    12d2:	9f 4f       	sbci	r25, 0xFF	; 255
    12d4:	9e 01       	movw	r18, r28
    12d6:	25 5a       	subi	r18, 0xA5	; 165
    12d8:	3f 4f       	sbci	r19, 0xFF	; 255
    12da:	f9 01       	movw	r30, r18
    12dc:	20 81       	ld	r18, Z
    12de:	31 81       	ldd	r19, Z+1	; 0x01
    12e0:	fc 01       	movw	r30, r24
    12e2:	31 83       	std	Z+1, r19	; 0x01
    12e4:	20 83       	st	Z, r18
    12e6:	ce 01       	movw	r24, r28
    12e8:	81 5a       	subi	r24, 0xA1	; 161
    12ea:	9f 4f       	sbci	r25, 0xFF	; 255
    12ec:	fc 01       	movw	r30, r24
    12ee:	80 81       	ld	r24, Z
    12f0:	91 81       	ldd	r25, Z+1	; 0x01
    12f2:	01 97       	sbiw	r24, 0x01	; 1
    12f4:	f1 f7       	brne	.-4      	; 0x12f2 <LCD_initialize+0x342>
    12f6:	9e 01       	movw	r18, r28
    12f8:	21 5a       	subi	r18, 0xA1	; 161
    12fa:	3f 4f       	sbci	r19, 0xFF	; 255
    12fc:	f9 01       	movw	r30, r18
    12fe:	91 83       	std	Z+1, r25	; 0x01
    1300:	80 83       	st	Z, r24
	_delay_ms(50);
	_delay_ms(40);
	LCD_Void_Write_Cmd(0b00111000);
    1302:	88 e3       	ldi	r24, 0x38	; 56
    1304:	0e 94 b4 07 	call	0xf68	; 0xf68 <LCD_Void_Write_Cmd>
    1308:	80 e0       	ldi	r24, 0x00	; 0
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	a8 e4       	ldi	r26, 0x48	; 72
    130e:	b2 e4       	ldi	r27, 0x42	; 66
    1310:	89 87       	std	Y+9, r24	; 0x09
    1312:	9a 87       	std	Y+10, r25	; 0x0a
    1314:	ab 87       	std	Y+11, r26	; 0x0b
    1316:	bc 87       	std	Y+12, r27	; 0x0c
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    1318:	2b ea       	ldi	r18, 0xAB	; 171
    131a:	3a ea       	ldi	r19, 0xAA	; 170
    131c:	4a e2       	ldi	r20, 0x2A	; 42
    131e:	50 e4       	ldi	r21, 0x40	; 64
    1320:	69 85       	ldd	r22, Y+9	; 0x09
    1322:	7a 85       	ldd	r23, Y+10	; 0x0a
    1324:	8b 85       	ldd	r24, Y+11	; 0x0b
    1326:	9c 85       	ldd	r25, Y+12	; 0x0c
    1328:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    132c:	dc 01       	movw	r26, r24
    132e:	cb 01       	movw	r24, r22
    1330:	8b af       	std	Y+59, r24	; 0x3b
    1332:	9c af       	std	Y+60, r25	; 0x3c
    1334:	ad af       	std	Y+61, r26	; 0x3d
    1336:	be af       	std	Y+62, r27	; 0x3e
	__tmp2 = ((F_CPU) / 4e6) * __us;
    1338:	8e 01       	movw	r16, r28
    133a:	01 5c       	subi	r16, 0xC1	; 193
    133c:	1f 4f       	sbci	r17, 0xFF	; 255
    133e:	89 85       	ldd	r24, Y+9	; 0x09
    1340:	9a 85       	ldd	r25, Y+10	; 0x0a
    1342:	ab 85       	ldd	r26, Y+11	; 0x0b
    1344:	bc 85       	ldd	r27, Y+12	; 0x0c
    1346:	9c 01       	movw	r18, r24
    1348:	ad 01       	movw	r20, r26
    134a:	bc 01       	movw	r22, r24
    134c:	cd 01       	movw	r24, r26
    134e:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <__addsf3>
    1352:	dc 01       	movw	r26, r24
    1354:	cb 01       	movw	r24, r22
    1356:	f8 01       	movw	r30, r16
    1358:	80 83       	st	Z, r24
    135a:	91 83       	std	Z+1, r25	; 0x01
    135c:	a2 83       	std	Z+2, r26	; 0x02
    135e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1360:	20 e0       	ldi	r18, 0x00	; 0
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	40 e8       	ldi	r20, 0x80	; 128
    1366:	5f e3       	ldi	r21, 0x3F	; 63
    1368:	6b ad       	ldd	r22, Y+59	; 0x3b
    136a:	7c ad       	ldd	r23, Y+60	; 0x3c
    136c:	8d ad       	ldd	r24, Y+61	; 0x3d
    136e:	9e ad       	ldd	r25, Y+62	; 0x3e
    1370:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    1374:	88 23       	and	r24, r24
    1376:	3c f4       	brge	.+14     	; 0x1386 <LCD_initialize+0x3d6>
		__ticks = 1;
    1378:	ce 01       	movw	r24, r28
    137a:	8d 5b       	subi	r24, 0xBD	; 189
    137c:	9f 4f       	sbci	r25, 0xFF	; 255
    137e:	21 e0       	ldi	r18, 0x01	; 1
    1380:	fc 01       	movw	r30, r24
    1382:	20 83       	st	Z, r18
    1384:	22 c1       	rjmp	.+580    	; 0x15ca <LCD_initialize+0x61a>
	else if (__tmp2 > 65535)
    1386:	ce 01       	movw	r24, r28
    1388:	cf 96       	adiw	r24, 0x3f	; 63
    138a:	20 e0       	ldi	r18, 0x00	; 0
    138c:	3f ef       	ldi	r19, 0xFF	; 255
    138e:	4f e7       	ldi	r20, 0x7F	; 127
    1390:	57 e4       	ldi	r21, 0x47	; 71
    1392:	fc 01       	movw	r30, r24
    1394:	60 81       	ld	r22, Z
    1396:	71 81       	ldd	r23, Z+1	; 0x01
    1398:	82 81       	ldd	r24, Z+2	; 0x02
    139a:	93 81       	ldd	r25, Z+3	; 0x03
    139c:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    13a0:	18 16       	cp	r1, r24
    13a2:	0c f0       	brlt	.+2      	; 0x13a6 <LCD_initialize+0x3f6>
    13a4:	cd c0       	rjmp	.+410    	; 0x1540 <LCD_initialize+0x590>
	{
		_delay_ms(__us / 1000.0);
    13a6:	20 e0       	ldi	r18, 0x00	; 0
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	4a e7       	ldi	r20, 0x7A	; 122
    13ac:	54 e4       	ldi	r21, 0x44	; 68
    13ae:	69 85       	ldd	r22, Y+9	; 0x09
    13b0:	7a 85       	ldd	r23, Y+10	; 0x0a
    13b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    13b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    13b6:	0e 94 59 30 	call	0x60b2	; 0x60b2 <__divsf3>
    13ba:	dc 01       	movw	r26, r24
    13bc:	cb 01       	movw	r24, r22
    13be:	9e 01       	movw	r18, r28
    13c0:	2c 5b       	subi	r18, 0xBC	; 188
    13c2:	3f 4f       	sbci	r19, 0xFF	; 255
    13c4:	f9 01       	movw	r30, r18
    13c6:	80 83       	st	Z, r24
    13c8:	91 83       	std	Z+1, r25	; 0x01
    13ca:	a2 83       	std	Z+2, r26	; 0x02
    13cc:	b3 83       	std	Z+3, r27	; 0x03

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    13ce:	8e 01       	movw	r16, r28
    13d0:	08 5b       	subi	r16, 0xB8	; 184
    13d2:	1f 4f       	sbci	r17, 0xFF	; 255
    13d4:	ce 01       	movw	r24, r28
    13d6:	8c 5b       	subi	r24, 0xBC	; 188
    13d8:	9f 4f       	sbci	r25, 0xFF	; 255
    13da:	20 e0       	ldi	r18, 0x00	; 0
    13dc:	30 e0       	ldi	r19, 0x00	; 0
    13de:	4a ef       	ldi	r20, 0xFA	; 250
    13e0:	54 e4       	ldi	r21, 0x44	; 68
    13e2:	fc 01       	movw	r30, r24
    13e4:	60 81       	ld	r22, Z
    13e6:	71 81       	ldd	r23, Z+1	; 0x01
    13e8:	82 81       	ldd	r24, Z+2	; 0x02
    13ea:	93 81       	ldd	r25, Z+3	; 0x03
    13ec:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    13f0:	dc 01       	movw	r26, r24
    13f2:	cb 01       	movw	r24, r22
    13f4:	f8 01       	movw	r30, r16
    13f6:	80 83       	st	Z, r24
    13f8:	91 83       	std	Z+1, r25	; 0x01
    13fa:	a2 83       	std	Z+2, r26	; 0x02
    13fc:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    13fe:	ce 01       	movw	r24, r28
    1400:	88 5b       	subi	r24, 0xB8	; 184
    1402:	9f 4f       	sbci	r25, 0xFF	; 255
    1404:	20 e0       	ldi	r18, 0x00	; 0
    1406:	30 e0       	ldi	r19, 0x00	; 0
    1408:	40 e8       	ldi	r20, 0x80	; 128
    140a:	5f e3       	ldi	r21, 0x3F	; 63
    140c:	fc 01       	movw	r30, r24
    140e:	60 81       	ld	r22, Z
    1410:	71 81       	ldd	r23, Z+1	; 0x01
    1412:	82 81       	ldd	r24, Z+2	; 0x02
    1414:	93 81       	ldd	r25, Z+3	; 0x03
    1416:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    141a:	88 23       	and	r24, r24
    141c:	4c f4       	brge	.+18     	; 0x1430 <LCD_initialize+0x480>
		__ticks = 1;
    141e:	ce 01       	movw	r24, r28
    1420:	84 5b       	subi	r24, 0xB4	; 180
    1422:	9f 4f       	sbci	r25, 0xFF	; 255
    1424:	21 e0       	ldi	r18, 0x01	; 1
    1426:	30 e0       	ldi	r19, 0x00	; 0
    1428:	fc 01       	movw	r30, r24
    142a:	31 83       	std	Z+1, r19	; 0x01
    142c:	20 83       	st	Z, r18
    142e:	6d c0       	rjmp	.+218    	; 0x150a <LCD_initialize+0x55a>
	else if (__tmp > 65535)
    1430:	ce 01       	movw	r24, r28
    1432:	88 5b       	subi	r24, 0xB8	; 184
    1434:	9f 4f       	sbci	r25, 0xFF	; 255
    1436:	20 e0       	ldi	r18, 0x00	; 0
    1438:	3f ef       	ldi	r19, 0xFF	; 255
    143a:	4f e7       	ldi	r20, 0x7F	; 127
    143c:	57 e4       	ldi	r21, 0x47	; 71
    143e:	fc 01       	movw	r30, r24
    1440:	60 81       	ld	r22, Z
    1442:	71 81       	ldd	r23, Z+1	; 0x01
    1444:	82 81       	ldd	r24, Z+2	; 0x02
    1446:	93 81       	ldd	r25, Z+3	; 0x03
    1448:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    144c:	18 16       	cp	r1, r24
    144e:	0c f0       	brlt	.+2      	; 0x1452 <LCD_initialize+0x4a2>
    1450:	4a c0       	rjmp	.+148    	; 0x14e6 <LCD_initialize+0x536>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1452:	ce 01       	movw	r24, r28
    1454:	8c 5b       	subi	r24, 0xBC	; 188
    1456:	9f 4f       	sbci	r25, 0xFF	; 255
    1458:	20 e0       	ldi	r18, 0x00	; 0
    145a:	30 e0       	ldi	r19, 0x00	; 0
    145c:	40 e2       	ldi	r20, 0x20	; 32
    145e:	51 e4       	ldi	r21, 0x41	; 65
    1460:	fc 01       	movw	r30, r24
    1462:	60 81       	ld	r22, Z
    1464:	71 81       	ldd	r23, Z+1	; 0x01
    1466:	82 81       	ldd	r24, Z+2	; 0x02
    1468:	93 81       	ldd	r25, Z+3	; 0x03
    146a:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    146e:	dc 01       	movw	r26, r24
    1470:	cb 01       	movw	r24, r22
    1472:	8e 01       	movw	r16, r28
    1474:	04 5b       	subi	r16, 0xB4	; 180
    1476:	1f 4f       	sbci	r17, 0xFF	; 255
    1478:	bc 01       	movw	r22, r24
    147a:	cd 01       	movw	r24, r26
    147c:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1480:	dc 01       	movw	r26, r24
    1482:	cb 01       	movw	r24, r22
    1484:	f8 01       	movw	r30, r16
    1486:	91 83       	std	Z+1, r25	; 0x01
    1488:	80 83       	st	Z, r24
    148a:	24 c0       	rjmp	.+72     	; 0x14d4 <LCD_initialize+0x524>
    148c:	ce 01       	movw	r24, r28
    148e:	82 5b       	subi	r24, 0xB2	; 178
    1490:	9f 4f       	sbci	r25, 0xFF	; 255
    1492:	28 ec       	ldi	r18, 0xC8	; 200
    1494:	30 e0       	ldi	r19, 0x00	; 0
    1496:	fc 01       	movw	r30, r24
    1498:	31 83       	std	Z+1, r19	; 0x01
    149a:	20 83       	st	Z, r18
    149c:	ce 01       	movw	r24, r28
    149e:	82 5b       	subi	r24, 0xB2	; 178
    14a0:	9f 4f       	sbci	r25, 0xFF	; 255
    14a2:	fc 01       	movw	r30, r24
    14a4:	80 81       	ld	r24, Z
    14a6:	91 81       	ldd	r25, Z+1	; 0x01
    14a8:	01 97       	sbiw	r24, 0x01	; 1
    14aa:	f1 f7       	brne	.-4      	; 0x14a8 <LCD_initialize+0x4f8>
    14ac:	9e 01       	movw	r18, r28
    14ae:	22 5b       	subi	r18, 0xB2	; 178
    14b0:	3f 4f       	sbci	r19, 0xFF	; 255
    14b2:	f9 01       	movw	r30, r18
    14b4:	91 83       	std	Z+1, r25	; 0x01
    14b6:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14b8:	ce 01       	movw	r24, r28
    14ba:	84 5b       	subi	r24, 0xB4	; 180
    14bc:	9f 4f       	sbci	r25, 0xFF	; 255
    14be:	9e 01       	movw	r18, r28
    14c0:	24 5b       	subi	r18, 0xB4	; 180
    14c2:	3f 4f       	sbci	r19, 0xFF	; 255
    14c4:	f9 01       	movw	r30, r18
    14c6:	20 81       	ld	r18, Z
    14c8:	31 81       	ldd	r19, Z+1	; 0x01
    14ca:	21 50       	subi	r18, 0x01	; 1
    14cc:	31 09       	sbc	r19, r1
    14ce:	fc 01       	movw	r30, r24
    14d0:	31 83       	std	Z+1, r19	; 0x01
    14d2:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    14d4:	ce 01       	movw	r24, r28
    14d6:	84 5b       	subi	r24, 0xB4	; 180
    14d8:	9f 4f       	sbci	r25, 0xFF	; 255
    14da:	fc 01       	movw	r30, r24
    14dc:	80 81       	ld	r24, Z
    14de:	91 81       	ldd	r25, Z+1	; 0x01
    14e0:	89 2b       	or	r24, r25
    14e2:	a1 f6       	brne	.-88     	; 0x148c <LCD_initialize+0x4dc>
    14e4:	72 c0       	rjmp	.+228    	; 0x15ca <LCD_initialize+0x61a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14e6:	8e 01       	movw	r16, r28
    14e8:	04 5b       	subi	r16, 0xB4	; 180
    14ea:	1f 4f       	sbci	r17, 0xFF	; 255
    14ec:	ce 01       	movw	r24, r28
    14ee:	88 5b       	subi	r24, 0xB8	; 184
    14f0:	9f 4f       	sbci	r25, 0xFF	; 255
    14f2:	fc 01       	movw	r30, r24
    14f4:	60 81       	ld	r22, Z
    14f6:	71 81       	ldd	r23, Z+1	; 0x01
    14f8:	82 81       	ldd	r24, Z+2	; 0x02
    14fa:	93 81       	ldd	r25, Z+3	; 0x03
    14fc:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1500:	dc 01       	movw	r26, r24
    1502:	cb 01       	movw	r24, r22
    1504:	f8 01       	movw	r30, r16
    1506:	91 83       	std	Z+1, r25	; 0x01
    1508:	80 83       	st	Z, r24
    150a:	ce 01       	movw	r24, r28
    150c:	80 5b       	subi	r24, 0xB0	; 176
    150e:	9f 4f       	sbci	r25, 0xFF	; 255
    1510:	9e 01       	movw	r18, r28
    1512:	24 5b       	subi	r18, 0xB4	; 180
    1514:	3f 4f       	sbci	r19, 0xFF	; 255
    1516:	f9 01       	movw	r30, r18
    1518:	20 81       	ld	r18, Z
    151a:	31 81       	ldd	r19, Z+1	; 0x01
    151c:	fc 01       	movw	r30, r24
    151e:	31 83       	std	Z+1, r19	; 0x01
    1520:	20 83       	st	Z, r18
    1522:	ce 01       	movw	r24, r28
    1524:	80 5b       	subi	r24, 0xB0	; 176
    1526:	9f 4f       	sbci	r25, 0xFF	; 255
    1528:	fc 01       	movw	r30, r24
    152a:	80 81       	ld	r24, Z
    152c:	91 81       	ldd	r25, Z+1	; 0x01
    152e:	01 97       	sbiw	r24, 0x01	; 1
    1530:	f1 f7       	brne	.-4      	; 0x152e <LCD_initialize+0x57e>
    1532:	9e 01       	movw	r18, r28
    1534:	20 5b       	subi	r18, 0xB0	; 176
    1536:	3f 4f       	sbci	r19, 0xFF	; 255
    1538:	f9 01       	movw	r30, r18
    153a:	91 83       	std	Z+1, r25	; 0x01
    153c:	80 83       	st	Z, r24
    153e:	45 c0       	rjmp	.+138    	; 0x15ca <LCD_initialize+0x61a>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    1540:	20 e0       	ldi	r18, 0x00	; 0
    1542:	30 e0       	ldi	r19, 0x00	; 0
    1544:	4f e7       	ldi	r20, 0x7F	; 127
    1546:	53 e4       	ldi	r21, 0x43	; 67
    1548:	6b ad       	ldd	r22, Y+59	; 0x3b
    154a:	7c ad       	ldd	r23, Y+60	; 0x3c
    154c:	8d ad       	ldd	r24, Y+61	; 0x3d
    154e:	9e ad       	ldd	r25, Y+62	; 0x3e
    1550:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    1554:	18 16       	cp	r1, r24
    1556:	64 f5       	brge	.+88     	; 0x15b0 <LCD_initialize+0x600>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    1558:	8e 01       	movw	r16, r28
    155a:	0e 5a       	subi	r16, 0xAE	; 174
    155c:	1f 4f       	sbci	r17, 0xFF	; 255
    155e:	ce 01       	movw	r24, r28
    1560:	cf 96       	adiw	r24, 0x3f	; 63
    1562:	fc 01       	movw	r30, r24
    1564:	60 81       	ld	r22, Z
    1566:	71 81       	ldd	r23, Z+1	; 0x01
    1568:	82 81       	ldd	r24, Z+2	; 0x02
    156a:	93 81       	ldd	r25, Z+3	; 0x03
    156c:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1570:	dc 01       	movw	r26, r24
    1572:	cb 01       	movw	r24, r22
    1574:	f8 01       	movw	r30, r16
    1576:	91 83       	std	Z+1, r25	; 0x01
    1578:	80 83       	st	Z, r24
    157a:	ce 01       	movw	r24, r28
    157c:	8c 5a       	subi	r24, 0xAC	; 172
    157e:	9f 4f       	sbci	r25, 0xFF	; 255
    1580:	9e 01       	movw	r18, r28
    1582:	2e 5a       	subi	r18, 0xAE	; 174
    1584:	3f 4f       	sbci	r19, 0xFF	; 255
    1586:	f9 01       	movw	r30, r18
    1588:	20 81       	ld	r18, Z
    158a:	31 81       	ldd	r19, Z+1	; 0x01
    158c:	fc 01       	movw	r30, r24
    158e:	31 83       	std	Z+1, r19	; 0x01
    1590:	20 83       	st	Z, r18
    1592:	ce 01       	movw	r24, r28
    1594:	8c 5a       	subi	r24, 0xAC	; 172
    1596:	9f 4f       	sbci	r25, 0xFF	; 255
    1598:	fc 01       	movw	r30, r24
    159a:	80 81       	ld	r24, Z
    159c:	91 81       	ldd	r25, Z+1	; 0x01
    159e:	01 97       	sbiw	r24, 0x01	; 1
    15a0:	f1 f7       	brne	.-4      	; 0x159e <LCD_initialize+0x5ee>
    15a2:	9e 01       	movw	r18, r28
    15a4:	2c 5a       	subi	r18, 0xAC	; 172
    15a6:	3f 4f       	sbci	r19, 0xFF	; 255
    15a8:	f9 01       	movw	r30, r18
    15aa:	91 83       	std	Z+1, r25	; 0x01
    15ac:	80 83       	st	Z, r24
    15ae:	24 c0       	rjmp	.+72     	; 0x15f8 <LCD_initialize+0x648>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    15b0:	8e 01       	movw	r16, r28
    15b2:	0d 5b       	subi	r16, 0xBD	; 189
    15b4:	1f 4f       	sbci	r17, 0xFF	; 255
    15b6:	6b ad       	ldd	r22, Y+59	; 0x3b
    15b8:	7c ad       	ldd	r23, Y+60	; 0x3c
    15ba:	8d ad       	ldd	r24, Y+61	; 0x3d
    15bc:	9e ad       	ldd	r25, Y+62	; 0x3e
    15be:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    15c2:	dc 01       	movw	r26, r24
    15c4:	cb 01       	movw	r24, r22
    15c6:	f8 01       	movw	r30, r16
    15c8:	80 83       	st	Z, r24
    15ca:	ce 01       	movw	r24, r28
    15cc:	8a 5a       	subi	r24, 0xAA	; 170
    15ce:	9f 4f       	sbci	r25, 0xFF	; 255
    15d0:	9e 01       	movw	r18, r28
    15d2:	2d 5b       	subi	r18, 0xBD	; 189
    15d4:	3f 4f       	sbci	r19, 0xFF	; 255
    15d6:	f9 01       	movw	r30, r18
    15d8:	20 81       	ld	r18, Z
    15da:	fc 01       	movw	r30, r24
    15dc:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    15de:	ce 01       	movw	r24, r28
    15e0:	8a 5a       	subi	r24, 0xAA	; 170
    15e2:	9f 4f       	sbci	r25, 0xFF	; 255
    15e4:	fc 01       	movw	r30, r24
    15e6:	80 81       	ld	r24, Z
    15e8:	28 2f       	mov	r18, r24
    15ea:	2a 95       	dec	r18
    15ec:	f1 f7       	brne	.-4      	; 0x15ea <LCD_initialize+0x63a>
    15ee:	ce 01       	movw	r24, r28
    15f0:	8a 5a       	subi	r24, 0xAA	; 170
    15f2:	9f 4f       	sbci	r25, 0xFF	; 255
    15f4:	fc 01       	movw	r30, r24
    15f6:	20 83       	st	Z, r18
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00001100);
    15f8:	8c e0       	ldi	r24, 0x0C	; 12
    15fa:	0e 94 b4 07 	call	0xf68	; 0xf68 <LCD_Void_Write_Cmd>
    15fe:	80 e0       	ldi	r24, 0x00	; 0
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	a8 e4       	ldi	r26, 0x48	; 72
    1604:	b2 e4       	ldi	r27, 0x42	; 66
    1606:	8d 87       	std	Y+13, r24	; 0x0d
    1608:	9e 87       	std	Y+14, r25	; 0x0e
    160a:	af 87       	std	Y+15, r26	; 0x0f
    160c:	b8 8b       	std	Y+16, r27	; 0x10
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    160e:	2b ea       	ldi	r18, 0xAB	; 171
    1610:	3a ea       	ldi	r19, 0xAA	; 170
    1612:	4a e2       	ldi	r20, 0x2A	; 42
    1614:	50 e4       	ldi	r21, 0x40	; 64
    1616:	6d 85       	ldd	r22, Y+13	; 0x0d
    1618:	7e 85       	ldd	r23, Y+14	; 0x0e
    161a:	8f 85       	ldd	r24, Y+15	; 0x0f
    161c:	98 89       	ldd	r25, Y+16	; 0x10
    161e:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1622:	dc 01       	movw	r26, r24
    1624:	cb 01       	movw	r24, r22
    1626:	8f 8f       	std	Y+31, r24	; 0x1f
    1628:	98 a3       	std	Y+32, r25	; 0x20
    162a:	a9 a3       	std	Y+33, r26	; 0x21
    162c:	ba a3       	std	Y+34, r27	; 0x22
	__tmp2 = ((F_CPU) / 4e6) * __us;
    162e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1630:	9e 85       	ldd	r25, Y+14	; 0x0e
    1632:	af 85       	ldd	r26, Y+15	; 0x0f
    1634:	b8 89       	ldd	r27, Y+16	; 0x10
    1636:	9c 01       	movw	r18, r24
    1638:	ad 01       	movw	r20, r26
    163a:	bc 01       	movw	r22, r24
    163c:	cd 01       	movw	r24, r26
    163e:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <__addsf3>
    1642:	dc 01       	movw	r26, r24
    1644:	cb 01       	movw	r24, r22
    1646:	8b a3       	std	Y+35, r24	; 0x23
    1648:	9c a3       	std	Y+36, r25	; 0x24
    164a:	ad a3       	std	Y+37, r26	; 0x25
    164c:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    164e:	20 e0       	ldi	r18, 0x00	; 0
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	40 e8       	ldi	r20, 0x80	; 128
    1654:	5f e3       	ldi	r21, 0x3F	; 63
    1656:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1658:	78 a1       	ldd	r23, Y+32	; 0x20
    165a:	89 a1       	ldd	r24, Y+33	; 0x21
    165c:	9a a1       	ldd	r25, Y+34	; 0x22
    165e:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    1662:	88 23       	and	r24, r24
    1664:	1c f4       	brge	.+6      	; 0x166c <LCD_initialize+0x6bc>
		__ticks = 1;
    1666:	81 e0       	ldi	r24, 0x01	; 1
    1668:	8f a3       	std	Y+39, r24	; 0x27
    166a:	b2 c0       	rjmp	.+356    	; 0x17d0 <LCD_initialize+0x820>
	else if (__tmp2 > 65535)
    166c:	20 e0       	ldi	r18, 0x00	; 0
    166e:	3f ef       	ldi	r19, 0xFF	; 255
    1670:	4f e7       	ldi	r20, 0x7F	; 127
    1672:	57 e4       	ldi	r21, 0x47	; 71
    1674:	6b a1       	ldd	r22, Y+35	; 0x23
    1676:	7c a1       	ldd	r23, Y+36	; 0x24
    1678:	8d a1       	ldd	r24, Y+37	; 0x25
    167a:	9e a1       	ldd	r25, Y+38	; 0x26
    167c:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    1680:	18 16       	cp	r1, r24
    1682:	0c f0       	brlt	.+2      	; 0x1686 <LCD_initialize+0x6d6>
    1684:	7b c0       	rjmp	.+246    	; 0x177c <LCD_initialize+0x7cc>
	{
		_delay_ms(__us / 1000.0);
    1686:	20 e0       	ldi	r18, 0x00	; 0
    1688:	30 e0       	ldi	r19, 0x00	; 0
    168a:	4a e7       	ldi	r20, 0x7A	; 122
    168c:	54 e4       	ldi	r21, 0x44	; 68
    168e:	6d 85       	ldd	r22, Y+13	; 0x0d
    1690:	7e 85       	ldd	r23, Y+14	; 0x0e
    1692:	8f 85       	ldd	r24, Y+15	; 0x0f
    1694:	98 89       	ldd	r25, Y+16	; 0x10
    1696:	0e 94 59 30 	call	0x60b2	; 0x60b2 <__divsf3>
    169a:	dc 01       	movw	r26, r24
    169c:	cb 01       	movw	r24, r22
    169e:	88 a7       	std	Y+40, r24	; 0x28
    16a0:	99 a7       	std	Y+41, r25	; 0x29
    16a2:	aa a7       	std	Y+42, r26	; 0x2a
    16a4:	bb a7       	std	Y+43, r27	; 0x2b

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    16a6:	20 e0       	ldi	r18, 0x00	; 0
    16a8:	30 e0       	ldi	r19, 0x00	; 0
    16aa:	4a ef       	ldi	r20, 0xFA	; 250
    16ac:	54 e4       	ldi	r21, 0x44	; 68
    16ae:	68 a5       	ldd	r22, Y+40	; 0x28
    16b0:	79 a5       	ldd	r23, Y+41	; 0x29
    16b2:	8a a5       	ldd	r24, Y+42	; 0x2a
    16b4:	9b a5       	ldd	r25, Y+43	; 0x2b
    16b6:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    16ba:	dc 01       	movw	r26, r24
    16bc:	cb 01       	movw	r24, r22
    16be:	8c a7       	std	Y+44, r24	; 0x2c
    16c0:	9d a7       	std	Y+45, r25	; 0x2d
    16c2:	ae a7       	std	Y+46, r26	; 0x2e
    16c4:	bf a7       	std	Y+47, r27	; 0x2f
	if (__tmp < 1.0)
    16c6:	20 e0       	ldi	r18, 0x00	; 0
    16c8:	30 e0       	ldi	r19, 0x00	; 0
    16ca:	40 e8       	ldi	r20, 0x80	; 128
    16cc:	5f e3       	ldi	r21, 0x3F	; 63
    16ce:	6c a5       	ldd	r22, Y+44	; 0x2c
    16d0:	7d a5       	ldd	r23, Y+45	; 0x2d
    16d2:	8e a5       	ldd	r24, Y+46	; 0x2e
    16d4:	9f a5       	ldd	r25, Y+47	; 0x2f
    16d6:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    16da:	88 23       	and	r24, r24
    16dc:	2c f4       	brge	.+10     	; 0x16e8 <LCD_initialize+0x738>
		__ticks = 1;
    16de:	81 e0       	ldi	r24, 0x01	; 1
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	99 ab       	std	Y+49, r25	; 0x31
    16e4:	88 ab       	std	Y+48, r24	; 0x30
    16e6:	3f c0       	rjmp	.+126    	; 0x1766 <LCD_initialize+0x7b6>
	else if (__tmp > 65535)
    16e8:	20 e0       	ldi	r18, 0x00	; 0
    16ea:	3f ef       	ldi	r19, 0xFF	; 255
    16ec:	4f e7       	ldi	r20, 0x7F	; 127
    16ee:	57 e4       	ldi	r21, 0x47	; 71
    16f0:	6c a5       	ldd	r22, Y+44	; 0x2c
    16f2:	7d a5       	ldd	r23, Y+45	; 0x2d
    16f4:	8e a5       	ldd	r24, Y+46	; 0x2e
    16f6:	9f a5       	ldd	r25, Y+47	; 0x2f
    16f8:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    16fc:	18 16       	cp	r1, r24
    16fe:	4c f5       	brge	.+82     	; 0x1752 <LCD_initialize+0x7a2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1700:	20 e0       	ldi	r18, 0x00	; 0
    1702:	30 e0       	ldi	r19, 0x00	; 0
    1704:	40 e2       	ldi	r20, 0x20	; 32
    1706:	51 e4       	ldi	r21, 0x41	; 65
    1708:	68 a5       	ldd	r22, Y+40	; 0x28
    170a:	79 a5       	ldd	r23, Y+41	; 0x29
    170c:	8a a5       	ldd	r24, Y+42	; 0x2a
    170e:	9b a5       	ldd	r25, Y+43	; 0x2b
    1710:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1714:	dc 01       	movw	r26, r24
    1716:	cb 01       	movw	r24, r22
    1718:	bc 01       	movw	r22, r24
    171a:	cd 01       	movw	r24, r26
    171c:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1720:	dc 01       	movw	r26, r24
    1722:	cb 01       	movw	r24, r22
    1724:	99 ab       	std	Y+49, r25	; 0x31
    1726:	88 ab       	std	Y+48, r24	; 0x30
    1728:	0f c0       	rjmp	.+30     	; 0x1748 <LCD_initialize+0x798>
    172a:	88 ec       	ldi	r24, 0xC8	; 200
    172c:	90 e0       	ldi	r25, 0x00	; 0
    172e:	9b ab       	std	Y+51, r25	; 0x33
    1730:	8a ab       	std	Y+50, r24	; 0x32
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1732:	8a a9       	ldd	r24, Y+50	; 0x32
    1734:	9b a9       	ldd	r25, Y+51	; 0x33
    1736:	01 97       	sbiw	r24, 0x01	; 1
    1738:	f1 f7       	brne	.-4      	; 0x1736 <LCD_initialize+0x786>
    173a:	9b ab       	std	Y+51, r25	; 0x33
    173c:	8a ab       	std	Y+50, r24	; 0x32
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    173e:	88 a9       	ldd	r24, Y+48	; 0x30
    1740:	99 a9       	ldd	r25, Y+49	; 0x31
    1742:	01 97       	sbiw	r24, 0x01	; 1
    1744:	99 ab       	std	Y+49, r25	; 0x31
    1746:	88 ab       	std	Y+48, r24	; 0x30
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1748:	88 a9       	ldd	r24, Y+48	; 0x30
    174a:	99 a9       	ldd	r25, Y+49	; 0x31
    174c:	89 2b       	or	r24, r25
    174e:	69 f7       	brne	.-38     	; 0x172a <LCD_initialize+0x77a>
    1750:	3f c0       	rjmp	.+126    	; 0x17d0 <LCD_initialize+0x820>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1752:	6c a5       	ldd	r22, Y+44	; 0x2c
    1754:	7d a5       	ldd	r23, Y+45	; 0x2d
    1756:	8e a5       	ldd	r24, Y+46	; 0x2e
    1758:	9f a5       	ldd	r25, Y+47	; 0x2f
    175a:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    175e:	dc 01       	movw	r26, r24
    1760:	cb 01       	movw	r24, r22
    1762:	99 ab       	std	Y+49, r25	; 0x31
    1764:	88 ab       	std	Y+48, r24	; 0x30
    1766:	88 a9       	ldd	r24, Y+48	; 0x30
    1768:	99 a9       	ldd	r25, Y+49	; 0x31
    176a:	9d ab       	std	Y+53, r25	; 0x35
    176c:	8c ab       	std	Y+52, r24	; 0x34
    176e:	8c a9       	ldd	r24, Y+52	; 0x34
    1770:	9d a9       	ldd	r25, Y+53	; 0x35
    1772:	01 97       	sbiw	r24, 0x01	; 1
    1774:	f1 f7       	brne	.-4      	; 0x1772 <LCD_initialize+0x7c2>
    1776:	9d ab       	std	Y+53, r25	; 0x35
    1778:	8c ab       	std	Y+52, r24	; 0x34
    177a:	2a c0       	rjmp	.+84     	; 0x17d0 <LCD_initialize+0x820>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    177c:	20 e0       	ldi	r18, 0x00	; 0
    177e:	30 e0       	ldi	r19, 0x00	; 0
    1780:	4f e7       	ldi	r20, 0x7F	; 127
    1782:	53 e4       	ldi	r21, 0x43	; 67
    1784:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1786:	78 a1       	ldd	r23, Y+32	; 0x20
    1788:	89 a1       	ldd	r24, Y+33	; 0x21
    178a:	9a a1       	ldd	r25, Y+34	; 0x22
    178c:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    1790:	18 16       	cp	r1, r24
    1792:	ac f4       	brge	.+42     	; 0x17be <LCD_initialize+0x80e>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    1794:	6b a1       	ldd	r22, Y+35	; 0x23
    1796:	7c a1       	ldd	r23, Y+36	; 0x24
    1798:	8d a1       	ldd	r24, Y+37	; 0x25
    179a:	9e a1       	ldd	r25, Y+38	; 0x26
    179c:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    17a0:	dc 01       	movw	r26, r24
    17a2:	cb 01       	movw	r24, r22
    17a4:	9f ab       	std	Y+55, r25	; 0x37
    17a6:	8e ab       	std	Y+54, r24	; 0x36
    17a8:	8e a9       	ldd	r24, Y+54	; 0x36
    17aa:	9f a9       	ldd	r25, Y+55	; 0x37
    17ac:	99 af       	std	Y+57, r25	; 0x39
    17ae:	88 af       	std	Y+56, r24	; 0x38
    17b0:	88 ad       	ldd	r24, Y+56	; 0x38
    17b2:	99 ad       	ldd	r25, Y+57	; 0x39
    17b4:	01 97       	sbiw	r24, 0x01	; 1
    17b6:	f1 f7       	brne	.-4      	; 0x17b4 <LCD_initialize+0x804>
    17b8:	99 af       	std	Y+57, r25	; 0x39
    17ba:	88 af       	std	Y+56, r24	; 0x38
    17bc:	0f c0       	rjmp	.+30     	; 0x17dc <LCD_initialize+0x82c>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    17be:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17c0:	78 a1       	ldd	r23, Y+32	; 0x20
    17c2:	89 a1       	ldd	r24, Y+33	; 0x21
    17c4:	9a a1       	ldd	r25, Y+34	; 0x22
    17c6:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    17ca:	dc 01       	movw	r26, r24
    17cc:	cb 01       	movw	r24, r22
    17ce:	8f a3       	std	Y+39, r24	; 0x27
    17d0:	8f a1       	ldd	r24, Y+39	; 0x27
    17d2:	8a af       	std	Y+58, r24	; 0x3a
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    17d4:	8a ad       	ldd	r24, Y+58	; 0x3a
    17d6:	8a 95       	dec	r24
    17d8:	f1 f7       	brne	.-4      	; 0x17d6 <LCD_initialize+0x826>
    17da:	8a af       	std	Y+58, r24	; 0x3a
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00000001);
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	0e 94 b4 07 	call	0xf68	; 0xf68 <LCD_Void_Write_Cmd>
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	90 e0       	ldi	r25, 0x00	; 0
    17e6:	a0 e0       	ldi	r26, 0x00	; 0
    17e8:	b0 e4       	ldi	r27, 0x40	; 64
    17ea:	89 8b       	std	Y+17, r24	; 0x11
    17ec:	9a 8b       	std	Y+18, r25	; 0x12
    17ee:	ab 8b       	std	Y+19, r26	; 0x13
    17f0:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    17f2:	20 e0       	ldi	r18, 0x00	; 0
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	4a ef       	ldi	r20, 0xFA	; 250
    17f8:	54 e4       	ldi	r21, 0x44	; 68
    17fa:	69 89       	ldd	r22, Y+17	; 0x11
    17fc:	7a 89       	ldd	r23, Y+18	; 0x12
    17fe:	8b 89       	ldd	r24, Y+19	; 0x13
    1800:	9c 89       	ldd	r25, Y+20	; 0x14
    1802:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1806:	dc 01       	movw	r26, r24
    1808:	cb 01       	movw	r24, r22
    180a:	8d 8b       	std	Y+21, r24	; 0x15
    180c:	9e 8b       	std	Y+22, r25	; 0x16
    180e:	af 8b       	std	Y+23, r26	; 0x17
    1810:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1812:	20 e0       	ldi	r18, 0x00	; 0
    1814:	30 e0       	ldi	r19, 0x00	; 0
    1816:	40 e8       	ldi	r20, 0x80	; 128
    1818:	5f e3       	ldi	r21, 0x3F	; 63
    181a:	6d 89       	ldd	r22, Y+21	; 0x15
    181c:	7e 89       	ldd	r23, Y+22	; 0x16
    181e:	8f 89       	ldd	r24, Y+23	; 0x17
    1820:	98 8d       	ldd	r25, Y+24	; 0x18
    1822:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    1826:	88 23       	and	r24, r24
    1828:	2c f4       	brge	.+10     	; 0x1834 <LCD_initialize+0x884>
		__ticks = 1;
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	90 e0       	ldi	r25, 0x00	; 0
    182e:	9a 8f       	std	Y+26, r25	; 0x1a
    1830:	89 8f       	std	Y+25, r24	; 0x19
    1832:	3f c0       	rjmp	.+126    	; 0x18b2 <LCD_initialize+0x902>
	else if (__tmp > 65535)
    1834:	20 e0       	ldi	r18, 0x00	; 0
    1836:	3f ef       	ldi	r19, 0xFF	; 255
    1838:	4f e7       	ldi	r20, 0x7F	; 127
    183a:	57 e4       	ldi	r21, 0x47	; 71
    183c:	6d 89       	ldd	r22, Y+21	; 0x15
    183e:	7e 89       	ldd	r23, Y+22	; 0x16
    1840:	8f 89       	ldd	r24, Y+23	; 0x17
    1842:	98 8d       	ldd	r25, Y+24	; 0x18
    1844:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    1848:	18 16       	cp	r1, r24
    184a:	4c f5       	brge	.+82     	; 0x189e <LCD_initialize+0x8ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    184c:	20 e0       	ldi	r18, 0x00	; 0
    184e:	30 e0       	ldi	r19, 0x00	; 0
    1850:	40 e2       	ldi	r20, 0x20	; 32
    1852:	51 e4       	ldi	r21, 0x41	; 65
    1854:	69 89       	ldd	r22, Y+17	; 0x11
    1856:	7a 89       	ldd	r23, Y+18	; 0x12
    1858:	8b 89       	ldd	r24, Y+19	; 0x13
    185a:	9c 89       	ldd	r25, Y+20	; 0x14
    185c:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1860:	dc 01       	movw	r26, r24
    1862:	cb 01       	movw	r24, r22
    1864:	bc 01       	movw	r22, r24
    1866:	cd 01       	movw	r24, r26
    1868:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    186c:	dc 01       	movw	r26, r24
    186e:	cb 01       	movw	r24, r22
    1870:	9a 8f       	std	Y+26, r25	; 0x1a
    1872:	89 8f       	std	Y+25, r24	; 0x19
    1874:	0f c0       	rjmp	.+30     	; 0x1894 <LCD_initialize+0x8e4>
    1876:	88 ec       	ldi	r24, 0xC8	; 200
    1878:	90 e0       	ldi	r25, 0x00	; 0
    187a:	9c 8f       	std	Y+28, r25	; 0x1c
    187c:	8b 8f       	std	Y+27, r24	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    187e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1880:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1882:	01 97       	sbiw	r24, 0x01	; 1
    1884:	f1 f7       	brne	.-4      	; 0x1882 <LCD_initialize+0x8d2>
    1886:	9c 8f       	std	Y+28, r25	; 0x1c
    1888:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    188a:	89 8d       	ldd	r24, Y+25	; 0x19
    188c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    188e:	01 97       	sbiw	r24, 0x01	; 1
    1890:	9a 8f       	std	Y+26, r25	; 0x1a
    1892:	89 8f       	std	Y+25, r24	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1894:	89 8d       	ldd	r24, Y+25	; 0x19
    1896:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1898:	89 2b       	or	r24, r25
    189a:	69 f7       	brne	.-38     	; 0x1876 <LCD_initialize+0x8c6>
	_delay_ms(2);
/*	LCD_Void_Write_CGRAM(Pattern_Alarm,Pixel_Alarm);
	LCD_Void_Write_CGRAM(Pattern_Arrow,Pixel_Arrow);*/

}
    189c:	14 c0       	rjmp	.+40     	; 0x18c6 <LCD_initialize+0x916>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    189e:	6d 89       	ldd	r22, Y+21	; 0x15
    18a0:	7e 89       	ldd	r23, Y+22	; 0x16
    18a2:	8f 89       	ldd	r24, Y+23	; 0x17
    18a4:	98 8d       	ldd	r25, Y+24	; 0x18
    18a6:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    18aa:	dc 01       	movw	r26, r24
    18ac:	cb 01       	movw	r24, r22
    18ae:	9a 8f       	std	Y+26, r25	; 0x1a
    18b0:	89 8f       	std	Y+25, r24	; 0x19
    18b2:	89 8d       	ldd	r24, Y+25	; 0x19
    18b4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18b6:	9e 8f       	std	Y+30, r25	; 0x1e
    18b8:	8d 8f       	std	Y+29, r24	; 0x1d
    18ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18bc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18be:	01 97       	sbiw	r24, 0x01	; 1
    18c0:	f1 f7       	brne	.-4      	; 0x18be <LCD_initialize+0x90e>
    18c2:	9e 8f       	std	Y+30, r25	; 0x1e
    18c4:	8d 8f       	std	Y+29, r24	; 0x1d
    18c6:	00 00       	nop
    18c8:	c6 59       	subi	r28, 0x96	; 150
    18ca:	df 4f       	sbci	r29, 0xFF	; 255
    18cc:	0f b6       	in	r0, 0x3f	; 63
    18ce:	f8 94       	cli
    18d0:	de bf       	out	0x3e, r29	; 62
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	cd bf       	out	0x3d, r28	; 61
    18d6:	df 91       	pop	r29
    18d8:	cf 91       	pop	r28
    18da:	1f 91       	pop	r17
    18dc:	0f 91       	pop	r16
    18de:	08 95       	ret

000018e0 <LCD_Void_Write_String>:

void LCD_Void_Write_String(u8* copy_string)
{
    18e0:	cf 93       	push	r28
    18e2:	df 93       	push	r29
    18e4:	00 d0       	rcall	.+0      	; 0x18e6 <LCD_Void_Write_String+0x6>
    18e6:	1f 92       	push	r1
    18e8:	cd b7       	in	r28, 0x3d	; 61
    18ea:	de b7       	in	r29, 0x3e	; 62
    18ec:	9b 83       	std	Y+3, r25	; 0x03
    18ee:	8a 83       	std	Y+2, r24	; 0x02
	u8 i = 0;
    18f0:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    18f2:	14 c0       	rjmp	.+40     	; 0x191c <LCD_Void_Write_String+0x3c>
	{	if(i==16)
    18f4:	89 81       	ldd	r24, Y+1	; 0x01
    18f6:	80 31       	cpi	r24, 0x10	; 16
    18f8:	19 f4       	brne	.+6      	; 0x1900 <LCD_Void_Write_String+0x20>
		{
			LCD_Set_Block(16);
    18fa:	80 e1       	ldi	r24, 0x10	; 16
    18fc:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
		}
		LCD_Void_Write_Data(copy_string[i]);
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	88 2f       	mov	r24, r24
    1904:	90 e0       	ldi	r25, 0x00	; 0
    1906:	2a 81       	ldd	r18, Y+2	; 0x02
    1908:	3b 81       	ldd	r19, Y+3	; 0x03
    190a:	82 0f       	add	r24, r18
    190c:	93 1f       	adc	r25, r19
    190e:	fc 01       	movw	r30, r24
    1910:	80 81       	ld	r24, Z
    1912:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
		i++;
    1916:	89 81       	ldd	r24, Y+1	; 0x01
    1918:	8f 5f       	subi	r24, 0xFF	; 255
    191a:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    191c:	89 81       	ldd	r24, Y+1	; 0x01
    191e:	88 2f       	mov	r24, r24
    1920:	90 e0       	ldi	r25, 0x00	; 0
    1922:	2a 81       	ldd	r18, Y+2	; 0x02
    1924:	3b 81       	ldd	r19, Y+3	; 0x03
    1926:	82 0f       	add	r24, r18
    1928:	93 1f       	adc	r25, r19
    192a:	fc 01       	movw	r30, r24
    192c:	80 81       	ld	r24, Z
    192e:	88 23       	and	r24, r24
    1930:	09 f7       	brne	.-62     	; 0x18f4 <LCD_Void_Write_String+0x14>
			LCD_Set_Block(16);
		}
		LCD_Void_Write_Data(copy_string[i]);
		i++;
	}
}
    1932:	00 00       	nop
    1934:	0f 90       	pop	r0
    1936:	0f 90       	pop	r0
    1938:	0f 90       	pop	r0
    193a:	df 91       	pop	r29
    193c:	cf 91       	pop	r28
    193e:	08 95       	ret

00001940 <LCD_Void_Clear>:

void LCD_Void_Clear(void)
{
    1940:	cf 93       	push	r28
    1942:	df 93       	push	r29
    1944:	cd b7       	in	r28, 0x3d	; 61
    1946:	de b7       	in	r29, 0x3e	; 62
	LCD_Void_Write_Cmd(0b00000001);
    1948:	81 e0       	ldi	r24, 0x01	; 1
    194a:	0e 94 b4 07 	call	0xf68	; 0xf68 <LCD_Void_Write_Cmd>
}
    194e:	00 00       	nop
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	08 95       	ret

00001956 <LCD_Void_Write_Blinking_String>:

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
    1956:	cf 93       	push	r28
    1958:	df 93       	push	r29
    195a:	cd b7       	in	r28, 0x3d	; 61
    195c:	de b7       	in	r29, 0x3e	; 62
    195e:	61 97       	sbiw	r28, 0x11	; 17
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	de bf       	out	0x3e, r29	; 62
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	cd bf       	out	0x3d, r28	; 61
    196a:	99 8b       	std	Y+17, r25	; 0x11
    196c:	88 8b       	std	Y+16, r24	; 0x10
	u8 i = 0;
    196e:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    1970:	80 c0       	rjmp	.+256    	; 0x1a72 <LCD_Void_Write_Blinking_String+0x11c>
	{
		LCD_Void_Write_Data(copy_string[i]);
    1972:	89 81       	ldd	r24, Y+1	; 0x01
    1974:	88 2f       	mov	r24, r24
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	28 89       	ldd	r18, Y+16	; 0x10
    197a:	39 89       	ldd	r19, Y+17	; 0x11
    197c:	82 0f       	add	r24, r18
    197e:	93 1f       	adc	r25, r19
    1980:	fc 01       	movw	r30, r24
    1982:	80 81       	ld	r24, Z
    1984:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
    1988:	80 e0       	ldi	r24, 0x00	; 0
    198a:	90 e0       	ldi	r25, 0x00	; 0
    198c:	aa ef       	ldi	r26, 0xFA	; 250
    198e:	b3 e4       	ldi	r27, 0x43	; 67
    1990:	8a 83       	std	Y+2, r24	; 0x02
    1992:	9b 83       	std	Y+3, r25	; 0x03
    1994:	ac 83       	std	Y+4, r26	; 0x04
    1996:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1998:	20 e0       	ldi	r18, 0x00	; 0
    199a:	30 e0       	ldi	r19, 0x00	; 0
    199c:	4a ef       	ldi	r20, 0xFA	; 250
    199e:	54 e4       	ldi	r21, 0x44	; 68
    19a0:	6a 81       	ldd	r22, Y+2	; 0x02
    19a2:	7b 81       	ldd	r23, Y+3	; 0x03
    19a4:	8c 81       	ldd	r24, Y+4	; 0x04
    19a6:	9d 81       	ldd	r25, Y+5	; 0x05
    19a8:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    19ac:	dc 01       	movw	r26, r24
    19ae:	cb 01       	movw	r24, r22
    19b0:	8e 83       	std	Y+6, r24	; 0x06
    19b2:	9f 83       	std	Y+7, r25	; 0x07
    19b4:	a8 87       	std	Y+8, r26	; 0x08
    19b6:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    19b8:	20 e0       	ldi	r18, 0x00	; 0
    19ba:	30 e0       	ldi	r19, 0x00	; 0
    19bc:	40 e8       	ldi	r20, 0x80	; 128
    19be:	5f e3       	ldi	r21, 0x3F	; 63
    19c0:	6e 81       	ldd	r22, Y+6	; 0x06
    19c2:	7f 81       	ldd	r23, Y+7	; 0x07
    19c4:	88 85       	ldd	r24, Y+8	; 0x08
    19c6:	99 85       	ldd	r25, Y+9	; 0x09
    19c8:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    19cc:	88 23       	and	r24, r24
    19ce:	2c f4       	brge	.+10     	; 0x19da <LCD_Void_Write_Blinking_String+0x84>
		__ticks = 1;
    19d0:	81 e0       	ldi	r24, 0x01	; 1
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	9b 87       	std	Y+11, r25	; 0x0b
    19d6:	8a 87       	std	Y+10, r24	; 0x0a
    19d8:	3f c0       	rjmp	.+126    	; 0x1a58 <LCD_Void_Write_Blinking_String+0x102>
	else if (__tmp > 65535)
    19da:	20 e0       	ldi	r18, 0x00	; 0
    19dc:	3f ef       	ldi	r19, 0xFF	; 255
    19de:	4f e7       	ldi	r20, 0x7F	; 127
    19e0:	57 e4       	ldi	r21, 0x47	; 71
    19e2:	6e 81       	ldd	r22, Y+6	; 0x06
    19e4:	7f 81       	ldd	r23, Y+7	; 0x07
    19e6:	88 85       	ldd	r24, Y+8	; 0x08
    19e8:	99 85       	ldd	r25, Y+9	; 0x09
    19ea:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    19ee:	18 16       	cp	r1, r24
    19f0:	4c f5       	brge	.+82     	; 0x1a44 <LCD_Void_Write_Blinking_String+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19f2:	20 e0       	ldi	r18, 0x00	; 0
    19f4:	30 e0       	ldi	r19, 0x00	; 0
    19f6:	40 e2       	ldi	r20, 0x20	; 32
    19f8:	51 e4       	ldi	r21, 0x41	; 65
    19fa:	6a 81       	ldd	r22, Y+2	; 0x02
    19fc:	7b 81       	ldd	r23, Y+3	; 0x03
    19fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1a00:	9d 81       	ldd	r25, Y+5	; 0x05
    1a02:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1a06:	dc 01       	movw	r26, r24
    1a08:	cb 01       	movw	r24, r22
    1a0a:	bc 01       	movw	r22, r24
    1a0c:	cd 01       	movw	r24, r26
    1a0e:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1a12:	dc 01       	movw	r26, r24
    1a14:	cb 01       	movw	r24, r22
    1a16:	9b 87       	std	Y+11, r25	; 0x0b
    1a18:	8a 87       	std	Y+10, r24	; 0x0a
    1a1a:	0f c0       	rjmp	.+30     	; 0x1a3a <LCD_Void_Write_Blinking_String+0xe4>
    1a1c:	88 ec       	ldi	r24, 0xC8	; 200
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	9d 87       	std	Y+13, r25	; 0x0d
    1a22:	8c 87       	std	Y+12, r24	; 0x0c
    1a24:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a26:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a28:	01 97       	sbiw	r24, 0x01	; 1
    1a2a:	f1 f7       	brne	.-4      	; 0x1a28 <LCD_Void_Write_Blinking_String+0xd2>
    1a2c:	9d 87       	std	Y+13, r25	; 0x0d
    1a2e:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a30:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a32:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a34:	01 97       	sbiw	r24, 0x01	; 1
    1a36:	9b 87       	std	Y+11, r25	; 0x0b
    1a38:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a3a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a3c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a3e:	89 2b       	or	r24, r25
    1a40:	69 f7       	brne	.-38     	; 0x1a1c <LCD_Void_Write_Blinking_String+0xc6>
    1a42:	14 c0       	rjmp	.+40     	; 0x1a6c <LCD_Void_Write_Blinking_String+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a44:	6e 81       	ldd	r22, Y+6	; 0x06
    1a46:	7f 81       	ldd	r23, Y+7	; 0x07
    1a48:	88 85       	ldd	r24, Y+8	; 0x08
    1a4a:	99 85       	ldd	r25, Y+9	; 0x09
    1a4c:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1a50:	dc 01       	movw	r26, r24
    1a52:	cb 01       	movw	r24, r22
    1a54:	9b 87       	std	Y+11, r25	; 0x0b
    1a56:	8a 87       	std	Y+10, r24	; 0x0a
    1a58:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a5a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a5c:	9f 87       	std	Y+15, r25	; 0x0f
    1a5e:	8e 87       	std	Y+14, r24	; 0x0e
    1a60:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a62:	9f 85       	ldd	r25, Y+15	; 0x0f
    1a64:	01 97       	sbiw	r24, 0x01	; 1
    1a66:	f1 f7       	brne	.-4      	; 0x1a64 <LCD_Void_Write_Blinking_String+0x10e>
    1a68:	9f 87       	std	Y+15, r25	; 0x0f
    1a6a:	8e 87       	std	Y+14, r24	; 0x0e
		_delay_ms(500);
		i++;
    1a6c:	89 81       	ldd	r24, Y+1	; 0x01
    1a6e:	8f 5f       	subi	r24, 0xFF	; 255
    1a70:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1a72:	89 81       	ldd	r24, Y+1	; 0x01
    1a74:	88 2f       	mov	r24, r24
    1a76:	90 e0       	ldi	r25, 0x00	; 0
    1a78:	28 89       	ldd	r18, Y+16	; 0x10
    1a7a:	39 89       	ldd	r19, Y+17	; 0x11
    1a7c:	82 0f       	add	r24, r18
    1a7e:	93 1f       	adc	r25, r19
    1a80:	fc 01       	movw	r30, r24
    1a82:	80 81       	ld	r24, Z
    1a84:	88 23       	and	r24, r24
    1a86:	09 f0       	breq	.+2      	; 0x1a8a <LCD_Void_Write_Blinking_String+0x134>
    1a88:	74 cf       	rjmp	.-280    	; 0x1972 <LCD_Void_Write_Blinking_String+0x1c>
	{
		LCD_Void_Write_Data(copy_string[i]);
		_delay_ms(500);
		i++;
	}
}
    1a8a:	00 00       	nop
    1a8c:	61 96       	adiw	r28, 0x11	; 17
    1a8e:	0f b6       	in	r0, 0x3f	; 63
    1a90:	f8 94       	cli
    1a92:	de bf       	out	0x3e, r29	; 62
    1a94:	0f be       	out	0x3f, r0	; 63
    1a96:	cd bf       	out	0x3d, r28	; 61
    1a98:	df 91       	pop	r29
    1a9a:	cf 91       	pop	r28
    1a9c:	08 95       	ret

00001a9e <LCD_Set_Block>:

void LCD_Set_Block(u8 copy_block_nb) // sets the ddram address to the block you want to write
{
    1a9e:	cf 93       	push	r28
    1aa0:	df 93       	push	r29
    1aa2:	1f 92       	push	r1
    1aa4:	cd b7       	in	r28, 0x3d	; 61
    1aa6:	de b7       	in	r29, 0x3e	; 62
    1aa8:	89 83       	std	Y+1, r24	; 0x01
	if(copy_block_nb<16)
    1aaa:	89 81       	ldd	r24, Y+1	; 0x01
    1aac:	80 31       	cpi	r24, 0x10	; 16
    1aae:	28 f4       	brcc	.+10     	; 0x1aba <LCD_Set_Block+0x1c>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	80 58       	subi	r24, 0x80	; 128
    1ab4:	0e 94 b4 07 	call	0xf68	; 0xf68 <LCD_Void_Write_Cmd>
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
	}
}
    1ab8:	04 c0       	rjmp	.+8      	; 0x1ac2 <LCD_Set_Block+0x24>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
    1abc:	80 55       	subi	r24, 0x50	; 80
    1abe:	0e 94 b4 07 	call	0xf68	; 0xf68 <LCD_Void_Write_Cmd>
	}
}
    1ac2:	00 00       	nop
    1ac4:	0f 90       	pop	r0
    1ac6:	df 91       	pop	r29
    1ac8:	cf 91       	pop	r28
    1aca:	08 95       	ret

00001acc <LCD_Void_Write_Moving_String>:

void LCD_Void_Write_Moving_String(u8* copy_string)
{
    1acc:	cf 93       	push	r28
    1ace:	df 93       	push	r29
    1ad0:	cd b7       	in	r28, 0x3d	; 61
    1ad2:	de b7       	in	r29, 0x3e	; 62
    1ad4:	63 97       	sbiw	r28, 0x13	; 19
    1ad6:	0f b6       	in	r0, 0x3f	; 63
    1ad8:	f8 94       	cli
    1ada:	de bf       	out	0x3e, r29	; 62
    1adc:	0f be       	out	0x3f, r0	; 63
    1ade:	cd bf       	out	0x3d, r28	; 61
    1ae0:	9b 8b       	std	Y+19, r25	; 0x13
    1ae2:	8a 8b       	std	Y+18, r24	; 0x12
	u8 i;
	for (int j = 0; j<5 ;j++)
    1ae4:	1b 82       	std	Y+3, r1	; 0x03
    1ae6:	1a 82       	std	Y+2, r1	; 0x02
    1ae8:	97 c0       	rjmp	.+302    	; 0x1c18 <LCD_Void_Write_Moving_String+0x14c>
	{
		LCD_Set_Block(j);
    1aea:	8a 81       	ldd	r24, Y+2	; 0x02
    1aec:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_Set_Block>
		i = 0;
    1af0:	19 82       	std	Y+1, r1	; 0x01
		while(copy_string[i] != '\0')
    1af2:	0e c0       	rjmp	.+28     	; 0x1b10 <LCD_Void_Write_Moving_String+0x44>
		{

			LCD_Void_Write_Data(copy_string[i]);
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	88 2f       	mov	r24, r24
    1af8:	90 e0       	ldi	r25, 0x00	; 0
    1afa:	2a 89       	ldd	r18, Y+18	; 0x12
    1afc:	3b 89       	ldd	r19, Y+19	; 0x13
    1afe:	82 0f       	add	r24, r18
    1b00:	93 1f       	adc	r25, r19
    1b02:	fc 01       	movw	r30, r24
    1b04:	80 81       	ld	r24, Z
    1b06:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
			i++;
    1b0a:	89 81       	ldd	r24, Y+1	; 0x01
    1b0c:	8f 5f       	subi	r24, 0xFF	; 255
    1b0e:	89 83       	std	Y+1, r24	; 0x01
	u8 i;
	for (int j = 0; j<5 ;j++)
	{
		LCD_Set_Block(j);
		i = 0;
		while(copy_string[i] != '\0')
    1b10:	89 81       	ldd	r24, Y+1	; 0x01
    1b12:	88 2f       	mov	r24, r24
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	2a 89       	ldd	r18, Y+18	; 0x12
    1b18:	3b 89       	ldd	r19, Y+19	; 0x13
    1b1a:	82 0f       	add	r24, r18
    1b1c:	93 1f       	adc	r25, r19
    1b1e:	fc 01       	movw	r30, r24
    1b20:	80 81       	ld	r24, Z
    1b22:	88 23       	and	r24, r24
    1b24:	39 f7       	brne	.-50     	; 0x1af4 <LCD_Void_Write_Moving_String+0x28>
    1b26:	80 e0       	ldi	r24, 0x00	; 0
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	aa e7       	ldi	r26, 0x7A	; 122
    1b2c:	b4 e4       	ldi	r27, 0x44	; 68
    1b2e:	8c 83       	std	Y+4, r24	; 0x04
    1b30:	9d 83       	std	Y+5, r25	; 0x05
    1b32:	ae 83       	std	Y+6, r26	; 0x06
    1b34:	bf 83       	std	Y+7, r27	; 0x07

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1b36:	20 e0       	ldi	r18, 0x00	; 0
    1b38:	30 e0       	ldi	r19, 0x00	; 0
    1b3a:	4a ef       	ldi	r20, 0xFA	; 250
    1b3c:	54 e4       	ldi	r21, 0x44	; 68
    1b3e:	6c 81       	ldd	r22, Y+4	; 0x04
    1b40:	7d 81       	ldd	r23, Y+5	; 0x05
    1b42:	8e 81       	ldd	r24, Y+6	; 0x06
    1b44:	9f 81       	ldd	r25, Y+7	; 0x07
    1b46:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1b4a:	dc 01       	movw	r26, r24
    1b4c:	cb 01       	movw	r24, r22
    1b4e:	88 87       	std	Y+8, r24	; 0x08
    1b50:	99 87       	std	Y+9, r25	; 0x09
    1b52:	aa 87       	std	Y+10, r26	; 0x0a
    1b54:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 e8       	ldi	r20, 0x80	; 128
    1b5c:	5f e3       	ldi	r21, 0x3F	; 63
    1b5e:	68 85       	ldd	r22, Y+8	; 0x08
    1b60:	79 85       	ldd	r23, Y+9	; 0x09
    1b62:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b64:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b66:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__cmpsf2>
    1b6a:	88 23       	and	r24, r24
    1b6c:	2c f4       	brge	.+10     	; 0x1b78 <LCD_Void_Write_Moving_String+0xac>
		__ticks = 1;
    1b6e:	81 e0       	ldi	r24, 0x01	; 1
    1b70:	90 e0       	ldi	r25, 0x00	; 0
    1b72:	9d 87       	std	Y+13, r25	; 0x0d
    1b74:	8c 87       	std	Y+12, r24	; 0x0c
    1b76:	3f c0       	rjmp	.+126    	; 0x1bf6 <LCD_Void_Write_Moving_String+0x12a>
	else if (__tmp > 65535)
    1b78:	20 e0       	ldi	r18, 0x00	; 0
    1b7a:	3f ef       	ldi	r19, 0xFF	; 255
    1b7c:	4f e7       	ldi	r20, 0x7F	; 127
    1b7e:	57 e4       	ldi	r21, 0x47	; 71
    1b80:	68 85       	ldd	r22, Y+8	; 0x08
    1b82:	79 85       	ldd	r23, Y+9	; 0x09
    1b84:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b86:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b88:	0e 94 6f 31 	call	0x62de	; 0x62de <__gesf2>
    1b8c:	18 16       	cp	r1, r24
    1b8e:	4c f5       	brge	.+82     	; 0x1be2 <LCD_Void_Write_Moving_String+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b90:	20 e0       	ldi	r18, 0x00	; 0
    1b92:	30 e0       	ldi	r19, 0x00	; 0
    1b94:	40 e2       	ldi	r20, 0x20	; 32
    1b96:	51 e4       	ldi	r21, 0x41	; 65
    1b98:	6c 81       	ldd	r22, Y+4	; 0x04
    1b9a:	7d 81       	ldd	r23, Y+5	; 0x05
    1b9c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b9e:	9f 81       	ldd	r25, Y+7	; 0x07
    1ba0:	0e 94 74 31 	call	0x62e8	; 0x62e8 <__mulsf3>
    1ba4:	dc 01       	movw	r26, r24
    1ba6:	cb 01       	movw	r24, r22
    1ba8:	bc 01       	movw	r22, r24
    1baa:	cd 01       	movw	r24, r26
    1bac:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1bb0:	dc 01       	movw	r26, r24
    1bb2:	cb 01       	movw	r24, r22
    1bb4:	9d 87       	std	Y+13, r25	; 0x0d
    1bb6:	8c 87       	std	Y+12, r24	; 0x0c
    1bb8:	0f c0       	rjmp	.+30     	; 0x1bd8 <LCD_Void_Write_Moving_String+0x10c>
    1bba:	88 ec       	ldi	r24, 0xC8	; 200
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	9f 87       	std	Y+15, r25	; 0x0f
    1bc0:	8e 87       	std	Y+14, r24	; 0x0e
    1bc2:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bc4:	9f 85       	ldd	r25, Y+15	; 0x0f
    1bc6:	01 97       	sbiw	r24, 0x01	; 1
    1bc8:	f1 f7       	brne	.-4      	; 0x1bc6 <LCD_Void_Write_Moving_String+0xfa>
    1bca:	9f 87       	std	Y+15, r25	; 0x0f
    1bcc:	8e 87       	std	Y+14, r24	; 0x0e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bce:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bd0:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bd2:	01 97       	sbiw	r24, 0x01	; 1
    1bd4:	9d 87       	std	Y+13, r25	; 0x0d
    1bd6:	8c 87       	std	Y+12, r24	; 0x0c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1bd8:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bda:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bdc:	89 2b       	or	r24, r25
    1bde:	69 f7       	brne	.-38     	; 0x1bba <LCD_Void_Write_Moving_String+0xee>
    1be0:	14 c0       	rjmp	.+40     	; 0x1c0a <LCD_Void_Write_Moving_String+0x13e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1be2:	68 85       	ldd	r22, Y+8	; 0x08
    1be4:	79 85       	ldd	r23, Y+9	; 0x09
    1be6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1be8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bea:	0e 94 cb 30 	call	0x6196	; 0x6196 <__fixunssfsi>
    1bee:	dc 01       	movw	r26, r24
    1bf0:	cb 01       	movw	r24, r22
    1bf2:	9d 87       	std	Y+13, r25	; 0x0d
    1bf4:	8c 87       	std	Y+12, r24	; 0x0c
    1bf6:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bf8:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bfa:	99 8b       	std	Y+17, r25	; 0x11
    1bfc:	88 8b       	std	Y+16, r24	; 0x10
    1bfe:	88 89       	ldd	r24, Y+16	; 0x10
    1c00:	99 89       	ldd	r25, Y+17	; 0x11
    1c02:	01 97       	sbiw	r24, 0x01	; 1
    1c04:	f1 f7       	brne	.-4      	; 0x1c02 <LCD_Void_Write_Moving_String+0x136>
    1c06:	99 8b       	std	Y+17, r25	; 0x11
    1c08:	88 8b       	std	Y+16, r24	; 0x10

			LCD_Void_Write_Data(copy_string[i]);
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
    1c0a:	0e 94 a0 0c 	call	0x1940	; 0x1940 <LCD_Void_Clear>
}

void LCD_Void_Write_Moving_String(u8* copy_string)
{
	u8 i;
	for (int j = 0; j<5 ;j++)
    1c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c10:	9b 81       	ldd	r25, Y+3	; 0x03
    1c12:	01 96       	adiw	r24, 0x01	; 1
    1c14:	9b 83       	std	Y+3, r25	; 0x03
    1c16:	8a 83       	std	Y+2, r24	; 0x02
    1c18:	8a 81       	ldd	r24, Y+2	; 0x02
    1c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c1c:	05 97       	sbiw	r24, 0x05	; 5
    1c1e:	0c f4       	brge	.+2      	; 0x1c22 <LCD_Void_Write_Moving_String+0x156>
    1c20:	64 cf       	rjmp	.-312    	; 0x1aea <LCD_Void_Write_Moving_String+0x1e>
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
	}
}
    1c22:	00 00       	nop
    1c24:	63 96       	adiw	r28, 0x13	; 19
    1c26:	0f b6       	in	r0, 0x3f	; 63
    1c28:	f8 94       	cli
    1c2a:	de bf       	out	0x3e, r29	; 62
    1c2c:	0f be       	out	0x3f, r0	; 63
    1c2e:	cd bf       	out	0x3d, r28	; 61
    1c30:	df 91       	pop	r29
    1c32:	cf 91       	pop	r28
    1c34:	08 95       	ret

00001c36 <LCD_Void_Write_CGRAM>:

void LCD_Void_Write_CGRAM(const u8 copy_rows[8],u8 copy_CGRAM_address)
{
    1c36:	cf 93       	push	r28
    1c38:	df 93       	push	r29
    1c3a:	00 d0       	rcall	.+0      	; 0x1c3c <LCD_Void_Write_CGRAM+0x6>
    1c3c:	00 d0       	rcall	.+0      	; 0x1c3e <LCD_Void_Write_CGRAM+0x8>
    1c3e:	1f 92       	push	r1
    1c40:	cd b7       	in	r28, 0x3d	; 61
    1c42:	de b7       	in	r29, 0x3e	; 62
    1c44:	9c 83       	std	Y+4, r25	; 0x04
    1c46:	8b 83       	std	Y+3, r24	; 0x03
    1c48:	6d 83       	std	Y+5, r22	; 0x05
	LCD_Void_Write_Cmd(0x40 + copy_CGRAM_address*8);
    1c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4c:	88 2f       	mov	r24, r24
    1c4e:	90 e0       	ldi	r25, 0x00	; 0
    1c50:	08 96       	adiw	r24, 0x08	; 8
    1c52:	88 0f       	add	r24, r24
    1c54:	88 0f       	add	r24, r24
    1c56:	88 0f       	add	r24, r24
    1c58:	0e 94 b4 07 	call	0xf68	; 0xf68 <LCD_Void_Write_Cmd>
	for(int i=0;i<8;i++)
    1c5c:	1a 82       	std	Y+2, r1	; 0x02
    1c5e:	19 82       	std	Y+1, r1	; 0x01
    1c60:	0f c0       	rjmp	.+30     	; 0x1c80 <LCD_Void_Write_CGRAM+0x4a>
	{
		LCD_Void_Write_Data(copy_rows[i]);
    1c62:	89 81       	ldd	r24, Y+1	; 0x01
    1c64:	9a 81       	ldd	r25, Y+2	; 0x02
    1c66:	2b 81       	ldd	r18, Y+3	; 0x03
    1c68:	3c 81       	ldd	r19, Y+4	; 0x04
    1c6a:	82 0f       	add	r24, r18
    1c6c:	93 1f       	adc	r25, r19
    1c6e:	fc 01       	movw	r30, r24
    1c70:	80 81       	ld	r24, Z
    1c72:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
}

void LCD_Void_Write_CGRAM(const u8 copy_rows[8],u8 copy_CGRAM_address)
{
	LCD_Void_Write_Cmd(0x40 + copy_CGRAM_address*8);
	for(int i=0;i<8;i++)
    1c76:	89 81       	ldd	r24, Y+1	; 0x01
    1c78:	9a 81       	ldd	r25, Y+2	; 0x02
    1c7a:	01 96       	adiw	r24, 0x01	; 1
    1c7c:	9a 83       	std	Y+2, r25	; 0x02
    1c7e:	89 83       	std	Y+1, r24	; 0x01
    1c80:	89 81       	ldd	r24, Y+1	; 0x01
    1c82:	9a 81       	ldd	r25, Y+2	; 0x02
    1c84:	08 97       	sbiw	r24, 0x08	; 8
    1c86:	6c f3       	brlt	.-38     	; 0x1c62 <LCD_Void_Write_CGRAM+0x2c>
	{
		LCD_Void_Write_Data(copy_rows[i]);
	}
}
    1c88:	00 00       	nop
    1c8a:	0f 90       	pop	r0
    1c8c:	0f 90       	pop	r0
    1c8e:	0f 90       	pop	r0
    1c90:	0f 90       	pop	r0
    1c92:	0f 90       	pop	r0
    1c94:	df 91       	pop	r29
    1c96:	cf 91       	pop	r28
    1c98:	08 95       	ret

00001c9a <LCD_Void_Write_Number>:

void LCD_Void_Write_Number(u32 Number)
{
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	00 d0       	rcall	.+0      	; 0x1ca0 <LCD_Void_Write_Number+0x6>
    1ca0:	00 d0       	rcall	.+0      	; 0x1ca2 <LCD_Void_Write_Number+0x8>
    1ca2:	1f 92       	push	r1
    1ca4:	cd b7       	in	r28, 0x3d	; 61
    1ca6:	de b7       	in	r29, 0x3e	; 62
    1ca8:	9d 83       	std	Y+5, r25	; 0x05
    1caa:	8c 83       	std	Y+4, r24	; 0x04
	u32 Reversed_Num = 0;
    1cac:	1a 82       	std	Y+2, r1	; 0x02
    1cae:	19 82       	std	Y+1, r1	; 0x01
	u8 count = 0;
    1cb0:	1b 82       	std	Y+3, r1	; 0x03
	while(Number > 0)
    1cb2:	3c c0       	rjmp	.+120    	; 0x1d2c <LCD_Void_Write_Number+0x92>
	{
		Reversed_Num = (Number%10) + (Reversed_Num*10);
    1cb4:	4c 81       	ldd	r20, Y+4	; 0x04
    1cb6:	5d 81       	ldd	r21, Y+5	; 0x05
    1cb8:	9a 01       	movw	r18, r20
    1cba:	ad ec       	ldi	r26, 0xCD	; 205
    1cbc:	bc ec       	ldi	r27, 0xCC	; 204
    1cbe:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <__umulhisi3>
    1cc2:	9c 01       	movw	r18, r24
    1cc4:	36 95       	lsr	r19
    1cc6:	27 95       	ror	r18
    1cc8:	36 95       	lsr	r19
    1cca:	27 95       	ror	r18
    1ccc:	36 95       	lsr	r19
    1cce:	27 95       	ror	r18
    1cd0:	c9 01       	movw	r24, r18
    1cd2:	88 0f       	add	r24, r24
    1cd4:	99 1f       	adc	r25, r25
    1cd6:	9c 01       	movw	r18, r24
    1cd8:	22 0f       	add	r18, r18
    1cda:	33 1f       	adc	r19, r19
    1cdc:	22 0f       	add	r18, r18
    1cde:	33 1f       	adc	r19, r19
    1ce0:	82 0f       	add	r24, r18
    1ce2:	93 1f       	adc	r25, r19
    1ce4:	9a 01       	movw	r18, r20
    1ce6:	28 1b       	sub	r18, r24
    1ce8:	39 0b       	sbc	r19, r25
    1cea:	89 81       	ldd	r24, Y+1	; 0x01
    1cec:	9a 81       	ldd	r25, Y+2	; 0x02
    1cee:	88 0f       	add	r24, r24
    1cf0:	99 1f       	adc	r25, r25
    1cf2:	ac 01       	movw	r20, r24
    1cf4:	44 0f       	add	r20, r20
    1cf6:	55 1f       	adc	r21, r21
    1cf8:	44 0f       	add	r20, r20
    1cfa:	55 1f       	adc	r21, r21
    1cfc:	84 0f       	add	r24, r20
    1cfe:	95 1f       	adc	r25, r21
    1d00:	82 0f       	add	r24, r18
    1d02:	93 1f       	adc	r25, r19
    1d04:	9a 83       	std	Y+2, r25	; 0x02
    1d06:	89 83       	std	Y+1, r24	; 0x01
		Number /= 10;
    1d08:	8c 81       	ldd	r24, Y+4	; 0x04
    1d0a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d0c:	9c 01       	movw	r18, r24
    1d0e:	ad ec       	ldi	r26, 0xCD	; 205
    1d10:	bc ec       	ldi	r27, 0xCC	; 204
    1d12:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <__umulhisi3>
    1d16:	96 95       	lsr	r25
    1d18:	87 95       	ror	r24
    1d1a:	96 95       	lsr	r25
    1d1c:	87 95       	ror	r24
    1d1e:	96 95       	lsr	r25
    1d20:	87 95       	ror	r24
    1d22:	9d 83       	std	Y+5, r25	; 0x05
    1d24:	8c 83       	std	Y+4, r24	; 0x04
		count ++;
    1d26:	8b 81       	ldd	r24, Y+3	; 0x03
    1d28:	8f 5f       	subi	r24, 0xFF	; 255
    1d2a:	8b 83       	std	Y+3, r24	; 0x03

void LCD_Void_Write_Number(u32 Number)
{
	u32 Reversed_Num = 0;
	u8 count = 0;
	while(Number > 0)
    1d2c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d2e:	9d 81       	ldd	r25, Y+5	; 0x05
    1d30:	89 2b       	or	r24, r25
    1d32:	09 f0       	breq	.+2      	; 0x1d36 <LCD_Void_Write_Number+0x9c>
    1d34:	bf cf       	rjmp	.-130    	; 0x1cb4 <LCD_Void_Write_Number+0x1a>
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1d36:	1d 82       	std	Y+5, r1	; 0x05
    1d38:	1c 82       	std	Y+4, r1	; 0x04
    1d3a:	31 c0       	rjmp	.+98     	; 0x1d9e <LCD_Void_Write_Number+0x104>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
    1d3c:	49 81       	ldd	r20, Y+1	; 0x01
    1d3e:	5a 81       	ldd	r21, Y+2	; 0x02
    1d40:	9a 01       	movw	r18, r20
    1d42:	ad ec       	ldi	r26, 0xCD	; 205
    1d44:	bc ec       	ldi	r27, 0xCC	; 204
    1d46:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <__umulhisi3>
    1d4a:	96 95       	lsr	r25
    1d4c:	87 95       	ror	r24
    1d4e:	96 95       	lsr	r25
    1d50:	87 95       	ror	r24
    1d52:	96 95       	lsr	r25
    1d54:	87 95       	ror	r24
    1d56:	88 0f       	add	r24, r24
    1d58:	99 1f       	adc	r25, r25
    1d5a:	9c 01       	movw	r18, r24
    1d5c:	22 0f       	add	r18, r18
    1d5e:	33 1f       	adc	r19, r19
    1d60:	22 0f       	add	r18, r18
    1d62:	33 1f       	adc	r19, r19
    1d64:	82 0f       	add	r24, r18
    1d66:	93 1f       	adc	r25, r19
    1d68:	9a 01       	movw	r18, r20
    1d6a:	28 1b       	sub	r18, r24
    1d6c:	39 0b       	sbc	r19, r25
    1d6e:	c9 01       	movw	r24, r18
    1d70:	80 5d       	subi	r24, 0xD0	; 208
    1d72:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
		Reversed_Num /= 10;
    1d76:	89 81       	ldd	r24, Y+1	; 0x01
    1d78:	9a 81       	ldd	r25, Y+2	; 0x02
    1d7a:	9c 01       	movw	r18, r24
    1d7c:	ad ec       	ldi	r26, 0xCD	; 205
    1d7e:	bc ec       	ldi	r27, 0xCC	; 204
    1d80:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <__umulhisi3>
    1d84:	96 95       	lsr	r25
    1d86:	87 95       	ror	r24
    1d88:	96 95       	lsr	r25
    1d8a:	87 95       	ror	r24
    1d8c:	96 95       	lsr	r25
    1d8e:	87 95       	ror	r24
    1d90:	9a 83       	std	Y+2, r25	; 0x02
    1d92:	89 83       	std	Y+1, r24	; 0x01
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1d94:	8c 81       	ldd	r24, Y+4	; 0x04
    1d96:	9d 81       	ldd	r25, Y+5	; 0x05
    1d98:	01 96       	adiw	r24, 0x01	; 1
    1d9a:	9d 83       	std	Y+5, r25	; 0x05
    1d9c:	8c 83       	std	Y+4, r24	; 0x04
    1d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1da0:	28 2f       	mov	r18, r24
    1da2:	30 e0       	ldi	r19, 0x00	; 0
    1da4:	8c 81       	ldd	r24, Y+4	; 0x04
    1da6:	9d 81       	ldd	r25, Y+5	; 0x05
    1da8:	82 17       	cp	r24, r18
    1daa:	93 07       	cpc	r25, r19
    1dac:	38 f2       	brcs	.-114    	; 0x1d3c <LCD_Void_Write_Number+0xa2>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
		Reversed_Num /= 10;
	}

}
    1dae:	00 00       	nop
    1db0:	0f 90       	pop	r0
    1db2:	0f 90       	pop	r0
    1db4:	0f 90       	pop	r0
    1db6:	0f 90       	pop	r0
    1db8:	0f 90       	pop	r0
    1dba:	df 91       	pop	r29
    1dbc:	cf 91       	pop	r28
    1dbe:	08 95       	ret

00001dc0 <LCD_Void_Write_Number_2>:


void LCD_Void_Write_Number_2(u8 Number)
{
    1dc0:	cf 93       	push	r28
    1dc2:	df 93       	push	r29
    1dc4:	1f 92       	push	r1
    1dc6:	cd b7       	in	r28, 0x3d	; 61
    1dc8:	de b7       	in	r29, 0x3e	; 62
    1dca:	89 83       	std	Y+1, r24	; 0x01

	LCD_Void_Write_Data((Number/10)+'0');
    1dcc:	99 81       	ldd	r25, Y+1	; 0x01
    1dce:	8d ec       	ldi	r24, 0xCD	; 205
    1dd0:	98 9f       	mul	r25, r24
    1dd2:	81 2d       	mov	r24, r1
    1dd4:	11 24       	eor	r1, r1
    1dd6:	86 95       	lsr	r24
    1dd8:	86 95       	lsr	r24
    1dda:	86 95       	lsr	r24
    1ddc:	80 5d       	subi	r24, 0xD0	; 208
    1dde:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>
	LCD_Void_Write_Data((Number%10)+'0');
    1de2:	99 81       	ldd	r25, Y+1	; 0x01
    1de4:	8d ec       	ldi	r24, 0xCD	; 205
    1de6:	98 9f       	mul	r25, r24
    1de8:	81 2d       	mov	r24, r1
    1dea:	11 24       	eor	r1, r1
    1dec:	86 95       	lsr	r24
    1dee:	86 95       	lsr	r24
    1df0:	86 95       	lsr	r24
    1df2:	88 0f       	add	r24, r24
    1df4:	28 2f       	mov	r18, r24
    1df6:	22 0f       	add	r18, r18
    1df8:	22 0f       	add	r18, r18
    1dfa:	82 0f       	add	r24, r18
    1dfc:	29 2f       	mov	r18, r25
    1dfe:	28 1b       	sub	r18, r24
    1e00:	82 2f       	mov	r24, r18
    1e02:	80 5d       	subi	r24, 0xD0	; 208
    1e04:	0e 94 c6 07 	call	0xf8c	; 0xf8c <LCD_Void_Write_Data>

}
    1e08:	00 00       	nop
    1e0a:	0f 90       	pop	r0
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	08 95       	ret

00001e12 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1e12:	cf 93       	push	r28
    1e14:	df 93       	push	r29
    1e16:	00 d0       	rcall	.+0      	; 0x1e18 <xEventGroupCreate+0x6>
    1e18:	cd b7       	in	r28, 0x3d	; 61
    1e1a:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1e1c:	8b e0       	ldi	r24, 0x0B	; 11
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <pvPortMalloc>
    1e24:	9a 83       	std	Y+2, r25	; 0x02
    1e26:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    1e28:	89 81       	ldd	r24, Y+1	; 0x01
    1e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e2c:	89 2b       	or	r24, r25
    1e2e:	51 f0       	breq	.+20     	; 0x1e44 <xEventGroupCreate+0x32>
		{
			pxEventBits->uxEventBits = 0;
    1e30:	89 81       	ldd	r24, Y+1	; 0x01
    1e32:	9a 81       	ldd	r25, Y+2	; 0x02
    1e34:	fc 01       	movw	r30, r24
    1e36:	11 82       	std	Z+1, r1	; 0x01
    1e38:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1e3a:	89 81       	ldd	r24, Y+1	; 0x01
    1e3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e3e:	02 96       	adiw	r24, 0x02	; 2
    1e40:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    1e44:	89 81       	ldd	r24, Y+1	; 0x01
    1e46:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1e48:	0f 90       	pop	r0
    1e4a:	0f 90       	pop	r0
    1e4c:	df 91       	pop	r29
    1e4e:	cf 91       	pop	r28
    1e50:	08 95       	ret

00001e52 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1e52:	cf 93       	push	r28
    1e54:	df 93       	push	r29
    1e56:	cd b7       	in	r28, 0x3d	; 61
    1e58:	de b7       	in	r29, 0x3e	; 62
    1e5a:	60 97       	sbiw	r28, 0x10	; 16
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	f8 94       	cli
    1e60:	de bf       	out	0x3e, r29	; 62
    1e62:	0f be       	out	0x3f, r0	; 63
    1e64:	cd bf       	out	0x3d, r28	; 61
    1e66:	9a 87       	std	Y+10, r25	; 0x0a
    1e68:	89 87       	std	Y+9, r24	; 0x09
    1e6a:	7c 87       	std	Y+12, r23	; 0x0c
    1e6c:	6b 87       	std	Y+11, r22	; 0x0b
    1e6e:	5e 87       	std	Y+14, r21	; 0x0e
    1e70:	4d 87       	std	Y+13, r20	; 0x0d
    1e72:	38 8b       	std	Y+16, r19	; 0x10
    1e74:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    1e76:	89 85       	ldd	r24, Y+9	; 0x09
    1e78:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e7a:	9c 83       	std	Y+4, r25	; 0x04
    1e7c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1e7e:	1d 82       	std	Y+5, r1	; 0x05
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1e80:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1e84:	8b 81       	ldd	r24, Y+3	; 0x03
    1e86:	9c 81       	ldd	r25, Y+4	; 0x04
    1e88:	fc 01       	movw	r30, r24
    1e8a:	80 81       	ld	r24, Z
    1e8c:	91 81       	ldd	r25, Z+1	; 0x01
    1e8e:	9f 83       	std	Y+7, r25	; 0x07
    1e90:	8e 83       	std	Y+6, r24	; 0x06

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1e92:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e94:	3c 85       	ldd	r19, Y+12	; 0x0c
    1e96:	89 85       	ldd	r24, Y+9	; 0x09
    1e98:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e9a:	b9 01       	movw	r22, r18
    1e9c:	0e 94 0b 11 	call	0x2216	; 0x2216 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1ea0:	2e 81       	ldd	r18, Y+6	; 0x06
    1ea2:	3f 81       	ldd	r19, Y+7	; 0x07
    1ea4:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ea6:	9c 85       	ldd	r25, Y+12	; 0x0c
    1ea8:	28 2b       	or	r18, r24
    1eaa:	39 2b       	or	r19, r25
    1eac:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eae:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eb0:	28 23       	and	r18, r24
    1eb2:	39 23       	and	r19, r25
    1eb4:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eb6:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eb8:	28 17       	cp	r18, r24
    1eba:	39 07       	cpc	r19, r25
    1ebc:	d9 f4       	brne	.+54     	; 0x1ef4 <xEventGroupSync+0xa2>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1ebe:	2e 81       	ldd	r18, Y+6	; 0x06
    1ec0:	3f 81       	ldd	r19, Y+7	; 0x07
    1ec2:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ec4:	9c 85       	ldd	r25, Y+12	; 0x0c
    1ec6:	82 2b       	or	r24, r18
    1ec8:	93 2b       	or	r25, r19
    1eca:	9a 83       	std	Y+2, r25	; 0x02
    1ecc:	89 83       	std	Y+1, r24	; 0x01

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1ece:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	20 81       	ld	r18, Z
    1ed6:	31 81       	ldd	r19, Z+1	; 0x01
    1ed8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eda:	9e 85       	ldd	r25, Y+14	; 0x0e
    1edc:	80 95       	com	r24
    1ede:	90 95       	com	r25
    1ee0:	28 23       	and	r18, r24
    1ee2:	39 23       	and	r19, r25
    1ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee8:	fc 01       	movw	r30, r24
    1eea:	31 83       	std	Z+1, r19	; 0x01
    1eec:	20 83       	st	Z, r18

			xTicksToWait = 0;
    1eee:	18 8a       	std	Y+16, r1	; 0x10
    1ef0:	1f 86       	std	Y+15, r1	; 0x0f
    1ef2:	1c c0       	rjmp	.+56     	; 0x1f2c <xEventGroupSync+0xda>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1ef4:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ef6:	98 89       	ldd	r25, Y+16	; 0x10
    1ef8:	89 2b       	or	r24, r25
    1efa:	79 f0       	breq	.+30     	; 0x1f1a <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1efc:	8d 85       	ldd	r24, Y+13	; 0x0d
    1efe:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f00:	9c 01       	movw	r18, r24
    1f02:	35 60       	ori	r19, 0x05	; 5
    1f04:	8b 81       	ldd	r24, Y+3	; 0x03
    1f06:	9c 81       	ldd	r25, Y+4	; 0x04
    1f08:	02 96       	adiw	r24, 0x02	; 2
    1f0a:	4f 85       	ldd	r20, Y+15	; 0x0f
    1f0c:	58 89       	ldd	r21, Y+16	; 0x10
    1f0e:	b9 01       	movw	r22, r18
    1f10:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1f14:	1a 82       	std	Y+2, r1	; 0x02
    1f16:	19 82       	std	Y+1, r1	; 0x01
    1f18:	09 c0       	rjmp	.+18     	; 0x1f2c <xEventGroupSync+0xda>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1e:	fc 01       	movw	r30, r24
    1f20:	80 81       	ld	r24, Z
    1f22:	91 81       	ldd	r25, Z+1	; 0x01
    1f24:	9a 83       	std	Y+2, r25	; 0x02
    1f26:	89 83       	std	Y+1, r24	; 0x01
				xTimeoutOccurred = pdTRUE;
    1f28:	81 e0       	ldi	r24, 0x01	; 1
    1f2a:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1f2c:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    1f30:	88 87       	std	Y+8, r24	; 0x08

	if( xTicksToWait != ( TickType_t ) 0 )
    1f32:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f34:	98 89       	ldd	r25, Y+16	; 0x10
    1f36:	89 2b       	or	r24, r25
    1f38:	09 f4       	brne	.+2      	; 0x1f3c <xEventGroupSync+0xea>
    1f3a:	3d c0       	rjmp	.+122    	; 0x1fb6 <xEventGroupSync+0x164>
	{
		if( xAlreadyYielded == pdFALSE )
    1f3c:	88 85       	ldd	r24, Y+8	; 0x08
    1f3e:	88 23       	and	r24, r24
    1f40:	11 f4       	brne	.+4      	; 0x1f46 <xEventGroupSync+0xf4>
		{
			portYIELD_WITHIN_API();
    1f42:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1f46:	0e 94 5c 2b 	call	0x56b8	; 0x56b8 <uxTaskResetEventItemValue>
    1f4a:	9a 83       	std	Y+2, r25	; 0x02
    1f4c:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1f4e:	89 81       	ldd	r24, Y+1	; 0x01
    1f50:	9a 81       	ldd	r25, Y+2	; 0x02
    1f52:	88 27       	eor	r24, r24
    1f54:	92 70       	andi	r25, 0x02	; 2
    1f56:	89 2b       	or	r24, r25
    1f58:	49 f5       	brne	.+82     	; 0x1fac <xEventGroupSync+0x15a>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1f60:	8b 81       	ldd	r24, Y+3	; 0x03
    1f62:	9c 81       	ldd	r25, Y+4	; 0x04
    1f64:	fc 01       	movw	r30, r24
    1f66:	80 81       	ld	r24, Z
    1f68:	91 81       	ldd	r25, Z+1	; 0x01
    1f6a:	9a 83       	std	Y+2, r25	; 0x02
    1f6c:	89 83       	std	Y+1, r24	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f6e:	29 81       	ldd	r18, Y+1	; 0x01
    1f70:	3a 81       	ldd	r19, Y+2	; 0x02
    1f72:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f74:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f76:	28 23       	and	r18, r24
    1f78:	39 23       	and	r19, r25
    1f7a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f7c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f7e:	28 17       	cp	r18, r24
    1f80:	39 07       	cpc	r19, r25
    1f82:	81 f4       	brne	.+32     	; 0x1fa4 <xEventGroupSync+0x152>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f84:	8b 81       	ldd	r24, Y+3	; 0x03
    1f86:	9c 81       	ldd	r25, Y+4	; 0x04
    1f88:	fc 01       	movw	r30, r24
    1f8a:	20 81       	ld	r18, Z
    1f8c:	31 81       	ldd	r19, Z+1	; 0x01
    1f8e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f90:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f92:	80 95       	com	r24
    1f94:	90 95       	com	r25
    1f96:	28 23       	and	r18, r24
    1f98:	39 23       	and	r19, r25
    1f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9e:	fc 01       	movw	r30, r24
    1fa0:	31 83       	std	Z+1, r19	; 0x01
    1fa2:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1fa4:	0f 90       	pop	r0
    1fa6:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1fa8:	81 e0       	ldi	r24, 0x01	; 1
    1faa:	8d 83       	std	Y+5, r24	; 0x05
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1fac:	89 81       	ldd	r24, Y+1	; 0x01
    1fae:	9a 81       	ldd	r25, Y+2	; 0x02
    1fb0:	99 27       	eor	r25, r25
    1fb2:	9a 83       	std	Y+2, r25	; 0x02
    1fb4:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1fb6:	89 81       	ldd	r24, Y+1	; 0x01
    1fb8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1fba:	60 96       	adiw	r28, 0x10	; 16
    1fbc:	0f b6       	in	r0, 0x3f	; 63
    1fbe:	f8 94       	cli
    1fc0:	de bf       	out	0x3e, r29	; 62
    1fc2:	0f be       	out	0x3f, r0	; 63
    1fc4:	cd bf       	out	0x3d, r28	; 61
    1fc6:	df 91       	pop	r29
    1fc8:	cf 91       	pop	r28
    1fca:	08 95       	ret

00001fcc <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1fcc:	0f 93       	push	r16
    1fce:	1f 93       	push	r17
    1fd0:	cf 93       	push	r28
    1fd2:	df 93       	push	r29
    1fd4:	cd b7       	in	r28, 0x3d	; 61
    1fd6:	de b7       	in	r29, 0x3e	; 62
    1fd8:	63 97       	sbiw	r28, 0x13	; 19
    1fda:	0f b6       	in	r0, 0x3f	; 63
    1fdc:	f8 94       	cli
    1fde:	de bf       	out	0x3e, r29	; 62
    1fe0:	0f be       	out	0x3f, r0	; 63
    1fe2:	cd bf       	out	0x3d, r28	; 61
    1fe4:	9d 87       	std	Y+13, r25	; 0x0d
    1fe6:	8c 87       	std	Y+12, r24	; 0x0c
    1fe8:	7f 87       	std	Y+15, r23	; 0x0f
    1fea:	6e 87       	std	Y+14, r22	; 0x0e
    1fec:	48 8b       	std	Y+16, r20	; 0x10
    1fee:	29 8b       	std	Y+17, r18	; 0x11
    1ff0:	1b 8b       	std	Y+19, r17	; 0x13
    1ff2:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    1ff4:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ff6:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ff8:	9e 83       	std	Y+6, r25	; 0x06
    1ffa:	8d 83       	std	Y+5, r24	; 0x05
EventBits_t uxReturn, uxControlBits = 0;
    1ffc:	1c 82       	std	Y+4, r1	; 0x04
    1ffe:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2000:	1f 82       	std	Y+7, r1	; 0x07
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2002:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2006:	8d 81       	ldd	r24, Y+5	; 0x05
    2008:	9e 81       	ldd	r25, Y+6	; 0x06
    200a:	fc 01       	movw	r30, r24
    200c:	80 81       	ld	r24, Z
    200e:	91 81       	ldd	r25, Z+1	; 0x01
    2010:	99 87       	std	Y+9, r25	; 0x09
    2012:	88 87       	std	Y+8, r24	; 0x08

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2014:	2e 85       	ldd	r18, Y+14	; 0x0e
    2016:	3f 85       	ldd	r19, Y+15	; 0x0f
    2018:	88 85       	ldd	r24, Y+8	; 0x08
    201a:	99 85       	ldd	r25, Y+9	; 0x09
    201c:	49 89       	ldd	r20, Y+17	; 0x11
    201e:	b9 01       	movw	r22, r18
    2020:	0e 94 38 12 	call	0x2470	; 0x2470 <prvTestWaitCondition>
    2024:	8a 87       	std	Y+10, r24	; 0x0a

		if( xWaitConditionMet != pdFALSE )
    2026:	8a 85       	ldd	r24, Y+10	; 0x0a
    2028:	88 23       	and	r24, r24
    202a:	d1 f0       	breq	.+52     	; 0x2060 <xEventGroupWaitBits+0x94>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    202c:	88 85       	ldd	r24, Y+8	; 0x08
    202e:	99 85       	ldd	r25, Y+9	; 0x09
    2030:	9a 83       	std	Y+2, r25	; 0x02
    2032:	89 83       	std	Y+1, r24	; 0x01
			xTicksToWait = ( TickType_t ) 0;
    2034:	1b 8a       	std	Y+19, r1	; 0x13
    2036:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2038:	88 89       	ldd	r24, Y+16	; 0x10
    203a:	88 23       	and	r24, r24
    203c:	e1 f1       	breq	.+120    	; 0x20b6 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    203e:	8d 81       	ldd	r24, Y+5	; 0x05
    2040:	9e 81       	ldd	r25, Y+6	; 0x06
    2042:	fc 01       	movw	r30, r24
    2044:	20 81       	ld	r18, Z
    2046:	31 81       	ldd	r19, Z+1	; 0x01
    2048:	8e 85       	ldd	r24, Y+14	; 0x0e
    204a:	9f 85       	ldd	r25, Y+15	; 0x0f
    204c:	80 95       	com	r24
    204e:	90 95       	com	r25
    2050:	28 23       	and	r18, r24
    2052:	39 23       	and	r19, r25
    2054:	8d 81       	ldd	r24, Y+5	; 0x05
    2056:	9e 81       	ldd	r25, Y+6	; 0x06
    2058:	fc 01       	movw	r30, r24
    205a:	31 83       	std	Z+1, r19	; 0x01
    205c:	20 83       	st	Z, r18
    205e:	2b c0       	rjmp	.+86     	; 0x20b6 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2060:	8a 89       	ldd	r24, Y+18	; 0x12
    2062:	9b 89       	ldd	r25, Y+19	; 0x13
    2064:	89 2b       	or	r24, r25
    2066:	39 f4       	brne	.+14     	; 0x2076 <xEventGroupWaitBits+0xaa>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2068:	88 85       	ldd	r24, Y+8	; 0x08
    206a:	99 85       	ldd	r25, Y+9	; 0x09
    206c:	9a 83       	std	Y+2, r25	; 0x02
    206e:	89 83       	std	Y+1, r24	; 0x01
			xTimeoutOccurred = pdTRUE;
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	8f 83       	std	Y+7, r24	; 0x07
    2074:	20 c0       	rjmp	.+64     	; 0x20b6 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2076:	88 89       	ldd	r24, Y+16	; 0x10
    2078:	88 23       	and	r24, r24
    207a:	29 f0       	breq	.+10     	; 0x2086 <xEventGroupWaitBits+0xba>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    207c:	8b 81       	ldd	r24, Y+3	; 0x03
    207e:	9c 81       	ldd	r25, Y+4	; 0x04
    2080:	91 60       	ori	r25, 0x01	; 1
    2082:	9c 83       	std	Y+4, r25	; 0x04
    2084:	8b 83       	std	Y+3, r24	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2086:	89 89       	ldd	r24, Y+17	; 0x11
    2088:	88 23       	and	r24, r24
    208a:	29 f0       	breq	.+10     	; 0x2096 <xEventGroupWaitBits+0xca>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    208c:	8b 81       	ldd	r24, Y+3	; 0x03
    208e:	9c 81       	ldd	r25, Y+4	; 0x04
    2090:	94 60       	ori	r25, 0x04	; 4
    2092:	9c 83       	std	Y+4, r25	; 0x04
    2094:	8b 83       	std	Y+3, r24	; 0x03
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2096:	2e 85       	ldd	r18, Y+14	; 0x0e
    2098:	3f 85       	ldd	r19, Y+15	; 0x0f
    209a:	8b 81       	ldd	r24, Y+3	; 0x03
    209c:	9c 81       	ldd	r25, Y+4	; 0x04
    209e:	28 2b       	or	r18, r24
    20a0:	39 2b       	or	r19, r25
    20a2:	8d 81       	ldd	r24, Y+5	; 0x05
    20a4:	9e 81       	ldd	r25, Y+6	; 0x06
    20a6:	02 96       	adiw	r24, 0x02	; 2
    20a8:	4a 89       	ldd	r20, Y+18	; 0x12
    20aa:	5b 89       	ldd	r21, Y+19	; 0x13
    20ac:	b9 01       	movw	r22, r18
    20ae:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    20b2:	1a 82       	std	Y+2, r1	; 0x02
    20b4:	19 82       	std	Y+1, r1	; 0x01

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    20b6:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    20ba:	8b 87       	std	Y+11, r24	; 0x0b

	if( xTicksToWait != ( TickType_t ) 0 )
    20bc:	8a 89       	ldd	r24, Y+18	; 0x12
    20be:	9b 89       	ldd	r25, Y+19	; 0x13
    20c0:	89 2b       	or	r24, r25
    20c2:	09 f4       	brne	.+2      	; 0x20c6 <xEventGroupWaitBits+0xfa>
    20c4:	3f c0       	rjmp	.+126    	; 0x2144 <xEventGroupWaitBits+0x178>
	{
		if( xAlreadyYielded == pdFALSE )
    20c6:	8b 85       	ldd	r24, Y+11	; 0x0b
    20c8:	88 23       	and	r24, r24
    20ca:	11 f4       	brne	.+4      	; 0x20d0 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    20cc:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    20d0:	0e 94 5c 2b 	call	0x56b8	; 0x56b8 <uxTaskResetEventItemValue>
    20d4:	9a 83       	std	Y+2, r25	; 0x02
    20d6:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    20d8:	89 81       	ldd	r24, Y+1	; 0x01
    20da:	9a 81       	ldd	r25, Y+2	; 0x02
    20dc:	88 27       	eor	r24, r24
    20de:	92 70       	andi	r25, 0x02	; 2
    20e0:	89 2b       	or	r24, r25
    20e2:	59 f5       	brne	.+86     	; 0x213a <xEventGroupWaitBits+0x16e>
		{
			taskENTER_CRITICAL();
    20e4:	0f b6       	in	r0, 0x3f	; 63
    20e6:	f8 94       	cli
    20e8:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    20ea:	8d 81       	ldd	r24, Y+5	; 0x05
    20ec:	9e 81       	ldd	r25, Y+6	; 0x06
    20ee:	fc 01       	movw	r30, r24
    20f0:	80 81       	ld	r24, Z
    20f2:	91 81       	ldd	r25, Z+1	; 0x01
    20f4:	9a 83       	std	Y+2, r25	; 0x02
    20f6:	89 83       	std	Y+1, r24	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    20f8:	2e 85       	ldd	r18, Y+14	; 0x0e
    20fa:	3f 85       	ldd	r19, Y+15	; 0x0f
    20fc:	89 81       	ldd	r24, Y+1	; 0x01
    20fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2100:	49 89       	ldd	r20, Y+17	; 0x11
    2102:	b9 01       	movw	r22, r18
    2104:	0e 94 38 12 	call	0x2470	; 0x2470 <prvTestWaitCondition>
    2108:	88 23       	and	r24, r24
    210a:	99 f0       	breq	.+38     	; 0x2132 <xEventGroupWaitBits+0x166>
				{
					if( xClearOnExit != pdFALSE )
    210c:	88 89       	ldd	r24, Y+16	; 0x10
    210e:	88 23       	and	r24, r24
    2110:	81 f0       	breq	.+32     	; 0x2132 <xEventGroupWaitBits+0x166>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2112:	8d 81       	ldd	r24, Y+5	; 0x05
    2114:	9e 81       	ldd	r25, Y+6	; 0x06
    2116:	fc 01       	movw	r30, r24
    2118:	20 81       	ld	r18, Z
    211a:	31 81       	ldd	r19, Z+1	; 0x01
    211c:	8e 85       	ldd	r24, Y+14	; 0x0e
    211e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2120:	80 95       	com	r24
    2122:	90 95       	com	r25
    2124:	28 23       	and	r18, r24
    2126:	39 23       	and	r19, r25
    2128:	8d 81       	ldd	r24, Y+5	; 0x05
    212a:	9e 81       	ldd	r25, Y+6	; 0x06
    212c:	fc 01       	movw	r30, r24
    212e:	31 83       	std	Z+1, r19	; 0x01
    2130:	20 83       	st	Z, r18
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    2132:	81 e0       	ldi	r24, 0x01	; 1
    2134:	8f 83       	std	Y+7, r24	; 0x07
			}
			taskEXIT_CRITICAL();
    2136:	0f 90       	pop	r0
    2138:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	99 27       	eor	r25, r25
    2140:	9a 83       	std	Y+2, r25	; 0x02
    2142:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2144:	89 81       	ldd	r24, Y+1	; 0x01
    2146:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2148:	63 96       	adiw	r28, 0x13	; 19
    214a:	0f b6       	in	r0, 0x3f	; 63
    214c:	f8 94       	cli
    214e:	de bf       	out	0x3e, r29	; 62
    2150:	0f be       	out	0x3f, r0	; 63
    2152:	cd bf       	out	0x3d, r28	; 61
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	1f 91       	pop	r17
    215a:	0f 91       	pop	r16
    215c:	08 95       	ret

0000215e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    215e:	cf 93       	push	r28
    2160:	df 93       	push	r29
    2162:	cd b7       	in	r28, 0x3d	; 61
    2164:	de b7       	in	r29, 0x3e	; 62
    2166:	28 97       	sbiw	r28, 0x08	; 8
    2168:	0f b6       	in	r0, 0x3f	; 63
    216a:	f8 94       	cli
    216c:	de bf       	out	0x3e, r29	; 62
    216e:	0f be       	out	0x3f, r0	; 63
    2170:	cd bf       	out	0x3d, r28	; 61
    2172:	9e 83       	std	Y+6, r25	; 0x06
    2174:	8d 83       	std	Y+5, r24	; 0x05
    2176:	78 87       	std	Y+8, r23	; 0x08
    2178:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    217a:	8d 81       	ldd	r24, Y+5	; 0x05
    217c:	9e 81       	ldd	r25, Y+6	; 0x06
    217e:	9a 83       	std	Y+2, r25	; 0x02
    2180:	89 83       	std	Y+1, r24	; 0x01
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2182:	0f b6       	in	r0, 0x3f	; 63
    2184:	f8 94       	cli
    2186:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2188:	89 81       	ldd	r24, Y+1	; 0x01
    218a:	9a 81       	ldd	r25, Y+2	; 0x02
    218c:	fc 01       	movw	r30, r24
    218e:	80 81       	ld	r24, Z
    2190:	91 81       	ldd	r25, Z+1	; 0x01
    2192:	9c 83       	std	Y+4, r25	; 0x04
    2194:	8b 83       	std	Y+3, r24	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2196:	89 81       	ldd	r24, Y+1	; 0x01
    2198:	9a 81       	ldd	r25, Y+2	; 0x02
    219a:	fc 01       	movw	r30, r24
    219c:	20 81       	ld	r18, Z
    219e:	31 81       	ldd	r19, Z+1	; 0x01
    21a0:	8f 81       	ldd	r24, Y+7	; 0x07
    21a2:	98 85       	ldd	r25, Y+8	; 0x08
    21a4:	80 95       	com	r24
    21a6:	90 95       	com	r25
    21a8:	28 23       	and	r18, r24
    21aa:	39 23       	and	r19, r25
    21ac:	89 81       	ldd	r24, Y+1	; 0x01
    21ae:	9a 81       	ldd	r25, Y+2	; 0x02
    21b0:	fc 01       	movw	r30, r24
    21b2:	31 83       	std	Z+1, r19	; 0x01
    21b4:	20 83       	st	Z, r18
	}
	taskEXIT_CRITICAL();
    21b6:	0f 90       	pop	r0
    21b8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    21ba:	8b 81       	ldd	r24, Y+3	; 0x03
    21bc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    21be:	28 96       	adiw	r28, 0x08	; 8
    21c0:	0f b6       	in	r0, 0x3f	; 63
    21c2:	f8 94       	cli
    21c4:	de bf       	out	0x3e, r29	; 62
    21c6:	0f be       	out	0x3f, r0	; 63
    21c8:	cd bf       	out	0x3d, r28	; 61
    21ca:	df 91       	pop	r29
    21cc:	cf 91       	pop	r28
    21ce:	08 95       	ret

000021d0 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    21d0:	cf 93       	push	r28
    21d2:	df 93       	push	r29
    21d4:	cd b7       	in	r28, 0x3d	; 61
    21d6:	de b7       	in	r29, 0x3e	; 62
    21d8:	27 97       	sbiw	r28, 0x07	; 7
    21da:	0f b6       	in	r0, 0x3f	; 63
    21dc:	f8 94       	cli
    21de:	de bf       	out	0x3e, r29	; 62
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	cd bf       	out	0x3d, r28	; 61
    21e4:	9f 83       	std	Y+7, r25	; 0x07
    21e6:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    21e8:	8e 81       	ldd	r24, Y+6	; 0x06
    21ea:	9f 81       	ldd	r25, Y+7	; 0x07
    21ec:	9a 83       	std	Y+2, r25	; 0x02
    21ee:	89 83       	std	Y+1, r24	; 0x01
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21f0:	1b 82       	std	Y+3, r1	; 0x03
	{
		uxReturn = pxEventBits->uxEventBits;
    21f2:	89 81       	ldd	r24, Y+1	; 0x01
    21f4:	9a 81       	ldd	r25, Y+2	; 0x02
    21f6:	fc 01       	movw	r30, r24
    21f8:	80 81       	ld	r24, Z
    21fa:	91 81       	ldd	r25, Z+1	; 0x01
    21fc:	9d 83       	std	Y+5, r25	; 0x05
    21fe:	8c 83       	std	Y+4, r24	; 0x04
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2200:	8c 81       	ldd	r24, Y+4	; 0x04
    2202:	9d 81       	ldd	r25, Y+5	; 0x05
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2204:	27 96       	adiw	r28, 0x07	; 7
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	de bf       	out	0x3e, r29	; 62
    220c:	0f be       	out	0x3f, r0	; 63
    220e:	cd bf       	out	0x3d, r28	; 61
    2210:	df 91       	pop	r29
    2212:	cf 91       	pop	r28
    2214:	08 95       	ret

00002216 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2216:	cf 93       	push	r28
    2218:	df 93       	push	r29
    221a:	cd b7       	in	r28, 0x3d	; 61
    221c:	de b7       	in	r29, 0x3e	; 62
    221e:	65 97       	sbiw	r28, 0x15	; 21
    2220:	0f b6       	in	r0, 0x3f	; 63
    2222:	f8 94       	cli
    2224:	de bf       	out	0x3e, r29	; 62
    2226:	0f be       	out	0x3f, r0	; 63
    2228:	cd bf       	out	0x3d, r28	; 61
    222a:	9b 8b       	std	Y+19, r25	; 0x13
    222c:	8a 8b       	std	Y+18, r24	; 0x12
    222e:	7d 8b       	std	Y+21, r23	; 0x15
    2230:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2232:	1c 82       	std	Y+4, r1	; 0x04
    2234:	1b 82       	std	Y+3, r1	; 0x03
EventGroup_t *pxEventBits = xEventGroup;
    2236:	8a 89       	ldd	r24, Y+18	; 0x12
    2238:	9b 89       	ldd	r25, Y+19	; 0x13
    223a:	9f 83       	std	Y+7, r25	; 0x07
    223c:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xMatchFound = pdFALSE;
    223e:	1d 82       	std	Y+5, r1	; 0x05
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    2240:	8e 81       	ldd	r24, Y+6	; 0x06
    2242:	9f 81       	ldd	r25, Y+7	; 0x07
    2244:	02 96       	adiw	r24, 0x02	; 2
    2246:	99 87       	std	Y+9, r25	; 0x09
    2248:	88 87       	std	Y+8, r24	; 0x08
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    224a:	88 85       	ldd	r24, Y+8	; 0x08
    224c:	99 85       	ldd	r25, Y+9	; 0x09
    224e:	03 96       	adiw	r24, 0x03	; 3
    2250:	9b 87       	std	Y+11, r25	; 0x0b
    2252:	8a 87       	std	Y+10, r24	; 0x0a
	vTaskSuspendAll();
    2254:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2258:	88 85       	ldd	r24, Y+8	; 0x08
    225a:	99 85       	ldd	r25, Y+9	; 0x09
    225c:	fc 01       	movw	r30, r24
    225e:	85 81       	ldd	r24, Z+5	; 0x05
    2260:	96 81       	ldd	r25, Z+6	; 0x06
    2262:	9a 83       	std	Y+2, r25	; 0x02
    2264:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2266:	8e 81       	ldd	r24, Y+6	; 0x06
    2268:	9f 81       	ldd	r25, Y+7	; 0x07
    226a:	fc 01       	movw	r30, r24
    226c:	20 81       	ld	r18, Z
    226e:	31 81       	ldd	r19, Z+1	; 0x01
    2270:	8c 89       	ldd	r24, Y+20	; 0x14
    2272:	9d 89       	ldd	r25, Y+21	; 0x15
    2274:	28 2b       	or	r18, r24
    2276:	39 2b       	or	r19, r25
    2278:	8e 81       	ldd	r24, Y+6	; 0x06
    227a:	9f 81       	ldd	r25, Y+7	; 0x07
    227c:	fc 01       	movw	r30, r24
    227e:	31 83       	std	Z+1, r19	; 0x01
    2280:	20 83       	st	Z, r18

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2282:	5e c0       	rjmp	.+188    	; 0x2340 <xEventGroupSetBits+0x12a>
		{
			pxNext = listGET_NEXT( pxListItem );
    2284:	89 81       	ldd	r24, Y+1	; 0x01
    2286:	9a 81       	ldd	r25, Y+2	; 0x02
    2288:	fc 01       	movw	r30, r24
    228a:	82 81       	ldd	r24, Z+2	; 0x02
    228c:	93 81       	ldd	r25, Z+3	; 0x03
    228e:	9d 87       	std	Y+13, r25	; 0x0d
    2290:	8c 87       	std	Y+12, r24	; 0x0c
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2292:	89 81       	ldd	r24, Y+1	; 0x01
    2294:	9a 81       	ldd	r25, Y+2	; 0x02
    2296:	fc 01       	movw	r30, r24
    2298:	80 81       	ld	r24, Z
    229a:	91 81       	ldd	r25, Z+1	; 0x01
    229c:	9f 87       	std	Y+15, r25	; 0x0f
    229e:	8e 87       	std	Y+14, r24	; 0x0e
			xMatchFound = pdFALSE;
    22a0:	1d 82       	std	Y+5, r1	; 0x05

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    22a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    22a4:	9f 85       	ldd	r25, Y+15	; 0x0f
    22a6:	88 27       	eor	r24, r24
    22a8:	99 8b       	std	Y+17, r25	; 0x11
    22aa:	88 8b       	std	Y+16, r24	; 0x10
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    22ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    22ae:	9f 85       	ldd	r25, Y+15	; 0x0f
    22b0:	99 27       	eor	r25, r25
    22b2:	9f 87       	std	Y+15, r25	; 0x0f
    22b4:	8e 87       	std	Y+14, r24	; 0x0e

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    22b6:	88 89       	ldd	r24, Y+16	; 0x10
    22b8:	99 89       	ldd	r25, Y+17	; 0x11
    22ba:	88 27       	eor	r24, r24
    22bc:	94 70       	andi	r25, 0x04	; 4
    22be:	89 2b       	or	r24, r25
    22c0:	71 f4       	brne	.+28     	; 0x22de <xEventGroupSetBits+0xc8>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    22c2:	8e 81       	ldd	r24, Y+6	; 0x06
    22c4:	9f 81       	ldd	r25, Y+7	; 0x07
    22c6:	fc 01       	movw	r30, r24
    22c8:	20 81       	ld	r18, Z
    22ca:	31 81       	ldd	r19, Z+1	; 0x01
    22cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    22ce:	9f 85       	ldd	r25, Y+15	; 0x0f
    22d0:	82 23       	and	r24, r18
    22d2:	93 23       	and	r25, r19
    22d4:	89 2b       	or	r24, r25
    22d6:	99 f0       	breq	.+38     	; 0x22fe <xEventGroupSetBits+0xe8>
				{
					xMatchFound = pdTRUE;
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	8d 83       	std	Y+5, r24	; 0x05
    22dc:	10 c0       	rjmp	.+32     	; 0x22fe <xEventGroupSetBits+0xe8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    22de:	8e 81       	ldd	r24, Y+6	; 0x06
    22e0:	9f 81       	ldd	r25, Y+7	; 0x07
    22e2:	fc 01       	movw	r30, r24
    22e4:	20 81       	ld	r18, Z
    22e6:	31 81       	ldd	r19, Z+1	; 0x01
    22e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    22ea:	9f 85       	ldd	r25, Y+15	; 0x0f
    22ec:	28 23       	and	r18, r24
    22ee:	39 23       	and	r19, r25
    22f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    22f2:	9f 85       	ldd	r25, Y+15	; 0x0f
    22f4:	28 17       	cp	r18, r24
    22f6:	39 07       	cpc	r19, r25
    22f8:	11 f4       	brne	.+4      	; 0x22fe <xEventGroupSetBits+0xe8>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    22fa:	81 e0       	ldi	r24, 0x01	; 1
    22fc:	8d 83       	std	Y+5, r24	; 0x05
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    22fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2300:	88 23       	and	r24, r24
    2302:	d1 f0       	breq	.+52     	; 0x2338 <xEventGroupSetBits+0x122>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2304:	88 89       	ldd	r24, Y+16	; 0x10
    2306:	99 89       	ldd	r25, Y+17	; 0x11
    2308:	88 27       	eor	r24, r24
    230a:	91 70       	andi	r25, 0x01	; 1
    230c:	89 2b       	or	r24, r25
    230e:	41 f0       	breq	.+16     	; 0x2320 <xEventGroupSetBits+0x10a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    2310:	2b 81       	ldd	r18, Y+3	; 0x03
    2312:	3c 81       	ldd	r19, Y+4	; 0x04
    2314:	8e 85       	ldd	r24, Y+14	; 0x0e
    2316:	9f 85       	ldd	r25, Y+15	; 0x0f
    2318:	82 2b       	or	r24, r18
    231a:	93 2b       	or	r25, r19
    231c:	9c 83       	std	Y+4, r25	; 0x04
    231e:	8b 83       	std	Y+3, r24	; 0x03
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2320:	8e 81       	ldd	r24, Y+6	; 0x06
    2322:	9f 81       	ldd	r25, Y+7	; 0x07
    2324:	fc 01       	movw	r30, r24
    2326:	80 81       	ld	r24, Z
    2328:	91 81       	ldd	r25, Z+1	; 0x01
    232a:	9c 01       	movw	r18, r24
    232c:	32 60       	ori	r19, 0x02	; 2
    232e:	89 81       	ldd	r24, Y+1	; 0x01
    2330:	9a 81       	ldd	r25, Y+2	; 0x02
    2332:	b9 01       	movw	r22, r18
    2334:	0e 94 98 27 	call	0x4f30	; 0x4f30 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2338:	8c 85       	ldd	r24, Y+12	; 0x0c
    233a:	9d 85       	ldd	r25, Y+13	; 0x0d
    233c:	9a 83       	std	Y+2, r25	; 0x02
    233e:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2340:	29 81       	ldd	r18, Y+1	; 0x01
    2342:	3a 81       	ldd	r19, Y+2	; 0x02
    2344:	8a 85       	ldd	r24, Y+10	; 0x0a
    2346:	9b 85       	ldd	r25, Y+11	; 0x0b
    2348:	28 17       	cp	r18, r24
    234a:	39 07       	cpc	r19, r25
    234c:	09 f0       	breq	.+2      	; 0x2350 <xEventGroupSetBits+0x13a>
    234e:	9a cf       	rjmp	.-204    	; 0x2284 <xEventGroupSetBits+0x6e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2350:	8e 81       	ldd	r24, Y+6	; 0x06
    2352:	9f 81       	ldd	r25, Y+7	; 0x07
    2354:	fc 01       	movw	r30, r24
    2356:	20 81       	ld	r18, Z
    2358:	31 81       	ldd	r19, Z+1	; 0x01
    235a:	8b 81       	ldd	r24, Y+3	; 0x03
    235c:	9c 81       	ldd	r25, Y+4	; 0x04
    235e:	80 95       	com	r24
    2360:	90 95       	com	r25
    2362:	28 23       	and	r18, r24
    2364:	39 23       	and	r19, r25
    2366:	8e 81       	ldd	r24, Y+6	; 0x06
    2368:	9f 81       	ldd	r25, Y+7	; 0x07
    236a:	fc 01       	movw	r30, r24
    236c:	31 83       	std	Z+1, r19	; 0x01
    236e:	20 83       	st	Z, r18
	}
	( void ) xTaskResumeAll();
    2370:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    2374:	8e 81       	ldd	r24, Y+6	; 0x06
    2376:	9f 81       	ldd	r25, Y+7	; 0x07
    2378:	fc 01       	movw	r30, r24
    237a:	80 81       	ld	r24, Z
    237c:	91 81       	ldd	r25, Z+1	; 0x01
}
    237e:	65 96       	adiw	r28, 0x15	; 21
    2380:	0f b6       	in	r0, 0x3f	; 63
    2382:	f8 94       	cli
    2384:	de bf       	out	0x3e, r29	; 62
    2386:	0f be       	out	0x3f, r0	; 63
    2388:	cd bf       	out	0x3d, r28	; 61
    238a:	df 91       	pop	r29
    238c:	cf 91       	pop	r28
    238e:	08 95       	ret

00002390 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	00 d0       	rcall	.+0      	; 0x2396 <vEventGroupDelete+0x6>
    2396:	00 d0       	rcall	.+0      	; 0x2398 <vEventGroupDelete+0x8>
    2398:	00 d0       	rcall	.+0      	; 0x239a <vEventGroupDelete+0xa>
    239a:	cd b7       	in	r28, 0x3d	; 61
    239c:	de b7       	in	r29, 0x3e	; 62
    239e:	9e 83       	std	Y+6, r25	; 0x06
    23a0:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    23a2:	8d 81       	ldd	r24, Y+5	; 0x05
    23a4:	9e 81       	ldd	r25, Y+6	; 0x06
    23a6:	9a 83       	std	Y+2, r25	; 0x02
    23a8:	89 83       	std	Y+1, r24	; 0x01
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    23aa:	89 81       	ldd	r24, Y+1	; 0x01
    23ac:	9a 81       	ldd	r25, Y+2	; 0x02
    23ae:	02 96       	adiw	r24, 0x02	; 2
    23b0:	9c 83       	std	Y+4, r25	; 0x04
    23b2:	8b 83       	std	Y+3, r24	; 0x03

	vTaskSuspendAll();
    23b4:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    23b8:	09 c0       	rjmp	.+18     	; 0x23cc <vEventGroupDelete+0x3c>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    23ba:	8b 81       	ldd	r24, Y+3	; 0x03
    23bc:	9c 81       	ldd	r25, Y+4	; 0x04
    23be:	fc 01       	movw	r30, r24
    23c0:	85 81       	ldd	r24, Z+5	; 0x05
    23c2:	96 81       	ldd	r25, Z+6	; 0x06
    23c4:	60 e0       	ldi	r22, 0x00	; 0
    23c6:	72 e0       	ldi	r23, 0x02	; 2
    23c8:	0e 94 98 27 	call	0x4f30	; 0x4f30 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    23cc:	8b 81       	ldd	r24, Y+3	; 0x03
    23ce:	9c 81       	ldd	r25, Y+4	; 0x04
    23d0:	fc 01       	movw	r30, r24
    23d2:	80 81       	ld	r24, Z
    23d4:	88 23       	and	r24, r24
    23d6:	89 f7       	brne	.-30     	; 0x23ba <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    23d8:	89 81       	ldd	r24, Y+1	; 0x01
    23da:	9a 81       	ldd	r25, Y+2	; 0x02
    23dc:	0e 94 bf 12 	call	0x257e	; 0x257e <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    23e0:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
}
    23e4:	00 00       	nop
    23e6:	26 96       	adiw	r28, 0x06	; 6
    23e8:	0f b6       	in	r0, 0x3f	; 63
    23ea:	f8 94       	cli
    23ec:	de bf       	out	0x3e, r29	; 62
    23ee:	0f be       	out	0x3f, r0	; 63
    23f0:	cd bf       	out	0x3d, r28	; 61
    23f2:	df 91       	pop	r29
    23f4:	cf 91       	pop	r28
    23f6:	08 95       	ret

000023f8 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    23f8:	cf 93       	push	r28
    23fa:	df 93       	push	r29
    23fc:	00 d0       	rcall	.+0      	; 0x23fe <vEventGroupSetBitsCallback+0x6>
    23fe:	00 d0       	rcall	.+0      	; 0x2400 <vEventGroupSetBitsCallback+0x8>
    2400:	00 d0       	rcall	.+0      	; 0x2402 <vEventGroupSetBitsCallback+0xa>
    2402:	cd b7       	in	r28, 0x3d	; 61
    2404:	de b7       	in	r29, 0x3e	; 62
    2406:	9a 83       	std	Y+2, r25	; 0x02
    2408:	89 83       	std	Y+1, r24	; 0x01
    240a:	4b 83       	std	Y+3, r20	; 0x03
    240c:	5c 83       	std	Y+4, r21	; 0x04
    240e:	6d 83       	std	Y+5, r22	; 0x05
    2410:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2412:	2b 81       	ldd	r18, Y+3	; 0x03
    2414:	3c 81       	ldd	r19, Y+4	; 0x04
    2416:	89 81       	ldd	r24, Y+1	; 0x01
    2418:	9a 81       	ldd	r25, Y+2	; 0x02
    241a:	b9 01       	movw	r22, r18
    241c:	0e 94 0b 11 	call	0x2216	; 0x2216 <xEventGroupSetBits>
}
    2420:	00 00       	nop
    2422:	26 96       	adiw	r28, 0x06	; 6
    2424:	0f b6       	in	r0, 0x3f	; 63
    2426:	f8 94       	cli
    2428:	de bf       	out	0x3e, r29	; 62
    242a:	0f be       	out	0x3f, r0	; 63
    242c:	cd bf       	out	0x3d, r28	; 61
    242e:	df 91       	pop	r29
    2430:	cf 91       	pop	r28
    2432:	08 95       	ret

00002434 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    2434:	cf 93       	push	r28
    2436:	df 93       	push	r29
    2438:	00 d0       	rcall	.+0      	; 0x243a <vEventGroupClearBitsCallback+0x6>
    243a:	00 d0       	rcall	.+0      	; 0x243c <vEventGroupClearBitsCallback+0x8>
    243c:	00 d0       	rcall	.+0      	; 0x243e <vEventGroupClearBitsCallback+0xa>
    243e:	cd b7       	in	r28, 0x3d	; 61
    2440:	de b7       	in	r29, 0x3e	; 62
    2442:	9a 83       	std	Y+2, r25	; 0x02
    2444:	89 83       	std	Y+1, r24	; 0x01
    2446:	4b 83       	std	Y+3, r20	; 0x03
    2448:	5c 83       	std	Y+4, r21	; 0x04
    244a:	6d 83       	std	Y+5, r22	; 0x05
    244c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    244e:	2b 81       	ldd	r18, Y+3	; 0x03
    2450:	3c 81       	ldd	r19, Y+4	; 0x04
    2452:	89 81       	ldd	r24, Y+1	; 0x01
    2454:	9a 81       	ldd	r25, Y+2	; 0x02
    2456:	b9 01       	movw	r22, r18
    2458:	0e 94 af 10 	call	0x215e	; 0x215e <xEventGroupClearBits>
}
    245c:	00 00       	nop
    245e:	26 96       	adiw	r28, 0x06	; 6
    2460:	0f b6       	in	r0, 0x3f	; 63
    2462:	f8 94       	cli
    2464:	de bf       	out	0x3e, r29	; 62
    2466:	0f be       	out	0x3f, r0	; 63
    2468:	cd bf       	out	0x3d, r28	; 61
    246a:	df 91       	pop	r29
    246c:	cf 91       	pop	r28
    246e:	08 95       	ret

00002470 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    2470:	cf 93       	push	r28
    2472:	df 93       	push	r29
    2474:	00 d0       	rcall	.+0      	; 0x2476 <prvTestWaitCondition+0x6>
    2476:	00 d0       	rcall	.+0      	; 0x2478 <prvTestWaitCondition+0x8>
    2478:	00 d0       	rcall	.+0      	; 0x247a <prvTestWaitCondition+0xa>
    247a:	cd b7       	in	r28, 0x3d	; 61
    247c:	de b7       	in	r29, 0x3e	; 62
    247e:	9b 83       	std	Y+3, r25	; 0x03
    2480:	8a 83       	std	Y+2, r24	; 0x02
    2482:	7d 83       	std	Y+5, r23	; 0x05
    2484:	6c 83       	std	Y+4, r22	; 0x04
    2486:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    2488:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    248a:	8e 81       	ldd	r24, Y+6	; 0x06
    248c:	88 23       	and	r24, r24
    248e:	59 f4       	brne	.+22     	; 0x24a6 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2490:	2a 81       	ldd	r18, Y+2	; 0x02
    2492:	3b 81       	ldd	r19, Y+3	; 0x03
    2494:	8c 81       	ldd	r24, Y+4	; 0x04
    2496:	9d 81       	ldd	r25, Y+5	; 0x05
    2498:	82 23       	and	r24, r18
    249a:	93 23       	and	r25, r19
    249c:	89 2b       	or	r24, r25
    249e:	81 f0       	breq	.+32     	; 0x24c0 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    24a0:	81 e0       	ldi	r24, 0x01	; 1
    24a2:	89 83       	std	Y+1, r24	; 0x01
    24a4:	0d c0       	rjmp	.+26     	; 0x24c0 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    24a6:	2a 81       	ldd	r18, Y+2	; 0x02
    24a8:	3b 81       	ldd	r19, Y+3	; 0x03
    24aa:	8c 81       	ldd	r24, Y+4	; 0x04
    24ac:	9d 81       	ldd	r25, Y+5	; 0x05
    24ae:	28 23       	and	r18, r24
    24b0:	39 23       	and	r19, r25
    24b2:	8c 81       	ldd	r24, Y+4	; 0x04
    24b4:	9d 81       	ldd	r25, Y+5	; 0x05
    24b6:	28 17       	cp	r18, r24
    24b8:	39 07       	cpc	r19, r25
    24ba:	11 f4       	brne	.+4      	; 0x24c0 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    24c0:	89 81       	ldd	r24, Y+1	; 0x01
}
    24c2:	26 96       	adiw	r28, 0x06	; 6
    24c4:	0f b6       	in	r0, 0x3f	; 63
    24c6:	f8 94       	cli
    24c8:	de bf       	out	0x3e, r29	; 62
    24ca:	0f be       	out	0x3f, r0	; 63
    24cc:	cd bf       	out	0x3d, r28	; 61
    24ce:	df 91       	pop	r29
    24d0:	cf 91       	pop	r28
    24d2:	08 95       	ret

000024d4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    24d4:	cf 93       	push	r28
    24d6:	df 93       	push	r29
    24d8:	00 d0       	rcall	.+0      	; 0x24da <pvPortMalloc+0x6>
    24da:	00 d0       	rcall	.+0      	; 0x24dc <pvPortMalloc+0x8>
    24dc:	cd b7       	in	r28, 0x3d	; 61
    24de:	de b7       	in	r29, 0x3e	; 62
    24e0:	9c 83       	std	Y+4, r25	; 0x04
    24e2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    24e4:	1a 82       	std	Y+2, r1	; 0x02
    24e6:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    24e8:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    24ec:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <pucAlignedHeap.2085>
    24f0:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <pucAlignedHeap.2085+0x1>
    24f4:	89 2b       	or	r24, r25
    24f6:	31 f4       	brne	.+12     	; 0x2504 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    24f8:	88 ed       	ldi	r24, 0xD8	; 216
    24fa:	90 e0       	ldi	r25, 0x00	; 0
    24fc:	90 93 b6 06 	sts	0x06B6, r25	; 0x8006b6 <pucAlignedHeap.2085+0x1>
    2500:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2504:	20 91 b3 06 	lds	r18, 0x06B3	; 0x8006b3 <xNextFreeByte>
    2508:	30 91 b4 06 	lds	r19, 0x06B4	; 0x8006b4 <xNextFreeByte+0x1>
    250c:	8b 81       	ldd	r24, Y+3	; 0x03
    250e:	9c 81       	ldd	r25, Y+4	; 0x04
    2510:	82 0f       	add	r24, r18
    2512:	93 1f       	adc	r25, r19
    2514:	8b 3d       	cpi	r24, 0xDB	; 219
    2516:	95 40       	sbci	r25, 0x05	; 5
    2518:	38 f5       	brcc	.+78     	; 0x2568 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    251a:	20 91 b3 06 	lds	r18, 0x06B3	; 0x8006b3 <xNextFreeByte>
    251e:	30 91 b4 06 	lds	r19, 0x06B4	; 0x8006b4 <xNextFreeByte+0x1>
    2522:	8b 81       	ldd	r24, Y+3	; 0x03
    2524:	9c 81       	ldd	r25, Y+4	; 0x04
    2526:	28 0f       	add	r18, r24
    2528:	39 1f       	adc	r19, r25
    252a:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <xNextFreeByte>
    252e:	90 91 b4 06 	lds	r25, 0x06B4	; 0x8006b4 <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2532:	82 17       	cp	r24, r18
    2534:	93 07       	cpc	r25, r19
    2536:	c0 f4       	brcc	.+48     	; 0x2568 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2538:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <pucAlignedHeap.2085>
    253c:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <pucAlignedHeap.2085+0x1>
    2540:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <xNextFreeByte>
    2544:	90 91 b4 06 	lds	r25, 0x06B4	; 0x8006b4 <xNextFreeByte+0x1>
    2548:	82 0f       	add	r24, r18
    254a:	93 1f       	adc	r25, r19
    254c:	9a 83       	std	Y+2, r25	; 0x02
    254e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2550:	20 91 b3 06 	lds	r18, 0x06B3	; 0x8006b3 <xNextFreeByte>
    2554:	30 91 b4 06 	lds	r19, 0x06B4	; 0x8006b4 <xNextFreeByte+0x1>
    2558:	8b 81       	ldd	r24, Y+3	; 0x03
    255a:	9c 81       	ldd	r25, Y+4	; 0x04
    255c:	82 0f       	add	r24, r18
    255e:	93 1f       	adc	r25, r19
    2560:	90 93 b4 06 	sts	0x06B4, r25	; 0x8006b4 <xNextFreeByte+0x1>
    2564:	80 93 b3 06 	sts	0x06B3, r24	; 0x8006b3 <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2568:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    256c:	89 81       	ldd	r24, Y+1	; 0x01
    256e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2570:	0f 90       	pop	r0
    2572:	0f 90       	pop	r0
    2574:	0f 90       	pop	r0
    2576:	0f 90       	pop	r0
    2578:	df 91       	pop	r29
    257a:	cf 91       	pop	r28
    257c:	08 95       	ret

0000257e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    257e:	cf 93       	push	r28
    2580:	df 93       	push	r29
    2582:	00 d0       	rcall	.+0      	; 0x2584 <vPortFree+0x6>
    2584:	cd b7       	in	r28, 0x3d	; 61
    2586:	de b7       	in	r29, 0x3e	; 62
    2588:	9a 83       	std	Y+2, r25	; 0x02
    258a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    258c:	00 00       	nop
    258e:	0f 90       	pop	r0
    2590:	0f 90       	pop	r0
    2592:	df 91       	pop	r29
    2594:	cf 91       	pop	r28
    2596:	08 95       	ret

00002598 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2598:	cf 93       	push	r28
    259a:	df 93       	push	r29
    259c:	cd b7       	in	r28, 0x3d	; 61
    259e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    25a0:	10 92 b4 06 	sts	0x06B4, r1	; 0x8006b4 <xNextFreeByte+0x1>
    25a4:	10 92 b3 06 	sts	0x06B3, r1	; 0x8006b3 <xNextFreeByte>
}
    25a8:	00 00       	nop
    25aa:	df 91       	pop	r29
    25ac:	cf 91       	pop	r28
    25ae:	08 95       	ret

000025b0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    25b0:	cf 93       	push	r28
    25b2:	df 93       	push	r29
    25b4:	cd b7       	in	r28, 0x3d	; 61
    25b6:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    25b8:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <xNextFreeByte>
    25bc:	90 91 b4 06 	lds	r25, 0x06B4	; 0x8006b4 <xNextFreeByte+0x1>
    25c0:	2b ed       	ldi	r18, 0xDB	; 219
    25c2:	35 e0       	ldi	r19, 0x05	; 5
    25c4:	a9 01       	movw	r20, r18
    25c6:	48 1b       	sub	r20, r24
    25c8:	59 0b       	sbc	r21, r25
    25ca:	ca 01       	movw	r24, r20
}
    25cc:	df 91       	pop	r29
    25ce:	cf 91       	pop	r28
    25d0:	08 95       	ret

000025d2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    25d2:	cf 93       	push	r28
    25d4:	df 93       	push	r29
    25d6:	00 d0       	rcall	.+0      	; 0x25d8 <vListInitialise+0x6>
    25d8:	cd b7       	in	r28, 0x3d	; 61
    25da:	de b7       	in	r29, 0x3e	; 62
    25dc:	9a 83       	std	Y+2, r25	; 0x02
    25de:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    25e0:	89 81       	ldd	r24, Y+1	; 0x01
    25e2:	9a 81       	ldd	r25, Y+2	; 0x02
    25e4:	9c 01       	movw	r18, r24
    25e6:	2d 5f       	subi	r18, 0xFD	; 253
    25e8:	3f 4f       	sbci	r19, 0xFF	; 255
    25ea:	89 81       	ldd	r24, Y+1	; 0x01
    25ec:	9a 81       	ldd	r25, Y+2	; 0x02
    25ee:	fc 01       	movw	r30, r24
    25f0:	32 83       	std	Z+2, r19	; 0x02
    25f2:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    25f4:	89 81       	ldd	r24, Y+1	; 0x01
    25f6:	9a 81       	ldd	r25, Y+2	; 0x02
    25f8:	2f ef       	ldi	r18, 0xFF	; 255
    25fa:	3f ef       	ldi	r19, 0xFF	; 255
    25fc:	fc 01       	movw	r30, r24
    25fe:	34 83       	std	Z+4, r19	; 0x04
    2600:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2602:	89 81       	ldd	r24, Y+1	; 0x01
    2604:	9a 81       	ldd	r25, Y+2	; 0x02
    2606:	9c 01       	movw	r18, r24
    2608:	2d 5f       	subi	r18, 0xFD	; 253
    260a:	3f 4f       	sbci	r19, 0xFF	; 255
    260c:	89 81       	ldd	r24, Y+1	; 0x01
    260e:	9a 81       	ldd	r25, Y+2	; 0x02
    2610:	fc 01       	movw	r30, r24
    2612:	36 83       	std	Z+6, r19	; 0x06
    2614:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2616:	89 81       	ldd	r24, Y+1	; 0x01
    2618:	9a 81       	ldd	r25, Y+2	; 0x02
    261a:	9c 01       	movw	r18, r24
    261c:	2d 5f       	subi	r18, 0xFD	; 253
    261e:	3f 4f       	sbci	r19, 0xFF	; 255
    2620:	89 81       	ldd	r24, Y+1	; 0x01
    2622:	9a 81       	ldd	r25, Y+2	; 0x02
    2624:	fc 01       	movw	r30, r24
    2626:	30 87       	std	Z+8, r19	; 0x08
    2628:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    262a:	89 81       	ldd	r24, Y+1	; 0x01
    262c:	9a 81       	ldd	r25, Y+2	; 0x02
    262e:	fc 01       	movw	r30, r24
    2630:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2632:	00 00       	nop
    2634:	0f 90       	pop	r0
    2636:	0f 90       	pop	r0
    2638:	df 91       	pop	r29
    263a:	cf 91       	pop	r28
    263c:	08 95       	ret

0000263e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    263e:	cf 93       	push	r28
    2640:	df 93       	push	r29
    2642:	00 d0       	rcall	.+0      	; 0x2644 <vListInitialiseItem+0x6>
    2644:	cd b7       	in	r28, 0x3d	; 61
    2646:	de b7       	in	r29, 0x3e	; 62
    2648:	9a 83       	std	Y+2, r25	; 0x02
    264a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    264c:	89 81       	ldd	r24, Y+1	; 0x01
    264e:	9a 81       	ldd	r25, Y+2	; 0x02
    2650:	fc 01       	movw	r30, r24
    2652:	11 86       	std	Z+9, r1	; 0x09
    2654:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2656:	00 00       	nop
    2658:	0f 90       	pop	r0
    265a:	0f 90       	pop	r0
    265c:	df 91       	pop	r29
    265e:	cf 91       	pop	r28
    2660:	08 95       	ret

00002662 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2662:	cf 93       	push	r28
    2664:	df 93       	push	r29
    2666:	00 d0       	rcall	.+0      	; 0x2668 <vListInsertEnd+0x6>
    2668:	00 d0       	rcall	.+0      	; 0x266a <vListInsertEnd+0x8>
    266a:	00 d0       	rcall	.+0      	; 0x266c <vListInsertEnd+0xa>
    266c:	cd b7       	in	r28, 0x3d	; 61
    266e:	de b7       	in	r29, 0x3e	; 62
    2670:	9c 83       	std	Y+4, r25	; 0x04
    2672:	8b 83       	std	Y+3, r24	; 0x03
    2674:	7e 83       	std	Y+6, r23	; 0x06
    2676:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2678:	8b 81       	ldd	r24, Y+3	; 0x03
    267a:	9c 81       	ldd	r25, Y+4	; 0x04
    267c:	fc 01       	movw	r30, r24
    267e:	81 81       	ldd	r24, Z+1	; 0x01
    2680:	92 81       	ldd	r25, Z+2	; 0x02
    2682:	9a 83       	std	Y+2, r25	; 0x02
    2684:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2686:	8d 81       	ldd	r24, Y+5	; 0x05
    2688:	9e 81       	ldd	r25, Y+6	; 0x06
    268a:	29 81       	ldd	r18, Y+1	; 0x01
    268c:	3a 81       	ldd	r19, Y+2	; 0x02
    268e:	fc 01       	movw	r30, r24
    2690:	33 83       	std	Z+3, r19	; 0x03
    2692:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2694:	89 81       	ldd	r24, Y+1	; 0x01
    2696:	9a 81       	ldd	r25, Y+2	; 0x02
    2698:	fc 01       	movw	r30, r24
    269a:	24 81       	ldd	r18, Z+4	; 0x04
    269c:	35 81       	ldd	r19, Z+5	; 0x05
    269e:	8d 81       	ldd	r24, Y+5	; 0x05
    26a0:	9e 81       	ldd	r25, Y+6	; 0x06
    26a2:	fc 01       	movw	r30, r24
    26a4:	35 83       	std	Z+5, r19	; 0x05
    26a6:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	9a 81       	ldd	r25, Y+2	; 0x02
    26ac:	fc 01       	movw	r30, r24
    26ae:	84 81       	ldd	r24, Z+4	; 0x04
    26b0:	95 81       	ldd	r25, Z+5	; 0x05
    26b2:	2d 81       	ldd	r18, Y+5	; 0x05
    26b4:	3e 81       	ldd	r19, Y+6	; 0x06
    26b6:	fc 01       	movw	r30, r24
    26b8:	33 83       	std	Z+3, r19	; 0x03
    26ba:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	9a 81       	ldd	r25, Y+2	; 0x02
    26c0:	2d 81       	ldd	r18, Y+5	; 0x05
    26c2:	3e 81       	ldd	r19, Y+6	; 0x06
    26c4:	fc 01       	movw	r30, r24
    26c6:	35 83       	std	Z+5, r19	; 0x05
    26c8:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    26ca:	8d 81       	ldd	r24, Y+5	; 0x05
    26cc:	9e 81       	ldd	r25, Y+6	; 0x06
    26ce:	2b 81       	ldd	r18, Y+3	; 0x03
    26d0:	3c 81       	ldd	r19, Y+4	; 0x04
    26d2:	fc 01       	movw	r30, r24
    26d4:	31 87       	std	Z+9, r19	; 0x09
    26d6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    26d8:	8b 81       	ldd	r24, Y+3	; 0x03
    26da:	9c 81       	ldd	r25, Y+4	; 0x04
    26dc:	fc 01       	movw	r30, r24
    26de:	80 81       	ld	r24, Z
    26e0:	21 e0       	ldi	r18, 0x01	; 1
    26e2:	28 0f       	add	r18, r24
    26e4:	8b 81       	ldd	r24, Y+3	; 0x03
    26e6:	9c 81       	ldd	r25, Y+4	; 0x04
    26e8:	fc 01       	movw	r30, r24
    26ea:	20 83       	st	Z, r18
}
    26ec:	00 00       	nop
    26ee:	26 96       	adiw	r28, 0x06	; 6
    26f0:	0f b6       	in	r0, 0x3f	; 63
    26f2:	f8 94       	cli
    26f4:	de bf       	out	0x3e, r29	; 62
    26f6:	0f be       	out	0x3f, r0	; 63
    26f8:	cd bf       	out	0x3d, r28	; 61
    26fa:	df 91       	pop	r29
    26fc:	cf 91       	pop	r28
    26fe:	08 95       	ret

00002700 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2700:	cf 93       	push	r28
    2702:	df 93       	push	r29
    2704:	cd b7       	in	r28, 0x3d	; 61
    2706:	de b7       	in	r29, 0x3e	; 62
    2708:	28 97       	sbiw	r28, 0x08	; 8
    270a:	0f b6       	in	r0, 0x3f	; 63
    270c:	f8 94       	cli
    270e:	de bf       	out	0x3e, r29	; 62
    2710:	0f be       	out	0x3f, r0	; 63
    2712:	cd bf       	out	0x3d, r28	; 61
    2714:	9e 83       	std	Y+6, r25	; 0x06
    2716:	8d 83       	std	Y+5, r24	; 0x05
    2718:	78 87       	std	Y+8, r23	; 0x08
    271a:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    271c:	8f 81       	ldd	r24, Y+7	; 0x07
    271e:	98 85       	ldd	r25, Y+8	; 0x08
    2720:	fc 01       	movw	r30, r24
    2722:	80 81       	ld	r24, Z
    2724:	91 81       	ldd	r25, Z+1	; 0x01
    2726:	9c 83       	std	Y+4, r25	; 0x04
    2728:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    272a:	8b 81       	ldd	r24, Y+3	; 0x03
    272c:	9c 81       	ldd	r25, Y+4	; 0x04
    272e:	01 96       	adiw	r24, 0x01	; 1
    2730:	41 f4       	brne	.+16     	; 0x2742 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2732:	8d 81       	ldd	r24, Y+5	; 0x05
    2734:	9e 81       	ldd	r25, Y+6	; 0x06
    2736:	fc 01       	movw	r30, r24
    2738:	87 81       	ldd	r24, Z+7	; 0x07
    273a:	90 85       	ldd	r25, Z+8	; 0x08
    273c:	9a 83       	std	Y+2, r25	; 0x02
    273e:	89 83       	std	Y+1, r24	; 0x01
    2740:	1a c0       	rjmp	.+52     	; 0x2776 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2742:	8d 81       	ldd	r24, Y+5	; 0x05
    2744:	9e 81       	ldd	r25, Y+6	; 0x06
    2746:	03 96       	adiw	r24, 0x03	; 3
    2748:	9a 83       	std	Y+2, r25	; 0x02
    274a:	89 83       	std	Y+1, r24	; 0x01
    274c:	07 c0       	rjmp	.+14     	; 0x275c <vListInsert+0x5c>
    274e:	89 81       	ldd	r24, Y+1	; 0x01
    2750:	9a 81       	ldd	r25, Y+2	; 0x02
    2752:	fc 01       	movw	r30, r24
    2754:	82 81       	ldd	r24, Z+2	; 0x02
    2756:	93 81       	ldd	r25, Z+3	; 0x03
    2758:	9a 83       	std	Y+2, r25	; 0x02
    275a:	89 83       	std	Y+1, r24	; 0x01
    275c:	89 81       	ldd	r24, Y+1	; 0x01
    275e:	9a 81       	ldd	r25, Y+2	; 0x02
    2760:	fc 01       	movw	r30, r24
    2762:	82 81       	ldd	r24, Z+2	; 0x02
    2764:	93 81       	ldd	r25, Z+3	; 0x03
    2766:	fc 01       	movw	r30, r24
    2768:	20 81       	ld	r18, Z
    276a:	31 81       	ldd	r19, Z+1	; 0x01
    276c:	8b 81       	ldd	r24, Y+3	; 0x03
    276e:	9c 81       	ldd	r25, Y+4	; 0x04
    2770:	82 17       	cp	r24, r18
    2772:	93 07       	cpc	r25, r19
    2774:	60 f7       	brcc	.-40     	; 0x274e <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2776:	89 81       	ldd	r24, Y+1	; 0x01
    2778:	9a 81       	ldd	r25, Y+2	; 0x02
    277a:	fc 01       	movw	r30, r24
    277c:	22 81       	ldd	r18, Z+2	; 0x02
    277e:	33 81       	ldd	r19, Z+3	; 0x03
    2780:	8f 81       	ldd	r24, Y+7	; 0x07
    2782:	98 85       	ldd	r25, Y+8	; 0x08
    2784:	fc 01       	movw	r30, r24
    2786:	33 83       	std	Z+3, r19	; 0x03
    2788:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    278a:	8f 81       	ldd	r24, Y+7	; 0x07
    278c:	98 85       	ldd	r25, Y+8	; 0x08
    278e:	fc 01       	movw	r30, r24
    2790:	82 81       	ldd	r24, Z+2	; 0x02
    2792:	93 81       	ldd	r25, Z+3	; 0x03
    2794:	2f 81       	ldd	r18, Y+7	; 0x07
    2796:	38 85       	ldd	r19, Y+8	; 0x08
    2798:	fc 01       	movw	r30, r24
    279a:	35 83       	std	Z+5, r19	; 0x05
    279c:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    279e:	8f 81       	ldd	r24, Y+7	; 0x07
    27a0:	98 85       	ldd	r25, Y+8	; 0x08
    27a2:	29 81       	ldd	r18, Y+1	; 0x01
    27a4:	3a 81       	ldd	r19, Y+2	; 0x02
    27a6:	fc 01       	movw	r30, r24
    27a8:	35 83       	std	Z+5, r19	; 0x05
    27aa:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
    27ae:	9a 81       	ldd	r25, Y+2	; 0x02
    27b0:	2f 81       	ldd	r18, Y+7	; 0x07
    27b2:	38 85       	ldd	r19, Y+8	; 0x08
    27b4:	fc 01       	movw	r30, r24
    27b6:	33 83       	std	Z+3, r19	; 0x03
    27b8:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    27ba:	8f 81       	ldd	r24, Y+7	; 0x07
    27bc:	98 85       	ldd	r25, Y+8	; 0x08
    27be:	2d 81       	ldd	r18, Y+5	; 0x05
    27c0:	3e 81       	ldd	r19, Y+6	; 0x06
    27c2:	fc 01       	movw	r30, r24
    27c4:	31 87       	std	Z+9, r19	; 0x09
    27c6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    27c8:	8d 81       	ldd	r24, Y+5	; 0x05
    27ca:	9e 81       	ldd	r25, Y+6	; 0x06
    27cc:	fc 01       	movw	r30, r24
    27ce:	80 81       	ld	r24, Z
    27d0:	21 e0       	ldi	r18, 0x01	; 1
    27d2:	28 0f       	add	r18, r24
    27d4:	8d 81       	ldd	r24, Y+5	; 0x05
    27d6:	9e 81       	ldd	r25, Y+6	; 0x06
    27d8:	fc 01       	movw	r30, r24
    27da:	20 83       	st	Z, r18
}
    27dc:	00 00       	nop
    27de:	28 96       	adiw	r28, 0x08	; 8
    27e0:	0f b6       	in	r0, 0x3f	; 63
    27e2:	f8 94       	cli
    27e4:	de bf       	out	0x3e, r29	; 62
    27e6:	0f be       	out	0x3f, r0	; 63
    27e8:	cd bf       	out	0x3d, r28	; 61
    27ea:	df 91       	pop	r29
    27ec:	cf 91       	pop	r28
    27ee:	08 95       	ret

000027f0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    27f0:	cf 93       	push	r28
    27f2:	df 93       	push	r29
    27f4:	00 d0       	rcall	.+0      	; 0x27f6 <uxListRemove+0x6>
    27f6:	00 d0       	rcall	.+0      	; 0x27f8 <uxListRemove+0x8>
    27f8:	cd b7       	in	r28, 0x3d	; 61
    27fa:	de b7       	in	r29, 0x3e	; 62
    27fc:	9c 83       	std	Y+4, r25	; 0x04
    27fe:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2800:	8b 81       	ldd	r24, Y+3	; 0x03
    2802:	9c 81       	ldd	r25, Y+4	; 0x04
    2804:	fc 01       	movw	r30, r24
    2806:	80 85       	ldd	r24, Z+8	; 0x08
    2808:	91 85       	ldd	r25, Z+9	; 0x09
    280a:	9a 83       	std	Y+2, r25	; 0x02
    280c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    280e:	8b 81       	ldd	r24, Y+3	; 0x03
    2810:	9c 81       	ldd	r25, Y+4	; 0x04
    2812:	fc 01       	movw	r30, r24
    2814:	82 81       	ldd	r24, Z+2	; 0x02
    2816:	93 81       	ldd	r25, Z+3	; 0x03
    2818:	2b 81       	ldd	r18, Y+3	; 0x03
    281a:	3c 81       	ldd	r19, Y+4	; 0x04
    281c:	f9 01       	movw	r30, r18
    281e:	24 81       	ldd	r18, Z+4	; 0x04
    2820:	35 81       	ldd	r19, Z+5	; 0x05
    2822:	fc 01       	movw	r30, r24
    2824:	35 83       	std	Z+5, r19	; 0x05
    2826:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2828:	8b 81       	ldd	r24, Y+3	; 0x03
    282a:	9c 81       	ldd	r25, Y+4	; 0x04
    282c:	fc 01       	movw	r30, r24
    282e:	84 81       	ldd	r24, Z+4	; 0x04
    2830:	95 81       	ldd	r25, Z+5	; 0x05
    2832:	2b 81       	ldd	r18, Y+3	; 0x03
    2834:	3c 81       	ldd	r19, Y+4	; 0x04
    2836:	f9 01       	movw	r30, r18
    2838:	22 81       	ldd	r18, Z+2	; 0x02
    283a:	33 81       	ldd	r19, Z+3	; 0x03
    283c:	fc 01       	movw	r30, r24
    283e:	33 83       	std	Z+3, r19	; 0x03
    2840:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2842:	89 81       	ldd	r24, Y+1	; 0x01
    2844:	9a 81       	ldd	r25, Y+2	; 0x02
    2846:	fc 01       	movw	r30, r24
    2848:	21 81       	ldd	r18, Z+1	; 0x01
    284a:	32 81       	ldd	r19, Z+2	; 0x02
    284c:	8b 81       	ldd	r24, Y+3	; 0x03
    284e:	9c 81       	ldd	r25, Y+4	; 0x04
    2850:	28 17       	cp	r18, r24
    2852:	39 07       	cpc	r19, r25
    2854:	51 f4       	brne	.+20     	; 0x286a <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2856:	8b 81       	ldd	r24, Y+3	; 0x03
    2858:	9c 81       	ldd	r25, Y+4	; 0x04
    285a:	fc 01       	movw	r30, r24
    285c:	24 81       	ldd	r18, Z+4	; 0x04
    285e:	35 81       	ldd	r19, Z+5	; 0x05
    2860:	89 81       	ldd	r24, Y+1	; 0x01
    2862:	9a 81       	ldd	r25, Y+2	; 0x02
    2864:	fc 01       	movw	r30, r24
    2866:	32 83       	std	Z+2, r19	; 0x02
    2868:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    286a:	8b 81       	ldd	r24, Y+3	; 0x03
    286c:	9c 81       	ldd	r25, Y+4	; 0x04
    286e:	fc 01       	movw	r30, r24
    2870:	11 86       	std	Z+9, r1	; 0x09
    2872:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2874:	89 81       	ldd	r24, Y+1	; 0x01
    2876:	9a 81       	ldd	r25, Y+2	; 0x02
    2878:	fc 01       	movw	r30, r24
    287a:	80 81       	ld	r24, Z
    287c:	2f ef       	ldi	r18, 0xFF	; 255
    287e:	28 0f       	add	r18, r24
    2880:	89 81       	ldd	r24, Y+1	; 0x01
    2882:	9a 81       	ldd	r25, Y+2	; 0x02
    2884:	fc 01       	movw	r30, r24
    2886:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2888:	89 81       	ldd	r24, Y+1	; 0x01
    288a:	9a 81       	ldd	r25, Y+2	; 0x02
    288c:	fc 01       	movw	r30, r24
    288e:	80 81       	ld	r24, Z
}
    2890:	0f 90       	pop	r0
    2892:	0f 90       	pop	r0
    2894:	0f 90       	pop	r0
    2896:	0f 90       	pop	r0
    2898:	df 91       	pop	r29
    289a:	cf 91       	pop	r28
    289c:	08 95       	ret

0000289e <main>:
#include "avr/sleep.h"
#include "KBD_interface.h"


int main(void)
{
    289e:	ef 92       	push	r14
    28a0:	ff 92       	push	r15
    28a2:	0f 93       	push	r16
    28a4:	cf 93       	push	r28
    28a6:	df 93       	push	r29
    28a8:	cd b7       	in	r28, 0x3d	; 61
    28aa:	de b7       	in	r29, 0x3e	; 62
	LCD_initialize();
    28ac:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <LCD_initialize>
	LCD_Void_Clear();
    28b0:	0e 94 a0 0c 	call	0x1940	; 0x1940 <LCD_Void_Clear>
	Clock_Print_Default_Interface();
    28b4:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
	KBD_u8Initialize(GROUP_B);
    28b8:	81 e0       	ldi	r24, 0x01	; 1
    28ba:	0e 94 bc 05 	call	0xb78	; 0xb78 <KBD_u8Initialize>
	xTaskCreate(Clock_Second,"seconds",150,NULL,1,NULL);
    28be:	e1 2c       	mov	r14, r1
    28c0:	f1 2c       	mov	r15, r1
    28c2:	01 e0       	ldi	r16, 0x01	; 1
    28c4:	20 e0       	ldi	r18, 0x00	; 0
    28c6:	30 e0       	ldi	r19, 0x00	; 0
    28c8:	46 e9       	ldi	r20, 0x96	; 150
    28ca:	50 e0       	ldi	r21, 0x00	; 0
    28cc:	62 e8       	ldi	r22, 0x82	; 130
    28ce:	70 e0       	ldi	r23, 0x00	; 0
    28d0:	8c e6       	ldi	r24, 0x6C	; 108
    28d2:	90 e0       	ldi	r25, 0x00	; 0
    28d4:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <xTaskCreate>
	xTaskCreate(Clock_Minute,"minutes",150,NULL,1,NULL);
    28d8:	e1 2c       	mov	r14, r1
    28da:	f1 2c       	mov	r15, r1
    28dc:	01 e0       	ldi	r16, 0x01	; 1
    28de:	20 e0       	ldi	r18, 0x00	; 0
    28e0:	30 e0       	ldi	r19, 0x00	; 0
    28e2:	46 e9       	ldi	r20, 0x96	; 150
    28e4:	50 e0       	ldi	r21, 0x00	; 0
    28e6:	6a e8       	ldi	r22, 0x8A	; 138
    28e8:	70 e0       	ldi	r23, 0x00	; 0
    28ea:	89 eb       	ldi	r24, 0xB9	; 185
    28ec:	90 e0       	ldi	r25, 0x00	; 0
    28ee:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <xTaskCreate>
	xTaskCreate(Clock_Hours,"hours",150,NULL,1,NULL);
    28f2:	e1 2c       	mov	r14, r1
    28f4:	f1 2c       	mov	r15, r1
    28f6:	01 e0       	ldi	r16, 0x01	; 1
    28f8:	20 e0       	ldi	r18, 0x00	; 0
    28fa:	30 e0       	ldi	r19, 0x00	; 0
    28fc:	46 e9       	ldi	r20, 0x96	; 150
    28fe:	50 e0       	ldi	r21, 0x00	; 0
    2900:	62 e9       	ldi	r22, 0x92	; 146
    2902:	70 e0       	ldi	r23, 0x00	; 0
    2904:	8f ef       	ldi	r24, 0xFF	; 255
    2906:	90 e0       	ldi	r25, 0x00	; 0
    2908:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <xTaskCreate>
	xTaskCreate(Clock_Check_KPD,"KPD_check",150,NULL,1,NULL);
    290c:	e1 2c       	mov	r14, r1
    290e:	f1 2c       	mov	r15, r1
    2910:	01 e0       	ldi	r16, 0x01	; 1
    2912:	20 e0       	ldi	r18, 0x00	; 0
    2914:	30 e0       	ldi	r19, 0x00	; 0
    2916:	46 e9       	ldi	r20, 0x96	; 150
    2918:	50 e0       	ldi	r21, 0x00	; 0
    291a:	68 e9       	ldi	r22, 0x98	; 152
    291c:	70 e0       	ldi	r23, 0x00	; 0
    291e:	85 e5       	ldi	r24, 0x55	; 85
    2920:	91 e0       	ldi	r25, 0x01	; 1
    2922:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <xTaskCreate>
	xTaskCreate(Clock_Enter_Typing_Mode,"Enter typing mode",400,NULL,1,NULL);
    2926:	e1 2c       	mov	r14, r1
    2928:	f1 2c       	mov	r15, r1
    292a:	01 e0       	ldi	r16, 0x01	; 1
    292c:	20 e0       	ldi	r18, 0x00	; 0
    292e:	30 e0       	ldi	r19, 0x00	; 0
    2930:	40 e9       	ldi	r20, 0x90	; 144
    2932:	51 e0       	ldi	r21, 0x01	; 1
    2934:	62 ea       	ldi	r22, 0xA2	; 162
    2936:	70 e0       	ldi	r23, 0x00	; 0
    2938:	8c e8       	ldi	r24, 0x8C	; 140
    293a:	91 e0       	ldi	r25, 0x01	; 1
    293c:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <xTaskCreate>
	vTaskStartScheduler();
    2940:	0e 94 3b 24 	call	0x4876	; 0x4876 <vTaskStartScheduler>

	while(1)
	{

	}
    2944:	ff cf       	rjmp	.-2      	; 0x2944 <main+0xa6>

00002946 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2946:	cf 93       	push	r28
    2948:	df 93       	push	r29
    294a:	cd b7       	in	r28, 0x3d	; 61
    294c:	de b7       	in	r29, 0x3e	; 62
    294e:	28 97       	sbiw	r28, 0x08	; 8
    2950:	0f b6       	in	r0, 0x3f	; 63
    2952:	f8 94       	cli
    2954:	de bf       	out	0x3e, r29	; 62
    2956:	0f be       	out	0x3f, r0	; 63
    2958:	cd bf       	out	0x3d, r28	; 61
    295a:	9c 83       	std	Y+4, r25	; 0x04
    295c:	8b 83       	std	Y+3, r24	; 0x03
    295e:	7e 83       	std	Y+6, r23	; 0x06
    2960:	6d 83       	std	Y+5, r22	; 0x05
    2962:	58 87       	std	Y+8, r21	; 0x08
    2964:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2966:	8b 81       	ldd	r24, Y+3	; 0x03
    2968:	9c 81       	ldd	r25, Y+4	; 0x04
    296a:	21 e1       	ldi	r18, 0x11	; 17
    296c:	fc 01       	movw	r30, r24
    296e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2970:	8b 81       	ldd	r24, Y+3	; 0x03
    2972:	9c 81       	ldd	r25, Y+4	; 0x04
    2974:	01 97       	sbiw	r24, 0x01	; 1
    2976:	9c 83       	std	Y+4, r25	; 0x04
    2978:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    297a:	8b 81       	ldd	r24, Y+3	; 0x03
    297c:	9c 81       	ldd	r25, Y+4	; 0x04
    297e:	22 e2       	ldi	r18, 0x22	; 34
    2980:	fc 01       	movw	r30, r24
    2982:	20 83       	st	Z, r18
	pxTopOfStack--;
    2984:	8b 81       	ldd	r24, Y+3	; 0x03
    2986:	9c 81       	ldd	r25, Y+4	; 0x04
    2988:	01 97       	sbiw	r24, 0x01	; 1
    298a:	9c 83       	std	Y+4, r25	; 0x04
    298c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    298e:	8b 81       	ldd	r24, Y+3	; 0x03
    2990:	9c 81       	ldd	r25, Y+4	; 0x04
    2992:	23 e3       	ldi	r18, 0x33	; 51
    2994:	fc 01       	movw	r30, r24
    2996:	20 83       	st	Z, r18
	pxTopOfStack--;
    2998:	8b 81       	ldd	r24, Y+3	; 0x03
    299a:	9c 81       	ldd	r25, Y+4	; 0x04
    299c:	01 97       	sbiw	r24, 0x01	; 1
    299e:	9c 83       	std	Y+4, r25	; 0x04
    29a0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    29a2:	8d 81       	ldd	r24, Y+5	; 0x05
    29a4:	9e 81       	ldd	r25, Y+6	; 0x06
    29a6:	9a 83       	std	Y+2, r25	; 0x02
    29a8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29aa:	29 81       	ldd	r18, Y+1	; 0x01
    29ac:	8b 81       	ldd	r24, Y+3	; 0x03
    29ae:	9c 81       	ldd	r25, Y+4	; 0x04
    29b0:	fc 01       	movw	r30, r24
    29b2:	20 83       	st	Z, r18
	pxTopOfStack--;
    29b4:	8b 81       	ldd	r24, Y+3	; 0x03
    29b6:	9c 81       	ldd	r25, Y+4	; 0x04
    29b8:	01 97       	sbiw	r24, 0x01	; 1
    29ba:	9c 83       	std	Y+4, r25	; 0x04
    29bc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    29be:	89 81       	ldd	r24, Y+1	; 0x01
    29c0:	9a 81       	ldd	r25, Y+2	; 0x02
    29c2:	89 2f       	mov	r24, r25
    29c4:	99 27       	eor	r25, r25
    29c6:	9a 83       	std	Y+2, r25	; 0x02
    29c8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29ca:	29 81       	ldd	r18, Y+1	; 0x01
    29cc:	8b 81       	ldd	r24, Y+3	; 0x03
    29ce:	9c 81       	ldd	r25, Y+4	; 0x04
    29d0:	fc 01       	movw	r30, r24
    29d2:	20 83       	st	Z, r18
	pxTopOfStack--;
    29d4:	8b 81       	ldd	r24, Y+3	; 0x03
    29d6:	9c 81       	ldd	r25, Y+4	; 0x04
    29d8:	01 97       	sbiw	r24, 0x01	; 1
    29da:	9c 83       	std	Y+4, r25	; 0x04
    29dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    29de:	8b 81       	ldd	r24, Y+3	; 0x03
    29e0:	9c 81       	ldd	r25, Y+4	; 0x04
    29e2:	fc 01       	movw	r30, r24
    29e4:	10 82       	st	Z, r1
	pxTopOfStack--;
    29e6:	8b 81       	ldd	r24, Y+3	; 0x03
    29e8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ea:	01 97       	sbiw	r24, 0x01	; 1
    29ec:	9c 83       	std	Y+4, r25	; 0x04
    29ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    29f0:	8b 81       	ldd	r24, Y+3	; 0x03
    29f2:	9c 81       	ldd	r25, Y+4	; 0x04
    29f4:	20 e8       	ldi	r18, 0x80	; 128
    29f6:	fc 01       	movw	r30, r24
    29f8:	20 83       	st	Z, r18
	pxTopOfStack--;
    29fa:	8b 81       	ldd	r24, Y+3	; 0x03
    29fc:	9c 81       	ldd	r25, Y+4	; 0x04
    29fe:	01 97       	sbiw	r24, 0x01	; 1
    2a00:	9c 83       	std	Y+4, r25	; 0x04
    2a02:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2a04:	8b 81       	ldd	r24, Y+3	; 0x03
    2a06:	9c 81       	ldd	r25, Y+4	; 0x04
    2a08:	fc 01       	movw	r30, r24
    2a0a:	10 82       	st	Z, r1
	pxTopOfStack--;
    2a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a10:	01 97       	sbiw	r24, 0x01	; 1
    2a12:	9c 83       	std	Y+4, r25	; 0x04
    2a14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2a16:	8b 81       	ldd	r24, Y+3	; 0x03
    2a18:	9c 81       	ldd	r25, Y+4	; 0x04
    2a1a:	22 e0       	ldi	r18, 0x02	; 2
    2a1c:	fc 01       	movw	r30, r24
    2a1e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a20:	8b 81       	ldd	r24, Y+3	; 0x03
    2a22:	9c 81       	ldd	r25, Y+4	; 0x04
    2a24:	01 97       	sbiw	r24, 0x01	; 1
    2a26:	9c 83       	std	Y+4, r25	; 0x04
    2a28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2e:	23 e0       	ldi	r18, 0x03	; 3
    2a30:	fc 01       	movw	r30, r24
    2a32:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a34:	8b 81       	ldd	r24, Y+3	; 0x03
    2a36:	9c 81       	ldd	r25, Y+4	; 0x04
    2a38:	01 97       	sbiw	r24, 0x01	; 1
    2a3a:	9c 83       	std	Y+4, r25	; 0x04
    2a3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a40:	9c 81       	ldd	r25, Y+4	; 0x04
    2a42:	24 e0       	ldi	r18, 0x04	; 4
    2a44:	fc 01       	movw	r30, r24
    2a46:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a48:	8b 81       	ldd	r24, Y+3	; 0x03
    2a4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a4c:	01 97       	sbiw	r24, 0x01	; 1
    2a4e:	9c 83       	std	Y+4, r25	; 0x04
    2a50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2a52:	8b 81       	ldd	r24, Y+3	; 0x03
    2a54:	9c 81       	ldd	r25, Y+4	; 0x04
    2a56:	25 e0       	ldi	r18, 0x05	; 5
    2a58:	fc 01       	movw	r30, r24
    2a5a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a60:	01 97       	sbiw	r24, 0x01	; 1
    2a62:	9c 83       	std	Y+4, r25	; 0x04
    2a64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2a66:	8b 81       	ldd	r24, Y+3	; 0x03
    2a68:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6a:	26 e0       	ldi	r18, 0x06	; 6
    2a6c:	fc 01       	movw	r30, r24
    2a6e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a70:	8b 81       	ldd	r24, Y+3	; 0x03
    2a72:	9c 81       	ldd	r25, Y+4	; 0x04
    2a74:	01 97       	sbiw	r24, 0x01	; 1
    2a76:	9c 83       	std	Y+4, r25	; 0x04
    2a78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7e:	27 e0       	ldi	r18, 0x07	; 7
    2a80:	fc 01       	movw	r30, r24
    2a82:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a84:	8b 81       	ldd	r24, Y+3	; 0x03
    2a86:	9c 81       	ldd	r25, Y+4	; 0x04
    2a88:	01 97       	sbiw	r24, 0x01	; 1
    2a8a:	9c 83       	std	Y+4, r25	; 0x04
    2a8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a90:	9c 81       	ldd	r25, Y+4	; 0x04
    2a92:	28 e0       	ldi	r18, 0x08	; 8
    2a94:	fc 01       	movw	r30, r24
    2a96:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a98:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a9c:	01 97       	sbiw	r24, 0x01	; 1
    2a9e:	9c 83       	std	Y+4, r25	; 0x04
    2aa0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa6:	29 e0       	ldi	r18, 0x09	; 9
    2aa8:	fc 01       	movw	r30, r24
    2aaa:	20 83       	st	Z, r18
	pxTopOfStack--;
    2aac:	8b 81       	ldd	r24, Y+3	; 0x03
    2aae:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab0:	01 97       	sbiw	r24, 0x01	; 1
    2ab2:	9c 83       	std	Y+4, r25	; 0x04
    2ab4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aba:	20 e1       	ldi	r18, 0x10	; 16
    2abc:	fc 01       	movw	r30, r24
    2abe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac4:	01 97       	sbiw	r24, 0x01	; 1
    2ac6:	9c 83       	std	Y+4, r25	; 0x04
    2ac8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2aca:	8b 81       	ldd	r24, Y+3	; 0x03
    2acc:	9c 81       	ldd	r25, Y+4	; 0x04
    2ace:	21 e1       	ldi	r18, 0x11	; 17
    2ad0:	fc 01       	movw	r30, r24
    2ad2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad8:	01 97       	sbiw	r24, 0x01	; 1
    2ada:	9c 83       	std	Y+4, r25	; 0x04
    2adc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2ade:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae2:	22 e1       	ldi	r18, 0x12	; 18
    2ae4:	fc 01       	movw	r30, r24
    2ae6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aea:	9c 81       	ldd	r25, Y+4	; 0x04
    2aec:	01 97       	sbiw	r24, 0x01	; 1
    2aee:	9c 83       	std	Y+4, r25	; 0x04
    2af0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2af2:	8b 81       	ldd	r24, Y+3	; 0x03
    2af4:	9c 81       	ldd	r25, Y+4	; 0x04
    2af6:	23 e1       	ldi	r18, 0x13	; 19
    2af8:	fc 01       	movw	r30, r24
    2afa:	20 83       	st	Z, r18
	pxTopOfStack--;
    2afc:	8b 81       	ldd	r24, Y+3	; 0x03
    2afe:	9c 81       	ldd	r25, Y+4	; 0x04
    2b00:	01 97       	sbiw	r24, 0x01	; 1
    2b02:	9c 83       	std	Y+4, r25	; 0x04
    2b04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2b06:	8b 81       	ldd	r24, Y+3	; 0x03
    2b08:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0a:	24 e1       	ldi	r18, 0x14	; 20
    2b0c:	fc 01       	movw	r30, r24
    2b0e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b10:	8b 81       	ldd	r24, Y+3	; 0x03
    2b12:	9c 81       	ldd	r25, Y+4	; 0x04
    2b14:	01 97       	sbiw	r24, 0x01	; 1
    2b16:	9c 83       	std	Y+4, r25	; 0x04
    2b18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b1e:	25 e1       	ldi	r18, 0x15	; 21
    2b20:	fc 01       	movw	r30, r24
    2b22:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b24:	8b 81       	ldd	r24, Y+3	; 0x03
    2b26:	9c 81       	ldd	r25, Y+4	; 0x04
    2b28:	01 97       	sbiw	r24, 0x01	; 1
    2b2a:	9c 83       	std	Y+4, r25	; 0x04
    2b2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2b2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b30:	9c 81       	ldd	r25, Y+4	; 0x04
    2b32:	26 e1       	ldi	r18, 0x16	; 22
    2b34:	fc 01       	movw	r30, r24
    2b36:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b38:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b3c:	01 97       	sbiw	r24, 0x01	; 1
    2b3e:	9c 83       	std	Y+4, r25	; 0x04
    2b40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2b42:	8b 81       	ldd	r24, Y+3	; 0x03
    2b44:	9c 81       	ldd	r25, Y+4	; 0x04
    2b46:	27 e1       	ldi	r18, 0x17	; 23
    2b48:	fc 01       	movw	r30, r24
    2b4a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b50:	01 97       	sbiw	r24, 0x01	; 1
    2b52:	9c 83       	std	Y+4, r25	; 0x04
    2b54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2b56:	8b 81       	ldd	r24, Y+3	; 0x03
    2b58:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5a:	28 e1       	ldi	r18, 0x18	; 24
    2b5c:	fc 01       	movw	r30, r24
    2b5e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b60:	8b 81       	ldd	r24, Y+3	; 0x03
    2b62:	9c 81       	ldd	r25, Y+4	; 0x04
    2b64:	01 97       	sbiw	r24, 0x01	; 1
    2b66:	9c 83       	std	Y+4, r25	; 0x04
    2b68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6e:	29 e1       	ldi	r18, 0x19	; 25
    2b70:	fc 01       	movw	r30, r24
    2b72:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b74:	8b 81       	ldd	r24, Y+3	; 0x03
    2b76:	9c 81       	ldd	r25, Y+4	; 0x04
    2b78:	01 97       	sbiw	r24, 0x01	; 1
    2b7a:	9c 83       	std	Y+4, r25	; 0x04
    2b7c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b80:	9c 81       	ldd	r25, Y+4	; 0x04
    2b82:	20 e2       	ldi	r18, 0x20	; 32
    2b84:	fc 01       	movw	r30, r24
    2b86:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b88:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8c:	01 97       	sbiw	r24, 0x01	; 1
    2b8e:	9c 83       	std	Y+4, r25	; 0x04
    2b90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2b92:	8b 81       	ldd	r24, Y+3	; 0x03
    2b94:	9c 81       	ldd	r25, Y+4	; 0x04
    2b96:	21 e2       	ldi	r18, 0x21	; 33
    2b98:	fc 01       	movw	r30, r24
    2b9a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba0:	01 97       	sbiw	r24, 0x01	; 1
    2ba2:	9c 83       	std	Y+4, r25	; 0x04
    2ba4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    2baa:	22 e2       	ldi	r18, 0x22	; 34
    2bac:	fc 01       	movw	r30, r24
    2bae:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb4:	01 97       	sbiw	r24, 0x01	; 1
    2bb6:	9c 83       	std	Y+4, r25	; 0x04
    2bb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2bba:	8b 81       	ldd	r24, Y+3	; 0x03
    2bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bbe:	23 e2       	ldi	r18, 0x23	; 35
    2bc0:	fc 01       	movw	r30, r24
    2bc2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc8:	01 97       	sbiw	r24, 0x01	; 1
    2bca:	9c 83       	std	Y+4, r25	; 0x04
    2bcc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2bce:	8f 81       	ldd	r24, Y+7	; 0x07
    2bd0:	98 85       	ldd	r25, Y+8	; 0x08
    2bd2:	9a 83       	std	Y+2, r25	; 0x02
    2bd4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2bd6:	29 81       	ldd	r18, Y+1	; 0x01
    2bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bda:	9c 81       	ldd	r25, Y+4	; 0x04
    2bdc:	fc 01       	movw	r30, r24
    2bde:	20 83       	st	Z, r18
	pxTopOfStack--;
    2be0:	8b 81       	ldd	r24, Y+3	; 0x03
    2be2:	9c 81       	ldd	r25, Y+4	; 0x04
    2be4:	01 97       	sbiw	r24, 0x01	; 1
    2be6:	9c 83       	std	Y+4, r25	; 0x04
    2be8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2bea:	89 81       	ldd	r24, Y+1	; 0x01
    2bec:	9a 81       	ldd	r25, Y+2	; 0x02
    2bee:	89 2f       	mov	r24, r25
    2bf0:	99 27       	eor	r25, r25
    2bf2:	9a 83       	std	Y+2, r25	; 0x02
    2bf4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2bf6:	29 81       	ldd	r18, Y+1	; 0x01
    2bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfc:	fc 01       	movw	r30, r24
    2bfe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c00:	8b 81       	ldd	r24, Y+3	; 0x03
    2c02:	9c 81       	ldd	r25, Y+4	; 0x04
    2c04:	01 97       	sbiw	r24, 0x01	; 1
    2c06:	9c 83       	std	Y+4, r25	; 0x04
    2c08:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c0e:	26 e2       	ldi	r18, 0x26	; 38
    2c10:	fc 01       	movw	r30, r24
    2c12:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c14:	8b 81       	ldd	r24, Y+3	; 0x03
    2c16:	9c 81       	ldd	r25, Y+4	; 0x04
    2c18:	01 97       	sbiw	r24, 0x01	; 1
    2c1a:	9c 83       	std	Y+4, r25	; 0x04
    2c1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2c1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c20:	9c 81       	ldd	r25, Y+4	; 0x04
    2c22:	27 e2       	ldi	r18, 0x27	; 39
    2c24:	fc 01       	movw	r30, r24
    2c26:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c28:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2c:	01 97       	sbiw	r24, 0x01	; 1
    2c2e:	9c 83       	std	Y+4, r25	; 0x04
    2c30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2c32:	8b 81       	ldd	r24, Y+3	; 0x03
    2c34:	9c 81       	ldd	r25, Y+4	; 0x04
    2c36:	28 e2       	ldi	r18, 0x28	; 40
    2c38:	fc 01       	movw	r30, r24
    2c3a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c40:	01 97       	sbiw	r24, 0x01	; 1
    2c42:	9c 83       	std	Y+4, r25	; 0x04
    2c44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2c46:	8b 81       	ldd	r24, Y+3	; 0x03
    2c48:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4a:	29 e2       	ldi	r18, 0x29	; 41
    2c4c:	fc 01       	movw	r30, r24
    2c4e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c50:	8b 81       	ldd	r24, Y+3	; 0x03
    2c52:	9c 81       	ldd	r25, Y+4	; 0x04
    2c54:	01 97       	sbiw	r24, 0x01	; 1
    2c56:	9c 83       	std	Y+4, r25	; 0x04
    2c58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5e:	20 e3       	ldi	r18, 0x30	; 48
    2c60:	fc 01       	movw	r30, r24
    2c62:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c64:	8b 81       	ldd	r24, Y+3	; 0x03
    2c66:	9c 81       	ldd	r25, Y+4	; 0x04
    2c68:	01 97       	sbiw	r24, 0x01	; 1
    2c6a:	9c 83       	std	Y+4, r25	; 0x04
    2c6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c70:	9c 81       	ldd	r25, Y+4	; 0x04
    2c72:	21 e3       	ldi	r18, 0x31	; 49
    2c74:	fc 01       	movw	r30, r24
    2c76:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c78:	8b 81       	ldd	r24, Y+3	; 0x03
    2c7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c7c:	01 97       	sbiw	r24, 0x01	; 1
    2c7e:	9c 83       	std	Y+4, r25	; 0x04
    2c80:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2c82:	8b 81       	ldd	r24, Y+3	; 0x03
    2c84:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2c86:	28 96       	adiw	r28, 0x08	; 8
    2c88:	0f b6       	in	r0, 0x3f	; 63
    2c8a:	f8 94       	cli
    2c8c:	de bf       	out	0x3e, r29	; 62
    2c8e:	0f be       	out	0x3f, r0	; 63
    2c90:	cd bf       	out	0x3d, r28	; 61
    2c92:	df 91       	pop	r29
    2c94:	cf 91       	pop	r28
    2c96:	08 95       	ret

00002c98 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2c98:	cf 93       	push	r28
    2c9a:	df 93       	push	r29
    2c9c:	cd b7       	in	r28, 0x3d	; 61
    2c9e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2ca0:	0e 94 41 17 	call	0x2e82	; 0x2e82 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2ca4:	a0 91 b7 06 	lds	r26, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    2ca8:	b0 91 b8 06 	lds	r27, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    2cac:	cd 91       	ld	r28, X+
    2cae:	cd bf       	out	0x3d, r28	; 61
    2cb0:	dd 91       	ld	r29, X+
    2cb2:	de bf       	out	0x3e, r29	; 62
    2cb4:	ff 91       	pop	r31
    2cb6:	ef 91       	pop	r30
    2cb8:	df 91       	pop	r29
    2cba:	cf 91       	pop	r28
    2cbc:	bf 91       	pop	r27
    2cbe:	af 91       	pop	r26
    2cc0:	9f 91       	pop	r25
    2cc2:	8f 91       	pop	r24
    2cc4:	7f 91       	pop	r23
    2cc6:	6f 91       	pop	r22
    2cc8:	5f 91       	pop	r21
    2cca:	4f 91       	pop	r20
    2ccc:	3f 91       	pop	r19
    2cce:	2f 91       	pop	r18
    2cd0:	1f 91       	pop	r17
    2cd2:	0f 91       	pop	r16
    2cd4:	ff 90       	pop	r15
    2cd6:	ef 90       	pop	r14
    2cd8:	df 90       	pop	r13
    2cda:	cf 90       	pop	r12
    2cdc:	bf 90       	pop	r11
    2cde:	af 90       	pop	r10
    2ce0:	9f 90       	pop	r9
    2ce2:	8f 90       	pop	r8
    2ce4:	7f 90       	pop	r7
    2ce6:	6f 90       	pop	r6
    2ce8:	5f 90       	pop	r5
    2cea:	4f 90       	pop	r4
    2cec:	3f 90       	pop	r3
    2cee:	2f 90       	pop	r2
    2cf0:	1f 90       	pop	r1
    2cf2:	0f 90       	pop	r0
    2cf4:	0f be       	out	0x3f, r0	; 63
    2cf6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2cf8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2cfa:	81 e0       	ldi	r24, 0x01	; 1
}
    2cfc:	df 91       	pop	r29
    2cfe:	cf 91       	pop	r28
    2d00:	08 95       	ret

00002d02 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2d02:	cf 93       	push	r28
    2d04:	df 93       	push	r29
    2d06:	cd b7       	in	r28, 0x3d	; 61
    2d08:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2d0a:	00 00       	nop
    2d0c:	df 91       	pop	r29
    2d0e:	cf 91       	pop	r28
    2d10:	08 95       	ret

00002d12 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2d12:	0f 92       	push	r0
    2d14:	0f b6       	in	r0, 0x3f	; 63
    2d16:	f8 94       	cli
    2d18:	0f 92       	push	r0
    2d1a:	1f 92       	push	r1
    2d1c:	11 24       	eor	r1, r1
    2d1e:	2f 92       	push	r2
    2d20:	3f 92       	push	r3
    2d22:	4f 92       	push	r4
    2d24:	5f 92       	push	r5
    2d26:	6f 92       	push	r6
    2d28:	7f 92       	push	r7
    2d2a:	8f 92       	push	r8
    2d2c:	9f 92       	push	r9
    2d2e:	af 92       	push	r10
    2d30:	bf 92       	push	r11
    2d32:	cf 92       	push	r12
    2d34:	df 92       	push	r13
    2d36:	ef 92       	push	r14
    2d38:	ff 92       	push	r15
    2d3a:	0f 93       	push	r16
    2d3c:	1f 93       	push	r17
    2d3e:	2f 93       	push	r18
    2d40:	3f 93       	push	r19
    2d42:	4f 93       	push	r20
    2d44:	5f 93       	push	r21
    2d46:	6f 93       	push	r22
    2d48:	7f 93       	push	r23
    2d4a:	8f 93       	push	r24
    2d4c:	9f 93       	push	r25
    2d4e:	af 93       	push	r26
    2d50:	bf 93       	push	r27
    2d52:	cf 93       	push	r28
    2d54:	df 93       	push	r29
    2d56:	ef 93       	push	r30
    2d58:	ff 93       	push	r31
    2d5a:	a0 91 b7 06 	lds	r26, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    2d5e:	b0 91 b8 06 	lds	r27, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    2d62:	0d b6       	in	r0, 0x3d	; 61
    2d64:	0d 92       	st	X+, r0
    2d66:	0e b6       	in	r0, 0x3e	; 62
    2d68:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2d6a:	0e 94 62 26 	call	0x4cc4	; 0x4cc4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2d6e:	a0 91 b7 06 	lds	r26, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    2d72:	b0 91 b8 06 	lds	r27, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    2d76:	cd 91       	ld	r28, X+
    2d78:	cd bf       	out	0x3d, r28	; 61
    2d7a:	dd 91       	ld	r29, X+
    2d7c:	de bf       	out	0x3e, r29	; 62
    2d7e:	ff 91       	pop	r31
    2d80:	ef 91       	pop	r30
    2d82:	df 91       	pop	r29
    2d84:	cf 91       	pop	r28
    2d86:	bf 91       	pop	r27
    2d88:	af 91       	pop	r26
    2d8a:	9f 91       	pop	r25
    2d8c:	8f 91       	pop	r24
    2d8e:	7f 91       	pop	r23
    2d90:	6f 91       	pop	r22
    2d92:	5f 91       	pop	r21
    2d94:	4f 91       	pop	r20
    2d96:	3f 91       	pop	r19
    2d98:	2f 91       	pop	r18
    2d9a:	1f 91       	pop	r17
    2d9c:	0f 91       	pop	r16
    2d9e:	ff 90       	pop	r15
    2da0:	ef 90       	pop	r14
    2da2:	df 90       	pop	r13
    2da4:	cf 90       	pop	r12
    2da6:	bf 90       	pop	r11
    2da8:	af 90       	pop	r10
    2daa:	9f 90       	pop	r9
    2dac:	8f 90       	pop	r8
    2dae:	7f 90       	pop	r7
    2db0:	6f 90       	pop	r6
    2db2:	5f 90       	pop	r5
    2db4:	4f 90       	pop	r4
    2db6:	3f 90       	pop	r3
    2db8:	2f 90       	pop	r2
    2dba:	1f 90       	pop	r1
    2dbc:	0f 90       	pop	r0
    2dbe:	0f be       	out	0x3f, r0	; 63
    2dc0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2dc2:	08 95       	ret
	...

00002dc6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2dc6:	0f 92       	push	r0
    2dc8:	0f b6       	in	r0, 0x3f	; 63
    2dca:	f8 94       	cli
    2dcc:	0f 92       	push	r0
    2dce:	1f 92       	push	r1
    2dd0:	11 24       	eor	r1, r1
    2dd2:	2f 92       	push	r2
    2dd4:	3f 92       	push	r3
    2dd6:	4f 92       	push	r4
    2dd8:	5f 92       	push	r5
    2dda:	6f 92       	push	r6
    2ddc:	7f 92       	push	r7
    2dde:	8f 92       	push	r8
    2de0:	9f 92       	push	r9
    2de2:	af 92       	push	r10
    2de4:	bf 92       	push	r11
    2de6:	cf 92       	push	r12
    2de8:	df 92       	push	r13
    2dea:	ef 92       	push	r14
    2dec:	ff 92       	push	r15
    2dee:	0f 93       	push	r16
    2df0:	1f 93       	push	r17
    2df2:	2f 93       	push	r18
    2df4:	3f 93       	push	r19
    2df6:	4f 93       	push	r20
    2df8:	5f 93       	push	r21
    2dfa:	6f 93       	push	r22
    2dfc:	7f 93       	push	r23
    2dfe:	8f 93       	push	r24
    2e00:	9f 93       	push	r25
    2e02:	af 93       	push	r26
    2e04:	bf 93       	push	r27
    2e06:	cf 93       	push	r28
    2e08:	df 93       	push	r29
    2e0a:	ef 93       	push	r30
    2e0c:	ff 93       	push	r31
    2e0e:	a0 91 b7 06 	lds	r26, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    2e12:	b0 91 b8 06 	lds	r27, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    2e16:	0d b6       	in	r0, 0x3d	; 61
    2e18:	0d 92       	st	X+, r0
    2e1a:	0e b6       	in	r0, 0x3e	; 62
    2e1c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2e1e:	0e 94 75 25 	call	0x4aea	; 0x4aea <xTaskIncrementTick>
    2e22:	88 23       	and	r24, r24
    2e24:	11 f0       	breq	.+4      	; 0x2e2a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2e26:	0e 94 62 26 	call	0x4cc4	; 0x4cc4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2e2a:	a0 91 b7 06 	lds	r26, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    2e2e:	b0 91 b8 06 	lds	r27, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    2e32:	cd 91       	ld	r28, X+
    2e34:	cd bf       	out	0x3d, r28	; 61
    2e36:	dd 91       	ld	r29, X+
    2e38:	de bf       	out	0x3e, r29	; 62
    2e3a:	ff 91       	pop	r31
    2e3c:	ef 91       	pop	r30
    2e3e:	df 91       	pop	r29
    2e40:	cf 91       	pop	r28
    2e42:	bf 91       	pop	r27
    2e44:	af 91       	pop	r26
    2e46:	9f 91       	pop	r25
    2e48:	8f 91       	pop	r24
    2e4a:	7f 91       	pop	r23
    2e4c:	6f 91       	pop	r22
    2e4e:	5f 91       	pop	r21
    2e50:	4f 91       	pop	r20
    2e52:	3f 91       	pop	r19
    2e54:	2f 91       	pop	r18
    2e56:	1f 91       	pop	r17
    2e58:	0f 91       	pop	r16
    2e5a:	ff 90       	pop	r15
    2e5c:	ef 90       	pop	r14
    2e5e:	df 90       	pop	r13
    2e60:	cf 90       	pop	r12
    2e62:	bf 90       	pop	r11
    2e64:	af 90       	pop	r10
    2e66:	9f 90       	pop	r9
    2e68:	8f 90       	pop	r8
    2e6a:	7f 90       	pop	r7
    2e6c:	6f 90       	pop	r6
    2e6e:	5f 90       	pop	r5
    2e70:	4f 90       	pop	r4
    2e72:	3f 90       	pop	r3
    2e74:	2f 90       	pop	r2
    2e76:	1f 90       	pop	r1
    2e78:	0f 90       	pop	r0
    2e7a:	0f be       	out	0x3f, r0	; 63
    2e7c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e7e:	08 95       	ret
	...

00002e82 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2e82:	cf 93       	push	r28
    2e84:	df 93       	push	r29
    2e86:	00 d0       	rcall	.+0      	; 0x2e88 <prvSetupTimerInterrupt+0x6>
    2e88:	00 d0       	rcall	.+0      	; 0x2e8a <prvSetupTimerInterrupt+0x8>
    2e8a:	00 d0       	rcall	.+0      	; 0x2e8c <prvSetupTimerInterrupt+0xa>
    2e8c:	cd b7       	in	r28, 0x3d	; 61
    2e8e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2e90:	80 e8       	ldi	r24, 0x80	; 128
    2e92:	94 e8       	ldi	r25, 0x84	; 132
    2e94:	ae e1       	ldi	r26, 0x1E	; 30
    2e96:	b0 e0       	ldi	r27, 0x00	; 0
    2e98:	89 83       	std	Y+1, r24	; 0x01
    2e9a:	9a 83       	std	Y+2, r25	; 0x02
    2e9c:	ab 83       	std	Y+3, r26	; 0x03
    2e9e:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2ea0:	89 81       	ldd	r24, Y+1	; 0x01
    2ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea4:	ab 81       	ldd	r26, Y+3	; 0x03
    2ea6:	bc 81       	ldd	r27, Y+4	; 0x04
    2ea8:	68 94       	set
    2eaa:	15 f8       	bld	r1, 5
    2eac:	b6 95       	lsr	r27
    2eae:	a7 95       	ror	r26
    2eb0:	97 95       	ror	r25
    2eb2:	87 95       	ror	r24
    2eb4:	16 94       	lsr	r1
    2eb6:	d1 f7       	brne	.-12     	; 0x2eac <prvSetupTimerInterrupt+0x2a>
    2eb8:	89 83       	std	Y+1, r24	; 0x01
    2eba:	9a 83       	std	Y+2, r25	; 0x02
    2ebc:	ab 83       	std	Y+3, r26	; 0x03
    2ebe:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2ec0:	89 81       	ldd	r24, Y+1	; 0x01
    2ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec4:	ab 81       	ldd	r26, Y+3	; 0x03
    2ec6:	bc 81       	ldd	r27, Y+4	; 0x04
    2ec8:	01 97       	sbiw	r24, 0x01	; 1
    2eca:	a1 09       	sbc	r26, r1
    2ecc:	b1 09       	sbc	r27, r1
    2ece:	89 83       	std	Y+1, r24	; 0x01
    2ed0:	9a 83       	std	Y+2, r25	; 0x02
    2ed2:	ab 83       	std	Y+3, r26	; 0x03
    2ed4:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2ed6:	89 81       	ldd	r24, Y+1	; 0x01
    2ed8:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    2eda:	89 81       	ldd	r24, Y+1	; 0x01
    2edc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ede:	ab 81       	ldd	r26, Y+3	; 0x03
    2ee0:	bc 81       	ldd	r27, Y+4	; 0x04
    2ee2:	89 2f       	mov	r24, r25
    2ee4:	9a 2f       	mov	r25, r26
    2ee6:	ab 2f       	mov	r26, r27
    2ee8:	bb 27       	eor	r27, r27
    2eea:	89 83       	std	Y+1, r24	; 0x01
    2eec:	9a 83       	std	Y+2, r25	; 0x02
    2eee:	ab 83       	std	Y+3, r26	; 0x03
    2ef0:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2ef2:	89 81       	ldd	r24, Y+1	; 0x01
    2ef4:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    2ef6:	8b e4       	ldi	r24, 0x4B	; 75
    2ef8:	90 e0       	ldi	r25, 0x00	; 0
    2efa:	2e 81       	ldd	r18, Y+6	; 0x06
    2efc:	fc 01       	movw	r30, r24
    2efe:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    2f00:	8a e4       	ldi	r24, 0x4A	; 74
    2f02:	90 e0       	ldi	r25, 0x00	; 0
    2f04:	2d 81       	ldd	r18, Y+5	; 0x05
    2f06:	fc 01       	movw	r30, r24
    2f08:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2f0a:	8b e0       	ldi	r24, 0x0B	; 11
    2f0c:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    2f0e:	8e e4       	ldi	r24, 0x4E	; 78
    2f10:	90 e0       	ldi	r25, 0x00	; 0
    2f12:	2d 81       	ldd	r18, Y+5	; 0x05
    2f14:	fc 01       	movw	r30, r24
    2f16:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2f18:	89 e5       	ldi	r24, 0x59	; 89
    2f1a:	90 e0       	ldi	r25, 0x00	; 0
    2f1c:	fc 01       	movw	r30, r24
    2f1e:	80 81       	ld	r24, Z
    2f20:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2f22:	8d 81       	ldd	r24, Y+5	; 0x05
    2f24:	80 61       	ori	r24, 0x10	; 16
    2f26:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK = ucLowByte;
    2f28:	89 e5       	ldi	r24, 0x59	; 89
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f2e:	fc 01       	movw	r30, r24
    2f30:	20 83       	st	Z, r18
}
    2f32:	00 00       	nop
    2f34:	26 96       	adiw	r28, 0x06	; 6
    2f36:	0f b6       	in	r0, 0x3f	; 63
    2f38:	f8 94       	cli
    2f3a:	de bf       	out	0x3e, r29	; 62
    2f3c:	0f be       	out	0x3f, r0	; 63
    2f3e:	cd bf       	out	0x3d, r28	; 61
    2f40:	df 91       	pop	r29
    2f42:	cf 91       	pop	r28
    2f44:	08 95       	ret

00002f46 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void _VECTOR(7)( void ) __attribute__ ( ( signal, naked ) );
	void _VECTOR(7)( void )
	{
		vPortYieldFromTick();
    2f46:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2f4a:	18 95       	reti
	...

00002f4e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2f4e:	cf 93       	push	r28
    2f50:	df 93       	push	r29
    2f52:	00 d0       	rcall	.+0      	; 0x2f54 <xQueueGenericReset+0x6>
    2f54:	00 d0       	rcall	.+0      	; 0x2f56 <xQueueGenericReset+0x8>
    2f56:	1f 92       	push	r1
    2f58:	cd b7       	in	r28, 0x3d	; 61
    2f5a:	de b7       	in	r29, 0x3e	; 62
    2f5c:	9c 83       	std	Y+4, r25	; 0x04
    2f5e:	8b 83       	std	Y+3, r24	; 0x03
    2f60:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2f62:	8b 81       	ldd	r24, Y+3	; 0x03
    2f64:	9c 81       	ldd	r25, Y+4	; 0x04
    2f66:	9a 83       	std	Y+2, r25	; 0x02
    2f68:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2f6a:	0f b6       	in	r0, 0x3f	; 63
    2f6c:	f8 94       	cli
    2f6e:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2f70:	89 81       	ldd	r24, Y+1	; 0x01
    2f72:	9a 81       	ldd	r25, Y+2	; 0x02
    2f74:	fc 01       	movw	r30, r24
    2f76:	80 81       	ld	r24, Z
    2f78:	91 81       	ldd	r25, Z+1	; 0x01
    2f7a:	29 81       	ldd	r18, Y+1	; 0x01
    2f7c:	3a 81       	ldd	r19, Y+2	; 0x02
    2f7e:	f9 01       	movw	r30, r18
    2f80:	23 8d       	ldd	r18, Z+27	; 0x1b
    2f82:	42 2f       	mov	r20, r18
    2f84:	50 e0       	ldi	r21, 0x00	; 0
    2f86:	29 81       	ldd	r18, Y+1	; 0x01
    2f88:	3a 81       	ldd	r19, Y+2	; 0x02
    2f8a:	f9 01       	movw	r30, r18
    2f8c:	24 8d       	ldd	r18, Z+28	; 0x1c
    2f8e:	22 2f       	mov	r18, r18
    2f90:	30 e0       	ldi	r19, 0x00	; 0
    2f92:	42 9f       	mul	r20, r18
    2f94:	b0 01       	movw	r22, r0
    2f96:	43 9f       	mul	r20, r19
    2f98:	70 0d       	add	r23, r0
    2f9a:	52 9f       	mul	r21, r18
    2f9c:	70 0d       	add	r23, r0
    2f9e:	11 24       	eor	r1, r1
    2fa0:	9b 01       	movw	r18, r22
    2fa2:	28 0f       	add	r18, r24
    2fa4:	39 1f       	adc	r19, r25
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2faa:	fc 01       	movw	r30, r24
    2fac:	35 83       	std	Z+5, r19	; 0x05
    2fae:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2fb0:	89 81       	ldd	r24, Y+1	; 0x01
    2fb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb4:	fc 01       	movw	r30, r24
    2fb6:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2fb8:	89 81       	ldd	r24, Y+1	; 0x01
    2fba:	9a 81       	ldd	r25, Y+2	; 0x02
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	20 81       	ld	r18, Z
    2fc0:	31 81       	ldd	r19, Z+1	; 0x01
    2fc2:	89 81       	ldd	r24, Y+1	; 0x01
    2fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc6:	fc 01       	movw	r30, r24
    2fc8:	33 83       	std	Z+3, r19	; 0x03
    2fca:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2fcc:	89 81       	ldd	r24, Y+1	; 0x01
    2fce:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	20 81       	ld	r18, Z
    2fd4:	31 81       	ldd	r19, Z+1	; 0x01
    2fd6:	89 81       	ldd	r24, Y+1	; 0x01
    2fd8:	9a 81       	ldd	r25, Y+2	; 0x02
    2fda:	fc 01       	movw	r30, r24
    2fdc:	83 8d       	ldd	r24, Z+27	; 0x1b
    2fde:	88 2f       	mov	r24, r24
    2fe0:	90 e0       	ldi	r25, 0x00	; 0
    2fe2:	bc 01       	movw	r22, r24
    2fe4:	61 50       	subi	r22, 0x01	; 1
    2fe6:	71 09       	sbc	r23, r1
    2fe8:	89 81       	ldd	r24, Y+1	; 0x01
    2fea:	9a 81       	ldd	r25, Y+2	; 0x02
    2fec:	fc 01       	movw	r30, r24
    2fee:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ff0:	48 2f       	mov	r20, r24
    2ff2:	50 e0       	ldi	r21, 0x00	; 0
    2ff4:	64 9f       	mul	r22, r20
    2ff6:	c0 01       	movw	r24, r0
    2ff8:	65 9f       	mul	r22, r21
    2ffa:	90 0d       	add	r25, r0
    2ffc:	74 9f       	mul	r23, r20
    2ffe:	90 0d       	add	r25, r0
    3000:	11 24       	eor	r1, r1
    3002:	28 0f       	add	r18, r24
    3004:	39 1f       	adc	r19, r25
    3006:	89 81       	ldd	r24, Y+1	; 0x01
    3008:	9a 81       	ldd	r25, Y+2	; 0x02
    300a:	fc 01       	movw	r30, r24
    300c:	37 83       	std	Z+7, r19	; 0x07
    300e:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    3010:	89 81       	ldd	r24, Y+1	; 0x01
    3012:	9a 81       	ldd	r25, Y+2	; 0x02
    3014:	2f ef       	ldi	r18, 0xFF	; 255
    3016:	fc 01       	movw	r30, r24
    3018:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    301a:	89 81       	ldd	r24, Y+1	; 0x01
    301c:	9a 81       	ldd	r25, Y+2	; 0x02
    301e:	2f ef       	ldi	r18, 0xFF	; 255
    3020:	fc 01       	movw	r30, r24
    3022:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    3024:	8d 81       	ldd	r24, Y+5	; 0x05
    3026:	88 23       	and	r24, r24
    3028:	81 f4       	brne	.+32     	; 0x304a <xQueueGenericReset+0xfc>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    302a:	89 81       	ldd	r24, Y+1	; 0x01
    302c:	9a 81       	ldd	r25, Y+2	; 0x02
    302e:	fc 01       	movw	r30, r24
    3030:	80 85       	ldd	r24, Z+8	; 0x08
    3032:	88 23       	and	r24, r24
    3034:	a1 f0       	breq	.+40     	; 0x305e <xQueueGenericReset+0x110>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3036:	89 81       	ldd	r24, Y+1	; 0x01
    3038:	9a 81       	ldd	r25, Y+2	; 0x02
    303a:	08 96       	adiw	r24, 0x08	; 8
    303c:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    3040:	88 23       	and	r24, r24
    3042:	69 f0       	breq	.+26     	; 0x305e <xQueueGenericReset+0x110>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3044:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
    3048:	0a c0       	rjmp	.+20     	; 0x305e <xQueueGenericReset+0x110>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	9a 81       	ldd	r25, Y+2	; 0x02
    304e:	08 96       	adiw	r24, 0x08	; 8
    3050:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3054:	89 81       	ldd	r24, Y+1	; 0x01
    3056:	9a 81       	ldd	r25, Y+2	; 0x02
    3058:	41 96       	adiw	r24, 0x11	; 17
    305a:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    305e:	0f 90       	pop	r0
    3060:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3062:	81 e0       	ldi	r24, 0x01	; 1
}
    3064:	0f 90       	pop	r0
    3066:	0f 90       	pop	r0
    3068:	0f 90       	pop	r0
    306a:	0f 90       	pop	r0
    306c:	0f 90       	pop	r0
    306e:	df 91       	pop	r29
    3070:	cf 91       	pop	r28
    3072:	08 95       	ret

00003074 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    3074:	0f 93       	push	r16
    3076:	1f 93       	push	r17
    3078:	cf 93       	push	r28
    307a:	df 93       	push	r29
    307c:	cd b7       	in	r28, 0x3d	; 61
    307e:	de b7       	in	r29, 0x3e	; 62
    3080:	29 97       	sbiw	r28, 0x09	; 9
    3082:	0f b6       	in	r0, 0x3f	; 63
    3084:	f8 94       	cli
    3086:	de bf       	out	0x3e, r29	; 62
    3088:	0f be       	out	0x3f, r0	; 63
    308a:	cd bf       	out	0x3d, r28	; 61
    308c:	8f 83       	std	Y+7, r24	; 0x07
    308e:	68 87       	std	Y+8, r22	; 0x08
    3090:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    3092:	88 85       	ldd	r24, Y+8	; 0x08
    3094:	88 23       	and	r24, r24
    3096:	19 f4       	brne	.+6      	; 0x309e <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    3098:	1a 82       	std	Y+2, r1	; 0x02
    309a:	19 82       	std	Y+1, r1	; 0x01
    309c:	0f c0       	rjmp	.+30     	; 0x30bc <xQueueGenericCreate+0x48>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    309e:	8f 81       	ldd	r24, Y+7	; 0x07
    30a0:	48 2f       	mov	r20, r24
    30a2:	50 e0       	ldi	r21, 0x00	; 0
    30a4:	88 85       	ldd	r24, Y+8	; 0x08
    30a6:	28 2f       	mov	r18, r24
    30a8:	30 e0       	ldi	r19, 0x00	; 0
    30aa:	42 9f       	mul	r20, r18
    30ac:	c0 01       	movw	r24, r0
    30ae:	43 9f       	mul	r20, r19
    30b0:	90 0d       	add	r25, r0
    30b2:	52 9f       	mul	r21, r18
    30b4:	90 0d       	add	r25, r0
    30b6:	11 24       	eor	r1, r1
    30b8:	9a 83       	std	Y+2, r25	; 0x02
    30ba:	89 83       	std	Y+1, r24	; 0x01
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    30bc:	89 81       	ldd	r24, Y+1	; 0x01
    30be:	9a 81       	ldd	r25, Y+2	; 0x02
    30c0:	4f 96       	adiw	r24, 0x1f	; 31
    30c2:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <pvPortMalloc>
    30c6:	9c 83       	std	Y+4, r25	; 0x04
    30c8:	8b 83       	std	Y+3, r24	; 0x03

		if( pxNewQueue != NULL )
    30ca:	8b 81       	ldd	r24, Y+3	; 0x03
    30cc:	9c 81       	ldd	r25, Y+4	; 0x04
    30ce:	89 2b       	or	r24, r25
    30d0:	a1 f0       	breq	.+40     	; 0x30fa <xQueueGenericCreate+0x86>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    30d2:	8b 81       	ldd	r24, Y+3	; 0x03
    30d4:	9c 81       	ldd	r25, Y+4	; 0x04
    30d6:	9e 83       	std	Y+6, r25	; 0x06
    30d8:	8d 83       	std	Y+5, r24	; 0x05
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    30da:	8d 81       	ldd	r24, Y+5	; 0x05
    30dc:	9e 81       	ldd	r25, Y+6	; 0x06
    30de:	4f 96       	adiw	r24, 0x1f	; 31
    30e0:	9e 83       	std	Y+6, r25	; 0x06
    30e2:	8d 83       	std	Y+5, r24	; 0x05
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    30e4:	2b 81       	ldd	r18, Y+3	; 0x03
    30e6:	3c 81       	ldd	r19, Y+4	; 0x04
    30e8:	8d 81       	ldd	r24, Y+5	; 0x05
    30ea:	9e 81       	ldd	r25, Y+6	; 0x06
    30ec:	89 01       	movw	r16, r18
    30ee:	29 85       	ldd	r18, Y+9	; 0x09
    30f0:	ac 01       	movw	r20, r24
    30f2:	68 85       	ldd	r22, Y+8	; 0x08
    30f4:	8f 81       	ldd	r24, Y+7	; 0x07
    30f6:	0e 94 8a 18 	call	0x3114	; 0x3114 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    30fa:	8b 81       	ldd	r24, Y+3	; 0x03
    30fc:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    30fe:	29 96       	adiw	r28, 0x09	; 9
    3100:	0f b6       	in	r0, 0x3f	; 63
    3102:	f8 94       	cli
    3104:	de bf       	out	0x3e, r29	; 62
    3106:	0f be       	out	0x3f, r0	; 63
    3108:	cd bf       	out	0x3d, r28	; 61
    310a:	df 91       	pop	r29
    310c:	cf 91       	pop	r28
    310e:	1f 91       	pop	r17
    3110:	0f 91       	pop	r16
    3112:	08 95       	ret

00003114 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    3114:	0f 93       	push	r16
    3116:	1f 93       	push	r17
    3118:	cf 93       	push	r28
    311a:	df 93       	push	r29
    311c:	cd b7       	in	r28, 0x3d	; 61
    311e:	de b7       	in	r29, 0x3e	; 62
    3120:	27 97       	sbiw	r28, 0x07	; 7
    3122:	0f b6       	in	r0, 0x3f	; 63
    3124:	f8 94       	cli
    3126:	de bf       	out	0x3e, r29	; 62
    3128:	0f be       	out	0x3f, r0	; 63
    312a:	cd bf       	out	0x3d, r28	; 61
    312c:	89 83       	std	Y+1, r24	; 0x01
    312e:	6a 83       	std	Y+2, r22	; 0x02
    3130:	5c 83       	std	Y+4, r21	; 0x04
    3132:	4b 83       	std	Y+3, r20	; 0x03
    3134:	2d 83       	std	Y+5, r18	; 0x05
    3136:	1f 83       	std	Y+7, r17	; 0x07
    3138:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    313a:	8a 81       	ldd	r24, Y+2	; 0x02
    313c:	88 23       	and	r24, r24
    313e:	41 f4       	brne	.+16     	; 0x3150 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3140:	8e 81       	ldd	r24, Y+6	; 0x06
    3142:	9f 81       	ldd	r25, Y+7	; 0x07
    3144:	2e 81       	ldd	r18, Y+6	; 0x06
    3146:	3f 81       	ldd	r19, Y+7	; 0x07
    3148:	fc 01       	movw	r30, r24
    314a:	31 83       	std	Z+1, r19	; 0x01
    314c:	20 83       	st	Z, r18
    314e:	07 c0       	rjmp	.+14     	; 0x315e <prvInitialiseNewQueue+0x4a>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3150:	8e 81       	ldd	r24, Y+6	; 0x06
    3152:	9f 81       	ldd	r25, Y+7	; 0x07
    3154:	2b 81       	ldd	r18, Y+3	; 0x03
    3156:	3c 81       	ldd	r19, Y+4	; 0x04
    3158:	fc 01       	movw	r30, r24
    315a:	31 83       	std	Z+1, r19	; 0x01
    315c:	20 83       	st	Z, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    315e:	8e 81       	ldd	r24, Y+6	; 0x06
    3160:	9f 81       	ldd	r25, Y+7	; 0x07
    3162:	29 81       	ldd	r18, Y+1	; 0x01
    3164:	fc 01       	movw	r30, r24
    3166:	23 8f       	std	Z+27, r18	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    3168:	8e 81       	ldd	r24, Y+6	; 0x06
    316a:	9f 81       	ldd	r25, Y+7	; 0x07
    316c:	2a 81       	ldd	r18, Y+2	; 0x02
    316e:	fc 01       	movw	r30, r24
    3170:	24 8f       	std	Z+28, r18	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3172:	8e 81       	ldd	r24, Y+6	; 0x06
    3174:	9f 81       	ldd	r25, Y+7	; 0x07
    3176:	61 e0       	ldi	r22, 0x01	; 1
    3178:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    317c:	00 00       	nop
    317e:	27 96       	adiw	r28, 0x07	; 7
    3180:	0f b6       	in	r0, 0x3f	; 63
    3182:	f8 94       	cli
    3184:	de bf       	out	0x3e, r29	; 62
    3186:	0f be       	out	0x3f, r0	; 63
    3188:	cd bf       	out	0x3d, r28	; 61
    318a:	df 91       	pop	r29
    318c:	cf 91       	pop	r28
    318e:	1f 91       	pop	r17
    3190:	0f 91       	pop	r16
    3192:	08 95       	ret

00003194 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    3194:	cf 93       	push	r28
    3196:	df 93       	push	r29
    3198:	00 d0       	rcall	.+0      	; 0x319a <prvInitialiseMutex+0x6>
    319a:	cd b7       	in	r28, 0x3d	; 61
    319c:	de b7       	in	r29, 0x3e	; 62
    319e:	9a 83       	std	Y+2, r25	; 0x02
    31a0:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    31a2:	89 81       	ldd	r24, Y+1	; 0x01
    31a4:	9a 81       	ldd	r25, Y+2	; 0x02
    31a6:	89 2b       	or	r24, r25
    31a8:	b9 f0       	breq	.+46     	; 0x31d8 <prvInitialiseMutex+0x44>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    31aa:	89 81       	ldd	r24, Y+1	; 0x01
    31ac:	9a 81       	ldd	r25, Y+2	; 0x02
    31ae:	fc 01       	movw	r30, r24
    31b0:	15 82       	std	Z+5, r1	; 0x05
    31b2:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    31b4:	89 81       	ldd	r24, Y+1	; 0x01
    31b6:	9a 81       	ldd	r25, Y+2	; 0x02
    31b8:	fc 01       	movw	r30, r24
    31ba:	11 82       	std	Z+1, r1	; 0x01
    31bc:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    31be:	89 81       	ldd	r24, Y+1	; 0x01
    31c0:	9a 81       	ldd	r25, Y+2	; 0x02
    31c2:	fc 01       	movw	r30, r24
    31c4:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    31c6:	89 81       	ldd	r24, Y+1	; 0x01
    31c8:	9a 81       	ldd	r25, Y+2	; 0x02
    31ca:	20 e0       	ldi	r18, 0x00	; 0
    31cc:	40 e0       	ldi	r20, 0x00	; 0
    31ce:	50 e0       	ldi	r21, 0x00	; 0
    31d0:	60 e0       	ldi	r22, 0x00	; 0
    31d2:	70 e0       	ldi	r23, 0x00	; 0
    31d4:	0e 94 12 19 	call	0x3224	; 0x3224 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    31d8:	00 00       	nop
    31da:	0f 90       	pop	r0
    31dc:	0f 90       	pop	r0
    31de:	df 91       	pop	r29
    31e0:	cf 91       	pop	r28
    31e2:	08 95       	ret

000031e4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    31e4:	cf 93       	push	r28
    31e6:	df 93       	push	r29
    31e8:	00 d0       	rcall	.+0      	; 0x31ea <xQueueCreateMutex+0x6>
    31ea:	00 d0       	rcall	.+0      	; 0x31ec <xQueueCreateMutex+0x8>
    31ec:	1f 92       	push	r1
    31ee:	cd b7       	in	r28, 0x3d	; 61
    31f0:	de b7       	in	r29, 0x3e	; 62
    31f2:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    31f4:	81 e0       	ldi	r24, 0x01	; 1
    31f6:	89 83       	std	Y+1, r24	; 0x01
    31f8:	1a 82       	std	Y+2, r1	; 0x02

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    31fa:	4d 81       	ldd	r20, Y+5	; 0x05
    31fc:	6a 81       	ldd	r22, Y+2	; 0x02
    31fe:	89 81       	ldd	r24, Y+1	; 0x01
    3200:	0e 94 3a 18 	call	0x3074	; 0x3074 <xQueueGenericCreate>
    3204:	9c 83       	std	Y+4, r25	; 0x04
    3206:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    3208:	8b 81       	ldd	r24, Y+3	; 0x03
    320a:	9c 81       	ldd	r25, Y+4	; 0x04
    320c:	0e 94 ca 18 	call	0x3194	; 0x3194 <prvInitialiseMutex>

		return xNewQueue;
    3210:	8b 81       	ldd	r24, Y+3	; 0x03
    3212:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    3214:	0f 90       	pop	r0
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	0f 90       	pop	r0
    321e:	df 91       	pop	r29
    3220:	cf 91       	pop	r28
    3222:	08 95       	ret

00003224 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3224:	cf 93       	push	r28
    3226:	df 93       	push	r29
    3228:	cd b7       	in	r28, 0x3d	; 61
    322a:	de b7       	in	r29, 0x3e	; 62
    322c:	2e 97       	sbiw	r28, 0x0e	; 14
    322e:	0f b6       	in	r0, 0x3f	; 63
    3230:	f8 94       	cli
    3232:	de bf       	out	0x3e, r29	; 62
    3234:	0f be       	out	0x3f, r0	; 63
    3236:	cd bf       	out	0x3d, r28	; 61
    3238:	99 87       	std	Y+9, r25	; 0x09
    323a:	88 87       	std	Y+8, r24	; 0x08
    323c:	7b 87       	std	Y+11, r23	; 0x0b
    323e:	6a 87       	std	Y+10, r22	; 0x0a
    3240:	5d 87       	std	Y+13, r21	; 0x0d
    3242:	4c 87       	std	Y+12, r20	; 0x0c
    3244:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3246:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3248:	88 85       	ldd	r24, Y+8	; 0x08
    324a:	99 85       	ldd	r25, Y+9	; 0x09
    324c:	9b 83       	std	Y+3, r25	; 0x03
    324e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3250:	0f b6       	in	r0, 0x3f	; 63
    3252:	f8 94       	cli
    3254:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3256:	8a 81       	ldd	r24, Y+2	; 0x02
    3258:	9b 81       	ldd	r25, Y+3	; 0x03
    325a:	fc 01       	movw	r30, r24
    325c:	22 8d       	ldd	r18, Z+26	; 0x1a
    325e:	8a 81       	ldd	r24, Y+2	; 0x02
    3260:	9b 81       	ldd	r25, Y+3	; 0x03
    3262:	fc 01       	movw	r30, r24
    3264:	83 8d       	ldd	r24, Z+27	; 0x1b
    3266:	28 17       	cp	r18, r24
    3268:	18 f0       	brcs	.+6      	; 0x3270 <xQueueGenericSend+0x4c>
    326a:	8e 85       	ldd	r24, Y+14	; 0x0e
    326c:	82 30       	cpi	r24, 0x02	; 2
    326e:	11 f5       	brne	.+68     	; 0x32b4 <xQueueGenericSend+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3270:	2a 85       	ldd	r18, Y+10	; 0x0a
    3272:	3b 85       	ldd	r19, Y+11	; 0x0b
    3274:	8a 81       	ldd	r24, Y+2	; 0x02
    3276:	9b 81       	ldd	r25, Y+3	; 0x03
    3278:	4e 85       	ldd	r20, Y+14	; 0x0e
    327a:	b9 01       	movw	r22, r18
    327c:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <prvCopyDataToQueue>
    3280:	8c 83       	std	Y+4, r24	; 0x04

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3282:	8a 81       	ldd	r24, Y+2	; 0x02
    3284:	9b 81       	ldd	r25, Y+3	; 0x03
    3286:	fc 01       	movw	r30, r24
    3288:	81 89       	ldd	r24, Z+17	; 0x11
    328a:	88 23       	and	r24, r24
    328c:	51 f0       	breq	.+20     	; 0x32a2 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    328e:	8a 81       	ldd	r24, Y+2	; 0x02
    3290:	9b 81       	ldd	r25, Y+3	; 0x03
    3292:	41 96       	adiw	r24, 0x11	; 17
    3294:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    3298:	88 23       	and	r24, r24
    329a:	41 f0       	breq	.+16     	; 0x32ac <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    329c:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
    32a0:	05 c0       	rjmp	.+10     	; 0x32ac <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    32a2:	8c 81       	ldd	r24, Y+4	; 0x04
    32a4:	88 23       	and	r24, r24
    32a6:	11 f0       	breq	.+4      	; 0x32ac <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    32a8:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    32ac:	0f 90       	pop	r0
    32ae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	60 c0       	rjmp	.+192    	; 0x3374 <xQueueGenericSend+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    32b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    32b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    32b8:	89 2b       	or	r24, r25
    32ba:	21 f4       	brne	.+8      	; 0x32c4 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    32bc:	0f 90       	pop	r0
    32be:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    32c0:	80 e0       	ldi	r24, 0x00	; 0
    32c2:	58 c0       	rjmp	.+176    	; 0x3374 <xQueueGenericSend+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    32c4:	89 81       	ldd	r24, Y+1	; 0x01
    32c6:	88 23       	and	r24, r24
    32c8:	31 f4       	brne	.+12     	; 0x32d6 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    32ca:	ce 01       	movw	r24, r28
    32cc:	05 96       	adiw	r24, 0x05	; 5
    32ce:	0e 94 1d 28 	call	0x503a	; 0x503a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    32d2:	81 e0       	ldi	r24, 0x01	; 1
    32d4:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    32d6:	0f 90       	pop	r0
    32d8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    32da:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    32de:	0f b6       	in	r0, 0x3f	; 63
    32e0:	f8 94       	cli
    32e2:	0f 92       	push	r0
    32e4:	8a 81       	ldd	r24, Y+2	; 0x02
    32e6:	9b 81       	ldd	r25, Y+3	; 0x03
    32e8:	fc 01       	movw	r30, r24
    32ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    32ec:	8f 3f       	cpi	r24, 0xFF	; 255
    32ee:	21 f4       	brne	.+8      	; 0x32f8 <xQueueGenericSend+0xd4>
    32f0:	8a 81       	ldd	r24, Y+2	; 0x02
    32f2:	9b 81       	ldd	r25, Y+3	; 0x03
    32f4:	fc 01       	movw	r30, r24
    32f6:	15 8e       	std	Z+29, r1	; 0x1d
    32f8:	8a 81       	ldd	r24, Y+2	; 0x02
    32fa:	9b 81       	ldd	r25, Y+3	; 0x03
    32fc:	fc 01       	movw	r30, r24
    32fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    3300:	8f 3f       	cpi	r24, 0xFF	; 255
    3302:	21 f4       	brne	.+8      	; 0x330c <xQueueGenericSend+0xe8>
    3304:	8a 81       	ldd	r24, Y+2	; 0x02
    3306:	9b 81       	ldd	r25, Y+3	; 0x03
    3308:	fc 01       	movw	r30, r24
    330a:	16 8e       	std	Z+30, r1	; 0x1e
    330c:	0f 90       	pop	r0
    330e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3310:	9e 01       	movw	r18, r28
    3312:	24 5f       	subi	r18, 0xF4	; 244
    3314:	3f 4f       	sbci	r19, 0xFF	; 255
    3316:	ce 01       	movw	r24, r28
    3318:	05 96       	adiw	r24, 0x05	; 5
    331a:	b9 01       	movw	r22, r18
    331c:	0e 94 39 28 	call	0x5072	; 0x5072 <xTaskCheckForTimeOut>
    3320:	88 23       	and	r24, r24
    3322:	09 f5       	brne	.+66     	; 0x3366 <xQueueGenericSend+0x142>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3324:	8a 81       	ldd	r24, Y+2	; 0x02
    3326:	9b 81       	ldd	r25, Y+3	; 0x03
    3328:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <prvIsQueueFull>
    332c:	88 23       	and	r24, r24
    332e:	a1 f0       	breq	.+40     	; 0x3358 <xQueueGenericSend+0x134>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3330:	2c 85       	ldd	r18, Y+12	; 0x0c
    3332:	3d 85       	ldd	r19, Y+13	; 0x0d
    3334:	8a 81       	ldd	r24, Y+2	; 0x02
    3336:	9b 81       	ldd	r25, Y+3	; 0x03
    3338:	08 96       	adiw	r24, 0x08	; 8
    333a:	b9 01       	movw	r22, r18
    333c:	0e 94 d6 26 	call	0x4dac	; 0x4dac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3340:	8a 81       	ldd	r24, Y+2	; 0x02
    3342:	9b 81       	ldd	r25, Y+3	; 0x03
    3344:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3348:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    334c:	88 23       	and	r24, r24
    334e:	09 f0       	breq	.+2      	; 0x3352 <xQueueGenericSend+0x12e>
    3350:	7f cf       	rjmp	.-258    	; 0x3250 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    3352:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
    3356:	7c cf       	rjmp	.-264    	; 0x3250 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3358:	8a 81       	ldd	r24, Y+2	; 0x02
    335a:	9b 81       	ldd	r25, Y+3	; 0x03
    335c:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3360:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    3364:	75 cf       	rjmp	.-278    	; 0x3250 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3366:	8a 81       	ldd	r24, Y+2	; 0x02
    3368:	9b 81       	ldd	r25, Y+3	; 0x03
    336a:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    336e:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3372:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    3374:	2e 96       	adiw	r28, 0x0e	; 14
    3376:	0f b6       	in	r0, 0x3f	; 63
    3378:	f8 94       	cli
    337a:	de bf       	out	0x3e, r29	; 62
    337c:	0f be       	out	0x3f, r0	; 63
    337e:	cd bf       	out	0x3d, r28	; 61
    3380:	df 91       	pop	r29
    3382:	cf 91       	pop	r28
    3384:	08 95       	ret

00003386 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3386:	cf 93       	push	r28
    3388:	df 93       	push	r29
    338a:	cd b7       	in	r28, 0x3d	; 61
    338c:	de b7       	in	r29, 0x3e	; 62
    338e:	2c 97       	sbiw	r28, 0x0c	; 12
    3390:	0f b6       	in	r0, 0x3f	; 63
    3392:	f8 94       	cli
    3394:	de bf       	out	0x3e, r29	; 62
    3396:	0f be       	out	0x3f, r0	; 63
    3398:	cd bf       	out	0x3d, r28	; 61
    339a:	9f 83       	std	Y+7, r25	; 0x07
    339c:	8e 83       	std	Y+6, r24	; 0x06
    339e:	79 87       	std	Y+9, r23	; 0x09
    33a0:	68 87       	std	Y+8, r22	; 0x08
    33a2:	5b 87       	std	Y+11, r21	; 0x0b
    33a4:	4a 87       	std	Y+10, r20	; 0x0a
    33a6:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    33a8:	8e 81       	ldd	r24, Y+6	; 0x06
    33aa:	9f 81       	ldd	r25, Y+7	; 0x07
    33ac:	9b 83       	std	Y+3, r25	; 0x03
    33ae:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    33b0:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    33b2:	8a 81       	ldd	r24, Y+2	; 0x02
    33b4:	9b 81       	ldd	r25, Y+3	; 0x03
    33b6:	fc 01       	movw	r30, r24
    33b8:	22 8d       	ldd	r18, Z+26	; 0x1a
    33ba:	8a 81       	ldd	r24, Y+2	; 0x02
    33bc:	9b 81       	ldd	r25, Y+3	; 0x03
    33be:	fc 01       	movw	r30, r24
    33c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    33c2:	28 17       	cp	r18, r24
    33c4:	18 f0       	brcs	.+6      	; 0x33cc <xQueueGenericSendFromISR+0x46>
    33c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    33c8:	82 30       	cpi	r24, 0x02	; 2
    33ca:	89 f5       	brne	.+98     	; 0x342e <xQueueGenericSendFromISR+0xa8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    33cc:	8a 81       	ldd	r24, Y+2	; 0x02
    33ce:	9b 81       	ldd	r25, Y+3	; 0x03
    33d0:	fc 01       	movw	r30, r24
    33d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    33d4:	8d 83       	std	Y+5, r24	; 0x05
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    33d6:	28 85       	ldd	r18, Y+8	; 0x08
    33d8:	39 85       	ldd	r19, Y+9	; 0x09
    33da:	8a 81       	ldd	r24, Y+2	; 0x02
    33dc:	9b 81       	ldd	r25, Y+3	; 0x03
    33de:	4c 85       	ldd	r20, Y+12	; 0x0c
    33e0:	b9 01       	movw	r22, r18
    33e2:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    33e6:	8d 81       	ldd	r24, Y+5	; 0x05
    33e8:	8f 3f       	cpi	r24, 0xFF	; 255
    33ea:	b9 f4       	brne	.+46     	; 0x341a <xQueueGenericSendFromISR+0x94>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    33ec:	8a 81       	ldd	r24, Y+2	; 0x02
    33ee:	9b 81       	ldd	r25, Y+3	; 0x03
    33f0:	fc 01       	movw	r30, r24
    33f2:	81 89       	ldd	r24, Z+17	; 0x11
    33f4:	88 23       	and	r24, r24
    33f6:	c1 f0       	breq	.+48     	; 0x3428 <xQueueGenericSendFromISR+0xa2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    33f8:	8a 81       	ldd	r24, Y+2	; 0x02
    33fa:	9b 81       	ldd	r25, Y+3	; 0x03
    33fc:	41 96       	adiw	r24, 0x11	; 17
    33fe:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    3402:	88 23       	and	r24, r24
    3404:	89 f0       	breq	.+34     	; 0x3428 <xQueueGenericSendFromISR+0xa2>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3406:	8a 85       	ldd	r24, Y+10	; 0x0a
    3408:	9b 85       	ldd	r25, Y+11	; 0x0b
    340a:	89 2b       	or	r24, r25
    340c:	69 f0       	breq	.+26     	; 0x3428 <xQueueGenericSendFromISR+0xa2>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    340e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3410:	9b 85       	ldd	r25, Y+11	; 0x0b
    3412:	21 e0       	ldi	r18, 0x01	; 1
    3414:	fc 01       	movw	r30, r24
    3416:	20 83       	st	Z, r18
    3418:	07 c0       	rjmp	.+14     	; 0x3428 <xQueueGenericSendFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    341a:	8d 81       	ldd	r24, Y+5	; 0x05
    341c:	8f 5f       	subi	r24, 0xFF	; 255
    341e:	28 2f       	mov	r18, r24
    3420:	8a 81       	ldd	r24, Y+2	; 0x02
    3422:	9b 81       	ldd	r25, Y+3	; 0x03
    3424:	fc 01       	movw	r30, r24
    3426:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    3428:	81 e0       	ldi	r24, 0x01	; 1
    342a:	89 83       	std	Y+1, r24	; 0x01
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
    342c:	01 c0       	rjmp	.+2      	; 0x3430 <xQueueGenericSendFromISR+0xaa>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    342e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3430:	89 81       	ldd	r24, Y+1	; 0x01
}
    3432:	2c 96       	adiw	r28, 0x0c	; 12
    3434:	0f b6       	in	r0, 0x3f	; 63
    3436:	f8 94       	cli
    3438:	de bf       	out	0x3e, r29	; 62
    343a:	0f be       	out	0x3f, r0	; 63
    343c:	cd bf       	out	0x3d, r28	; 61
    343e:	df 91       	pop	r29
    3440:	cf 91       	pop	r28
    3442:	08 95       	ret

00003444 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3444:	cf 93       	push	r28
    3446:	df 93       	push	r29
    3448:	cd b7       	in	r28, 0x3d	; 61
    344a:	de b7       	in	r29, 0x3e	; 62
    344c:	2a 97       	sbiw	r28, 0x0a	; 10
    344e:	0f b6       	in	r0, 0x3f	; 63
    3450:	f8 94       	cli
    3452:	de bf       	out	0x3e, r29	; 62
    3454:	0f be       	out	0x3f, r0	; 63
    3456:	cd bf       	out	0x3d, r28	; 61
    3458:	98 87       	std	Y+8, r25	; 0x08
    345a:	8f 83       	std	Y+7, r24	; 0x07
    345c:	7a 87       	std	Y+10, r23	; 0x0a
    345e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3460:	8f 81       	ldd	r24, Y+7	; 0x07
    3462:	98 85       	ldd	r25, Y+8	; 0x08
    3464:	9b 83       	std	Y+3, r25	; 0x03
    3466:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3468:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    346a:	8a 81       	ldd	r24, Y+2	; 0x02
    346c:	9b 81       	ldd	r25, Y+3	; 0x03
    346e:	fc 01       	movw	r30, r24
    3470:	82 8d       	ldd	r24, Z+26	; 0x1a
    3472:	8d 83       	std	Y+5, r24	; 0x05

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    3474:	8a 81       	ldd	r24, Y+2	; 0x02
    3476:	9b 81       	ldd	r25, Y+3	; 0x03
    3478:	fc 01       	movw	r30, r24
    347a:	93 8d       	ldd	r25, Z+27	; 0x1b
    347c:	8d 81       	ldd	r24, Y+5	; 0x05
    347e:	89 17       	cp	r24, r25
    3480:	80 f5       	brcc	.+96     	; 0x34e2 <xQueueGiveFromISR+0x9e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3482:	8a 81       	ldd	r24, Y+2	; 0x02
    3484:	9b 81       	ldd	r25, Y+3	; 0x03
    3486:	fc 01       	movw	r30, r24
    3488:	86 8d       	ldd	r24, Z+30	; 0x1e
    348a:	8e 83       	std	Y+6, r24	; 0x06
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    348c:	8d 81       	ldd	r24, Y+5	; 0x05
    348e:	21 e0       	ldi	r18, 0x01	; 1
    3490:	28 0f       	add	r18, r24
    3492:	8a 81       	ldd	r24, Y+2	; 0x02
    3494:	9b 81       	ldd	r25, Y+3	; 0x03
    3496:	fc 01       	movw	r30, r24
    3498:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    349a:	8e 81       	ldd	r24, Y+6	; 0x06
    349c:	8f 3f       	cpi	r24, 0xFF	; 255
    349e:	b9 f4       	brne	.+46     	; 0x34ce <xQueueGiveFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34a0:	8a 81       	ldd	r24, Y+2	; 0x02
    34a2:	9b 81       	ldd	r25, Y+3	; 0x03
    34a4:	fc 01       	movw	r30, r24
    34a6:	81 89       	ldd	r24, Z+17	; 0x11
    34a8:	88 23       	and	r24, r24
    34aa:	c1 f0       	breq	.+48     	; 0x34dc <xQueueGiveFromISR+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    34ac:	8a 81       	ldd	r24, Y+2	; 0x02
    34ae:	9b 81       	ldd	r25, Y+3	; 0x03
    34b0:	41 96       	adiw	r24, 0x11	; 17
    34b2:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    34b6:	88 23       	and	r24, r24
    34b8:	89 f0       	breq	.+34     	; 0x34dc <xQueueGiveFromISR+0x98>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    34ba:	89 85       	ldd	r24, Y+9	; 0x09
    34bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    34be:	89 2b       	or	r24, r25
    34c0:	69 f0       	breq	.+26     	; 0x34dc <xQueueGiveFromISR+0x98>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    34c2:	89 85       	ldd	r24, Y+9	; 0x09
    34c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    34c6:	21 e0       	ldi	r18, 0x01	; 1
    34c8:	fc 01       	movw	r30, r24
    34ca:	20 83       	st	Z, r18
    34cc:	07 c0       	rjmp	.+14     	; 0x34dc <xQueueGiveFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    34ce:	8e 81       	ldd	r24, Y+6	; 0x06
    34d0:	8f 5f       	subi	r24, 0xFF	; 255
    34d2:	28 2f       	mov	r18, r24
    34d4:	8a 81       	ldd	r24, Y+2	; 0x02
    34d6:	9b 81       	ldd	r25, Y+3	; 0x03
    34d8:	fc 01       	movw	r30, r24
    34da:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    34dc:	81 e0       	ldi	r24, 0x01	; 1
    34de:	89 83       	std	Y+1, r24	; 0x01
    34e0:	01 c0       	rjmp	.+2      	; 0x34e4 <xQueueGiveFromISR+0xa0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    34e2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    34e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    34e6:	2a 96       	adiw	r28, 0x0a	; 10
    34e8:	0f b6       	in	r0, 0x3f	; 63
    34ea:	f8 94       	cli
    34ec:	de bf       	out	0x3e, r29	; 62
    34ee:	0f be       	out	0x3f, r0	; 63
    34f0:	cd bf       	out	0x3d, r28	; 61
    34f2:	df 91       	pop	r29
    34f4:	cf 91       	pop	r28
    34f6:	08 95       	ret

000034f8 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    34f8:	cf 93       	push	r28
    34fa:	df 93       	push	r29
    34fc:	cd b7       	in	r28, 0x3d	; 61
    34fe:	de b7       	in	r29, 0x3e	; 62
    3500:	2d 97       	sbiw	r28, 0x0d	; 13
    3502:	0f b6       	in	r0, 0x3f	; 63
    3504:	f8 94       	cli
    3506:	de bf       	out	0x3e, r29	; 62
    3508:	0f be       	out	0x3f, r0	; 63
    350a:	cd bf       	out	0x3d, r28	; 61
    350c:	99 87       	std	Y+9, r25	; 0x09
    350e:	88 87       	std	Y+8, r24	; 0x08
    3510:	7b 87       	std	Y+11, r23	; 0x0b
    3512:	6a 87       	std	Y+10, r22	; 0x0a
    3514:	5d 87       	std	Y+13, r21	; 0x0d
    3516:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3518:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    351a:	88 85       	ldd	r24, Y+8	; 0x08
    351c:	99 85       	ldd	r25, Y+9	; 0x09
    351e:	9b 83       	std	Y+3, r25	; 0x03
    3520:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3522:	0f b6       	in	r0, 0x3f	; 63
    3524:	f8 94       	cli
    3526:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3528:	8a 81       	ldd	r24, Y+2	; 0x02
    352a:	9b 81       	ldd	r25, Y+3	; 0x03
    352c:	fc 01       	movw	r30, r24
    352e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3530:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3532:	8c 81       	ldd	r24, Y+4	; 0x04
    3534:	88 23       	and	r24, r24
    3536:	09 f1       	breq	.+66     	; 0x357a <xQueueReceive+0x82>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3538:	2a 85       	ldd	r18, Y+10	; 0x0a
    353a:	3b 85       	ldd	r19, Y+11	; 0x0b
    353c:	8a 81       	ldd	r24, Y+2	; 0x02
    353e:	9b 81       	ldd	r25, Y+3	; 0x03
    3540:	b9 01       	movw	r22, r18
    3542:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3546:	8c 81       	ldd	r24, Y+4	; 0x04
    3548:	2f ef       	ldi	r18, 0xFF	; 255
    354a:	28 0f       	add	r18, r24
    354c:	8a 81       	ldd	r24, Y+2	; 0x02
    354e:	9b 81       	ldd	r25, Y+3	; 0x03
    3550:	fc 01       	movw	r30, r24
    3552:	22 8f       	std	Z+26, r18	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3554:	8a 81       	ldd	r24, Y+2	; 0x02
    3556:	9b 81       	ldd	r25, Y+3	; 0x03
    3558:	fc 01       	movw	r30, r24
    355a:	80 85       	ldd	r24, Z+8	; 0x08
    355c:	88 23       	and	r24, r24
    355e:	49 f0       	breq	.+18     	; 0x3572 <xQueueReceive+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3560:	8a 81       	ldd	r24, Y+2	; 0x02
    3562:	9b 81       	ldd	r25, Y+3	; 0x03
    3564:	08 96       	adiw	r24, 0x08	; 8
    3566:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    356a:	88 23       	and	r24, r24
    356c:	11 f0       	breq	.+4      	; 0x3572 <xQueueReceive+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    356e:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3572:	0f 90       	pop	r0
    3574:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3576:	81 e0       	ldi	r24, 0x01	; 1
    3578:	67 c0       	rjmp	.+206    	; 0x3648 <xQueueReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    357a:	8c 85       	ldd	r24, Y+12	; 0x0c
    357c:	9d 85       	ldd	r25, Y+13	; 0x0d
    357e:	89 2b       	or	r24, r25
    3580:	21 f4       	brne	.+8      	; 0x358a <xQueueReceive+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3582:	0f 90       	pop	r0
    3584:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3586:	80 e0       	ldi	r24, 0x00	; 0
    3588:	5f c0       	rjmp	.+190    	; 0x3648 <xQueueReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    358a:	89 81       	ldd	r24, Y+1	; 0x01
    358c:	88 23       	and	r24, r24
    358e:	31 f4       	brne	.+12     	; 0x359c <xQueueReceive+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3590:	ce 01       	movw	r24, r28
    3592:	05 96       	adiw	r24, 0x05	; 5
    3594:	0e 94 1d 28 	call	0x503a	; 0x503a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3598:	81 e0       	ldi	r24, 0x01	; 1
    359a:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    359c:	0f 90       	pop	r0
    359e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    35a0:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    35a4:	0f b6       	in	r0, 0x3f	; 63
    35a6:	f8 94       	cli
    35a8:	0f 92       	push	r0
    35aa:	8a 81       	ldd	r24, Y+2	; 0x02
    35ac:	9b 81       	ldd	r25, Y+3	; 0x03
    35ae:	fc 01       	movw	r30, r24
    35b0:	85 8d       	ldd	r24, Z+29	; 0x1d
    35b2:	8f 3f       	cpi	r24, 0xFF	; 255
    35b4:	21 f4       	brne	.+8      	; 0x35be <xQueueReceive+0xc6>
    35b6:	8a 81       	ldd	r24, Y+2	; 0x02
    35b8:	9b 81       	ldd	r25, Y+3	; 0x03
    35ba:	fc 01       	movw	r30, r24
    35bc:	15 8e       	std	Z+29, r1	; 0x1d
    35be:	8a 81       	ldd	r24, Y+2	; 0x02
    35c0:	9b 81       	ldd	r25, Y+3	; 0x03
    35c2:	fc 01       	movw	r30, r24
    35c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    35c6:	8f 3f       	cpi	r24, 0xFF	; 255
    35c8:	21 f4       	brne	.+8      	; 0x35d2 <xQueueReceive+0xda>
    35ca:	8a 81       	ldd	r24, Y+2	; 0x02
    35cc:	9b 81       	ldd	r25, Y+3	; 0x03
    35ce:	fc 01       	movw	r30, r24
    35d0:	16 8e       	std	Z+30, r1	; 0x1e
    35d2:	0f 90       	pop	r0
    35d4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    35d6:	9e 01       	movw	r18, r28
    35d8:	24 5f       	subi	r18, 0xF4	; 244
    35da:	3f 4f       	sbci	r19, 0xFF	; 255
    35dc:	ce 01       	movw	r24, r28
    35de:	05 96       	adiw	r24, 0x05	; 5
    35e0:	b9 01       	movw	r22, r18
    35e2:	0e 94 39 28 	call	0x5072	; 0x5072 <xTaskCheckForTimeOut>
    35e6:	88 23       	and	r24, r24
    35e8:	09 f5       	brne	.+66     	; 0x362c <xQueueReceive+0x134>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    35ea:	8a 81       	ldd	r24, Y+2	; 0x02
    35ec:	9b 81       	ldd	r25, Y+3	; 0x03
    35ee:	0e 94 76 1f 	call	0x3eec	; 0x3eec <prvIsQueueEmpty>
    35f2:	88 23       	and	r24, r24
    35f4:	a1 f0       	breq	.+40     	; 0x361e <xQueueReceive+0x126>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    35f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    35f8:	3d 85       	ldd	r19, Y+13	; 0x0d
    35fa:	8a 81       	ldd	r24, Y+2	; 0x02
    35fc:	9b 81       	ldd	r25, Y+3	; 0x03
    35fe:	41 96       	adiw	r24, 0x11	; 17
    3600:	b9 01       	movw	r22, r18
    3602:	0e 94 d6 26 	call	0x4dac	; 0x4dac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3606:	8a 81       	ldd	r24, Y+2	; 0x02
    3608:	9b 81       	ldd	r25, Y+3	; 0x03
    360a:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    360e:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    3612:	88 23       	and	r24, r24
    3614:	09 f0       	breq	.+2      	; 0x3618 <xQueueReceive+0x120>
    3616:	85 cf       	rjmp	.-246    	; 0x3522 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    3618:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
    361c:	82 cf       	rjmp	.-252    	; 0x3522 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    361e:	8a 81       	ldd	r24, Y+2	; 0x02
    3620:	9b 81       	ldd	r25, Y+3	; 0x03
    3622:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3626:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    362a:	7b cf       	rjmp	.-266    	; 0x3522 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    362c:	8a 81       	ldd	r24, Y+2	; 0x02
    362e:	9b 81       	ldd	r25, Y+3	; 0x03
    3630:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3634:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3638:	8a 81       	ldd	r24, Y+2	; 0x02
    363a:	9b 81       	ldd	r25, Y+3	; 0x03
    363c:	0e 94 76 1f 	call	0x3eec	; 0x3eec <prvIsQueueEmpty>
    3640:	88 23       	and	r24, r24
    3642:	09 f4       	brne	.+2      	; 0x3646 <xQueueReceive+0x14e>
    3644:	6e cf       	rjmp	.-292    	; 0x3522 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3646:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3648:	2d 96       	adiw	r28, 0x0d	; 13
    364a:	0f b6       	in	r0, 0x3f	; 63
    364c:	f8 94       	cli
    364e:	de bf       	out	0x3e, r29	; 62
    3650:	0f be       	out	0x3f, r0	; 63
    3652:	cd bf       	out	0x3d, r28	; 61
    3654:	df 91       	pop	r29
    3656:	cf 91       	pop	r28
    3658:	08 95       	ret

0000365a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    365a:	cf 93       	push	r28
    365c:	df 93       	push	r29
    365e:	cd b7       	in	r28, 0x3d	; 61
    3660:	de b7       	in	r29, 0x3e	; 62
    3662:	2d 97       	sbiw	r28, 0x0d	; 13
    3664:	0f b6       	in	r0, 0x3f	; 63
    3666:	f8 94       	cli
    3668:	de bf       	out	0x3e, r29	; 62
    366a:	0f be       	out	0x3f, r0	; 63
    366c:	cd bf       	out	0x3d, r28	; 61
    366e:	9b 87       	std	Y+11, r25	; 0x0b
    3670:	8a 87       	std	Y+10, r24	; 0x0a
    3672:	7d 87       	std	Y+13, r23	; 0x0d
    3674:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3676:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3678:	8a 85       	ldd	r24, Y+10	; 0x0a
    367a:	9b 85       	ldd	r25, Y+11	; 0x0b
    367c:	9c 83       	std	Y+4, r25	; 0x04
    367e:	8b 83       	std	Y+3, r24	; 0x03

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    3680:	1a 82       	std	Y+2, r1	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3682:	0f b6       	in	r0, 0x3f	; 63
    3684:	f8 94       	cli
    3686:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3688:	8b 81       	ldd	r24, Y+3	; 0x03
    368a:	9c 81       	ldd	r25, Y+4	; 0x04
    368c:	fc 01       	movw	r30, r24
    368e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3690:	8d 83       	std	Y+5, r24	; 0x05

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3692:	8d 81       	ldd	r24, Y+5	; 0x05
    3694:	88 23       	and	r24, r24
    3696:	49 f1       	breq	.+82     	; 0x36ea <xQueueSemaphoreTake+0x90>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3698:	8d 81       	ldd	r24, Y+5	; 0x05
    369a:	2f ef       	ldi	r18, 0xFF	; 255
    369c:	28 0f       	add	r18, r24
    369e:	8b 81       	ldd	r24, Y+3	; 0x03
    36a0:	9c 81       	ldd	r25, Y+4	; 0x04
    36a2:	fc 01       	movw	r30, r24
    36a4:	22 8f       	std	Z+26, r18	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    36a6:	8b 81       	ldd	r24, Y+3	; 0x03
    36a8:	9c 81       	ldd	r25, Y+4	; 0x04
    36aa:	fc 01       	movw	r30, r24
    36ac:	80 81       	ld	r24, Z
    36ae:	91 81       	ldd	r25, Z+1	; 0x01
    36b0:	89 2b       	or	r24, r25
    36b2:	41 f4       	brne	.+16     	; 0x36c4 <xQueueSemaphoreTake+0x6a>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    36b4:	0e 94 86 2b 	call	0x570c	; 0x570c <pvTaskIncrementMutexHeldCount>
    36b8:	9c 01       	movw	r18, r24
    36ba:	8b 81       	ldd	r24, Y+3	; 0x03
    36bc:	9c 81       	ldd	r25, Y+4	; 0x04
    36be:	fc 01       	movw	r30, r24
    36c0:	35 83       	std	Z+5, r19	; 0x05
    36c2:	24 83       	std	Z+4, r18	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    36c4:	8b 81       	ldd	r24, Y+3	; 0x03
    36c6:	9c 81       	ldd	r25, Y+4	; 0x04
    36c8:	fc 01       	movw	r30, r24
    36ca:	80 85       	ldd	r24, Z+8	; 0x08
    36cc:	88 23       	and	r24, r24
    36ce:	49 f0       	breq	.+18     	; 0x36e2 <xQueueSemaphoreTake+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    36d0:	8b 81       	ldd	r24, Y+3	; 0x03
    36d2:	9c 81       	ldd	r25, Y+4	; 0x04
    36d4:	08 96       	adiw	r24, 0x08	; 8
    36d6:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    36da:	88 23       	and	r24, r24
    36dc:	11 f0       	breq	.+4      	; 0x36e2 <xQueueSemaphoreTake+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
    36de:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    36e2:	0f 90       	pop	r0
    36e4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    36e6:	81 e0       	ldi	r24, 0x01	; 1
    36e8:	90 c0       	rjmp	.+288    	; 0x380a <xQueueSemaphoreTake+0x1b0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    36ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    36ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    36ee:	89 2b       	or	r24, r25
    36f0:	21 f4       	brne	.+8      	; 0x36fa <xQueueSemaphoreTake+0xa0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    36f2:	0f 90       	pop	r0
    36f4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    36f6:	80 e0       	ldi	r24, 0x00	; 0
    36f8:	88 c0       	rjmp	.+272    	; 0x380a <xQueueSemaphoreTake+0x1b0>
				}
				else if( xEntryTimeSet == pdFALSE )
    36fa:	89 81       	ldd	r24, Y+1	; 0x01
    36fc:	88 23       	and	r24, r24
    36fe:	31 f4       	brne	.+12     	; 0x370c <xQueueSemaphoreTake+0xb2>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3700:	ce 01       	movw	r24, r28
    3702:	07 96       	adiw	r24, 0x07	; 7
    3704:	0e 94 1d 28 	call	0x503a	; 0x503a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3708:	81 e0       	ldi	r24, 0x01	; 1
    370a:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    370c:	0f 90       	pop	r0
    370e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    3710:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3714:	0f b6       	in	r0, 0x3f	; 63
    3716:	f8 94       	cli
    3718:	0f 92       	push	r0
    371a:	8b 81       	ldd	r24, Y+3	; 0x03
    371c:	9c 81       	ldd	r25, Y+4	; 0x04
    371e:	fc 01       	movw	r30, r24
    3720:	85 8d       	ldd	r24, Z+29	; 0x1d
    3722:	8f 3f       	cpi	r24, 0xFF	; 255
    3724:	21 f4       	brne	.+8      	; 0x372e <xQueueSemaphoreTake+0xd4>
    3726:	8b 81       	ldd	r24, Y+3	; 0x03
    3728:	9c 81       	ldd	r25, Y+4	; 0x04
    372a:	fc 01       	movw	r30, r24
    372c:	15 8e       	std	Z+29, r1	; 0x1d
    372e:	8b 81       	ldd	r24, Y+3	; 0x03
    3730:	9c 81       	ldd	r25, Y+4	; 0x04
    3732:	fc 01       	movw	r30, r24
    3734:	86 8d       	ldd	r24, Z+30	; 0x1e
    3736:	8f 3f       	cpi	r24, 0xFF	; 255
    3738:	21 f4       	brne	.+8      	; 0x3742 <xQueueSemaphoreTake+0xe8>
    373a:	8b 81       	ldd	r24, Y+3	; 0x03
    373c:	9c 81       	ldd	r25, Y+4	; 0x04
    373e:	fc 01       	movw	r30, r24
    3740:	16 8e       	std	Z+30, r1	; 0x1e
    3742:	0f 90       	pop	r0
    3744:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3746:	9e 01       	movw	r18, r28
    3748:	24 5f       	subi	r18, 0xF4	; 244
    374a:	3f 4f       	sbci	r19, 0xFF	; 255
    374c:	ce 01       	movw	r24, r28
    374e:	07 96       	adiw	r24, 0x07	; 7
    3750:	b9 01       	movw	r22, r18
    3752:	0e 94 39 28 	call	0x5072	; 0x5072 <xTaskCheckForTimeOut>
    3756:	88 23       	and	r24, r24
    3758:	a9 f5       	brne	.+106    	; 0x37c4 <xQueueSemaphoreTake+0x16a>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    375a:	8b 81       	ldd	r24, Y+3	; 0x03
    375c:	9c 81       	ldd	r25, Y+4	; 0x04
    375e:	0e 94 76 1f 	call	0x3eec	; 0x3eec <prvIsQueueEmpty>
    3762:	88 23       	and	r24, r24
    3764:	41 f1       	breq	.+80     	; 0x37b6 <xQueueSemaphoreTake+0x15c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3766:	8b 81       	ldd	r24, Y+3	; 0x03
    3768:	9c 81       	ldd	r25, Y+4	; 0x04
    376a:	fc 01       	movw	r30, r24
    376c:	80 81       	ld	r24, Z
    376e:	91 81       	ldd	r25, Z+1	; 0x01
    3770:	89 2b       	or	r24, r25
    3772:	69 f4       	brne	.+26     	; 0x378e <xQueueSemaphoreTake+0x134>
					{
						taskENTER_CRITICAL();
    3774:	0f b6       	in	r0, 0x3f	; 63
    3776:	f8 94       	cli
    3778:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    377a:	8b 81       	ldd	r24, Y+3	; 0x03
    377c:	9c 81       	ldd	r25, Y+4	; 0x04
    377e:	fc 01       	movw	r30, r24
    3780:	84 81       	ldd	r24, Z+4	; 0x04
    3782:	95 81       	ldd	r25, Z+5	; 0x05
    3784:	0e 94 93 29 	call	0x5326	; 0x5326 <xTaskPriorityInherit>
    3788:	8a 83       	std	Y+2, r24	; 0x02
						}
						taskEXIT_CRITICAL();
    378a:	0f 90       	pop	r0
    378c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    378e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3790:	3d 85       	ldd	r19, Y+13	; 0x0d
    3792:	8b 81       	ldd	r24, Y+3	; 0x03
    3794:	9c 81       	ldd	r25, Y+4	; 0x04
    3796:	41 96       	adiw	r24, 0x11	; 17
    3798:	b9 01       	movw	r22, r18
    379a:	0e 94 d6 26 	call	0x4dac	; 0x4dac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    379e:	8b 81       	ldd	r24, Y+3	; 0x03
    37a0:	9c 81       	ldd	r25, Y+4	; 0x04
    37a2:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    37a6:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    37aa:	88 23       	and	r24, r24
    37ac:	09 f0       	breq	.+2      	; 0x37b0 <xQueueSemaphoreTake+0x156>
    37ae:	69 cf       	rjmp	.-302    	; 0x3682 <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    37b0:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
    37b4:	66 cf       	rjmp	.-308    	; 0x3682 <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    37b6:	8b 81       	ldd	r24, Y+3	; 0x03
    37b8:	9c 81       	ldd	r25, Y+4	; 0x04
    37ba:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    37be:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    37c2:	5f cf       	rjmp	.-322    	; 0x3682 <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    37c4:	8b 81       	ldd	r24, Y+3	; 0x03
    37c6:	9c 81       	ldd	r25, Y+4	; 0x04
    37c8:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    37cc:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37d0:	8b 81       	ldd	r24, Y+3	; 0x03
    37d2:	9c 81       	ldd	r25, Y+4	; 0x04
    37d4:	0e 94 76 1f 	call	0x3eec	; 0x3eec <prvIsQueueEmpty>
    37d8:	88 23       	and	r24, r24
    37da:	09 f4       	brne	.+2      	; 0x37de <xQueueSemaphoreTake+0x184>
    37dc:	52 cf       	rjmp	.-348    	; 0x3682 <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    37de:	8a 81       	ldd	r24, Y+2	; 0x02
    37e0:	88 23       	and	r24, r24
    37e2:	91 f0       	breq	.+36     	; 0x3808 <xQueueSemaphoreTake+0x1ae>
					{
						taskENTER_CRITICAL();
    37e4:	0f b6       	in	r0, 0x3f	; 63
    37e6:	f8 94       	cli
    37e8:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    37ea:	8b 81       	ldd	r24, Y+3	; 0x03
    37ec:	9c 81       	ldd	r25, Y+4	; 0x04
    37ee:	0e 94 d4 1d 	call	0x3ba8	; 0x3ba8 <prvGetDisinheritPriorityAfterTimeout>
    37f2:	8e 83       	std	Y+6, r24	; 0x06
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    37f4:	8b 81       	ldd	r24, Y+3	; 0x03
    37f6:	9c 81       	ldd	r25, Y+4	; 0x04
    37f8:	fc 01       	movw	r30, r24
    37fa:	84 81       	ldd	r24, Z+4	; 0x04
    37fc:	95 81       	ldd	r25, Z+5	; 0x05
    37fe:	6e 81       	ldd	r22, Y+6	; 0x06
    3800:	0e 94 bc 2a 	call	0x5578	; 0x5578 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    3804:	0f 90       	pop	r0
    3806:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3808:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    380a:	2d 96       	adiw	r28, 0x0d	; 13
    380c:	0f b6       	in	r0, 0x3f	; 63
    380e:	f8 94       	cli
    3810:	de bf       	out	0x3e, r29	; 62
    3812:	0f be       	out	0x3f, r0	; 63
    3814:	cd bf       	out	0x3d, r28	; 61
    3816:	df 91       	pop	r29
    3818:	cf 91       	pop	r28
    381a:	08 95       	ret

0000381c <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    381c:	cf 93       	push	r28
    381e:	df 93       	push	r29
    3820:	cd b7       	in	r28, 0x3d	; 61
    3822:	de b7       	in	r29, 0x3e	; 62
    3824:	2f 97       	sbiw	r28, 0x0f	; 15
    3826:	0f b6       	in	r0, 0x3f	; 63
    3828:	f8 94       	cli
    382a:	de bf       	out	0x3e, r29	; 62
    382c:	0f be       	out	0x3f, r0	; 63
    382e:	cd bf       	out	0x3d, r28	; 61
    3830:	9b 87       	std	Y+11, r25	; 0x0b
    3832:	8a 87       	std	Y+10, r24	; 0x0a
    3834:	7d 87       	std	Y+13, r23	; 0x0d
    3836:	6c 87       	std	Y+12, r22	; 0x0c
    3838:	5f 87       	std	Y+15, r21	; 0x0f
    383a:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    383c:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    383e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3840:	9b 85       	ldd	r25, Y+11	; 0x0b
    3842:	9b 83       	std	Y+3, r25	; 0x03
    3844:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3846:	0f b6       	in	r0, 0x3f	; 63
    3848:	f8 94       	cli
    384a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    384c:	8a 81       	ldd	r24, Y+2	; 0x02
    384e:	9b 81       	ldd	r25, Y+3	; 0x03
    3850:	fc 01       	movw	r30, r24
    3852:	82 8d       	ldd	r24, Z+26	; 0x1a
    3854:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3856:	8c 81       	ldd	r24, Y+4	; 0x04
    3858:	88 23       	and	r24, r24
    385a:	41 f1       	breq	.+80     	; 0x38ac <xQueuePeek+0x90>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    385c:	8a 81       	ldd	r24, Y+2	; 0x02
    385e:	9b 81       	ldd	r25, Y+3	; 0x03
    3860:	fc 01       	movw	r30, r24
    3862:	86 81       	ldd	r24, Z+6	; 0x06
    3864:	97 81       	ldd	r25, Z+7	; 0x07
    3866:	9e 83       	std	Y+6, r25	; 0x06
    3868:	8d 83       	std	Y+5, r24	; 0x05

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    386a:	2c 85       	ldd	r18, Y+12	; 0x0c
    386c:	3d 85       	ldd	r19, Y+13	; 0x0d
    386e:	8a 81       	ldd	r24, Y+2	; 0x02
    3870:	9b 81       	ldd	r25, Y+3	; 0x03
    3872:	b9 01       	movw	r22, r18
    3874:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3878:	8a 81       	ldd	r24, Y+2	; 0x02
    387a:	9b 81       	ldd	r25, Y+3	; 0x03
    387c:	2d 81       	ldd	r18, Y+5	; 0x05
    387e:	3e 81       	ldd	r19, Y+6	; 0x06
    3880:	fc 01       	movw	r30, r24
    3882:	37 83       	std	Z+7, r19	; 0x07
    3884:	26 83       	std	Z+6, r18	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3886:	8a 81       	ldd	r24, Y+2	; 0x02
    3888:	9b 81       	ldd	r25, Y+3	; 0x03
    388a:	fc 01       	movw	r30, r24
    388c:	81 89       	ldd	r24, Z+17	; 0x11
    388e:	88 23       	and	r24, r24
    3890:	49 f0       	breq	.+18     	; 0x38a4 <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3892:	8a 81       	ldd	r24, Y+2	; 0x02
    3894:	9b 81       	ldd	r25, Y+3	; 0x03
    3896:	41 96       	adiw	r24, 0x11	; 17
    3898:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    389c:	88 23       	and	r24, r24
    389e:	11 f0       	breq	.+4      	; 0x38a4 <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    38a0:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    38a4:	0f 90       	pop	r0
    38a6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    38a8:	81 e0       	ldi	r24, 0x01	; 1
    38aa:	67 c0       	rjmp	.+206    	; 0x397a <xQueuePeek+0x15e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    38ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    38ae:	9f 85       	ldd	r25, Y+15	; 0x0f
    38b0:	89 2b       	or	r24, r25
    38b2:	21 f4       	brne	.+8      	; 0x38bc <xQueuePeek+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    38b4:	0f 90       	pop	r0
    38b6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    38b8:	80 e0       	ldi	r24, 0x00	; 0
    38ba:	5f c0       	rjmp	.+190    	; 0x397a <xQueuePeek+0x15e>
				}
				else if( xEntryTimeSet == pdFALSE )
    38bc:	89 81       	ldd	r24, Y+1	; 0x01
    38be:	88 23       	and	r24, r24
    38c0:	31 f4       	brne	.+12     	; 0x38ce <xQueuePeek+0xb2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    38c2:	ce 01       	movw	r24, r28
    38c4:	07 96       	adiw	r24, 0x07	; 7
    38c6:	0e 94 1d 28 	call	0x503a	; 0x503a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    38ce:	0f 90       	pop	r0
    38d0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    38d2:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    38d6:	0f b6       	in	r0, 0x3f	; 63
    38d8:	f8 94       	cli
    38da:	0f 92       	push	r0
    38dc:	8a 81       	ldd	r24, Y+2	; 0x02
    38de:	9b 81       	ldd	r25, Y+3	; 0x03
    38e0:	fc 01       	movw	r30, r24
    38e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    38e4:	8f 3f       	cpi	r24, 0xFF	; 255
    38e6:	21 f4       	brne	.+8      	; 0x38f0 <xQueuePeek+0xd4>
    38e8:	8a 81       	ldd	r24, Y+2	; 0x02
    38ea:	9b 81       	ldd	r25, Y+3	; 0x03
    38ec:	fc 01       	movw	r30, r24
    38ee:	15 8e       	std	Z+29, r1	; 0x1d
    38f0:	8a 81       	ldd	r24, Y+2	; 0x02
    38f2:	9b 81       	ldd	r25, Y+3	; 0x03
    38f4:	fc 01       	movw	r30, r24
    38f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    38f8:	8f 3f       	cpi	r24, 0xFF	; 255
    38fa:	21 f4       	brne	.+8      	; 0x3904 <xQueuePeek+0xe8>
    38fc:	8a 81       	ldd	r24, Y+2	; 0x02
    38fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3900:	fc 01       	movw	r30, r24
    3902:	16 8e       	std	Z+30, r1	; 0x1e
    3904:	0f 90       	pop	r0
    3906:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3908:	9e 01       	movw	r18, r28
    390a:	22 5f       	subi	r18, 0xF2	; 242
    390c:	3f 4f       	sbci	r19, 0xFF	; 255
    390e:	ce 01       	movw	r24, r28
    3910:	07 96       	adiw	r24, 0x07	; 7
    3912:	b9 01       	movw	r22, r18
    3914:	0e 94 39 28 	call	0x5072	; 0x5072 <xTaskCheckForTimeOut>
    3918:	88 23       	and	r24, r24
    391a:	09 f5       	brne	.+66     	; 0x395e <xQueuePeek+0x142>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    391c:	8a 81       	ldd	r24, Y+2	; 0x02
    391e:	9b 81       	ldd	r25, Y+3	; 0x03
    3920:	0e 94 76 1f 	call	0x3eec	; 0x3eec <prvIsQueueEmpty>
    3924:	88 23       	and	r24, r24
    3926:	a1 f0       	breq	.+40     	; 0x3950 <xQueuePeek+0x134>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3928:	2e 85       	ldd	r18, Y+14	; 0x0e
    392a:	3f 85       	ldd	r19, Y+15	; 0x0f
    392c:	8a 81       	ldd	r24, Y+2	; 0x02
    392e:	9b 81       	ldd	r25, Y+3	; 0x03
    3930:	41 96       	adiw	r24, 0x11	; 17
    3932:	b9 01       	movw	r22, r18
    3934:	0e 94 d6 26 	call	0x4dac	; 0x4dac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3938:	8a 81       	ldd	r24, Y+2	; 0x02
    393a:	9b 81       	ldd	r25, Y+3	; 0x03
    393c:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3940:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    3944:	88 23       	and	r24, r24
    3946:	09 f0       	breq	.+2      	; 0x394a <xQueuePeek+0x12e>
    3948:	7e cf       	rjmp	.-260    	; 0x3846 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    394a:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
    394e:	7b cf       	rjmp	.-266    	; 0x3846 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    3950:	8a 81       	ldd	r24, Y+2	; 0x02
    3952:	9b 81       	ldd	r25, Y+3	; 0x03
    3954:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3958:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    395c:	74 cf       	rjmp	.-280    	; 0x3846 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    395e:	8a 81       	ldd	r24, Y+2	; 0x02
    3960:	9b 81       	ldd	r25, Y+3	; 0x03
    3962:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3966:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    396a:	8a 81       	ldd	r24, Y+2	; 0x02
    396c:	9b 81       	ldd	r25, Y+3	; 0x03
    396e:	0e 94 76 1f 	call	0x3eec	; 0x3eec <prvIsQueueEmpty>
    3972:	88 23       	and	r24, r24
    3974:	09 f4       	brne	.+2      	; 0x3978 <xQueuePeek+0x15c>
    3976:	67 cf       	rjmp	.-306    	; 0x3846 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3978:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    397a:	2f 96       	adiw	r28, 0x0f	; 15
    397c:	0f b6       	in	r0, 0x3f	; 63
    397e:	f8 94       	cli
    3980:	de bf       	out	0x3e, r29	; 62
    3982:	0f be       	out	0x3f, r0	; 63
    3984:	cd bf       	out	0x3d, r28	; 61
    3986:	df 91       	pop	r29
    3988:	cf 91       	pop	r28
    398a:	08 95       	ret

0000398c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    398c:	cf 93       	push	r28
    398e:	df 93       	push	r29
    3990:	cd b7       	in	r28, 0x3d	; 61
    3992:	de b7       	in	r29, 0x3e	; 62
    3994:	2c 97       	sbiw	r28, 0x0c	; 12
    3996:	0f b6       	in	r0, 0x3f	; 63
    3998:	f8 94       	cli
    399a:	de bf       	out	0x3e, r29	; 62
    399c:	0f be       	out	0x3f, r0	; 63
    399e:	cd bf       	out	0x3d, r28	; 61
    39a0:	98 87       	std	Y+8, r25	; 0x08
    39a2:	8f 83       	std	Y+7, r24	; 0x07
    39a4:	7a 87       	std	Y+10, r23	; 0x0a
    39a6:	69 87       	std	Y+9, r22	; 0x09
    39a8:	5c 87       	std	Y+12, r21	; 0x0c
    39aa:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    39ac:	8f 81       	ldd	r24, Y+7	; 0x07
    39ae:	98 85       	ldd	r25, Y+8	; 0x08
    39b0:	9b 83       	std	Y+3, r25	; 0x03
    39b2:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    39b4:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    39b6:	8a 81       	ldd	r24, Y+2	; 0x02
    39b8:	9b 81       	ldd	r25, Y+3	; 0x03
    39ba:	fc 01       	movw	r30, r24
    39bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    39be:	8d 83       	std	Y+5, r24	; 0x05

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    39c0:	8d 81       	ldd	r24, Y+5	; 0x05
    39c2:	88 23       	and	r24, r24
    39c4:	b9 f1       	breq	.+110    	; 0x3a34 <xQueueReceiveFromISR+0xa8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    39c6:	8a 81       	ldd	r24, Y+2	; 0x02
    39c8:	9b 81       	ldd	r25, Y+3	; 0x03
    39ca:	fc 01       	movw	r30, r24
    39cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    39ce:	8e 83       	std	Y+6, r24	; 0x06

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    39d0:	29 85       	ldd	r18, Y+9	; 0x09
    39d2:	3a 85       	ldd	r19, Y+10	; 0x0a
    39d4:	8a 81       	ldd	r24, Y+2	; 0x02
    39d6:	9b 81       	ldd	r25, Y+3	; 0x03
    39d8:	b9 01       	movw	r22, r18
    39da:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    39de:	8d 81       	ldd	r24, Y+5	; 0x05
    39e0:	2f ef       	ldi	r18, 0xFF	; 255
    39e2:	28 0f       	add	r18, r24
    39e4:	8a 81       	ldd	r24, Y+2	; 0x02
    39e6:	9b 81       	ldd	r25, Y+3	; 0x03
    39e8:	fc 01       	movw	r30, r24
    39ea:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    39ec:	8e 81       	ldd	r24, Y+6	; 0x06
    39ee:	8f 3f       	cpi	r24, 0xFF	; 255
    39f0:	b9 f4       	brne	.+46     	; 0x3a20 <xQueueReceiveFromISR+0x94>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39f2:	8a 81       	ldd	r24, Y+2	; 0x02
    39f4:	9b 81       	ldd	r25, Y+3	; 0x03
    39f6:	fc 01       	movw	r30, r24
    39f8:	80 85       	ldd	r24, Z+8	; 0x08
    39fa:	88 23       	and	r24, r24
    39fc:	c1 f0       	breq	.+48     	; 0x3a2e <xQueueReceiveFromISR+0xa2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    39fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3a00:	9b 81       	ldd	r25, Y+3	; 0x03
    3a02:	08 96       	adiw	r24, 0x08	; 8
    3a04:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    3a08:	88 23       	and	r24, r24
    3a0a:	89 f0       	breq	.+34     	; 0x3a2e <xQueueReceiveFromISR+0xa2>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3a0c:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a0e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a10:	89 2b       	or	r24, r25
    3a12:	69 f0       	breq	.+26     	; 0x3a2e <xQueueReceiveFromISR+0xa2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3a14:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a16:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a18:	21 e0       	ldi	r18, 0x01	; 1
    3a1a:	fc 01       	movw	r30, r24
    3a1c:	20 83       	st	Z, r18
    3a1e:	07 c0       	rjmp	.+14     	; 0x3a2e <xQueueReceiveFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3a20:	8e 81       	ldd	r24, Y+6	; 0x06
    3a22:	8f 5f       	subi	r24, 0xFF	; 255
    3a24:	28 2f       	mov	r18, r24
    3a26:	8a 81       	ldd	r24, Y+2	; 0x02
    3a28:	9b 81       	ldd	r25, Y+3	; 0x03
    3a2a:	fc 01       	movw	r30, r24
    3a2c:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3a2e:	81 e0       	ldi	r24, 0x01	; 1
    3a30:	89 83       	std	Y+1, r24	; 0x01
    3a32:	01 c0       	rjmp	.+2      	; 0x3a36 <xQueueReceiveFromISR+0xaa>
		}
		else
		{
			xReturn = pdFAIL;
    3a34:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3a36:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a38:	2c 96       	adiw	r28, 0x0c	; 12
    3a3a:	0f b6       	in	r0, 0x3f	; 63
    3a3c:	f8 94       	cli
    3a3e:	de bf       	out	0x3e, r29	; 62
    3a40:	0f be       	out	0x3f, r0	; 63
    3a42:	cd bf       	out	0x3d, r28	; 61
    3a44:	df 91       	pop	r29
    3a46:	cf 91       	pop	r28
    3a48:	08 95       	ret

00003a4a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3a4a:	cf 93       	push	r28
    3a4c:	df 93       	push	r29
    3a4e:	cd b7       	in	r28, 0x3d	; 61
    3a50:	de b7       	in	r29, 0x3e	; 62
    3a52:	2a 97       	sbiw	r28, 0x0a	; 10
    3a54:	0f b6       	in	r0, 0x3f	; 63
    3a56:	f8 94       	cli
    3a58:	de bf       	out	0x3e, r29	; 62
    3a5a:	0f be       	out	0x3f, r0	; 63
    3a5c:	cd bf       	out	0x3d, r28	; 61
    3a5e:	98 87       	std	Y+8, r25	; 0x08
    3a60:	8f 83       	std	Y+7, r24	; 0x07
    3a62:	7a 87       	std	Y+10, r23	; 0x0a
    3a64:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3a66:	8f 81       	ldd	r24, Y+7	; 0x07
    3a68:	98 85       	ldd	r25, Y+8	; 0x08
    3a6a:	9b 83       	std	Y+3, r25	; 0x03
    3a6c:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3a6e:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a70:	8a 81       	ldd	r24, Y+2	; 0x02
    3a72:	9b 81       	ldd	r25, Y+3	; 0x03
    3a74:	fc 01       	movw	r30, r24
    3a76:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a78:	88 23       	and	r24, r24
    3a7a:	c1 f0       	breq	.+48     	; 0x3aac <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a80:	fc 01       	movw	r30, r24
    3a82:	86 81       	ldd	r24, Z+6	; 0x06
    3a84:	97 81       	ldd	r25, Z+7	; 0x07
    3a86:	9e 83       	std	Y+6, r25	; 0x06
    3a88:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a8a:	29 85       	ldd	r18, Y+9	; 0x09
    3a8c:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a90:	9b 81       	ldd	r25, Y+3	; 0x03
    3a92:	b9 01       	movw	r22, r18
    3a94:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3a98:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a9c:	2d 81       	ldd	r18, Y+5	; 0x05
    3a9e:	3e 81       	ldd	r19, Y+6	; 0x06
    3aa0:	fc 01       	movw	r30, r24
    3aa2:	37 83       	std	Z+7, r19	; 0x07
    3aa4:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3aa6:	81 e0       	ldi	r24, 0x01	; 1
    3aa8:	89 83       	std	Y+1, r24	; 0x01
    3aaa:	01 c0       	rjmp	.+2      	; 0x3aae <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    3aac:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3aae:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ab0:	2a 96       	adiw	r28, 0x0a	; 10
    3ab2:	0f b6       	in	r0, 0x3f	; 63
    3ab4:	f8 94       	cli
    3ab6:	de bf       	out	0x3e, r29	; 62
    3ab8:	0f be       	out	0x3f, r0	; 63
    3aba:	cd bf       	out	0x3d, r28	; 61
    3abc:	df 91       	pop	r29
    3abe:	cf 91       	pop	r28
    3ac0:	08 95       	ret

00003ac2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3ac2:	cf 93       	push	r28
    3ac4:	df 93       	push	r29
    3ac6:	00 d0       	rcall	.+0      	; 0x3ac8 <uxQueueMessagesWaiting+0x6>
    3ac8:	1f 92       	push	r1
    3aca:	cd b7       	in	r28, 0x3d	; 61
    3acc:	de b7       	in	r29, 0x3e	; 62
    3ace:	9b 83       	std	Y+3, r25	; 0x03
    3ad0:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3ad2:	0f b6       	in	r0, 0x3f	; 63
    3ad4:	f8 94       	cli
    3ad6:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3ad8:	8a 81       	ldd	r24, Y+2	; 0x02
    3ada:	9b 81       	ldd	r25, Y+3	; 0x03
    3adc:	fc 01       	movw	r30, r24
    3ade:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ae0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3ae2:	0f 90       	pop	r0
    3ae4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3ae6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3ae8:	0f 90       	pop	r0
    3aea:	0f 90       	pop	r0
    3aec:	0f 90       	pop	r0
    3aee:	df 91       	pop	r29
    3af0:	cf 91       	pop	r28
    3af2:	08 95       	ret

00003af4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3af4:	cf 93       	push	r28
    3af6:	df 93       	push	r29
    3af8:	00 d0       	rcall	.+0      	; 0x3afa <uxQueueSpacesAvailable+0x6>
    3afa:	00 d0       	rcall	.+0      	; 0x3afc <uxQueueSpacesAvailable+0x8>
    3afc:	1f 92       	push	r1
    3afe:	cd b7       	in	r28, 0x3d	; 61
    3b00:	de b7       	in	r29, 0x3e	; 62
    3b02:	9d 83       	std	Y+5, r25	; 0x05
    3b04:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3b06:	8c 81       	ldd	r24, Y+4	; 0x04
    3b08:	9d 81       	ldd	r25, Y+5	; 0x05
    3b0a:	9a 83       	std	Y+2, r25	; 0x02
    3b0c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3b0e:	0f b6       	in	r0, 0x3f	; 63
    3b10:	f8 94       	cli
    3b12:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3b14:	89 81       	ldd	r24, Y+1	; 0x01
    3b16:	9a 81       	ldd	r25, Y+2	; 0x02
    3b18:	fc 01       	movw	r30, r24
    3b1a:	23 8d       	ldd	r18, Z+27	; 0x1b
    3b1c:	89 81       	ldd	r24, Y+1	; 0x01
    3b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b20:	fc 01       	movw	r30, r24
    3b22:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b24:	f2 2f       	mov	r31, r18
    3b26:	f8 1b       	sub	r31, r24
    3b28:	8f 2f       	mov	r24, r31
    3b2a:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3b2c:	0f 90       	pop	r0
    3b2e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3b30:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b32:	0f 90       	pop	r0
    3b34:	0f 90       	pop	r0
    3b36:	0f 90       	pop	r0
    3b38:	0f 90       	pop	r0
    3b3a:	0f 90       	pop	r0
    3b3c:	df 91       	pop	r29
    3b3e:	cf 91       	pop	r28
    3b40:	08 95       	ret

00003b42 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3b42:	cf 93       	push	r28
    3b44:	df 93       	push	r29
    3b46:	00 d0       	rcall	.+0      	; 0x3b48 <uxQueueMessagesWaitingFromISR+0x6>
    3b48:	00 d0       	rcall	.+0      	; 0x3b4a <uxQueueMessagesWaitingFromISR+0x8>
    3b4a:	1f 92       	push	r1
    3b4c:	cd b7       	in	r28, 0x3d	; 61
    3b4e:	de b7       	in	r29, 0x3e	; 62
    3b50:	9d 83       	std	Y+5, r25	; 0x05
    3b52:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3b54:	8c 81       	ldd	r24, Y+4	; 0x04
    3b56:	9d 81       	ldd	r25, Y+5	; 0x05
    3b58:	9a 83       	std	Y+2, r25	; 0x02
    3b5a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3b5c:	89 81       	ldd	r24, Y+1	; 0x01
    3b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b60:	fc 01       	movw	r30, r24
    3b62:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b64:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3b66:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b68:	0f 90       	pop	r0
    3b6a:	0f 90       	pop	r0
    3b6c:	0f 90       	pop	r0
    3b6e:	0f 90       	pop	r0
    3b70:	0f 90       	pop	r0
    3b72:	df 91       	pop	r29
    3b74:	cf 91       	pop	r28
    3b76:	08 95       	ret

00003b78 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3b78:	cf 93       	push	r28
    3b7a:	df 93       	push	r29
    3b7c:	00 d0       	rcall	.+0      	; 0x3b7e <vQueueDelete+0x6>
    3b7e:	00 d0       	rcall	.+0      	; 0x3b80 <vQueueDelete+0x8>
    3b80:	cd b7       	in	r28, 0x3d	; 61
    3b82:	de b7       	in	r29, 0x3e	; 62
    3b84:	9c 83       	std	Y+4, r25	; 0x04
    3b86:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3b88:	8b 81       	ldd	r24, Y+3	; 0x03
    3b8a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b8c:	9a 83       	std	Y+2, r25	; 0x02
    3b8e:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3b90:	89 81       	ldd	r24, Y+1	; 0x01
    3b92:	9a 81       	ldd	r25, Y+2	; 0x02
    3b94:	0e 94 bf 12 	call	0x257e	; 0x257e <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3b98:	00 00       	nop
    3b9a:	0f 90       	pop	r0
    3b9c:	0f 90       	pop	r0
    3b9e:	0f 90       	pop	r0
    3ba0:	0f 90       	pop	r0
    3ba2:	df 91       	pop	r29
    3ba4:	cf 91       	pop	r28
    3ba6:	08 95       	ret

00003ba8 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    3ba8:	cf 93       	push	r28
    3baa:	df 93       	push	r29
    3bac:	00 d0       	rcall	.+0      	; 0x3bae <prvGetDisinheritPriorityAfterTimeout+0x6>
    3bae:	1f 92       	push	r1
    3bb0:	cd b7       	in	r28, 0x3d	; 61
    3bb2:	de b7       	in	r29, 0x3e	; 62
    3bb4:	9b 83       	std	Y+3, r25	; 0x03
    3bb6:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    3bb8:	8a 81       	ldd	r24, Y+2	; 0x02
    3bba:	9b 81       	ldd	r25, Y+3	; 0x03
    3bbc:	fc 01       	movw	r30, r24
    3bbe:	81 89       	ldd	r24, Z+17	; 0x11
    3bc0:	88 23       	and	r24, r24
    3bc2:	69 f0       	breq	.+26     	; 0x3bde <prvGetDisinheritPriorityAfterTimeout+0x36>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    3bc4:	8a 81       	ldd	r24, Y+2	; 0x02
    3bc6:	9b 81       	ldd	r25, Y+3	; 0x03
    3bc8:	fc 01       	movw	r30, r24
    3bca:	86 89       	ldd	r24, Z+22	; 0x16
    3bcc:	97 89       	ldd	r25, Z+23	; 0x17
    3bce:	fc 01       	movw	r30, r24
    3bd0:	80 81       	ld	r24, Z
    3bd2:	91 81       	ldd	r25, Z+1	; 0x01
    3bd4:	98 2f       	mov	r25, r24
    3bd6:	85 e0       	ldi	r24, 0x05	; 5
    3bd8:	89 1b       	sub	r24, r25
    3bda:	89 83       	std	Y+1, r24	; 0x01
    3bdc:	01 c0       	rjmp	.+2      	; 0x3be0 <prvGetDisinheritPriorityAfterTimeout+0x38>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    3bde:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    3be0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3be2:	0f 90       	pop	r0
    3be4:	0f 90       	pop	r0
    3be6:	0f 90       	pop	r0
    3be8:	df 91       	pop	r29
    3bea:	cf 91       	pop	r28
    3bec:	08 95       	ret

00003bee <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3bee:	cf 93       	push	r28
    3bf0:	df 93       	push	r29
    3bf2:	cd b7       	in	r28, 0x3d	; 61
    3bf4:	de b7       	in	r29, 0x3e	; 62
    3bf6:	27 97       	sbiw	r28, 0x07	; 7
    3bf8:	0f b6       	in	r0, 0x3f	; 63
    3bfa:	f8 94       	cli
    3bfc:	de bf       	out	0x3e, r29	; 62
    3bfe:	0f be       	out	0x3f, r0	; 63
    3c00:	cd bf       	out	0x3d, r28	; 61
    3c02:	9c 83       	std	Y+4, r25	; 0x04
    3c04:	8b 83       	std	Y+3, r24	; 0x03
    3c06:	7e 83       	std	Y+6, r23	; 0x06
    3c08:	6d 83       	std	Y+5, r22	; 0x05
    3c0a:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3c0c:	19 82       	std	Y+1, r1	; 0x01
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c10:	9c 81       	ldd	r25, Y+4	; 0x04
    3c12:	fc 01       	movw	r30, r24
    3c14:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c16:	8a 83       	std	Y+2, r24	; 0x02

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3c18:	8b 81       	ldd	r24, Y+3	; 0x03
    3c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c1c:	fc 01       	movw	r30, r24
    3c1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c20:	88 23       	and	r24, r24
    3c22:	b1 f4       	brne	.+44     	; 0x3c50 <prvCopyDataToQueue+0x62>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3c24:	8b 81       	ldd	r24, Y+3	; 0x03
    3c26:	9c 81       	ldd	r25, Y+4	; 0x04
    3c28:	fc 01       	movw	r30, r24
    3c2a:	80 81       	ld	r24, Z
    3c2c:	91 81       	ldd	r25, Z+1	; 0x01
    3c2e:	89 2b       	or	r24, r25
    3c30:	09 f0       	breq	.+2      	; 0x3c34 <prvCopyDataToQueue+0x46>
    3c32:	9c c0       	rjmp	.+312    	; 0x3d6c <prvCopyDataToQueue+0x17e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    3c34:	8b 81       	ldd	r24, Y+3	; 0x03
    3c36:	9c 81       	ldd	r25, Y+4	; 0x04
    3c38:	fc 01       	movw	r30, r24
    3c3a:	84 81       	ldd	r24, Z+4	; 0x04
    3c3c:	95 81       	ldd	r25, Z+5	; 0x05
    3c3e:	0e 94 3f 2a 	call	0x547e	; 0x547e <xTaskPriorityDisinherit>
    3c42:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    3c44:	8b 81       	ldd	r24, Y+3	; 0x03
    3c46:	9c 81       	ldd	r25, Y+4	; 0x04
    3c48:	fc 01       	movw	r30, r24
    3c4a:	15 82       	std	Z+5, r1	; 0x05
    3c4c:	14 82       	std	Z+4, r1	; 0x04
    3c4e:	8e c0       	rjmp	.+284    	; 0x3d6c <prvCopyDataToQueue+0x17e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3c50:	8f 81       	ldd	r24, Y+7	; 0x07
    3c52:	88 23       	and	r24, r24
    3c54:	d9 f5       	brne	.+118    	; 0x3ccc <prvCopyDataToQueue+0xde>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3c56:	8b 81       	ldd	r24, Y+3	; 0x03
    3c58:	9c 81       	ldd	r25, Y+4	; 0x04
    3c5a:	fc 01       	movw	r30, r24
    3c5c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c5e:	48 2f       	mov	r20, r24
    3c60:	50 e0       	ldi	r21, 0x00	; 0
    3c62:	8b 81       	ldd	r24, Y+3	; 0x03
    3c64:	9c 81       	ldd	r25, Y+4	; 0x04
    3c66:	fc 01       	movw	r30, r24
    3c68:	82 81       	ldd	r24, Z+2	; 0x02
    3c6a:	93 81       	ldd	r25, Z+3	; 0x03
    3c6c:	2d 81       	ldd	r18, Y+5	; 0x05
    3c6e:	3e 81       	ldd	r19, Y+6	; 0x06
    3c70:	b9 01       	movw	r22, r18
    3c72:	0e 94 e1 31 	call	0x63c2	; 0x63c2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3c76:	8b 81       	ldd	r24, Y+3	; 0x03
    3c78:	9c 81       	ldd	r25, Y+4	; 0x04
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	22 81       	ldd	r18, Z+2	; 0x02
    3c7e:	33 81       	ldd	r19, Z+3	; 0x03
    3c80:	8b 81       	ldd	r24, Y+3	; 0x03
    3c82:	9c 81       	ldd	r25, Y+4	; 0x04
    3c84:	fc 01       	movw	r30, r24
    3c86:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c88:	88 2f       	mov	r24, r24
    3c8a:	90 e0       	ldi	r25, 0x00	; 0
    3c8c:	28 0f       	add	r18, r24
    3c8e:	39 1f       	adc	r19, r25
    3c90:	8b 81       	ldd	r24, Y+3	; 0x03
    3c92:	9c 81       	ldd	r25, Y+4	; 0x04
    3c94:	fc 01       	movw	r30, r24
    3c96:	33 83       	std	Z+3, r19	; 0x03
    3c98:	22 83       	std	Z+2, r18	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c9e:	fc 01       	movw	r30, r24
    3ca0:	22 81       	ldd	r18, Z+2	; 0x02
    3ca2:	33 81       	ldd	r19, Z+3	; 0x03
    3ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ca8:	fc 01       	movw	r30, r24
    3caa:	84 81       	ldd	r24, Z+4	; 0x04
    3cac:	95 81       	ldd	r25, Z+5	; 0x05
    3cae:	28 17       	cp	r18, r24
    3cb0:	39 07       	cpc	r19, r25
    3cb2:	08 f4       	brcc	.+2      	; 0x3cb6 <prvCopyDataToQueue+0xc8>
    3cb4:	5b c0       	rjmp	.+182    	; 0x3d6c <prvCopyDataToQueue+0x17e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cba:	fc 01       	movw	r30, r24
    3cbc:	20 81       	ld	r18, Z
    3cbe:	31 81       	ldd	r19, Z+1	; 0x01
    3cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc4:	fc 01       	movw	r30, r24
    3cc6:	33 83       	std	Z+3, r19	; 0x03
    3cc8:	22 83       	std	Z+2, r18	; 0x02
    3cca:	50 c0       	rjmp	.+160    	; 0x3d6c <prvCopyDataToQueue+0x17e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cce:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd0:	fc 01       	movw	r30, r24
    3cd2:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cd4:	48 2f       	mov	r20, r24
    3cd6:	50 e0       	ldi	r21, 0x00	; 0
    3cd8:	8b 81       	ldd	r24, Y+3	; 0x03
    3cda:	9c 81       	ldd	r25, Y+4	; 0x04
    3cdc:	fc 01       	movw	r30, r24
    3cde:	86 81       	ldd	r24, Z+6	; 0x06
    3ce0:	97 81       	ldd	r25, Z+7	; 0x07
    3ce2:	2d 81       	ldd	r18, Y+5	; 0x05
    3ce4:	3e 81       	ldd	r19, Y+6	; 0x06
    3ce6:	b9 01       	movw	r22, r18
    3ce8:	0e 94 e1 31 	call	0x63c2	; 0x63c2 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3cec:	8b 81       	ldd	r24, Y+3	; 0x03
    3cee:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf0:	fc 01       	movw	r30, r24
    3cf2:	26 81       	ldd	r18, Z+6	; 0x06
    3cf4:	37 81       	ldd	r19, Z+7	; 0x07
    3cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cfa:	fc 01       	movw	r30, r24
    3cfc:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cfe:	88 2f       	mov	r24, r24
    3d00:	90 e0       	ldi	r25, 0x00	; 0
    3d02:	91 95       	neg	r25
    3d04:	81 95       	neg	r24
    3d06:	91 09       	sbc	r25, r1
    3d08:	28 0f       	add	r18, r24
    3d0a:	39 1f       	adc	r19, r25
    3d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d10:	fc 01       	movw	r30, r24
    3d12:	37 83       	std	Z+7, r19	; 0x07
    3d14:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d16:	8b 81       	ldd	r24, Y+3	; 0x03
    3d18:	9c 81       	ldd	r25, Y+4	; 0x04
    3d1a:	fc 01       	movw	r30, r24
    3d1c:	26 81       	ldd	r18, Z+6	; 0x06
    3d1e:	37 81       	ldd	r19, Z+7	; 0x07
    3d20:	8b 81       	ldd	r24, Y+3	; 0x03
    3d22:	9c 81       	ldd	r25, Y+4	; 0x04
    3d24:	fc 01       	movw	r30, r24
    3d26:	80 81       	ld	r24, Z
    3d28:	91 81       	ldd	r25, Z+1	; 0x01
    3d2a:	28 17       	cp	r18, r24
    3d2c:	39 07       	cpc	r19, r25
    3d2e:	a8 f4       	brcc	.+42     	; 0x3d5a <prvCopyDataToQueue+0x16c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3d30:	8b 81       	ldd	r24, Y+3	; 0x03
    3d32:	9c 81       	ldd	r25, Y+4	; 0x04
    3d34:	fc 01       	movw	r30, r24
    3d36:	24 81       	ldd	r18, Z+4	; 0x04
    3d38:	35 81       	ldd	r19, Z+5	; 0x05
    3d3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d3c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d3e:	fc 01       	movw	r30, r24
    3d40:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d42:	88 2f       	mov	r24, r24
    3d44:	90 e0       	ldi	r25, 0x00	; 0
    3d46:	91 95       	neg	r25
    3d48:	81 95       	neg	r24
    3d4a:	91 09       	sbc	r25, r1
    3d4c:	28 0f       	add	r18, r24
    3d4e:	39 1f       	adc	r19, r25
    3d50:	8b 81       	ldd	r24, Y+3	; 0x03
    3d52:	9c 81       	ldd	r25, Y+4	; 0x04
    3d54:	fc 01       	movw	r30, r24
    3d56:	37 83       	std	Z+7, r19	; 0x07
    3d58:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3d5a:	8f 81       	ldd	r24, Y+7	; 0x07
    3d5c:	82 30       	cpi	r24, 0x02	; 2
    3d5e:	31 f4       	brne	.+12     	; 0x3d6c <prvCopyDataToQueue+0x17e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3d60:	8a 81       	ldd	r24, Y+2	; 0x02
    3d62:	88 23       	and	r24, r24
    3d64:	19 f0       	breq	.+6      	; 0x3d6c <prvCopyDataToQueue+0x17e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3d66:	8a 81       	ldd	r24, Y+2	; 0x02
    3d68:	81 50       	subi	r24, 0x01	; 1
    3d6a:	8a 83       	std	Y+2, r24	; 0x02
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3d6c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d6e:	21 e0       	ldi	r18, 0x01	; 1
    3d70:	28 0f       	add	r18, r24
    3d72:	8b 81       	ldd	r24, Y+3	; 0x03
    3d74:	9c 81       	ldd	r25, Y+4	; 0x04
    3d76:	fc 01       	movw	r30, r24
    3d78:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3d7a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d7c:	27 96       	adiw	r28, 0x07	; 7
    3d7e:	0f b6       	in	r0, 0x3f	; 63
    3d80:	f8 94       	cli
    3d82:	de bf       	out	0x3e, r29	; 62
    3d84:	0f be       	out	0x3f, r0	; 63
    3d86:	cd bf       	out	0x3d, r28	; 61
    3d88:	df 91       	pop	r29
    3d8a:	cf 91       	pop	r28
    3d8c:	08 95       	ret

00003d8e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3d8e:	cf 93       	push	r28
    3d90:	df 93       	push	r29
    3d92:	00 d0       	rcall	.+0      	; 0x3d94 <prvCopyDataFromQueue+0x6>
    3d94:	00 d0       	rcall	.+0      	; 0x3d96 <prvCopyDataFromQueue+0x8>
    3d96:	cd b7       	in	r28, 0x3d	; 61
    3d98:	de b7       	in	r29, 0x3e	; 62
    3d9a:	9a 83       	std	Y+2, r25	; 0x02
    3d9c:	89 83       	std	Y+1, r24	; 0x01
    3d9e:	7c 83       	std	Y+4, r23	; 0x04
    3da0:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3da2:	89 81       	ldd	r24, Y+1	; 0x01
    3da4:	9a 81       	ldd	r25, Y+2	; 0x02
    3da6:	fc 01       	movw	r30, r24
    3da8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3daa:	88 23       	and	r24, r24
    3dac:	c9 f1       	breq	.+114    	; 0x3e20 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3dae:	89 81       	ldd	r24, Y+1	; 0x01
    3db0:	9a 81       	ldd	r25, Y+2	; 0x02
    3db2:	fc 01       	movw	r30, r24
    3db4:	26 81       	ldd	r18, Z+6	; 0x06
    3db6:	37 81       	ldd	r19, Z+7	; 0x07
    3db8:	89 81       	ldd	r24, Y+1	; 0x01
    3dba:	9a 81       	ldd	r25, Y+2	; 0x02
    3dbc:	fc 01       	movw	r30, r24
    3dbe:	84 8d       	ldd	r24, Z+28	; 0x1c
    3dc0:	88 2f       	mov	r24, r24
    3dc2:	90 e0       	ldi	r25, 0x00	; 0
    3dc4:	28 0f       	add	r18, r24
    3dc6:	39 1f       	adc	r19, r25
    3dc8:	89 81       	ldd	r24, Y+1	; 0x01
    3dca:	9a 81       	ldd	r25, Y+2	; 0x02
    3dcc:	fc 01       	movw	r30, r24
    3dce:	37 83       	std	Z+7, r19	; 0x07
    3dd0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3dd2:	89 81       	ldd	r24, Y+1	; 0x01
    3dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    3dd6:	fc 01       	movw	r30, r24
    3dd8:	26 81       	ldd	r18, Z+6	; 0x06
    3dda:	37 81       	ldd	r19, Z+7	; 0x07
    3ddc:	89 81       	ldd	r24, Y+1	; 0x01
    3dde:	9a 81       	ldd	r25, Y+2	; 0x02
    3de0:	fc 01       	movw	r30, r24
    3de2:	84 81       	ldd	r24, Z+4	; 0x04
    3de4:	95 81       	ldd	r25, Z+5	; 0x05
    3de6:	28 17       	cp	r18, r24
    3de8:	39 07       	cpc	r19, r25
    3dea:	50 f0       	brcs	.+20     	; 0x3e00 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3dec:	89 81       	ldd	r24, Y+1	; 0x01
    3dee:	9a 81       	ldd	r25, Y+2	; 0x02
    3df0:	fc 01       	movw	r30, r24
    3df2:	20 81       	ld	r18, Z
    3df4:	31 81       	ldd	r19, Z+1	; 0x01
    3df6:	89 81       	ldd	r24, Y+1	; 0x01
    3df8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dfa:	fc 01       	movw	r30, r24
    3dfc:	37 83       	std	Z+7, r19	; 0x07
    3dfe:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3e00:	89 81       	ldd	r24, Y+1	; 0x01
    3e02:	9a 81       	ldd	r25, Y+2	; 0x02
    3e04:	fc 01       	movw	r30, r24
    3e06:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e08:	48 2f       	mov	r20, r24
    3e0a:	50 e0       	ldi	r21, 0x00	; 0
    3e0c:	89 81       	ldd	r24, Y+1	; 0x01
    3e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e10:	fc 01       	movw	r30, r24
    3e12:	26 81       	ldd	r18, Z+6	; 0x06
    3e14:	37 81       	ldd	r19, Z+7	; 0x07
    3e16:	8b 81       	ldd	r24, Y+3	; 0x03
    3e18:	9c 81       	ldd	r25, Y+4	; 0x04
    3e1a:	b9 01       	movw	r22, r18
    3e1c:	0e 94 e1 31 	call	0x63c2	; 0x63c2 <memcpy>
	}
}
    3e20:	00 00       	nop
    3e22:	0f 90       	pop	r0
    3e24:	0f 90       	pop	r0
    3e26:	0f 90       	pop	r0
    3e28:	0f 90       	pop	r0
    3e2a:	df 91       	pop	r29
    3e2c:	cf 91       	pop	r28
    3e2e:	08 95       	ret

00003e30 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3e30:	cf 93       	push	r28
    3e32:	df 93       	push	r29
    3e34:	00 d0       	rcall	.+0      	; 0x3e36 <prvUnlockQueue+0x6>
    3e36:	00 d0       	rcall	.+0      	; 0x3e38 <prvUnlockQueue+0x8>
    3e38:	cd b7       	in	r28, 0x3d	; 61
    3e3a:	de b7       	in	r29, 0x3e	; 62
    3e3c:	9c 83       	std	Y+4, r25	; 0x04
    3e3e:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3e40:	0f b6       	in	r0, 0x3f	; 63
    3e42:	f8 94       	cli
    3e44:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3e46:	8b 81       	ldd	r24, Y+3	; 0x03
    3e48:	9c 81       	ldd	r25, Y+4	; 0x04
    3e4a:	fc 01       	movw	r30, r24
    3e4c:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e4e:	89 83       	std	Y+1, r24	; 0x01

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3e50:	12 c0       	rjmp	.+36     	; 0x3e76 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3e52:	8b 81       	ldd	r24, Y+3	; 0x03
    3e54:	9c 81       	ldd	r25, Y+4	; 0x04
    3e56:	fc 01       	movw	r30, r24
    3e58:	81 89       	ldd	r24, Z+17	; 0x11
    3e5a:	88 23       	and	r24, r24
    3e5c:	81 f0       	breq	.+32     	; 0x3e7e <prvUnlockQueue+0x4e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3e5e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e60:	9c 81       	ldd	r25, Y+4	; 0x04
    3e62:	41 96       	adiw	r24, 0x11	; 17
    3e64:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    3e68:	88 23       	and	r24, r24
    3e6a:	11 f0       	breq	.+4      	; 0x3e70 <prvUnlockQueue+0x40>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3e6c:	0e 94 ac 28 	call	0x5158	; 0x5158 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	81 50       	subi	r24, 0x01	; 1
    3e74:	89 83       	std	Y+1, r24	; 0x01
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3e76:	89 81       	ldd	r24, Y+1	; 0x01
    3e78:	18 16       	cp	r1, r24
    3e7a:	5c f3       	brlt	.-42     	; 0x3e52 <prvUnlockQueue+0x22>
    3e7c:	01 c0       	rjmp	.+2      	; 0x3e80 <prvUnlockQueue+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3e7e:	00 00       	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3e80:	8b 81       	ldd	r24, Y+3	; 0x03
    3e82:	9c 81       	ldd	r25, Y+4	; 0x04
    3e84:	2f ef       	ldi	r18, 0xFF	; 255
    3e86:	fc 01       	movw	r30, r24
    3e88:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3e8a:	0f 90       	pop	r0
    3e8c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3e8e:	0f b6       	in	r0, 0x3f	; 63
    3e90:	f8 94       	cli
    3e92:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3e94:	8b 81       	ldd	r24, Y+3	; 0x03
    3e96:	9c 81       	ldd	r25, Y+4	; 0x04
    3e98:	fc 01       	movw	r30, r24
    3e9a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e9c:	8a 83       	std	Y+2, r24	; 0x02

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3e9e:	12 c0       	rjmp	.+36     	; 0x3ec4 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ea4:	fc 01       	movw	r30, r24
    3ea6:	80 85       	ldd	r24, Z+8	; 0x08
    3ea8:	88 23       	and	r24, r24
    3eaa:	81 f0       	breq	.+32     	; 0x3ecc <prvUnlockQueue+0x9c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3eac:	8b 81       	ldd	r24, Y+3	; 0x03
    3eae:	9c 81       	ldd	r25, Y+4	; 0x04
    3eb0:	08 96       	adiw	r24, 0x08	; 8
    3eb2:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <xTaskRemoveFromEventList>
    3eb6:	88 23       	and	r24, r24
    3eb8:	11 f0       	breq	.+4      	; 0x3ebe <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    3eba:	0e 94 ac 28 	call	0x5158	; 0x5158 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3ebe:	8a 81       	ldd	r24, Y+2	; 0x02
    3ec0:	81 50       	subi	r24, 0x01	; 1
    3ec2:	8a 83       	std	Y+2, r24	; 0x02
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ec6:	18 16       	cp	r1, r24
    3ec8:	5c f3       	brlt	.-42     	; 0x3ea0 <prvUnlockQueue+0x70>
    3eca:	01 c0       	rjmp	.+2      	; 0x3ece <prvUnlockQueue+0x9e>

				--cRxLock;
			}
			else
			{
				break;
    3ecc:	00 00       	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3ece:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ed2:	2f ef       	ldi	r18, 0xFF	; 255
    3ed4:	fc 01       	movw	r30, r24
    3ed6:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    3ed8:	0f 90       	pop	r0
    3eda:	0f be       	out	0x3f, r0	; 63
}
    3edc:	00 00       	nop
    3ede:	0f 90       	pop	r0
    3ee0:	0f 90       	pop	r0
    3ee2:	0f 90       	pop	r0
    3ee4:	0f 90       	pop	r0
    3ee6:	df 91       	pop	r29
    3ee8:	cf 91       	pop	r28
    3eea:	08 95       	ret

00003eec <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3eec:	cf 93       	push	r28
    3eee:	df 93       	push	r29
    3ef0:	00 d0       	rcall	.+0      	; 0x3ef2 <prvIsQueueEmpty+0x6>
    3ef2:	1f 92       	push	r1
    3ef4:	cd b7       	in	r28, 0x3d	; 61
    3ef6:	de b7       	in	r29, 0x3e	; 62
    3ef8:	9b 83       	std	Y+3, r25	; 0x03
    3efa:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3efc:	0f b6       	in	r0, 0x3f	; 63
    3efe:	f8 94       	cli
    3f00:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3f02:	8a 81       	ldd	r24, Y+2	; 0x02
    3f04:	9b 81       	ldd	r25, Y+3	; 0x03
    3f06:	fc 01       	movw	r30, r24
    3f08:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f0a:	88 23       	and	r24, r24
    3f0c:	19 f4       	brne	.+6      	; 0x3f14 <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    3f0e:	81 e0       	ldi	r24, 0x01	; 1
    3f10:	89 83       	std	Y+1, r24	; 0x01
    3f12:	01 c0       	rjmp	.+2      	; 0x3f16 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    3f14:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3f16:	0f 90       	pop	r0
    3f18:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f1a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f1c:	0f 90       	pop	r0
    3f1e:	0f 90       	pop	r0
    3f20:	0f 90       	pop	r0
    3f22:	df 91       	pop	r29
    3f24:	cf 91       	pop	r28
    3f26:	08 95       	ret

00003f28 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3f28:	cf 93       	push	r28
    3f2a:	df 93       	push	r29
    3f2c:	00 d0       	rcall	.+0      	; 0x3f2e <xQueueIsQueueEmptyFromISR+0x6>
    3f2e:	00 d0       	rcall	.+0      	; 0x3f30 <xQueueIsQueueEmptyFromISR+0x8>
    3f30:	1f 92       	push	r1
    3f32:	cd b7       	in	r28, 0x3d	; 61
    3f34:	de b7       	in	r29, 0x3e	; 62
    3f36:	9d 83       	std	Y+5, r25	; 0x05
    3f38:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3f3a:	8c 81       	ldd	r24, Y+4	; 0x04
    3f3c:	9d 81       	ldd	r25, Y+5	; 0x05
    3f3e:	9b 83       	std	Y+3, r25	; 0x03
    3f40:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3f42:	8a 81       	ldd	r24, Y+2	; 0x02
    3f44:	9b 81       	ldd	r25, Y+3	; 0x03
    3f46:	fc 01       	movw	r30, r24
    3f48:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f4a:	88 23       	and	r24, r24
    3f4c:	19 f4       	brne	.+6      	; 0x3f54 <xQueueIsQueueEmptyFromISR+0x2c>
	{
		xReturn = pdTRUE;
    3f4e:	81 e0       	ldi	r24, 0x01	; 1
    3f50:	89 83       	std	Y+1, r24	; 0x01
    3f52:	01 c0       	rjmp	.+2      	; 0x3f56 <xQueueIsQueueEmptyFromISR+0x2e>
	}
	else
	{
		xReturn = pdFALSE;
    3f54:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3f56:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3f58:	0f 90       	pop	r0
    3f5a:	0f 90       	pop	r0
    3f5c:	0f 90       	pop	r0
    3f5e:	0f 90       	pop	r0
    3f60:	0f 90       	pop	r0
    3f62:	df 91       	pop	r29
    3f64:	cf 91       	pop	r28
    3f66:	08 95       	ret

00003f68 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3f68:	cf 93       	push	r28
    3f6a:	df 93       	push	r29
    3f6c:	00 d0       	rcall	.+0      	; 0x3f6e <prvIsQueueFull+0x6>
    3f6e:	1f 92       	push	r1
    3f70:	cd b7       	in	r28, 0x3d	; 61
    3f72:	de b7       	in	r29, 0x3e	; 62
    3f74:	9b 83       	std	Y+3, r25	; 0x03
    3f76:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3f78:	0f b6       	in	r0, 0x3f	; 63
    3f7a:	f8 94       	cli
    3f7c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3f7e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f80:	9b 81       	ldd	r25, Y+3	; 0x03
    3f82:	fc 01       	movw	r30, r24
    3f84:	22 8d       	ldd	r18, Z+26	; 0x1a
    3f86:	8a 81       	ldd	r24, Y+2	; 0x02
    3f88:	9b 81       	ldd	r25, Y+3	; 0x03
    3f8a:	fc 01       	movw	r30, r24
    3f8c:	83 8d       	ldd	r24, Z+27	; 0x1b
    3f8e:	28 17       	cp	r18, r24
    3f90:	19 f4       	brne	.+6      	; 0x3f98 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    3f92:	81 e0       	ldi	r24, 0x01	; 1
    3f94:	89 83       	std	Y+1, r24	; 0x01
    3f96:	01 c0       	rjmp	.+2      	; 0x3f9a <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    3f98:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3f9a:	0f 90       	pop	r0
    3f9c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f9e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3fa0:	0f 90       	pop	r0
    3fa2:	0f 90       	pop	r0
    3fa4:	0f 90       	pop	r0
    3fa6:	df 91       	pop	r29
    3fa8:	cf 91       	pop	r28
    3faa:	08 95       	ret

00003fac <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3fac:	cf 93       	push	r28
    3fae:	df 93       	push	r29
    3fb0:	00 d0       	rcall	.+0      	; 0x3fb2 <xQueueIsQueueFullFromISR+0x6>
    3fb2:	00 d0       	rcall	.+0      	; 0x3fb4 <xQueueIsQueueFullFromISR+0x8>
    3fb4:	1f 92       	push	r1
    3fb6:	cd b7       	in	r28, 0x3d	; 61
    3fb8:	de b7       	in	r29, 0x3e	; 62
    3fba:	9d 83       	std	Y+5, r25	; 0x05
    3fbc:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3fbe:	8c 81       	ldd	r24, Y+4	; 0x04
    3fc0:	9d 81       	ldd	r25, Y+5	; 0x05
    3fc2:	9b 83       	std	Y+3, r25	; 0x03
    3fc4:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3fc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3fca:	fc 01       	movw	r30, r24
    3fcc:	22 8d       	ldd	r18, Z+26	; 0x1a
    3fce:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd0:	9b 81       	ldd	r25, Y+3	; 0x03
    3fd2:	fc 01       	movw	r30, r24
    3fd4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fd6:	28 17       	cp	r18, r24
    3fd8:	19 f4       	brne	.+6      	; 0x3fe0 <xQueueIsQueueFullFromISR+0x34>
	{
		xReturn = pdTRUE;
    3fda:	81 e0       	ldi	r24, 0x01	; 1
    3fdc:	89 83       	std	Y+1, r24	; 0x01
    3fde:	01 c0       	rjmp	.+2      	; 0x3fe2 <xQueueIsQueueFullFromISR+0x36>
	}
	else
	{
		xReturn = pdFALSE;
    3fe0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3fe2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3fe4:	0f 90       	pop	r0
    3fe6:	0f 90       	pop	r0
    3fe8:	0f 90       	pop	r0
    3fea:	0f 90       	pop	r0
    3fec:	0f 90       	pop	r0
    3fee:	df 91       	pop	r29
    3ff0:	cf 91       	pop	r28
    3ff2:	08 95       	ret

00003ff4 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3ff4:	8f 92       	push	r8
    3ff6:	9f 92       	push	r9
    3ff8:	af 92       	push	r10
    3ffa:	bf 92       	push	r11
    3ffc:	cf 92       	push	r12
    3ffe:	df 92       	push	r13
    4000:	ef 92       	push	r14
    4002:	ff 92       	push	r15
    4004:	0f 93       	push	r16
    4006:	1f 93       	push	r17
    4008:	cf 93       	push	r28
    400a:	df 93       	push	r29
    400c:	cd b7       	in	r28, 0x3d	; 61
    400e:	de b7       	in	r29, 0x3e	; 62
    4010:	60 97       	sbiw	r28, 0x10	; 16
    4012:	0f b6       	in	r0, 0x3f	; 63
    4014:	f8 94       	cli
    4016:	de bf       	out	0x3e, r29	; 62
    4018:	0f be       	out	0x3f, r0	; 63
    401a:	cd bf       	out	0x3d, r28	; 61
    401c:	9f 83       	std	Y+7, r25	; 0x07
    401e:	8e 83       	std	Y+6, r24	; 0x06
    4020:	79 87       	std	Y+9, r23	; 0x09
    4022:	68 87       	std	Y+8, r22	; 0x08
    4024:	5b 87       	std	Y+11, r21	; 0x0b
    4026:	4a 87       	std	Y+10, r20	; 0x0a
    4028:	3d 87       	std	Y+13, r19	; 0x0d
    402a:	2c 87       	std	Y+12, r18	; 0x0c
    402c:	0e 87       	std	Y+14, r16	; 0x0e
    402e:	f8 8a       	std	Y+16, r15	; 0x10
    4030:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4032:	8a 85       	ldd	r24, Y+10	; 0x0a
    4034:	9b 85       	ldd	r25, Y+11	; 0x0b
    4036:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <pvPortMalloc>
    403a:	9d 83       	std	Y+5, r25	; 0x05
    403c:	8c 83       	std	Y+4, r24	; 0x04

			if( pxStack != NULL )
    403e:	8c 81       	ldd	r24, Y+4	; 0x04
    4040:	9d 81       	ldd	r25, Y+5	; 0x05
    4042:	89 2b       	or	r24, r25
    4044:	b9 f0       	breq	.+46     	; 0x4074 <xTaskCreate+0x80>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4046:	88 e2       	ldi	r24, 0x28	; 40
    4048:	90 e0       	ldi	r25, 0x00	; 0
    404a:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <pvPortMalloc>
    404e:	9a 83       	std	Y+2, r25	; 0x02
    4050:	89 83       	std	Y+1, r24	; 0x01

				if( pxNewTCB != NULL )
    4052:	89 81       	ldd	r24, Y+1	; 0x01
    4054:	9a 81       	ldd	r25, Y+2	; 0x02
    4056:	89 2b       	or	r24, r25
    4058:	41 f0       	breq	.+16     	; 0x406a <xTaskCreate+0x76>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    405a:	89 81       	ldd	r24, Y+1	; 0x01
    405c:	9a 81       	ldd	r25, Y+2	; 0x02
    405e:	2c 81       	ldd	r18, Y+4	; 0x04
    4060:	3d 81       	ldd	r19, Y+5	; 0x05
    4062:	fc 01       	movw	r30, r24
    4064:	30 8f       	std	Z+24, r19	; 0x18
    4066:	27 8b       	std	Z+23, r18	; 0x17
    4068:	07 c0       	rjmp	.+14     	; 0x4078 <xTaskCreate+0x84>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    406a:	8c 81       	ldd	r24, Y+4	; 0x04
    406c:	9d 81       	ldd	r25, Y+5	; 0x05
    406e:	0e 94 bf 12 	call	0x257e	; 0x257e <vPortFree>
    4072:	02 c0       	rjmp	.+4      	; 0x4078 <xTaskCreate+0x84>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4074:	1a 82       	std	Y+2, r1	; 0x02
    4076:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4078:	89 81       	ldd	r24, Y+1	; 0x01
    407a:	9a 81       	ldd	r25, Y+2	; 0x02
    407c:	89 2b       	or	r24, r25
    407e:	09 f1       	breq	.+66     	; 0x40c2 <xTaskCreate+0xce>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4080:	8a 85       	ldd	r24, Y+10	; 0x0a
    4082:	9b 85       	ldd	r25, Y+11	; 0x0b
    4084:	cc 01       	movw	r24, r24
    4086:	a0 e0       	ldi	r26, 0x00	; 0
    4088:	b0 e0       	ldi	r27, 0x00	; 0
    408a:	09 81       	ldd	r16, Y+1	; 0x01
    408c:	1a 81       	ldd	r17, Y+2	; 0x02
    408e:	4f 85       	ldd	r20, Y+15	; 0x0f
    4090:	58 89       	ldd	r21, Y+16	; 0x10
    4092:	2c 85       	ldd	r18, Y+12	; 0x0c
    4094:	3d 85       	ldd	r19, Y+13	; 0x0d
    4096:	68 85       	ldd	r22, Y+8	; 0x08
    4098:	79 85       	ldd	r23, Y+9	; 0x09
    409a:	ee 81       	ldd	r30, Y+6	; 0x06
    409c:	ff 81       	ldd	r31, Y+7	; 0x07
    409e:	81 2c       	mov	r8, r1
    40a0:	91 2c       	mov	r9, r1
    40a2:	58 01       	movw	r10, r16
    40a4:	6a 01       	movw	r12, r20
    40a6:	ee 84       	ldd	r14, Y+14	; 0x0e
    40a8:	89 01       	movw	r16, r18
    40aa:	9c 01       	movw	r18, r24
    40ac:	ad 01       	movw	r20, r26
    40ae:	cf 01       	movw	r24, r30
    40b0:	0e 94 77 20 	call	0x40ee	; 0x40ee <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    40b4:	89 81       	ldd	r24, Y+1	; 0x01
    40b6:	9a 81       	ldd	r25, Y+2	; 0x02
    40b8:	0e 94 4b 21 	call	0x4296	; 0x4296 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    40bc:	81 e0       	ldi	r24, 0x01	; 1
    40be:	8b 83       	std	Y+3, r24	; 0x03
    40c0:	02 c0       	rjmp	.+4      	; 0x40c6 <xTaskCreate+0xd2>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    40c2:	8f ef       	ldi	r24, 0xFF	; 255
    40c4:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    40c6:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    40c8:	60 96       	adiw	r28, 0x10	; 16
    40ca:	0f b6       	in	r0, 0x3f	; 63
    40cc:	f8 94       	cli
    40ce:	de bf       	out	0x3e, r29	; 62
    40d0:	0f be       	out	0x3f, r0	; 63
    40d2:	cd bf       	out	0x3d, r28	; 61
    40d4:	df 91       	pop	r29
    40d6:	cf 91       	pop	r28
    40d8:	1f 91       	pop	r17
    40da:	0f 91       	pop	r16
    40dc:	ff 90       	pop	r15
    40de:	ef 90       	pop	r14
    40e0:	df 90       	pop	r13
    40e2:	cf 90       	pop	r12
    40e4:	bf 90       	pop	r11
    40e6:	af 90       	pop	r10
    40e8:	9f 90       	pop	r9
    40ea:	8f 90       	pop	r8
    40ec:	08 95       	ret

000040ee <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    40ee:	8f 92       	push	r8
    40f0:	9f 92       	push	r9
    40f2:	af 92       	push	r10
    40f4:	bf 92       	push	r11
    40f6:	cf 92       	push	r12
    40f8:	df 92       	push	r13
    40fa:	ef 92       	push	r14
    40fc:	0f 93       	push	r16
    40fe:	1f 93       	push	r17
    4100:	cf 93       	push	r28
    4102:	df 93       	push	r29
    4104:	cd b7       	in	r28, 0x3d	; 61
    4106:	de b7       	in	r29, 0x3e	; 62
    4108:	64 97       	sbiw	r28, 0x14	; 20
    410a:	0f b6       	in	r0, 0x3f	; 63
    410c:	f8 94       	cli
    410e:	de bf       	out	0x3e, r29	; 62
    4110:	0f be       	out	0x3f, r0	; 63
    4112:	cd bf       	out	0x3d, r28	; 61
    4114:	9d 83       	std	Y+5, r25	; 0x05
    4116:	8c 83       	std	Y+4, r24	; 0x04
    4118:	7f 83       	std	Y+7, r23	; 0x07
    411a:	6e 83       	std	Y+6, r22	; 0x06
    411c:	28 87       	std	Y+8, r18	; 0x08
    411e:	39 87       	std	Y+9, r19	; 0x09
    4120:	4a 87       	std	Y+10, r20	; 0x0a
    4122:	5b 87       	std	Y+11, r21	; 0x0b
    4124:	1d 87       	std	Y+13, r17	; 0x0d
    4126:	0c 87       	std	Y+12, r16	; 0x0c
    4128:	ee 86       	std	Y+14, r14	; 0x0e
    412a:	d8 8a       	std	Y+16, r13	; 0x10
    412c:	cf 86       	std	Y+15, r12	; 0x0f
    412e:	ba 8a       	std	Y+18, r11	; 0x12
    4130:	a9 8a       	std	Y+17, r10	; 0x11
    4132:	9c 8a       	std	Y+20, r9	; 0x14
    4134:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4136:	89 89       	ldd	r24, Y+17	; 0x11
    4138:	9a 89       	ldd	r25, Y+18	; 0x12
    413a:	fc 01       	movw	r30, r24
    413c:	27 89       	ldd	r18, Z+23	; 0x17
    413e:	30 8d       	ldd	r19, Z+24	; 0x18
    4140:	88 85       	ldd	r24, Y+8	; 0x08
    4142:	99 85       	ldd	r25, Y+9	; 0x09
    4144:	01 97       	sbiw	r24, 0x01	; 1
    4146:	82 0f       	add	r24, r18
    4148:	93 1f       	adc	r25, r19
    414a:	9b 83       	std	Y+3, r25	; 0x03
    414c:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    414e:	8e 81       	ldd	r24, Y+6	; 0x06
    4150:	9f 81       	ldd	r25, Y+7	; 0x07
    4152:	89 2b       	or	r24, r25
    4154:	69 f1       	breq	.+90     	; 0x41b0 <prvInitialiseNewTask+0xc2>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4156:	19 82       	std	Y+1, r1	; 0x01
    4158:	21 c0       	rjmp	.+66     	; 0x419c <prvInitialiseNewTask+0xae>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    415a:	89 81       	ldd	r24, Y+1	; 0x01
    415c:	88 2f       	mov	r24, r24
    415e:	90 e0       	ldi	r25, 0x00	; 0
    4160:	29 81       	ldd	r18, Y+1	; 0x01
    4162:	22 2f       	mov	r18, r18
    4164:	30 e0       	ldi	r19, 0x00	; 0
    4166:	4e 81       	ldd	r20, Y+6	; 0x06
    4168:	5f 81       	ldd	r21, Y+7	; 0x07
    416a:	24 0f       	add	r18, r20
    416c:	35 1f       	adc	r19, r21
    416e:	f9 01       	movw	r30, r18
    4170:	40 81       	ld	r20, Z
    4172:	29 89       	ldd	r18, Y+17	; 0x11
    4174:	3a 89       	ldd	r19, Y+18	; 0x12
    4176:	82 0f       	add	r24, r18
    4178:	93 1f       	adc	r25, r19
    417a:	49 96       	adiw	r24, 0x19	; 25
    417c:	fc 01       	movw	r30, r24
    417e:	40 83       	st	Z, r20

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4180:	89 81       	ldd	r24, Y+1	; 0x01
    4182:	88 2f       	mov	r24, r24
    4184:	90 e0       	ldi	r25, 0x00	; 0
    4186:	2e 81       	ldd	r18, Y+6	; 0x06
    4188:	3f 81       	ldd	r19, Y+7	; 0x07
    418a:	82 0f       	add	r24, r18
    418c:	93 1f       	adc	r25, r19
    418e:	fc 01       	movw	r30, r24
    4190:	80 81       	ld	r24, Z
    4192:	88 23       	and	r24, r24
    4194:	39 f0       	breq	.+14     	; 0x41a4 <prvInitialiseNewTask+0xb6>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4196:	89 81       	ldd	r24, Y+1	; 0x01
    4198:	8f 5f       	subi	r24, 0xFF	; 255
    419a:	89 83       	std	Y+1, r24	; 0x01
    419c:	89 81       	ldd	r24, Y+1	; 0x01
    419e:	88 30       	cpi	r24, 0x08	; 8
    41a0:	e0 f2       	brcs	.-72     	; 0x415a <prvInitialiseNewTask+0x6c>
    41a2:	01 c0       	rjmp	.+2      	; 0x41a6 <prvInitialiseNewTask+0xb8>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
    41a4:	00 00       	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    41a6:	89 89       	ldd	r24, Y+17	; 0x11
    41a8:	9a 89       	ldd	r25, Y+18	; 0x12
    41aa:	fc 01       	movw	r30, r24
    41ac:	10 a2       	std	Z+32, r1	; 0x20
    41ae:	04 c0       	rjmp	.+8      	; 0x41b8 <prvInitialiseNewTask+0xca>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    41b0:	89 89       	ldd	r24, Y+17	; 0x11
    41b2:	9a 89       	ldd	r25, Y+18	; 0x12
    41b4:	fc 01       	movw	r30, r24
    41b6:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    41b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    41ba:	85 30       	cpi	r24, 0x05	; 5
    41bc:	10 f0       	brcs	.+4      	; 0x41c2 <prvInitialiseNewTask+0xd4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    41be:	84 e0       	ldi	r24, 0x04	; 4
    41c0:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    41c2:	89 89       	ldd	r24, Y+17	; 0x11
    41c4:	9a 89       	ldd	r25, Y+18	; 0x12
    41c6:	2e 85       	ldd	r18, Y+14	; 0x0e
    41c8:	fc 01       	movw	r30, r24
    41ca:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    41cc:	89 89       	ldd	r24, Y+17	; 0x11
    41ce:	9a 89       	ldd	r25, Y+18	; 0x12
    41d0:	2e 85       	ldd	r18, Y+14	; 0x0e
    41d2:	fc 01       	movw	r30, r24
    41d4:	21 a3       	std	Z+33, r18	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    41d6:	89 89       	ldd	r24, Y+17	; 0x11
    41d8:	9a 89       	ldd	r25, Y+18	; 0x12
    41da:	fc 01       	movw	r30, r24
    41dc:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    41de:	89 89       	ldd	r24, Y+17	; 0x11
    41e0:	9a 89       	ldd	r25, Y+18	; 0x12
    41e2:	02 96       	adiw	r24, 0x02	; 2
    41e4:	0e 94 1f 13 	call	0x263e	; 0x263e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    41e8:	89 89       	ldd	r24, Y+17	; 0x11
    41ea:	9a 89       	ldd	r25, Y+18	; 0x12
    41ec:	0c 96       	adiw	r24, 0x0c	; 12
    41ee:	0e 94 1f 13 	call	0x263e	; 0x263e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    41f2:	89 89       	ldd	r24, Y+17	; 0x11
    41f4:	9a 89       	ldd	r25, Y+18	; 0x12
    41f6:	29 89       	ldd	r18, Y+17	; 0x11
    41f8:	3a 89       	ldd	r19, Y+18	; 0x12
    41fa:	fc 01       	movw	r30, r24
    41fc:	31 87       	std	Z+9, r19	; 0x09
    41fe:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4200:	8e 85       	ldd	r24, Y+14	; 0x0e
    4202:	88 2f       	mov	r24, r24
    4204:	90 e0       	ldi	r25, 0x00	; 0
    4206:	25 e0       	ldi	r18, 0x05	; 5
    4208:	30 e0       	ldi	r19, 0x00	; 0
    420a:	28 1b       	sub	r18, r24
    420c:	39 0b       	sbc	r19, r25
    420e:	89 89       	ldd	r24, Y+17	; 0x11
    4210:	9a 89       	ldd	r25, Y+18	; 0x12
    4212:	fc 01       	movw	r30, r24
    4214:	35 87       	std	Z+13, r19	; 0x0d
    4216:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4218:	89 89       	ldd	r24, Y+17	; 0x11
    421a:	9a 89       	ldd	r25, Y+18	; 0x12
    421c:	29 89       	ldd	r18, Y+17	; 0x11
    421e:	3a 89       	ldd	r19, Y+18	; 0x12
    4220:	fc 01       	movw	r30, r24
    4222:	33 8b       	std	Z+19, r19	; 0x13
    4224:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4226:	89 89       	ldd	r24, Y+17	; 0x11
    4228:	9a 89       	ldd	r25, Y+18	; 0x12
    422a:	fc 01       	movw	r30, r24
    422c:	13 a2       	std	Z+35, r1	; 0x23
    422e:	14 a2       	std	Z+36, r1	; 0x24
    4230:	15 a2       	std	Z+37, r1	; 0x25
    4232:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4234:	89 89       	ldd	r24, Y+17	; 0x11
    4236:	9a 89       	ldd	r25, Y+18	; 0x12
    4238:	fc 01       	movw	r30, r24
    423a:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    423c:	4c 85       	ldd	r20, Y+12	; 0x0c
    423e:	5d 85       	ldd	r21, Y+13	; 0x0d
    4240:	2c 81       	ldd	r18, Y+4	; 0x04
    4242:	3d 81       	ldd	r19, Y+5	; 0x05
    4244:	8a 81       	ldd	r24, Y+2	; 0x02
    4246:	9b 81       	ldd	r25, Y+3	; 0x03
    4248:	b9 01       	movw	r22, r18
    424a:	0e 94 a3 14 	call	0x2946	; 0x2946 <pxPortInitialiseStack>
    424e:	9c 01       	movw	r18, r24
    4250:	89 89       	ldd	r24, Y+17	; 0x11
    4252:	9a 89       	ldd	r25, Y+18	; 0x12
    4254:	fc 01       	movw	r30, r24
    4256:	31 83       	std	Z+1, r19	; 0x01
    4258:	20 83       	st	Z, r18
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    425a:	8f 85       	ldd	r24, Y+15	; 0x0f
    425c:	98 89       	ldd	r25, Y+16	; 0x10
    425e:	89 2b       	or	r24, r25
    4260:	39 f0       	breq	.+14     	; 0x4270 <prvInitialiseNewTask+0x182>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4262:	8f 85       	ldd	r24, Y+15	; 0x0f
    4264:	98 89       	ldd	r25, Y+16	; 0x10
    4266:	29 89       	ldd	r18, Y+17	; 0x11
    4268:	3a 89       	ldd	r19, Y+18	; 0x12
    426a:	fc 01       	movw	r30, r24
    426c:	31 83       	std	Z+1, r19	; 0x01
    426e:	20 83       	st	Z, r18
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4270:	00 00       	nop
    4272:	64 96       	adiw	r28, 0x14	; 20
    4274:	0f b6       	in	r0, 0x3f	; 63
    4276:	f8 94       	cli
    4278:	de bf       	out	0x3e, r29	; 62
    427a:	0f be       	out	0x3f, r0	; 63
    427c:	cd bf       	out	0x3d, r28	; 61
    427e:	df 91       	pop	r29
    4280:	cf 91       	pop	r28
    4282:	1f 91       	pop	r17
    4284:	0f 91       	pop	r16
    4286:	ef 90       	pop	r14
    4288:	df 90       	pop	r13
    428a:	cf 90       	pop	r12
    428c:	bf 90       	pop	r11
    428e:	af 90       	pop	r10
    4290:	9f 90       	pop	r9
    4292:	8f 90       	pop	r8
    4294:	08 95       	ret

00004296 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4296:	cf 93       	push	r28
    4298:	df 93       	push	r29
    429a:	00 d0       	rcall	.+0      	; 0x429c <prvAddNewTaskToReadyList+0x6>
    429c:	cd b7       	in	r28, 0x3d	; 61
    429e:	de b7       	in	r29, 0x3e	; 62
    42a0:	9a 83       	std	Y+2, r25	; 0x02
    42a2:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    42a4:	0f b6       	in	r0, 0x3f	; 63
    42a6:	f8 94       	cli
    42a8:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    42aa:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <uxCurrentNumberOfTasks>
    42ae:	8f 5f       	subi	r24, 0xFF	; 255
    42b0:	80 93 18 07 	sts	0x0718, r24	; 0x800718 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    42b4:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    42b8:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    42bc:	89 2b       	or	r24, r25
    42be:	69 f4       	brne	.+26     	; 0x42da <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    42c0:	89 81       	ldd	r24, Y+1	; 0x01
    42c2:	9a 81       	ldd	r25, Y+2	; 0x02
    42c4:	90 93 b8 06 	sts	0x06B8, r25	; 0x8006b8 <pxCurrentTCB+0x1>
    42c8:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    42cc:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <uxCurrentNumberOfTasks>
    42d0:	81 30       	cpi	r24, 0x01	; 1
    42d2:	c9 f4       	brne	.+50     	; 0x4306 <prvAddNewTaskToReadyList+0x70>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    42d4:	0e 94 c7 28 	call	0x518e	; 0x518e <prvInitialiseTaskLists>
    42d8:	16 c0       	rjmp	.+44     	; 0x4306 <prvAddNewTaskToReadyList+0x70>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    42da:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <xSchedulerRunning>
    42de:	88 23       	and	r24, r24
    42e0:	91 f4       	brne	.+36     	; 0x4306 <prvAddNewTaskToReadyList+0x70>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    42e2:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    42e6:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    42ea:	fc 01       	movw	r30, r24
    42ec:	26 89       	ldd	r18, Z+22	; 0x16
    42ee:	89 81       	ldd	r24, Y+1	; 0x01
    42f0:	9a 81       	ldd	r25, Y+2	; 0x02
    42f2:	fc 01       	movw	r30, r24
    42f4:	86 89       	ldd	r24, Z+22	; 0x16
    42f6:	82 17       	cp	r24, r18
    42f8:	30 f0       	brcs	.+12     	; 0x4306 <prvAddNewTaskToReadyList+0x70>
				{
					pxCurrentTCB = pxNewTCB;
    42fa:	89 81       	ldd	r24, Y+1	; 0x01
    42fc:	9a 81       	ldd	r25, Y+2	; 0x02
    42fe:	90 93 b8 06 	sts	0x06B8, r25	; 0x8006b8 <pxCurrentTCB+0x1>
    4302:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4306:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <uxTaskNumber>
    430a:	8f 5f       	subi	r24, 0xFF	; 255
    430c:	80 93 20 07 	sts	0x0720, r24	; 0x800720 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4310:	89 81       	ldd	r24, Y+1	; 0x01
    4312:	9a 81       	ldd	r25, Y+2	; 0x02
    4314:	fc 01       	movw	r30, r24
    4316:	96 89       	ldd	r25, Z+22	; 0x16
    4318:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    431c:	89 17       	cp	r24, r25
    431e:	30 f4       	brcc	.+12     	; 0x432c <prvAddNewTaskToReadyList+0x96>
    4320:	89 81       	ldd	r24, Y+1	; 0x01
    4322:	9a 81       	ldd	r25, Y+2	; 0x02
    4324:	fc 01       	movw	r30, r24
    4326:	86 89       	ldd	r24, Z+22	; 0x16
    4328:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    432c:	89 81       	ldd	r24, Y+1	; 0x01
    432e:	9a 81       	ldd	r25, Y+2	; 0x02
    4330:	ac 01       	movw	r20, r24
    4332:	4e 5f       	subi	r20, 0xFE	; 254
    4334:	5f 4f       	sbci	r21, 0xFF	; 255
    4336:	89 81       	ldd	r24, Y+1	; 0x01
    4338:	9a 81       	ldd	r25, Y+2	; 0x02
    433a:	fc 01       	movw	r30, r24
    433c:	86 89       	ldd	r24, Z+22	; 0x16
    433e:	28 2f       	mov	r18, r24
    4340:	30 e0       	ldi	r19, 0x00	; 0
    4342:	c9 01       	movw	r24, r18
    4344:	88 0f       	add	r24, r24
    4346:	99 1f       	adc	r25, r25
    4348:	88 0f       	add	r24, r24
    434a:	99 1f       	adc	r25, r25
    434c:	88 0f       	add	r24, r24
    434e:	99 1f       	adc	r25, r25
    4350:	82 0f       	add	r24, r18
    4352:	93 1f       	adc	r25, r19
    4354:	87 54       	subi	r24, 0x47	; 71
    4356:	99 4f       	sbci	r25, 0xF9	; 249
    4358:	ba 01       	movw	r22, r20
    435a:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    435e:	0f 90       	pop	r0
    4360:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4362:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <xSchedulerRunning>
    4366:	88 23       	and	r24, r24
    4368:	71 f0       	breq	.+28     	; 0x4386 <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    436a:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    436e:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4372:	fc 01       	movw	r30, r24
    4374:	26 89       	ldd	r18, Z+22	; 0x16
    4376:	89 81       	ldd	r24, Y+1	; 0x01
    4378:	9a 81       	ldd	r25, Y+2	; 0x02
    437a:	fc 01       	movw	r30, r24
    437c:	86 89       	ldd	r24, Z+22	; 0x16
    437e:	28 17       	cp	r18, r24
    4380:	10 f4       	brcc	.+4      	; 0x4386 <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4382:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4386:	00 00       	nop
    4388:	0f 90       	pop	r0
    438a:	0f 90       	pop	r0
    438c:	df 91       	pop	r29
    438e:	cf 91       	pop	r28
    4390:	08 95       	ret

00004392 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4392:	cf 93       	push	r28
    4394:	df 93       	push	r29
    4396:	00 d0       	rcall	.+0      	; 0x4398 <vTaskDelete+0x6>
    4398:	00 d0       	rcall	.+0      	; 0x439a <vTaskDelete+0x8>
    439a:	cd b7       	in	r28, 0x3d	; 61
    439c:	de b7       	in	r29, 0x3e	; 62
    439e:	9c 83       	std	Y+4, r25	; 0x04
    43a0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    43a2:	0f b6       	in	r0, 0x3f	; 63
    43a4:	f8 94       	cli
    43a6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    43a8:	8b 81       	ldd	r24, Y+3	; 0x03
    43aa:	9c 81       	ldd	r25, Y+4	; 0x04
    43ac:	89 2b       	or	r24, r25
    43ae:	29 f4       	brne	.+10     	; 0x43ba <vTaskDelete+0x28>
    43b0:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    43b4:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    43b8:	02 c0       	rjmp	.+4      	; 0x43be <vTaskDelete+0x2c>
    43ba:	8b 81       	ldd	r24, Y+3	; 0x03
    43bc:	9c 81       	ldd	r25, Y+4	; 0x04
    43be:	9a 83       	std	Y+2, r25	; 0x02
    43c0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    43c2:	89 81       	ldd	r24, Y+1	; 0x01
    43c4:	9a 81       	ldd	r25, Y+2	; 0x02
    43c6:	02 96       	adiw	r24, 0x02	; 2
    43c8:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    43cc:	89 81       	ldd	r24, Y+1	; 0x01
    43ce:	9a 81       	ldd	r25, Y+2	; 0x02
    43d0:	fc 01       	movw	r30, r24
    43d2:	84 89       	ldd	r24, Z+20	; 0x14
    43d4:	95 89       	ldd	r25, Z+21	; 0x15
    43d6:	89 2b       	or	r24, r25
    43d8:	29 f0       	breq	.+10     	; 0x43e4 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    43da:	89 81       	ldd	r24, Y+1	; 0x01
    43dc:	9a 81       	ldd	r25, Y+2	; 0x02
    43de:	0c 96       	adiw	r24, 0x0c	; 12
    43e0:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    43e4:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <uxTaskNumber>
    43e8:	8f 5f       	subi	r24, 0xFF	; 255
    43ea:	80 93 20 07 	sts	0x0720, r24	; 0x800720 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    43ee:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    43f2:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    43f6:	29 81       	ldd	r18, Y+1	; 0x01
    43f8:	3a 81       	ldd	r19, Y+2	; 0x02
    43fa:	28 17       	cp	r18, r24
    43fc:	39 07       	cpc	r19, r25
    43fe:	71 f4       	brne	.+28     	; 0x441c <vTaskDelete+0x8a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4400:	89 81       	ldd	r24, Y+1	; 0x01
    4402:	9a 81       	ldd	r25, Y+2	; 0x02
    4404:	02 96       	adiw	r24, 0x02	; 2
    4406:	bc 01       	movw	r22, r24
    4408:	85 e0       	ldi	r24, 0x05	; 5
    440a:	97 e0       	ldi	r25, 0x07	; 7
    440c:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4410:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxDeletedTasksWaitingCleanUp>
    4414:	8f 5f       	subi	r24, 0xFF	; 255
    4416:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <uxDeletedTasksWaitingCleanUp>
    441a:	0b c0       	rjmp	.+22     	; 0x4432 <vTaskDelete+0xa0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    441c:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <uxCurrentNumberOfTasks>
    4420:	81 50       	subi	r24, 0x01	; 1
    4422:	80 93 18 07 	sts	0x0718, r24	; 0x800718 <uxCurrentNumberOfTasks>
				prvDeleteTCB( pxTCB );
    4426:	89 81       	ldd	r24, Y+1	; 0x01
    4428:	9a 81       	ldd	r25, Y+2	; 0x02
    442a:	0e 94 3a 29 	call	0x5274	; 0x5274 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    442e:	0e 94 52 29 	call	0x52a4	; 0x52a4 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4432:	0f 90       	pop	r0
    4434:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4436:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <xSchedulerRunning>
    443a:	88 23       	and	r24, r24
    443c:	59 f0       	breq	.+22     	; 0x4454 <vTaskDelete+0xc2>
		{
			if( pxTCB == pxCurrentTCB )
    443e:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4442:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4446:	29 81       	ldd	r18, Y+1	; 0x01
    4448:	3a 81       	ldd	r19, Y+2	; 0x02
    444a:	28 17       	cp	r18, r24
    444c:	39 07       	cpc	r19, r25
    444e:	11 f4       	brne	.+4      	; 0x4454 <vTaskDelete+0xc2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4450:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4454:	00 00       	nop
    4456:	0f 90       	pop	r0
    4458:	0f 90       	pop	r0
    445a:	0f 90       	pop	r0
    445c:	0f 90       	pop	r0
    445e:	df 91       	pop	r29
    4460:	cf 91       	pop	r28
    4462:	08 95       	ret

00004464 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    4464:	cf 93       	push	r28
    4466:	df 93       	push	r29
    4468:	cd b7       	in	r28, 0x3d	; 61
    446a:	de b7       	in	r29, 0x3e	; 62
    446c:	2a 97       	sbiw	r28, 0x0a	; 10
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	f8 94       	cli
    4472:	de bf       	out	0x3e, r29	; 62
    4474:	0f be       	out	0x3f, r0	; 63
    4476:	cd bf       	out	0x3d, r28	; 61
    4478:	98 87       	std	Y+8, r25	; 0x08
    447a:	8f 83       	std	Y+7, r24	; 0x07
    447c:	7a 87       	std	Y+10, r23	; 0x0a
    447e:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    4480:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    4482:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    4486:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <xTickCount>
    448a:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <xTickCount+0x1>
    448e:	9b 83       	std	Y+3, r25	; 0x03
    4490:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4492:	8f 81       	ldd	r24, Y+7	; 0x07
    4494:	98 85       	ldd	r25, Y+8	; 0x08
    4496:	fc 01       	movw	r30, r24
    4498:	20 81       	ld	r18, Z
    449a:	31 81       	ldd	r19, Z+1	; 0x01
    449c:	89 85       	ldd	r24, Y+9	; 0x09
    449e:	9a 85       	ldd	r25, Y+10	; 0x0a
    44a0:	82 0f       	add	r24, r18
    44a2:	93 1f       	adc	r25, r19
    44a4:	9d 83       	std	Y+5, r25	; 0x05
    44a6:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    44a8:	8f 81       	ldd	r24, Y+7	; 0x07
    44aa:	98 85       	ldd	r25, Y+8	; 0x08
    44ac:	fc 01       	movw	r30, r24
    44ae:	20 81       	ld	r18, Z
    44b0:	31 81       	ldd	r19, Z+1	; 0x01
    44b2:	8a 81       	ldd	r24, Y+2	; 0x02
    44b4:	9b 81       	ldd	r25, Y+3	; 0x03
    44b6:	82 17       	cp	r24, r18
    44b8:	93 07       	cpc	r25, r19
    44ba:	a0 f4       	brcc	.+40     	; 0x44e4 <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    44bc:	8f 81       	ldd	r24, Y+7	; 0x07
    44be:	98 85       	ldd	r25, Y+8	; 0x08
    44c0:	fc 01       	movw	r30, r24
    44c2:	20 81       	ld	r18, Z
    44c4:	31 81       	ldd	r19, Z+1	; 0x01
    44c6:	8c 81       	ldd	r24, Y+4	; 0x04
    44c8:	9d 81       	ldd	r25, Y+5	; 0x05
    44ca:	82 17       	cp	r24, r18
    44cc:	93 07       	cpc	r25, r19
    44ce:	e8 f4       	brcc	.+58     	; 0x450a <vTaskDelayUntil+0xa6>
    44d0:	2c 81       	ldd	r18, Y+4	; 0x04
    44d2:	3d 81       	ldd	r19, Y+5	; 0x05
    44d4:	8a 81       	ldd	r24, Y+2	; 0x02
    44d6:	9b 81       	ldd	r25, Y+3	; 0x03
    44d8:	82 17       	cp	r24, r18
    44da:	93 07       	cpc	r25, r19
    44dc:	b0 f4       	brcc	.+44     	; 0x450a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    44de:	81 e0       	ldi	r24, 0x01	; 1
    44e0:	89 83       	std	Y+1, r24	; 0x01
    44e2:	13 c0       	rjmp	.+38     	; 0x450a <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    44e4:	8f 81       	ldd	r24, Y+7	; 0x07
    44e6:	98 85       	ldd	r25, Y+8	; 0x08
    44e8:	fc 01       	movw	r30, r24
    44ea:	20 81       	ld	r18, Z
    44ec:	31 81       	ldd	r19, Z+1	; 0x01
    44ee:	8c 81       	ldd	r24, Y+4	; 0x04
    44f0:	9d 81       	ldd	r25, Y+5	; 0x05
    44f2:	82 17       	cp	r24, r18
    44f4:	93 07       	cpc	r25, r19
    44f6:	38 f0       	brcs	.+14     	; 0x4506 <vTaskDelayUntil+0xa2>
    44f8:	2c 81       	ldd	r18, Y+4	; 0x04
    44fa:	3d 81       	ldd	r19, Y+5	; 0x05
    44fc:	8a 81       	ldd	r24, Y+2	; 0x02
    44fe:	9b 81       	ldd	r25, Y+3	; 0x03
    4500:	82 17       	cp	r24, r18
    4502:	93 07       	cpc	r25, r19
    4504:	10 f4       	brcc	.+4      	; 0x450a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    4506:	81 e0       	ldi	r24, 0x01	; 1
    4508:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    450a:	8f 81       	ldd	r24, Y+7	; 0x07
    450c:	98 85       	ldd	r25, Y+8	; 0x08
    450e:	2c 81       	ldd	r18, Y+4	; 0x04
    4510:	3d 81       	ldd	r19, Y+5	; 0x05
    4512:	fc 01       	movw	r30, r24
    4514:	31 83       	std	Z+1, r19	; 0x01
    4516:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    4518:	89 81       	ldd	r24, Y+1	; 0x01
    451a:	88 23       	and	r24, r24
    451c:	59 f0       	breq	.+22     	; 0x4534 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    451e:	2c 81       	ldd	r18, Y+4	; 0x04
    4520:	3d 81       	ldd	r19, Y+5	; 0x05
    4522:	8a 81       	ldd	r24, Y+2	; 0x02
    4524:	9b 81       	ldd	r25, Y+3	; 0x03
    4526:	a9 01       	movw	r20, r18
    4528:	48 1b       	sub	r20, r24
    452a:	59 0b       	sbc	r21, r25
    452c:	ca 01       	movw	r24, r20
    452e:	60 e0       	ldi	r22, 0x00	; 0
    4530:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4534:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    4538:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    453a:	8e 81       	ldd	r24, Y+6	; 0x06
    453c:	88 23       	and	r24, r24
    453e:	11 f4       	brne	.+4      	; 0x4544 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    4540:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4544:	00 00       	nop
    4546:	2a 96       	adiw	r28, 0x0a	; 10
    4548:	0f b6       	in	r0, 0x3f	; 63
    454a:	f8 94       	cli
    454c:	de bf       	out	0x3e, r29	; 62
    454e:	0f be       	out	0x3f, r0	; 63
    4550:	cd bf       	out	0x3d, r28	; 61
    4552:	df 91       	pop	r29
    4554:	cf 91       	pop	r28
    4556:	08 95       	ret

00004558 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4558:	cf 93       	push	r28
    455a:	df 93       	push	r29
    455c:	00 d0       	rcall	.+0      	; 0x455e <vTaskDelay+0x6>
    455e:	1f 92       	push	r1
    4560:	cd b7       	in	r28, 0x3d	; 61
    4562:	de b7       	in	r29, 0x3e	; 62
    4564:	9b 83       	std	Y+3, r25	; 0x03
    4566:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4568:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    456a:	8a 81       	ldd	r24, Y+2	; 0x02
    456c:	9b 81       	ldd	r25, Y+3	; 0x03
    456e:	89 2b       	or	r24, r25
    4570:	51 f0       	breq	.+20     	; 0x4586 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4572:	0e 94 7d 24 	call	0x48fa	; 0x48fa <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4576:	8a 81       	ldd	r24, Y+2	; 0x02
    4578:	9b 81       	ldd	r25, Y+3	; 0x03
    457a:	60 e0       	ldi	r22, 0x00	; 0
    457c:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4580:	0e 94 8a 24 	call	0x4914	; 0x4914 <xTaskResumeAll>
    4584:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4586:	89 81       	ldd	r24, Y+1	; 0x01
    4588:	88 23       	and	r24, r24
    458a:	11 f4       	brne	.+4      	; 0x4590 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    458c:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4590:	00 00       	nop
    4592:	0f 90       	pop	r0
    4594:	0f 90       	pop	r0
    4596:	0f 90       	pop	r0
    4598:	df 91       	pop	r29
    459a:	cf 91       	pop	r28
    459c:	08 95       	ret

0000459e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    459e:	cf 93       	push	r28
    45a0:	df 93       	push	r29
    45a2:	00 d0       	rcall	.+0      	; 0x45a4 <vTaskSuspend+0x6>
    45a4:	00 d0       	rcall	.+0      	; 0x45a6 <vTaskSuspend+0x8>
    45a6:	cd b7       	in	r28, 0x3d	; 61
    45a8:	de b7       	in	r29, 0x3e	; 62
    45aa:	9c 83       	std	Y+4, r25	; 0x04
    45ac:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    45ae:	0f b6       	in	r0, 0x3f	; 63
    45b0:	f8 94       	cli
    45b2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    45b4:	8b 81       	ldd	r24, Y+3	; 0x03
    45b6:	9c 81       	ldd	r25, Y+4	; 0x04
    45b8:	89 2b       	or	r24, r25
    45ba:	29 f4       	brne	.+10     	; 0x45c6 <vTaskSuspend+0x28>
    45bc:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    45c0:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    45c4:	02 c0       	rjmp	.+4      	; 0x45ca <vTaskSuspend+0x2c>
    45c6:	8b 81       	ldd	r24, Y+3	; 0x03
    45c8:	9c 81       	ldd	r25, Y+4	; 0x04
    45ca:	9a 83       	std	Y+2, r25	; 0x02
    45cc:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    45ce:	89 81       	ldd	r24, Y+1	; 0x01
    45d0:	9a 81       	ldd	r25, Y+2	; 0x02
    45d2:	02 96       	adiw	r24, 0x02	; 2
    45d4:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    45d8:	89 81       	ldd	r24, Y+1	; 0x01
    45da:	9a 81       	ldd	r25, Y+2	; 0x02
    45dc:	fc 01       	movw	r30, r24
    45de:	84 89       	ldd	r24, Z+20	; 0x14
    45e0:	95 89       	ldd	r25, Z+21	; 0x15
    45e2:	89 2b       	or	r24, r25
    45e4:	29 f0       	breq	.+10     	; 0x45f0 <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    45e6:	89 81       	ldd	r24, Y+1	; 0x01
    45e8:	9a 81       	ldd	r25, Y+2	; 0x02
    45ea:	0c 96       	adiw	r24, 0x0c	; 12
    45ec:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    45f0:	89 81       	ldd	r24, Y+1	; 0x01
    45f2:	9a 81       	ldd	r25, Y+2	; 0x02
    45f4:	02 96       	adiw	r24, 0x02	; 2
    45f6:	bc 01       	movw	r22, r24
    45f8:	8f e0       	ldi	r24, 0x0F	; 15
    45fa:	97 e0       	ldi	r25, 0x07	; 7
    45fc:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4600:	89 81       	ldd	r24, Y+1	; 0x01
    4602:	9a 81       	ldd	r25, Y+2	; 0x02
    4604:	fc 01       	movw	r30, r24
    4606:	87 a1       	ldd	r24, Z+39	; 0x27
    4608:	81 30       	cpi	r24, 0x01	; 1
    460a:	21 f4       	brne	.+8      	; 0x4614 <vTaskSuspend+0x76>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    460c:	89 81       	ldd	r24, Y+1	; 0x01
    460e:	9a 81       	ldd	r25, Y+2	; 0x02
    4610:	fc 01       	movw	r30, r24
    4612:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4614:	0f 90       	pop	r0
    4616:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    4618:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <xSchedulerRunning>
    461c:	88 23       	and	r24, r24
    461e:	39 f0       	breq	.+14     	; 0x462e <vTaskSuspend+0x90>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    4620:	0f b6       	in	r0, 0x3f	; 63
    4622:	f8 94       	cli
    4624:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    4626:	0e 94 52 29 	call	0x52a4	; 0x52a4 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    462a:	0f 90       	pop	r0
    462c:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    462e:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4632:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4636:	29 81       	ldd	r18, Y+1	; 0x01
    4638:	3a 81       	ldd	r19, Y+2	; 0x02
    463a:	28 17       	cp	r18, r24
    463c:	39 07       	cpc	r19, r25
    463e:	a1 f4       	brne	.+40     	; 0x4668 <vTaskSuspend+0xca>
		{
			if( xSchedulerRunning != pdFALSE )
    4640:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <xSchedulerRunning>
    4644:	88 23       	and	r24, r24
    4646:	19 f0       	breq	.+6      	; 0x464e <vTaskSuspend+0xb0>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4648:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    464c:	0d c0       	rjmp	.+26     	; 0x4668 <vTaskSuspend+0xca>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    464e:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <xSuspendedTaskList>
    4652:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <uxCurrentNumberOfTasks>
    4656:	98 17       	cp	r25, r24
    4658:	29 f4       	brne	.+10     	; 0x4664 <vTaskSuspend+0xc6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    465a:	10 92 b8 06 	sts	0x06B8, r1	; 0x8006b8 <pxCurrentTCB+0x1>
    465e:	10 92 b7 06 	sts	0x06B7, r1	; 0x8006b7 <pxCurrentTCB>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4662:	02 c0       	rjmp	.+4      	; 0x4668 <vTaskSuspend+0xca>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
    4664:	0e 94 62 26 	call	0x4cc4	; 0x4cc4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4668:	00 00       	nop
    466a:	0f 90       	pop	r0
    466c:	0f 90       	pop	r0
    466e:	0f 90       	pop	r0
    4670:	0f 90       	pop	r0
    4672:	df 91       	pop	r29
    4674:	cf 91       	pop	r28
    4676:	08 95       	ret

00004678 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4678:	cf 93       	push	r28
    467a:	df 93       	push	r29
    467c:	00 d0       	rcall	.+0      	; 0x467e <prvTaskIsTaskSuspended+0x6>
    467e:	00 d0       	rcall	.+0      	; 0x4680 <prvTaskIsTaskSuspended+0x8>
    4680:	1f 92       	push	r1
    4682:	cd b7       	in	r28, 0x3d	; 61
    4684:	de b7       	in	r29, 0x3e	; 62
    4686:	9d 83       	std	Y+5, r25	; 0x05
    4688:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    468a:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = xTask;
    468c:	8c 81       	ldd	r24, Y+4	; 0x04
    468e:	9d 81       	ldd	r25, Y+5	; 0x05
    4690:	9b 83       	std	Y+3, r25	; 0x03
    4692:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    4694:	8a 81       	ldd	r24, Y+2	; 0x02
    4696:	9b 81       	ldd	r25, Y+3	; 0x03
    4698:	fc 01       	movw	r30, r24
    469a:	82 85       	ldd	r24, Z+10	; 0x0a
    469c:	93 85       	ldd	r25, Z+11	; 0x0b
    469e:	8f 50       	subi	r24, 0x0F	; 15
    46a0:	97 40       	sbci	r25, 0x07	; 7
    46a2:	89 f4       	brne	.+34     	; 0x46c6 <prvTaskIsTaskSuspended+0x4e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    46a4:	8a 81       	ldd	r24, Y+2	; 0x02
    46a6:	9b 81       	ldd	r25, Y+3	; 0x03
    46a8:	fc 01       	movw	r30, r24
    46aa:	84 89       	ldd	r24, Z+20	; 0x14
    46ac:	95 89       	ldd	r25, Z+21	; 0x15
    46ae:	8c 5f       	subi	r24, 0xFC	; 252
    46b0:	96 40       	sbci	r25, 0x06	; 6
    46b2:	49 f0       	breq	.+18     	; 0x46c6 <prvTaskIsTaskSuspended+0x4e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    46b4:	8a 81       	ldd	r24, Y+2	; 0x02
    46b6:	9b 81       	ldd	r25, Y+3	; 0x03
    46b8:	fc 01       	movw	r30, r24
    46ba:	84 89       	ldd	r24, Z+20	; 0x14
    46bc:	95 89       	ldd	r25, Z+21	; 0x15
    46be:	89 2b       	or	r24, r25
    46c0:	11 f4       	brne	.+4      	; 0x46c6 <prvTaskIsTaskSuspended+0x4e>
				{
					xReturn = pdTRUE;
    46c2:	81 e0       	ldi	r24, 0x01	; 1
    46c4:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    46c6:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    46c8:	0f 90       	pop	r0
    46ca:	0f 90       	pop	r0
    46cc:	0f 90       	pop	r0
    46ce:	0f 90       	pop	r0
    46d0:	0f 90       	pop	r0
    46d2:	df 91       	pop	r29
    46d4:	cf 91       	pop	r28
    46d6:	08 95       	ret

000046d8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    46d8:	cf 93       	push	r28
    46da:	df 93       	push	r29
    46dc:	00 d0       	rcall	.+0      	; 0x46de <vTaskResume+0x6>
    46de:	00 d0       	rcall	.+0      	; 0x46e0 <vTaskResume+0x8>
    46e0:	cd b7       	in	r28, 0x3d	; 61
    46e2:	de b7       	in	r29, 0x3e	; 62
    46e4:	9c 83       	std	Y+4, r25	; 0x04
    46e6:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    46e8:	8b 81       	ldd	r24, Y+3	; 0x03
    46ea:	9c 81       	ldd	r25, Y+4	; 0x04
    46ec:	9a 83       	std	Y+2, r25	; 0x02
    46ee:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    46f0:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    46f4:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    46f8:	29 81       	ldd	r18, Y+1	; 0x01
    46fa:	3a 81       	ldd	r19, Y+2	; 0x02
    46fc:	28 17       	cp	r18, r24
    46fe:	39 07       	cpc	r19, r25
    4700:	09 f4       	brne	.+2      	; 0x4704 <vTaskResume+0x2c>
    4702:	4a c0       	rjmp	.+148    	; 0x4798 <vTaskResume+0xc0>
    4704:	89 81       	ldd	r24, Y+1	; 0x01
    4706:	9a 81       	ldd	r25, Y+2	; 0x02
    4708:	89 2b       	or	r24, r25
    470a:	09 f4       	brne	.+2      	; 0x470e <vTaskResume+0x36>
    470c:	45 c0       	rjmp	.+138    	; 0x4798 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    470e:	0f b6       	in	r0, 0x3f	; 63
    4710:	f8 94       	cli
    4712:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4714:	89 81       	ldd	r24, Y+1	; 0x01
    4716:	9a 81       	ldd	r25, Y+2	; 0x02
    4718:	0e 94 3c 23 	call	0x4678	; 0x4678 <prvTaskIsTaskSuspended>
    471c:	88 23       	and	r24, r24
    471e:	d1 f1       	breq	.+116    	; 0x4794 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4720:	89 81       	ldd	r24, Y+1	; 0x01
    4722:	9a 81       	ldd	r25, Y+2	; 0x02
    4724:	02 96       	adiw	r24, 0x02	; 2
    4726:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    472a:	89 81       	ldd	r24, Y+1	; 0x01
    472c:	9a 81       	ldd	r25, Y+2	; 0x02
    472e:	fc 01       	movw	r30, r24
    4730:	96 89       	ldd	r25, Z+22	; 0x16
    4732:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    4736:	89 17       	cp	r24, r25
    4738:	30 f4       	brcc	.+12     	; 0x4746 <vTaskResume+0x6e>
    473a:	89 81       	ldd	r24, Y+1	; 0x01
    473c:	9a 81       	ldd	r25, Y+2	; 0x02
    473e:	fc 01       	movw	r30, r24
    4740:	86 89       	ldd	r24, Z+22	; 0x16
    4742:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    4746:	89 81       	ldd	r24, Y+1	; 0x01
    4748:	9a 81       	ldd	r25, Y+2	; 0x02
    474a:	ac 01       	movw	r20, r24
    474c:	4e 5f       	subi	r20, 0xFE	; 254
    474e:	5f 4f       	sbci	r21, 0xFF	; 255
    4750:	89 81       	ldd	r24, Y+1	; 0x01
    4752:	9a 81       	ldd	r25, Y+2	; 0x02
    4754:	fc 01       	movw	r30, r24
    4756:	86 89       	ldd	r24, Z+22	; 0x16
    4758:	28 2f       	mov	r18, r24
    475a:	30 e0       	ldi	r19, 0x00	; 0
    475c:	c9 01       	movw	r24, r18
    475e:	88 0f       	add	r24, r24
    4760:	99 1f       	adc	r25, r25
    4762:	88 0f       	add	r24, r24
    4764:	99 1f       	adc	r25, r25
    4766:	88 0f       	add	r24, r24
    4768:	99 1f       	adc	r25, r25
    476a:	82 0f       	add	r24, r18
    476c:	93 1f       	adc	r25, r19
    476e:	87 54       	subi	r24, 0x47	; 71
    4770:	99 4f       	sbci	r25, 0xF9	; 249
    4772:	ba 01       	movw	r22, r20
    4774:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4778:	89 81       	ldd	r24, Y+1	; 0x01
    477a:	9a 81       	ldd	r25, Y+2	; 0x02
    477c:	fc 01       	movw	r30, r24
    477e:	26 89       	ldd	r18, Z+22	; 0x16
    4780:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4784:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4788:	fc 01       	movw	r30, r24
    478a:	86 89       	ldd	r24, Z+22	; 0x16
    478c:	28 17       	cp	r18, r24
    478e:	10 f0       	brcs	.+4      	; 0x4794 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4790:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4794:	0f 90       	pop	r0
    4796:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4798:	00 00       	nop
    479a:	0f 90       	pop	r0
    479c:	0f 90       	pop	r0
    479e:	0f 90       	pop	r0
    47a0:	0f 90       	pop	r0
    47a2:	df 91       	pop	r29
    47a4:	cf 91       	pop	r28
    47a6:	08 95       	ret

000047a8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    47a8:	cf 93       	push	r28
    47aa:	df 93       	push	r29
    47ac:	00 d0       	rcall	.+0      	; 0x47ae <xTaskResumeFromISR+0x6>
    47ae:	00 d0       	rcall	.+0      	; 0x47b0 <xTaskResumeFromISR+0x8>
    47b0:	00 d0       	rcall	.+0      	; 0x47b2 <xTaskResumeFromISR+0xa>
    47b2:	cd b7       	in	r28, 0x3d	; 61
    47b4:	de b7       	in	r29, 0x3e	; 62
    47b6:	9e 83       	std	Y+6, r25	; 0x06
    47b8:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    47ba:	19 82       	std	Y+1, r1	; 0x01
	TCB_t * const pxTCB = xTaskToResume;
    47bc:	8d 81       	ldd	r24, Y+5	; 0x05
    47be:	9e 81       	ldd	r25, Y+6	; 0x06
    47c0:	9b 83       	std	Y+3, r25	; 0x03
    47c2:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    47c4:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    47c6:	8a 81       	ldd	r24, Y+2	; 0x02
    47c8:	9b 81       	ldd	r25, Y+3	; 0x03
    47ca:	0e 94 3c 23 	call	0x4678	; 0x4678 <prvTaskIsTaskSuspended>
    47ce:	88 23       	and	r24, r24
    47d0:	09 f4       	brne	.+2      	; 0x47d4 <xTaskResumeFromISR+0x2c>
    47d2:	47 c0       	rjmp	.+142    	; 0x4862 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    47d4:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    47d8:	88 23       	and	r24, r24
    47da:	d9 f5       	brne	.+118    	; 0x4852 <xTaskResumeFromISR+0xaa>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    47dc:	8a 81       	ldd	r24, Y+2	; 0x02
    47de:	9b 81       	ldd	r25, Y+3	; 0x03
    47e0:	fc 01       	movw	r30, r24
    47e2:	26 89       	ldd	r18, Z+22	; 0x16
    47e4:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    47e8:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    47ec:	fc 01       	movw	r30, r24
    47ee:	86 89       	ldd	r24, Z+22	; 0x16
    47f0:	28 17       	cp	r18, r24
    47f2:	10 f0       	brcs	.+4      	; 0x47f8 <xTaskResumeFromISR+0x50>
					{
						xYieldRequired = pdTRUE;
    47f4:	81 e0       	ldi	r24, 0x01	; 1
    47f6:	89 83       	std	Y+1, r24	; 0x01
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    47f8:	8a 81       	ldd	r24, Y+2	; 0x02
    47fa:	9b 81       	ldd	r25, Y+3	; 0x03
    47fc:	02 96       	adiw	r24, 0x02	; 2
    47fe:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4802:	8a 81       	ldd	r24, Y+2	; 0x02
    4804:	9b 81       	ldd	r25, Y+3	; 0x03
    4806:	fc 01       	movw	r30, r24
    4808:	96 89       	ldd	r25, Z+22	; 0x16
    480a:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    480e:	89 17       	cp	r24, r25
    4810:	30 f4       	brcc	.+12     	; 0x481e <xTaskResumeFromISR+0x76>
    4812:	8a 81       	ldd	r24, Y+2	; 0x02
    4814:	9b 81       	ldd	r25, Y+3	; 0x03
    4816:	fc 01       	movw	r30, r24
    4818:	86 89       	ldd	r24, Z+22	; 0x16
    481a:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    481e:	8a 81       	ldd	r24, Y+2	; 0x02
    4820:	9b 81       	ldd	r25, Y+3	; 0x03
    4822:	ac 01       	movw	r20, r24
    4824:	4e 5f       	subi	r20, 0xFE	; 254
    4826:	5f 4f       	sbci	r21, 0xFF	; 255
    4828:	8a 81       	ldd	r24, Y+2	; 0x02
    482a:	9b 81       	ldd	r25, Y+3	; 0x03
    482c:	fc 01       	movw	r30, r24
    482e:	86 89       	ldd	r24, Z+22	; 0x16
    4830:	28 2f       	mov	r18, r24
    4832:	30 e0       	ldi	r19, 0x00	; 0
    4834:	c9 01       	movw	r24, r18
    4836:	88 0f       	add	r24, r24
    4838:	99 1f       	adc	r25, r25
    483a:	88 0f       	add	r24, r24
    483c:	99 1f       	adc	r25, r25
    483e:	88 0f       	add	r24, r24
    4840:	99 1f       	adc	r25, r25
    4842:	82 0f       	add	r24, r18
    4844:	93 1f       	adc	r25, r19
    4846:	87 54       	subi	r24, 0x47	; 71
    4848:	99 4f       	sbci	r25, 0xF9	; 249
    484a:	ba 01       	movw	r22, r20
    484c:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
    4850:	08 c0       	rjmp	.+16     	; 0x4862 <xTaskResumeFromISR+0xba>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4852:	8a 81       	ldd	r24, Y+2	; 0x02
    4854:	9b 81       	ldd	r25, Y+3	; 0x03
    4856:	0c 96       	adiw	r24, 0x0c	; 12
    4858:	bc 01       	movw	r22, r24
    485a:	8c ef       	ldi	r24, 0xFC	; 252
    485c:	96 e0       	ldi	r25, 0x06	; 6
    485e:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4862:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4864:	26 96       	adiw	r28, 0x06	; 6
    4866:	0f b6       	in	r0, 0x3f	; 63
    4868:	f8 94       	cli
    486a:	de bf       	out	0x3e, r29	; 62
    486c:	0f be       	out	0x3f, r0	; 63
    486e:	cd bf       	out	0x3d, r28	; 61
    4870:	df 91       	pop	r29
    4872:	cf 91       	pop	r28
    4874:	08 95       	ret

00004876 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4876:	ef 92       	push	r14
    4878:	ff 92       	push	r15
    487a:	0f 93       	push	r16
    487c:	cf 93       	push	r28
    487e:	df 93       	push	r29
    4880:	1f 92       	push	r1
    4882:	cd b7       	in	r28, 0x3d	; 61
    4884:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4886:	0f 2e       	mov	r0, r31
    4888:	f3 e2       	ldi	r31, 0x23	; 35
    488a:	ef 2e       	mov	r14, r31
    488c:	f7 e0       	ldi	r31, 0x07	; 7
    488e:	ff 2e       	mov	r15, r31
    4890:	f0 2d       	mov	r31, r0
    4892:	00 e0       	ldi	r16, 0x00	; 0
    4894:	20 e0       	ldi	r18, 0x00	; 0
    4896:	30 e0       	ldi	r19, 0x00	; 0
    4898:	45 e5       	ldi	r20, 0x55	; 85
    489a:	50 e0       	ldi	r21, 0x00	; 0
    489c:	64 eb       	ldi	r22, 0xB4	; 180
    489e:	70 e0       	ldi	r23, 0x00	; 0
    48a0:	87 eb       	ldi	r24, 0xB7	; 183
    48a2:	98 e2       	ldi	r25, 0x28	; 40
    48a4:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <xTaskCreate>
    48a8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    48aa:	89 81       	ldd	r24, Y+1	; 0x01
    48ac:	81 30       	cpi	r24, 0x01	; 1
    48ae:	81 f4       	brne	.+32     	; 0x48d0 <vTaskStartScheduler+0x5a>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    48b0:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    48b2:	8f ef       	ldi	r24, 0xFF	; 255
    48b4:	9f ef       	ldi	r25, 0xFF	; 255
    48b6:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <xNextTaskUnblockTime+0x1>
    48ba:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    48be:	81 e0       	ldi	r24, 0x01	; 1
    48c0:	80 93 1c 07 	sts	0x071C, r24	; 0x80071c <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    48c4:	10 92 1a 07 	sts	0x071A, r1	; 0x80071a <xTickCount+0x1>
    48c8:	10 92 19 07 	sts	0x0719, r1	; 0x800719 <xTickCount>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    48cc:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    48d0:	00 00       	nop
    48d2:	0f 90       	pop	r0
    48d4:	df 91       	pop	r29
    48d6:	cf 91       	pop	r28
    48d8:	0f 91       	pop	r16
    48da:	ff 90       	pop	r15
    48dc:	ef 90       	pop	r14
    48de:	08 95       	ret

000048e0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    48e0:	cf 93       	push	r28
    48e2:	df 93       	push	r29
    48e4:	cd b7       	in	r28, 0x3d	; 61
    48e6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    48e8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    48ea:	10 92 1c 07 	sts	0x071C, r1	; 0x80071c <xSchedulerRunning>
	vPortEndScheduler();
    48ee:	0e 94 81 16 	call	0x2d02	; 0x2d02 <vPortEndScheduler>
}
    48f2:	00 00       	nop
    48f4:	df 91       	pop	r29
    48f6:	cf 91       	pop	r28
    48f8:	08 95       	ret

000048fa <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    48fa:	cf 93       	push	r28
    48fc:	df 93       	push	r29
    48fe:	cd b7       	in	r28, 0x3d	; 61
    4900:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4902:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    4906:	8f 5f       	subi	r24, 0xFF	; 255
    4908:	80 93 25 07 	sts	0x0725, r24	; 0x800725 <uxSchedulerSuspended>
	portMEMORY_BARRIER();
}
    490c:	00 00       	nop
    490e:	df 91       	pop	r29
    4910:	cf 91       	pop	r28
    4912:	08 95       	ret

00004914 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4914:	cf 93       	push	r28
    4916:	df 93       	push	r29
    4918:	00 d0       	rcall	.+0      	; 0x491a <xTaskResumeAll+0x6>
    491a:	00 d0       	rcall	.+0      	; 0x491c <xTaskResumeAll+0x8>
    491c:	cd b7       	in	r28, 0x3d	; 61
    491e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4920:	1a 82       	std	Y+2, r1	; 0x02
    4922:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xAlreadyYielded = pdFALSE;
    4924:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4926:	0f b6       	in	r0, 0x3f	; 63
    4928:	f8 94       	cli
    492a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    492c:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    4930:	81 50       	subi	r24, 0x01	; 1
    4932:	80 93 25 07 	sts	0x0725, r24	; 0x800725 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4936:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    493a:	88 23       	and	r24, r24
    493c:	09 f0       	breq	.+2      	; 0x4940 <xTaskResumeAll+0x2c>
    493e:	77 c0       	rjmp	.+238    	; 0x4a2e <xTaskResumeAll+0x11a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4940:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <uxCurrentNumberOfTasks>
    4944:	88 23       	and	r24, r24
    4946:	09 f4       	brne	.+2      	; 0x494a <xTaskResumeAll+0x36>
    4948:	72 c0       	rjmp	.+228    	; 0x4a2e <xTaskResumeAll+0x11a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    494a:	49 c0       	rjmp	.+146    	; 0x49de <xTaskResumeAll+0xca>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    494c:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xPendingReadyList+0x5>
    4950:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xPendingReadyList+0x6>
    4954:	fc 01       	movw	r30, r24
    4956:	86 81       	ldd	r24, Z+6	; 0x06
    4958:	97 81       	ldd	r25, Z+7	; 0x07
    495a:	9a 83       	std	Y+2, r25	; 0x02
    495c:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    495e:	89 81       	ldd	r24, Y+1	; 0x01
    4960:	9a 81       	ldd	r25, Y+2	; 0x02
    4962:	0c 96       	adiw	r24, 0x0c	; 12
    4964:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4968:	89 81       	ldd	r24, Y+1	; 0x01
    496a:	9a 81       	ldd	r25, Y+2	; 0x02
    496c:	02 96       	adiw	r24, 0x02	; 2
    496e:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4972:	89 81       	ldd	r24, Y+1	; 0x01
    4974:	9a 81       	ldd	r25, Y+2	; 0x02
    4976:	fc 01       	movw	r30, r24
    4978:	96 89       	ldd	r25, Z+22	; 0x16
    497a:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    497e:	89 17       	cp	r24, r25
    4980:	30 f4       	brcc	.+12     	; 0x498e <xTaskResumeAll+0x7a>
    4982:	89 81       	ldd	r24, Y+1	; 0x01
    4984:	9a 81       	ldd	r25, Y+2	; 0x02
    4986:	fc 01       	movw	r30, r24
    4988:	86 89       	ldd	r24, Z+22	; 0x16
    498a:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    498e:	89 81       	ldd	r24, Y+1	; 0x01
    4990:	9a 81       	ldd	r25, Y+2	; 0x02
    4992:	ac 01       	movw	r20, r24
    4994:	4e 5f       	subi	r20, 0xFE	; 254
    4996:	5f 4f       	sbci	r21, 0xFF	; 255
    4998:	89 81       	ldd	r24, Y+1	; 0x01
    499a:	9a 81       	ldd	r25, Y+2	; 0x02
    499c:	fc 01       	movw	r30, r24
    499e:	86 89       	ldd	r24, Z+22	; 0x16
    49a0:	28 2f       	mov	r18, r24
    49a2:	30 e0       	ldi	r19, 0x00	; 0
    49a4:	c9 01       	movw	r24, r18
    49a6:	88 0f       	add	r24, r24
    49a8:	99 1f       	adc	r25, r25
    49aa:	88 0f       	add	r24, r24
    49ac:	99 1f       	adc	r25, r25
    49ae:	88 0f       	add	r24, r24
    49b0:	99 1f       	adc	r25, r25
    49b2:	82 0f       	add	r24, r18
    49b4:	93 1f       	adc	r25, r19
    49b6:	87 54       	subi	r24, 0x47	; 71
    49b8:	99 4f       	sbci	r25, 0xF9	; 249
    49ba:	ba 01       	movw	r22, r20
    49bc:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    49c0:	89 81       	ldd	r24, Y+1	; 0x01
    49c2:	9a 81       	ldd	r25, Y+2	; 0x02
    49c4:	fc 01       	movw	r30, r24
    49c6:	26 89       	ldd	r18, Z+22	; 0x16
    49c8:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    49cc:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    49d0:	fc 01       	movw	r30, r24
    49d2:	86 89       	ldd	r24, Z+22	; 0x16
    49d4:	28 17       	cp	r18, r24
    49d6:	18 f0       	brcs	.+6      	; 0x49de <xTaskResumeAll+0xca>
					{
						xYieldPending = pdTRUE;
    49d8:	81 e0       	ldi	r24, 0x01	; 1
    49da:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    49de:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <xPendingReadyList>
    49e2:	88 23       	and	r24, r24
    49e4:	09 f0       	breq	.+2      	; 0x49e8 <xTaskResumeAll+0xd4>
    49e6:	b2 cf       	rjmp	.-156    	; 0x494c <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    49e8:	89 81       	ldd	r24, Y+1	; 0x01
    49ea:	9a 81       	ldd	r25, Y+2	; 0x02
    49ec:	89 2b       	or	r24, r25
    49ee:	11 f0       	breq	.+4      	; 0x49f4 <xTaskResumeAll+0xe0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    49f0:	0e 94 52 29 	call	0x52a4	; 0x52a4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    49f4:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <uxPendedTicks>
    49f8:	8c 83       	std	Y+4, r24	; 0x04

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    49fa:	8c 81       	ldd	r24, Y+4	; 0x04
    49fc:	88 23       	and	r24, r24
    49fe:	79 f0       	breq	.+30     	; 0x4a1e <xTaskResumeAll+0x10a>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4a00:	0e 94 75 25 	call	0x4aea	; 0x4aea <xTaskIncrementTick>
    4a04:	88 23       	and	r24, r24
    4a06:	19 f0       	breq	.+6      	; 0x4a0e <xTaskResumeAll+0xfa>
							{
								xYieldPending = pdTRUE;
    4a08:	81 e0       	ldi	r24, 0x01	; 1
    4a0a:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4a0e:	8c 81       	ldd	r24, Y+4	; 0x04
    4a10:	81 50       	subi	r24, 0x01	; 1
    4a12:	8c 83       	std	Y+4, r24	; 0x04
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4a14:	8c 81       	ldd	r24, Y+4	; 0x04
    4a16:	88 23       	and	r24, r24
    4a18:	99 f7       	brne	.-26     	; 0x4a00 <xTaskResumeAll+0xec>

						uxPendedTicks = 0;
    4a1a:	10 92 1d 07 	sts	0x071D, r1	; 0x80071d <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4a1e:	80 91 1e 07 	lds	r24, 0x071E	; 0x80071e <xYieldPending>
    4a22:	88 23       	and	r24, r24
    4a24:	21 f0       	breq	.+8      	; 0x4a2e <xTaskResumeAll+0x11a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4a26:	81 e0       	ldi	r24, 0x01	; 1
    4a28:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4a2a:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4a2e:	0f 90       	pop	r0
    4a30:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4a32:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4a34:	0f 90       	pop	r0
    4a36:	0f 90       	pop	r0
    4a38:	0f 90       	pop	r0
    4a3a:	0f 90       	pop	r0
    4a3c:	df 91       	pop	r29
    4a3e:	cf 91       	pop	r28
    4a40:	08 95       	ret

00004a42 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4a42:	cf 93       	push	r28
    4a44:	df 93       	push	r29
    4a46:	00 d0       	rcall	.+0      	; 0x4a48 <xTaskGetTickCount+0x6>
    4a48:	cd b7       	in	r28, 0x3d	; 61
    4a4a:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4a4c:	0f b6       	in	r0, 0x3f	; 63
    4a4e:	f8 94       	cli
    4a50:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4a52:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <xTickCount>
    4a56:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <xTickCount+0x1>
    4a5a:	9a 83       	std	Y+2, r25	; 0x02
    4a5c:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4a5e:	0f 90       	pop	r0
    4a60:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4a62:	89 81       	ldd	r24, Y+1	; 0x01
    4a64:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4a66:	0f 90       	pop	r0
    4a68:	0f 90       	pop	r0
    4a6a:	df 91       	pop	r29
    4a6c:	cf 91       	pop	r28
    4a6e:	08 95       	ret

00004a70 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4a70:	cf 93       	push	r28
    4a72:	df 93       	push	r29
    4a74:	00 d0       	rcall	.+0      	; 0x4a76 <xTaskGetTickCountFromISR+0x6>
    4a76:	1f 92       	push	r1
    4a78:	cd b7       	in	r28, 0x3d	; 61
    4a7a:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4a7c:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4a7e:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <xTickCount>
    4a82:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <xTickCount+0x1>
    4a86:	9b 83       	std	Y+3, r25	; 0x03
    4a88:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a8c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4a8e:	0f 90       	pop	r0
    4a90:	0f 90       	pop	r0
    4a92:	0f 90       	pop	r0
    4a94:	df 91       	pop	r29
    4a96:	cf 91       	pop	r28
    4a98:	08 95       	ret

00004a9a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4a9a:	cf 93       	push	r28
    4a9c:	df 93       	push	r29
    4a9e:	cd b7       	in	r28, 0x3d	; 61
    4aa0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4aa2:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <uxCurrentNumberOfTasks>
}
    4aa6:	df 91       	pop	r29
    4aa8:	cf 91       	pop	r28
    4aaa:	08 95       	ret

00004aac <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4aac:	cf 93       	push	r28
    4aae:	df 93       	push	r29
    4ab0:	00 d0       	rcall	.+0      	; 0x4ab2 <pcTaskGetName+0x6>
    4ab2:	00 d0       	rcall	.+0      	; 0x4ab4 <pcTaskGetName+0x8>
    4ab4:	cd b7       	in	r28, 0x3d	; 61
    4ab6:	de b7       	in	r29, 0x3e	; 62
    4ab8:	9c 83       	std	Y+4, r25	; 0x04
    4aba:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4abc:	8b 81       	ldd	r24, Y+3	; 0x03
    4abe:	9c 81       	ldd	r25, Y+4	; 0x04
    4ac0:	89 2b       	or	r24, r25
    4ac2:	29 f4       	brne	.+10     	; 0x4ace <pcTaskGetName+0x22>
    4ac4:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4ac8:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4acc:	02 c0       	rjmp	.+4      	; 0x4ad2 <pcTaskGetName+0x26>
    4ace:	8b 81       	ldd	r24, Y+3	; 0x03
    4ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ad2:	9a 83       	std	Y+2, r25	; 0x02
    4ad4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4ad6:	89 81       	ldd	r24, Y+1	; 0x01
    4ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    4ada:	49 96       	adiw	r24, 0x19	; 25
}
    4adc:	0f 90       	pop	r0
    4ade:	0f 90       	pop	r0
    4ae0:	0f 90       	pop	r0
    4ae2:	0f 90       	pop	r0
    4ae4:	df 91       	pop	r29
    4ae6:	cf 91       	pop	r28
    4ae8:	08 95       	ret

00004aea <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4aea:	cf 93       	push	r28
    4aec:	df 93       	push	r29
    4aee:	cd b7       	in	r28, 0x3d	; 61
    4af0:	de b7       	in	r29, 0x3e	; 62
    4af2:	29 97       	sbiw	r28, 0x09	; 9
    4af4:	0f b6       	in	r0, 0x3f	; 63
    4af6:	f8 94       	cli
    4af8:	de bf       	out	0x3e, r29	; 62
    4afa:	0f be       	out	0x3f, r0	; 63
    4afc:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4afe:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b00:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    4b04:	88 23       	and	r24, r24
    4b06:	09 f0       	breq	.+2      	; 0x4b0a <xTaskIncrementTick+0x20>
    4b08:	c8 c0       	rjmp	.+400    	; 0x4c9a <xTaskIncrementTick+0x1b0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4b0a:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <xTickCount>
    4b0e:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <xTickCount+0x1>
    4b12:	01 96       	adiw	r24, 0x01	; 1
    4b14:	9b 83       	std	Y+3, r25	; 0x03
    4b16:	8a 83       	std	Y+2, r24	; 0x02

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4b18:	8a 81       	ldd	r24, Y+2	; 0x02
    4b1a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b1c:	90 93 1a 07 	sts	0x071A, r25	; 0x80071a <xTickCount+0x1>
    4b20:	80 93 19 07 	sts	0x0719, r24	; 0x800719 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4b24:	8a 81       	ldd	r24, Y+2	; 0x02
    4b26:	9b 81       	ldd	r25, Y+3	; 0x03
    4b28:	89 2b       	or	r24, r25
    4b2a:	d9 f4       	brne	.+54     	; 0x4b62 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4b2c:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    4b30:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    4b34:	9d 83       	std	Y+5, r25	; 0x05
    4b36:	8c 83       	std	Y+4, r24	; 0x04
    4b38:	80 91 fa 06 	lds	r24, 0x06FA	; 0x8006fa <pxOverflowDelayedTaskList>
    4b3c:	90 91 fb 06 	lds	r25, 0x06FB	; 0x8006fb <pxOverflowDelayedTaskList+0x1>
    4b40:	90 93 f9 06 	sts	0x06F9, r25	; 0x8006f9 <pxDelayedTaskList+0x1>
    4b44:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <pxDelayedTaskList>
    4b48:	8c 81       	ldd	r24, Y+4	; 0x04
    4b4a:	9d 81       	ldd	r25, Y+5	; 0x05
    4b4c:	90 93 fb 06 	sts	0x06FB, r25	; 0x8006fb <pxOverflowDelayedTaskList+0x1>
    4b50:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <pxOverflowDelayedTaskList>
    4b54:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <xNumOfOverflows>
    4b58:	8f 5f       	subi	r24, 0xFF	; 255
    4b5a:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <xNumOfOverflows>
    4b5e:	0e 94 52 29 	call	0x52a4	; 0x52a4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4b62:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <xNextTaskUnblockTime>
    4b66:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <xNextTaskUnblockTime+0x1>
    4b6a:	2a 81       	ldd	r18, Y+2	; 0x02
    4b6c:	3b 81       	ldd	r19, Y+3	; 0x03
    4b6e:	28 17       	cp	r18, r24
    4b70:	39 07       	cpc	r19, r25
    4b72:	08 f4       	brcc	.+2      	; 0x4b76 <xTaskIncrementTick+0x8c>
    4b74:	78 c0       	rjmp	.+240    	; 0x4c66 <xTaskIncrementTick+0x17c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4b76:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    4b7a:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    4b7e:	fc 01       	movw	r30, r24
    4b80:	80 81       	ld	r24, Z
    4b82:	88 23       	and	r24, r24
    4b84:	39 f4       	brne	.+14     	; 0x4b94 <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4b86:	8f ef       	ldi	r24, 0xFF	; 255
    4b88:	9f ef       	ldi	r25, 0xFF	; 255
    4b8a:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <xNextTaskUnblockTime+0x1>
    4b8e:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xNextTaskUnblockTime>
					break;
    4b92:	69 c0       	rjmp	.+210    	; 0x4c66 <xTaskIncrementTick+0x17c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b94:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    4b98:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    4b9c:	fc 01       	movw	r30, r24
    4b9e:	85 81       	ldd	r24, Z+5	; 0x05
    4ba0:	96 81       	ldd	r25, Z+6	; 0x06
    4ba2:	fc 01       	movw	r30, r24
    4ba4:	86 81       	ldd	r24, Z+6	; 0x06
    4ba6:	97 81       	ldd	r25, Z+7	; 0x07
    4ba8:	9f 83       	std	Y+7, r25	; 0x07
    4baa:	8e 83       	std	Y+6, r24	; 0x06
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4bac:	8e 81       	ldd	r24, Y+6	; 0x06
    4bae:	9f 81       	ldd	r25, Y+7	; 0x07
    4bb0:	fc 01       	movw	r30, r24
    4bb2:	82 81       	ldd	r24, Z+2	; 0x02
    4bb4:	93 81       	ldd	r25, Z+3	; 0x03
    4bb6:	99 87       	std	Y+9, r25	; 0x09
    4bb8:	88 87       	std	Y+8, r24	; 0x08

					if( xConstTickCount < xItemValue )
    4bba:	2a 81       	ldd	r18, Y+2	; 0x02
    4bbc:	3b 81       	ldd	r19, Y+3	; 0x03
    4bbe:	88 85       	ldd	r24, Y+8	; 0x08
    4bc0:	99 85       	ldd	r25, Y+9	; 0x09
    4bc2:	28 17       	cp	r18, r24
    4bc4:	39 07       	cpc	r19, r25
    4bc6:	38 f4       	brcc	.+14     	; 0x4bd6 <xTaskIncrementTick+0xec>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4bc8:	88 85       	ldd	r24, Y+8	; 0x08
    4bca:	99 85       	ldd	r25, Y+9	; 0x09
    4bcc:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <xNextTaskUnblockTime+0x1>
    4bd0:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    4bd4:	48 c0       	rjmp	.+144    	; 0x4c66 <xTaskIncrementTick+0x17c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4bd6:	8e 81       	ldd	r24, Y+6	; 0x06
    4bd8:	9f 81       	ldd	r25, Y+7	; 0x07
    4bda:	02 96       	adiw	r24, 0x02	; 2
    4bdc:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4be0:	8e 81       	ldd	r24, Y+6	; 0x06
    4be2:	9f 81       	ldd	r25, Y+7	; 0x07
    4be4:	fc 01       	movw	r30, r24
    4be6:	84 89       	ldd	r24, Z+20	; 0x14
    4be8:	95 89       	ldd	r25, Z+21	; 0x15
    4bea:	89 2b       	or	r24, r25
    4bec:	29 f0       	breq	.+10     	; 0x4bf8 <xTaskIncrementTick+0x10e>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4bee:	8e 81       	ldd	r24, Y+6	; 0x06
    4bf0:	9f 81       	ldd	r25, Y+7	; 0x07
    4bf2:	0c 96       	adiw	r24, 0x0c	; 12
    4bf4:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4bf8:	8e 81       	ldd	r24, Y+6	; 0x06
    4bfa:	9f 81       	ldd	r25, Y+7	; 0x07
    4bfc:	fc 01       	movw	r30, r24
    4bfe:	96 89       	ldd	r25, Z+22	; 0x16
    4c00:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    4c04:	89 17       	cp	r24, r25
    4c06:	30 f4       	brcc	.+12     	; 0x4c14 <xTaskIncrementTick+0x12a>
    4c08:	8e 81       	ldd	r24, Y+6	; 0x06
    4c0a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c0c:	fc 01       	movw	r30, r24
    4c0e:	86 89       	ldd	r24, Z+22	; 0x16
    4c10:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    4c14:	8e 81       	ldd	r24, Y+6	; 0x06
    4c16:	9f 81       	ldd	r25, Y+7	; 0x07
    4c18:	ac 01       	movw	r20, r24
    4c1a:	4e 5f       	subi	r20, 0xFE	; 254
    4c1c:	5f 4f       	sbci	r21, 0xFF	; 255
    4c1e:	8e 81       	ldd	r24, Y+6	; 0x06
    4c20:	9f 81       	ldd	r25, Y+7	; 0x07
    4c22:	fc 01       	movw	r30, r24
    4c24:	86 89       	ldd	r24, Z+22	; 0x16
    4c26:	28 2f       	mov	r18, r24
    4c28:	30 e0       	ldi	r19, 0x00	; 0
    4c2a:	c9 01       	movw	r24, r18
    4c2c:	88 0f       	add	r24, r24
    4c2e:	99 1f       	adc	r25, r25
    4c30:	88 0f       	add	r24, r24
    4c32:	99 1f       	adc	r25, r25
    4c34:	88 0f       	add	r24, r24
    4c36:	99 1f       	adc	r25, r25
    4c38:	82 0f       	add	r24, r18
    4c3a:	93 1f       	adc	r25, r19
    4c3c:	87 54       	subi	r24, 0x47	; 71
    4c3e:	99 4f       	sbci	r25, 0xF9	; 249
    4c40:	ba 01       	movw	r22, r20
    4c42:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4c46:	8e 81       	ldd	r24, Y+6	; 0x06
    4c48:	9f 81       	ldd	r25, Y+7	; 0x07
    4c4a:	fc 01       	movw	r30, r24
    4c4c:	26 89       	ldd	r18, Z+22	; 0x16
    4c4e:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4c52:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4c56:	fc 01       	movw	r30, r24
    4c58:	86 89       	ldd	r24, Z+22	; 0x16
    4c5a:	28 17       	cp	r18, r24
    4c5c:	08 f4       	brcc	.+2      	; 0x4c60 <xTaskIncrementTick+0x176>
    4c5e:	8b cf       	rjmp	.-234    	; 0x4b76 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4c60:	81 e0       	ldi	r24, 0x01	; 1
    4c62:	89 83       	std	Y+1, r24	; 0x01
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    4c64:	88 cf       	rjmp	.-240    	; 0x4b76 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4c66:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4c6a:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4c6e:	fc 01       	movw	r30, r24
    4c70:	86 89       	ldd	r24, Z+22	; 0x16
    4c72:	28 2f       	mov	r18, r24
    4c74:	30 e0       	ldi	r19, 0x00	; 0
    4c76:	c9 01       	movw	r24, r18
    4c78:	88 0f       	add	r24, r24
    4c7a:	99 1f       	adc	r25, r25
    4c7c:	88 0f       	add	r24, r24
    4c7e:	99 1f       	adc	r25, r25
    4c80:	88 0f       	add	r24, r24
    4c82:	99 1f       	adc	r25, r25
    4c84:	82 0f       	add	r24, r18
    4c86:	93 1f       	adc	r25, r19
    4c88:	87 54       	subi	r24, 0x47	; 71
    4c8a:	99 4f       	sbci	r25, 0xF9	; 249
    4c8c:	fc 01       	movw	r30, r24
    4c8e:	80 81       	ld	r24, Z
    4c90:	82 30       	cpi	r24, 0x02	; 2
    4c92:	40 f0       	brcs	.+16     	; 0x4ca4 <xTaskIncrementTick+0x1ba>
			{
				xSwitchRequired = pdTRUE;
    4c94:	81 e0       	ldi	r24, 0x01	; 1
    4c96:	89 83       	std	Y+1, r24	; 0x01
    4c98:	05 c0       	rjmp	.+10     	; 0x4ca4 <xTaskIncrementTick+0x1ba>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4c9a:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <uxPendedTicks>
    4c9e:	8f 5f       	subi	r24, 0xFF	; 255
    4ca0:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <uxPendedTicks>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4ca4:	80 91 1e 07 	lds	r24, 0x071E	; 0x80071e <xYieldPending>
    4ca8:	88 23       	and	r24, r24
    4caa:	11 f0       	breq	.+4      	; 0x4cb0 <xTaskIncrementTick+0x1c6>
		{
			xSwitchRequired = pdTRUE;
    4cac:	81 e0       	ldi	r24, 0x01	; 1
    4cae:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4cb0:	89 81       	ldd	r24, Y+1	; 0x01
}
    4cb2:	29 96       	adiw	r28, 0x09	; 9
    4cb4:	0f b6       	in	r0, 0x3f	; 63
    4cb6:	f8 94       	cli
    4cb8:	de bf       	out	0x3e, r29	; 62
    4cba:	0f be       	out	0x3f, r0	; 63
    4cbc:	cd bf       	out	0x3d, r28	; 61
    4cbe:	df 91       	pop	r29
    4cc0:	cf 91       	pop	r28
    4cc2:	08 95       	ret

00004cc4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4cc4:	cf 93       	push	r28
    4cc6:	df 93       	push	r29
    4cc8:	00 d0       	rcall	.+0      	; 0x4cca <vTaskSwitchContext+0x6>
    4cca:	1f 92       	push	r1
    4ccc:	cd b7       	in	r28, 0x3d	; 61
    4cce:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4cd0:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    4cd4:	88 23       	and	r24, r24
    4cd6:	21 f0       	breq	.+8      	; 0x4ce0 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4cd8:	81 e0       	ldi	r24, 0x01	; 1
    4cda:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4cde:	5f c0       	rjmp	.+190    	; 0x4d9e <vTaskSwitchContext+0xda>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    4ce0:	10 92 1e 07 	sts	0x071E, r1	; 0x80071e <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ce4:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    4ce8:	89 83       	std	Y+1, r24	; 0x01
    4cea:	03 c0       	rjmp	.+6      	; 0x4cf2 <vTaskSwitchContext+0x2e>
    4cec:	89 81       	ldd	r24, Y+1	; 0x01
    4cee:	81 50       	subi	r24, 0x01	; 1
    4cf0:	89 83       	std	Y+1, r24	; 0x01
    4cf2:	89 81       	ldd	r24, Y+1	; 0x01
    4cf4:	28 2f       	mov	r18, r24
    4cf6:	30 e0       	ldi	r19, 0x00	; 0
    4cf8:	c9 01       	movw	r24, r18
    4cfa:	88 0f       	add	r24, r24
    4cfc:	99 1f       	adc	r25, r25
    4cfe:	88 0f       	add	r24, r24
    4d00:	99 1f       	adc	r25, r25
    4d02:	88 0f       	add	r24, r24
    4d04:	99 1f       	adc	r25, r25
    4d06:	82 0f       	add	r24, r18
    4d08:	93 1f       	adc	r25, r19
    4d0a:	87 54       	subi	r24, 0x47	; 71
    4d0c:	99 4f       	sbci	r25, 0xF9	; 249
    4d0e:	fc 01       	movw	r30, r24
    4d10:	80 81       	ld	r24, Z
    4d12:	88 23       	and	r24, r24
    4d14:	59 f3       	breq	.-42     	; 0x4cec <vTaskSwitchContext+0x28>
    4d16:	89 81       	ldd	r24, Y+1	; 0x01
    4d18:	28 2f       	mov	r18, r24
    4d1a:	30 e0       	ldi	r19, 0x00	; 0
    4d1c:	c9 01       	movw	r24, r18
    4d1e:	88 0f       	add	r24, r24
    4d20:	99 1f       	adc	r25, r25
    4d22:	88 0f       	add	r24, r24
    4d24:	99 1f       	adc	r25, r25
    4d26:	88 0f       	add	r24, r24
    4d28:	99 1f       	adc	r25, r25
    4d2a:	82 0f       	add	r24, r18
    4d2c:	93 1f       	adc	r25, r19
    4d2e:	87 54       	subi	r24, 0x47	; 71
    4d30:	99 4f       	sbci	r25, 0xF9	; 249
    4d32:	9b 83       	std	Y+3, r25	; 0x03
    4d34:	8a 83       	std	Y+2, r24	; 0x02
    4d36:	8a 81       	ldd	r24, Y+2	; 0x02
    4d38:	9b 81       	ldd	r25, Y+3	; 0x03
    4d3a:	fc 01       	movw	r30, r24
    4d3c:	81 81       	ldd	r24, Z+1	; 0x01
    4d3e:	92 81       	ldd	r25, Z+2	; 0x02
    4d40:	fc 01       	movw	r30, r24
    4d42:	22 81       	ldd	r18, Z+2	; 0x02
    4d44:	33 81       	ldd	r19, Z+3	; 0x03
    4d46:	8a 81       	ldd	r24, Y+2	; 0x02
    4d48:	9b 81       	ldd	r25, Y+3	; 0x03
    4d4a:	fc 01       	movw	r30, r24
    4d4c:	32 83       	std	Z+2, r19	; 0x02
    4d4e:	21 83       	std	Z+1, r18	; 0x01
    4d50:	8a 81       	ldd	r24, Y+2	; 0x02
    4d52:	9b 81       	ldd	r25, Y+3	; 0x03
    4d54:	fc 01       	movw	r30, r24
    4d56:	21 81       	ldd	r18, Z+1	; 0x01
    4d58:	32 81       	ldd	r19, Z+2	; 0x02
    4d5a:	8a 81       	ldd	r24, Y+2	; 0x02
    4d5c:	9b 81       	ldd	r25, Y+3	; 0x03
    4d5e:	03 96       	adiw	r24, 0x03	; 3
    4d60:	28 17       	cp	r18, r24
    4d62:	39 07       	cpc	r19, r25
    4d64:	69 f4       	brne	.+26     	; 0x4d80 <vTaskSwitchContext+0xbc>
    4d66:	8a 81       	ldd	r24, Y+2	; 0x02
    4d68:	9b 81       	ldd	r25, Y+3	; 0x03
    4d6a:	fc 01       	movw	r30, r24
    4d6c:	81 81       	ldd	r24, Z+1	; 0x01
    4d6e:	92 81       	ldd	r25, Z+2	; 0x02
    4d70:	fc 01       	movw	r30, r24
    4d72:	22 81       	ldd	r18, Z+2	; 0x02
    4d74:	33 81       	ldd	r19, Z+3	; 0x03
    4d76:	8a 81       	ldd	r24, Y+2	; 0x02
    4d78:	9b 81       	ldd	r25, Y+3	; 0x03
    4d7a:	fc 01       	movw	r30, r24
    4d7c:	32 83       	std	Z+2, r19	; 0x02
    4d7e:	21 83       	std	Z+1, r18	; 0x01
    4d80:	8a 81       	ldd	r24, Y+2	; 0x02
    4d82:	9b 81       	ldd	r25, Y+3	; 0x03
    4d84:	fc 01       	movw	r30, r24
    4d86:	81 81       	ldd	r24, Z+1	; 0x01
    4d88:	92 81       	ldd	r25, Z+2	; 0x02
    4d8a:	fc 01       	movw	r30, r24
    4d8c:	86 81       	ldd	r24, Z+6	; 0x06
    4d8e:	97 81       	ldd	r25, Z+7	; 0x07
    4d90:	90 93 b8 06 	sts	0x06B8, r25	; 0x8006b8 <pxCurrentTCB+0x1>
    4d94:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <pxCurrentTCB>
    4d98:	89 81       	ldd	r24, Y+1	; 0x01
    4d9a:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4d9e:	00 00       	nop
    4da0:	0f 90       	pop	r0
    4da2:	0f 90       	pop	r0
    4da4:	0f 90       	pop	r0
    4da6:	df 91       	pop	r29
    4da8:	cf 91       	pop	r28
    4daa:	08 95       	ret

00004dac <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4dac:	cf 93       	push	r28
    4dae:	df 93       	push	r29
    4db0:	00 d0       	rcall	.+0      	; 0x4db2 <vTaskPlaceOnEventList+0x6>
    4db2:	00 d0       	rcall	.+0      	; 0x4db4 <vTaskPlaceOnEventList+0x8>
    4db4:	cd b7       	in	r28, 0x3d	; 61
    4db6:	de b7       	in	r29, 0x3e	; 62
    4db8:	9a 83       	std	Y+2, r25	; 0x02
    4dba:	89 83       	std	Y+1, r24	; 0x01
    4dbc:	7c 83       	std	Y+4, r23	; 0x04
    4dbe:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4dc0:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4dc4:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4dc8:	9c 01       	movw	r18, r24
    4dca:	24 5f       	subi	r18, 0xF4	; 244
    4dcc:	3f 4f       	sbci	r19, 0xFF	; 255
    4dce:	89 81       	ldd	r24, Y+1	; 0x01
    4dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    4dd2:	b9 01       	movw	r22, r18
    4dd4:	0e 94 80 13 	call	0x2700	; 0x2700 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4dd8:	8b 81       	ldd	r24, Y+3	; 0x03
    4dda:	9c 81       	ldd	r25, Y+4	; 0x04
    4ddc:	61 e0       	ldi	r22, 0x01	; 1
    4dde:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <prvAddCurrentTaskToDelayedList>
}
    4de2:	00 00       	nop
    4de4:	0f 90       	pop	r0
    4de6:	0f 90       	pop	r0
    4de8:	0f 90       	pop	r0
    4dea:	0f 90       	pop	r0
    4dec:	df 91       	pop	r29
    4dee:	cf 91       	pop	r28
    4df0:	08 95       	ret

00004df2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4df2:	cf 93       	push	r28
    4df4:	df 93       	push	r29
    4df6:	00 d0       	rcall	.+0      	; 0x4df8 <vTaskPlaceOnUnorderedEventList+0x6>
    4df8:	00 d0       	rcall	.+0      	; 0x4dfa <vTaskPlaceOnUnorderedEventList+0x8>
    4dfa:	00 d0       	rcall	.+0      	; 0x4dfc <vTaskPlaceOnUnorderedEventList+0xa>
    4dfc:	cd b7       	in	r28, 0x3d	; 61
    4dfe:	de b7       	in	r29, 0x3e	; 62
    4e00:	9a 83       	std	Y+2, r25	; 0x02
    4e02:	89 83       	std	Y+1, r24	; 0x01
    4e04:	7c 83       	std	Y+4, r23	; 0x04
    4e06:	6b 83       	std	Y+3, r22	; 0x03
    4e08:	5e 83       	std	Y+6, r21	; 0x06
    4e0a:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4e0c:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4e10:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4e14:	2b 81       	ldd	r18, Y+3	; 0x03
    4e16:	3c 81       	ldd	r19, Y+4	; 0x04
    4e18:	30 68       	ori	r19, 0x80	; 128
    4e1a:	fc 01       	movw	r30, r24
    4e1c:	35 87       	std	Z+13, r19	; 0x0d
    4e1e:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4e20:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4e24:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4e28:	9c 01       	movw	r18, r24
    4e2a:	24 5f       	subi	r18, 0xF4	; 244
    4e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    4e2e:	89 81       	ldd	r24, Y+1	; 0x01
    4e30:	9a 81       	ldd	r25, Y+2	; 0x02
    4e32:	b9 01       	movw	r22, r18
    4e34:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e38:	8d 81       	ldd	r24, Y+5	; 0x05
    4e3a:	9e 81       	ldd	r25, Y+6	; 0x06
    4e3c:	61 e0       	ldi	r22, 0x01	; 1
    4e3e:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <prvAddCurrentTaskToDelayedList>
}
    4e42:	00 00       	nop
    4e44:	26 96       	adiw	r28, 0x06	; 6
    4e46:	0f b6       	in	r0, 0x3f	; 63
    4e48:	f8 94       	cli
    4e4a:	de bf       	out	0x3e, r29	; 62
    4e4c:	0f be       	out	0x3f, r0	; 63
    4e4e:	cd bf       	out	0x3d, r28	; 61
    4e50:	df 91       	pop	r29
    4e52:	cf 91       	pop	r28
    4e54:	08 95       	ret

00004e56 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4e56:	cf 93       	push	r28
    4e58:	df 93       	push	r29
    4e5a:	00 d0       	rcall	.+0      	; 0x4e5c <xTaskRemoveFromEventList+0x6>
    4e5c:	00 d0       	rcall	.+0      	; 0x4e5e <xTaskRemoveFromEventList+0x8>
    4e5e:	1f 92       	push	r1
    4e60:	cd b7       	in	r28, 0x3d	; 61
    4e62:	de b7       	in	r29, 0x3e	; 62
    4e64:	9d 83       	std	Y+5, r25	; 0x05
    4e66:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4e68:	8c 81       	ldd	r24, Y+4	; 0x04
    4e6a:	9d 81       	ldd	r25, Y+5	; 0x05
    4e6c:	fc 01       	movw	r30, r24
    4e6e:	85 81       	ldd	r24, Z+5	; 0x05
    4e70:	96 81       	ldd	r25, Z+6	; 0x06
    4e72:	fc 01       	movw	r30, r24
    4e74:	86 81       	ldd	r24, Z+6	; 0x06
    4e76:	97 81       	ldd	r25, Z+7	; 0x07
    4e78:	9b 83       	std	Y+3, r25	; 0x03
    4e7a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4e80:	0c 96       	adiw	r24, 0x0c	; 12
    4e82:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4e86:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    4e8a:	88 23       	and	r24, r24
    4e8c:	69 f5       	brne	.+90     	; 0x4ee8 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e90:	9b 81       	ldd	r25, Y+3	; 0x03
    4e92:	02 96       	adiw	r24, 0x02	; 2
    4e94:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4e98:	8a 81       	ldd	r24, Y+2	; 0x02
    4e9a:	9b 81       	ldd	r25, Y+3	; 0x03
    4e9c:	fc 01       	movw	r30, r24
    4e9e:	96 89       	ldd	r25, Z+22	; 0x16
    4ea0:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    4ea4:	89 17       	cp	r24, r25
    4ea6:	30 f4       	brcc	.+12     	; 0x4eb4 <xTaskRemoveFromEventList+0x5e>
    4ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eaa:	9b 81       	ldd	r25, Y+3	; 0x03
    4eac:	fc 01       	movw	r30, r24
    4eae:	86 89       	ldd	r24, Z+22	; 0x16
    4eb0:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    4eb4:	8a 81       	ldd	r24, Y+2	; 0x02
    4eb6:	9b 81       	ldd	r25, Y+3	; 0x03
    4eb8:	ac 01       	movw	r20, r24
    4eba:	4e 5f       	subi	r20, 0xFE	; 254
    4ebc:	5f 4f       	sbci	r21, 0xFF	; 255
    4ebe:	8a 81       	ldd	r24, Y+2	; 0x02
    4ec0:	9b 81       	ldd	r25, Y+3	; 0x03
    4ec2:	fc 01       	movw	r30, r24
    4ec4:	86 89       	ldd	r24, Z+22	; 0x16
    4ec6:	28 2f       	mov	r18, r24
    4ec8:	30 e0       	ldi	r19, 0x00	; 0
    4eca:	c9 01       	movw	r24, r18
    4ecc:	88 0f       	add	r24, r24
    4ece:	99 1f       	adc	r25, r25
    4ed0:	88 0f       	add	r24, r24
    4ed2:	99 1f       	adc	r25, r25
    4ed4:	88 0f       	add	r24, r24
    4ed6:	99 1f       	adc	r25, r25
    4ed8:	82 0f       	add	r24, r18
    4eda:	93 1f       	adc	r25, r19
    4edc:	87 54       	subi	r24, 0x47	; 71
    4ede:	99 4f       	sbci	r25, 0xF9	; 249
    4ee0:	ba 01       	movw	r22, r20
    4ee2:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
    4ee6:	08 c0       	rjmp	.+16     	; 0x4ef8 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eea:	9b 81       	ldd	r25, Y+3	; 0x03
    4eec:	0c 96       	adiw	r24, 0x0c	; 12
    4eee:	bc 01       	movw	r22, r24
    4ef0:	8c ef       	ldi	r24, 0xFC	; 252
    4ef2:	96 e0       	ldi	r25, 0x06	; 6
    4ef4:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    4efa:	9b 81       	ldd	r25, Y+3	; 0x03
    4efc:	fc 01       	movw	r30, r24
    4efe:	26 89       	ldd	r18, Z+22	; 0x16
    4f00:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4f04:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4f08:	fc 01       	movw	r30, r24
    4f0a:	86 89       	ldd	r24, Z+22	; 0x16
    4f0c:	82 17       	cp	r24, r18
    4f0e:	30 f4       	brcc	.+12     	; 0x4f1c <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4f10:	81 e0       	ldi	r24, 0x01	; 1
    4f12:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4f14:	81 e0       	ldi	r24, 0x01	; 1
    4f16:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
    4f1a:	01 c0       	rjmp	.+2      	; 0x4f1e <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    4f1c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4f1e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f20:	0f 90       	pop	r0
    4f22:	0f 90       	pop	r0
    4f24:	0f 90       	pop	r0
    4f26:	0f 90       	pop	r0
    4f28:	0f 90       	pop	r0
    4f2a:	df 91       	pop	r29
    4f2c:	cf 91       	pop	r28
    4f2e:	08 95       	ret

00004f30 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4f30:	cf 93       	push	r28
    4f32:	df 93       	push	r29
    4f34:	00 d0       	rcall	.+0      	; 0x4f36 <vTaskRemoveFromUnorderedEventList+0x6>
    4f36:	00 d0       	rcall	.+0      	; 0x4f38 <vTaskRemoveFromUnorderedEventList+0x8>
    4f38:	00 d0       	rcall	.+0      	; 0x4f3a <vTaskRemoveFromUnorderedEventList+0xa>
    4f3a:	cd b7       	in	r28, 0x3d	; 61
    4f3c:	de b7       	in	r29, 0x3e	; 62
    4f3e:	9c 83       	std	Y+4, r25	; 0x04
    4f40:	8b 83       	std	Y+3, r24	; 0x03
    4f42:	7e 83       	std	Y+6, r23	; 0x06
    4f44:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4f46:	8d 81       	ldd	r24, Y+5	; 0x05
    4f48:	9e 81       	ldd	r25, Y+6	; 0x06
    4f4a:	9c 01       	movw	r18, r24
    4f4c:	30 68       	ori	r19, 0x80	; 128
    4f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f50:	9c 81       	ldd	r25, Y+4	; 0x04
    4f52:	fc 01       	movw	r30, r24
    4f54:	31 83       	std	Z+1, r19	; 0x01
    4f56:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4f58:	8b 81       	ldd	r24, Y+3	; 0x03
    4f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f5c:	fc 01       	movw	r30, r24
    4f5e:	86 81       	ldd	r24, Z+6	; 0x06
    4f60:	97 81       	ldd	r25, Z+7	; 0x07
    4f62:	9a 83       	std	Y+2, r25	; 0x02
    4f64:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4f66:	8b 81       	ldd	r24, Y+3	; 0x03
    4f68:	9c 81       	ldd	r25, Y+4	; 0x04
    4f6a:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4f6e:	89 81       	ldd	r24, Y+1	; 0x01
    4f70:	9a 81       	ldd	r25, Y+2	; 0x02
    4f72:	02 96       	adiw	r24, 0x02	; 2
    4f74:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4f78:	89 81       	ldd	r24, Y+1	; 0x01
    4f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	96 89       	ldd	r25, Z+22	; 0x16
    4f80:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    4f84:	89 17       	cp	r24, r25
    4f86:	30 f4       	brcc	.+12     	; 0x4f94 <vTaskRemoveFromUnorderedEventList+0x64>
    4f88:	89 81       	ldd	r24, Y+1	; 0x01
    4f8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f8c:	fc 01       	movw	r30, r24
    4f8e:	86 89       	ldd	r24, Z+22	; 0x16
    4f90:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    4f94:	89 81       	ldd	r24, Y+1	; 0x01
    4f96:	9a 81       	ldd	r25, Y+2	; 0x02
    4f98:	ac 01       	movw	r20, r24
    4f9a:	4e 5f       	subi	r20, 0xFE	; 254
    4f9c:	5f 4f       	sbci	r21, 0xFF	; 255
    4f9e:	89 81       	ldd	r24, Y+1	; 0x01
    4fa0:	9a 81       	ldd	r25, Y+2	; 0x02
    4fa2:	fc 01       	movw	r30, r24
    4fa4:	86 89       	ldd	r24, Z+22	; 0x16
    4fa6:	28 2f       	mov	r18, r24
    4fa8:	30 e0       	ldi	r19, 0x00	; 0
    4faa:	c9 01       	movw	r24, r18
    4fac:	88 0f       	add	r24, r24
    4fae:	99 1f       	adc	r25, r25
    4fb0:	88 0f       	add	r24, r24
    4fb2:	99 1f       	adc	r25, r25
    4fb4:	88 0f       	add	r24, r24
    4fb6:	99 1f       	adc	r25, r25
    4fb8:	82 0f       	add	r24, r18
    4fba:	93 1f       	adc	r25, r19
    4fbc:	87 54       	subi	r24, 0x47	; 71
    4fbe:	99 4f       	sbci	r25, 0xF9	; 249
    4fc0:	ba 01       	movw	r22, r20
    4fc2:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fc6:	89 81       	ldd	r24, Y+1	; 0x01
    4fc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fca:	fc 01       	movw	r30, r24
    4fcc:	26 89       	ldd	r18, Z+22	; 0x16
    4fce:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    4fd2:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    4fd6:	fc 01       	movw	r30, r24
    4fd8:	86 89       	ldd	r24, Z+22	; 0x16
    4fda:	82 17       	cp	r24, r18
    4fdc:	18 f4       	brcc	.+6      	; 0x4fe4 <vTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4fde:	81 e0       	ldi	r24, 0x01	; 1
    4fe0:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
	}
}
    4fe4:	00 00       	nop
    4fe6:	26 96       	adiw	r28, 0x06	; 6
    4fe8:	0f b6       	in	r0, 0x3f	; 63
    4fea:	f8 94       	cli
    4fec:	de bf       	out	0x3e, r29	; 62
    4fee:	0f be       	out	0x3f, r0	; 63
    4ff0:	cd bf       	out	0x3d, r28	; 61
    4ff2:	df 91       	pop	r29
    4ff4:	cf 91       	pop	r28
    4ff6:	08 95       	ret

00004ff8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4ff8:	cf 93       	push	r28
    4ffa:	df 93       	push	r29
    4ffc:	00 d0       	rcall	.+0      	; 0x4ffe <vTaskSetTimeOutState+0x6>
    4ffe:	cd b7       	in	r28, 0x3d	; 61
    5000:	de b7       	in	r29, 0x3e	; 62
    5002:	9a 83       	std	Y+2, r25	; 0x02
    5004:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5006:	0f b6       	in	r0, 0x3f	; 63
    5008:	f8 94       	cli
    500a:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    500c:	20 91 1f 07 	lds	r18, 0x071F	; 0x80071f <xNumOfOverflows>
    5010:	89 81       	ldd	r24, Y+1	; 0x01
    5012:	9a 81       	ldd	r25, Y+2	; 0x02
    5014:	fc 01       	movw	r30, r24
    5016:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    5018:	20 91 19 07 	lds	r18, 0x0719	; 0x800719 <xTickCount>
    501c:	30 91 1a 07 	lds	r19, 0x071A	; 0x80071a <xTickCount+0x1>
    5020:	89 81       	ldd	r24, Y+1	; 0x01
    5022:	9a 81       	ldd	r25, Y+2	; 0x02
    5024:	fc 01       	movw	r30, r24
    5026:	32 83       	std	Z+2, r19	; 0x02
    5028:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    502a:	0f 90       	pop	r0
    502c:	0f be       	out	0x3f, r0	; 63
}
    502e:	00 00       	nop
    5030:	0f 90       	pop	r0
    5032:	0f 90       	pop	r0
    5034:	df 91       	pop	r29
    5036:	cf 91       	pop	r28
    5038:	08 95       	ret

0000503a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    503a:	cf 93       	push	r28
    503c:	df 93       	push	r29
    503e:	00 d0       	rcall	.+0      	; 0x5040 <vTaskInternalSetTimeOutState+0x6>
    5040:	cd b7       	in	r28, 0x3d	; 61
    5042:	de b7       	in	r29, 0x3e	; 62
    5044:	9a 83       	std	Y+2, r25	; 0x02
    5046:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5048:	20 91 1f 07 	lds	r18, 0x071F	; 0x80071f <xNumOfOverflows>
    504c:	89 81       	ldd	r24, Y+1	; 0x01
    504e:	9a 81       	ldd	r25, Y+2	; 0x02
    5050:	fc 01       	movw	r30, r24
    5052:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    5054:	20 91 19 07 	lds	r18, 0x0719	; 0x800719 <xTickCount>
    5058:	30 91 1a 07 	lds	r19, 0x071A	; 0x80071a <xTickCount+0x1>
    505c:	89 81       	ldd	r24, Y+1	; 0x01
    505e:	9a 81       	ldd	r25, Y+2	; 0x02
    5060:	fc 01       	movw	r30, r24
    5062:	32 83       	std	Z+2, r19	; 0x02
    5064:	21 83       	std	Z+1, r18	; 0x01
}
    5066:	00 00       	nop
    5068:	0f 90       	pop	r0
    506a:	0f 90       	pop	r0
    506c:	df 91       	pop	r29
    506e:	cf 91       	pop	r28
    5070:	08 95       	ret

00005072 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5072:	cf 93       	push	r28
    5074:	df 93       	push	r29
    5076:	cd b7       	in	r28, 0x3d	; 61
    5078:	de b7       	in	r29, 0x3e	; 62
    507a:	29 97       	sbiw	r28, 0x09	; 9
    507c:	0f b6       	in	r0, 0x3f	; 63
    507e:	f8 94       	cli
    5080:	de bf       	out	0x3e, r29	; 62
    5082:	0f be       	out	0x3f, r0	; 63
    5084:	cd bf       	out	0x3d, r28	; 61
    5086:	9f 83       	std	Y+7, r25	; 0x07
    5088:	8e 83       	std	Y+6, r24	; 0x06
    508a:	79 87       	std	Y+9, r23	; 0x09
    508c:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    508e:	0f b6       	in	r0, 0x3f	; 63
    5090:	f8 94       	cli
    5092:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5094:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <xTickCount>
    5098:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <xTickCount+0x1>
    509c:	9b 83       	std	Y+3, r25	; 0x03
    509e:	8a 83       	std	Y+2, r24	; 0x02
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    50a0:	8e 81       	ldd	r24, Y+6	; 0x06
    50a2:	9f 81       	ldd	r25, Y+7	; 0x07
    50a4:	fc 01       	movw	r30, r24
    50a6:	81 81       	ldd	r24, Z+1	; 0x01
    50a8:	92 81       	ldd	r25, Z+2	; 0x02
    50aa:	2a 81       	ldd	r18, Y+2	; 0x02
    50ac:	3b 81       	ldd	r19, Y+3	; 0x03
    50ae:	a9 01       	movw	r20, r18
    50b0:	48 1b       	sub	r20, r24
    50b2:	59 0b       	sbc	r21, r25
    50b4:	ca 01       	movw	r24, r20
    50b6:	9d 83       	std	Y+5, r25	; 0x05
    50b8:	8c 83       	std	Y+4, r24	; 0x04
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    50ba:	88 85       	ldd	r24, Y+8	; 0x08
    50bc:	99 85       	ldd	r25, Y+9	; 0x09
    50be:	fc 01       	movw	r30, r24
    50c0:	80 81       	ld	r24, Z
    50c2:	91 81       	ldd	r25, Z+1	; 0x01
    50c4:	01 96       	adiw	r24, 0x01	; 1
    50c6:	11 f4       	brne	.+4      	; 0x50cc <xTaskCheckForTimeOut+0x5a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    50c8:	19 82       	std	Y+1, r1	; 0x01
    50ca:	3a c0       	rjmp	.+116    	; 0x5140 <xTaskCheckForTimeOut+0xce>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    50cc:	8e 81       	ldd	r24, Y+6	; 0x06
    50ce:	9f 81       	ldd	r25, Y+7	; 0x07
    50d0:	fc 01       	movw	r30, r24
    50d2:	90 81       	ld	r25, Z
    50d4:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <xNumOfOverflows>
    50d8:	98 17       	cp	r25, r24
    50da:	69 f0       	breq	.+26     	; 0x50f6 <xTaskCheckForTimeOut+0x84>
    50dc:	8e 81       	ldd	r24, Y+6	; 0x06
    50de:	9f 81       	ldd	r25, Y+7	; 0x07
    50e0:	fc 01       	movw	r30, r24
    50e2:	21 81       	ldd	r18, Z+1	; 0x01
    50e4:	32 81       	ldd	r19, Z+2	; 0x02
    50e6:	8a 81       	ldd	r24, Y+2	; 0x02
    50e8:	9b 81       	ldd	r25, Y+3	; 0x03
    50ea:	82 17       	cp	r24, r18
    50ec:	93 07       	cpc	r25, r19
    50ee:	18 f0       	brcs	.+6      	; 0x50f6 <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    50f0:	81 e0       	ldi	r24, 0x01	; 1
    50f2:	89 83       	std	Y+1, r24	; 0x01
    50f4:	25 c0       	rjmp	.+74     	; 0x5140 <xTaskCheckForTimeOut+0xce>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    50f6:	88 85       	ldd	r24, Y+8	; 0x08
    50f8:	99 85       	ldd	r25, Y+9	; 0x09
    50fa:	fc 01       	movw	r30, r24
    50fc:	20 81       	ld	r18, Z
    50fe:	31 81       	ldd	r19, Z+1	; 0x01
    5100:	8c 81       	ldd	r24, Y+4	; 0x04
    5102:	9d 81       	ldd	r25, Y+5	; 0x05
    5104:	82 17       	cp	r24, r18
    5106:	93 07       	cpc	r25, r19
    5108:	a0 f4       	brcc	.+40     	; 0x5132 <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    510a:	88 85       	ldd	r24, Y+8	; 0x08
    510c:	99 85       	ldd	r25, Y+9	; 0x09
    510e:	fc 01       	movw	r30, r24
    5110:	20 81       	ld	r18, Z
    5112:	31 81       	ldd	r19, Z+1	; 0x01
    5114:	8c 81       	ldd	r24, Y+4	; 0x04
    5116:	9d 81       	ldd	r25, Y+5	; 0x05
    5118:	28 1b       	sub	r18, r24
    511a:	39 0b       	sbc	r19, r25
    511c:	88 85       	ldd	r24, Y+8	; 0x08
    511e:	99 85       	ldd	r25, Y+9	; 0x09
    5120:	fc 01       	movw	r30, r24
    5122:	31 83       	std	Z+1, r19	; 0x01
    5124:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    5126:	8e 81       	ldd	r24, Y+6	; 0x06
    5128:	9f 81       	ldd	r25, Y+7	; 0x07
    512a:	0e 94 1d 28 	call	0x503a	; 0x503a <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    512e:	19 82       	std	Y+1, r1	; 0x01
    5130:	07 c0       	rjmp	.+14     	; 0x5140 <xTaskCheckForTimeOut+0xce>
		}
		else
		{
			*pxTicksToWait = 0;
    5132:	88 85       	ldd	r24, Y+8	; 0x08
    5134:	99 85       	ldd	r25, Y+9	; 0x09
    5136:	fc 01       	movw	r30, r24
    5138:	11 82       	std	Z+1, r1	; 0x01
    513a:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    513c:	81 e0       	ldi	r24, 0x01	; 1
    513e:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    5140:	0f 90       	pop	r0
    5142:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5144:	89 81       	ldd	r24, Y+1	; 0x01
}
    5146:	29 96       	adiw	r28, 0x09	; 9
    5148:	0f b6       	in	r0, 0x3f	; 63
    514a:	f8 94       	cli
    514c:	de bf       	out	0x3e, r29	; 62
    514e:	0f be       	out	0x3f, r0	; 63
    5150:	cd bf       	out	0x3d, r28	; 61
    5152:	df 91       	pop	r29
    5154:	cf 91       	pop	r28
    5156:	08 95       	ret

00005158 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5158:	cf 93       	push	r28
    515a:	df 93       	push	r29
    515c:	cd b7       	in	r28, 0x3d	; 61
    515e:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5160:	81 e0       	ldi	r24, 0x01	; 1
    5162:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
}
    5166:	00 00       	nop
    5168:	df 91       	pop	r29
    516a:	cf 91       	pop	r28
    516c:	08 95       	ret

0000516e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    516e:	cf 93       	push	r28
    5170:	df 93       	push	r29
    5172:	00 d0       	rcall	.+0      	; 0x5174 <prvIdleTask+0x6>
    5174:	cd b7       	in	r28, 0x3d	; 61
    5176:	de b7       	in	r29, 0x3e	; 62
    5178:	9a 83       	std	Y+2, r25	; 0x02
    517a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    517c:	0e 94 09 29 	call	0x5212	; 0x5212 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5180:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <pxReadyTasksLists>
    5184:	82 30       	cpi	r24, 0x02	; 2
    5186:	d0 f3       	brcs	.-12     	; 0x517c <prvIdleTask+0xe>
			{
				taskYIELD();
    5188:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    518c:	f7 cf       	rjmp	.-18     	; 0x517c <prvIdleTask+0xe>

0000518e <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    518e:	cf 93       	push	r28
    5190:	df 93       	push	r29
    5192:	1f 92       	push	r1
    5194:	cd b7       	in	r28, 0x3d	; 61
    5196:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5198:	19 82       	std	Y+1, r1	; 0x01
    519a:	13 c0       	rjmp	.+38     	; 0x51c2 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    519c:	89 81       	ldd	r24, Y+1	; 0x01
    519e:	28 2f       	mov	r18, r24
    51a0:	30 e0       	ldi	r19, 0x00	; 0
    51a2:	c9 01       	movw	r24, r18
    51a4:	88 0f       	add	r24, r24
    51a6:	99 1f       	adc	r25, r25
    51a8:	88 0f       	add	r24, r24
    51aa:	99 1f       	adc	r25, r25
    51ac:	88 0f       	add	r24, r24
    51ae:	99 1f       	adc	r25, r25
    51b0:	82 0f       	add	r24, r18
    51b2:	93 1f       	adc	r25, r19
    51b4:	87 54       	subi	r24, 0x47	; 71
    51b6:	99 4f       	sbci	r25, 0xF9	; 249
    51b8:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    51bc:	89 81       	ldd	r24, Y+1	; 0x01
    51be:	8f 5f       	subi	r24, 0xFF	; 255
    51c0:	89 83       	std	Y+1, r24	; 0x01
    51c2:	89 81       	ldd	r24, Y+1	; 0x01
    51c4:	85 30       	cpi	r24, 0x05	; 5
    51c6:	50 f3       	brcs	.-44     	; 0x519c <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    51c8:	86 ee       	ldi	r24, 0xE6	; 230
    51ca:	96 e0       	ldi	r25, 0x06	; 6
    51cc:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    51d0:	8f ee       	ldi	r24, 0xEF	; 239
    51d2:	96 e0       	ldi	r25, 0x06	; 6
    51d4:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    51d8:	8c ef       	ldi	r24, 0xFC	; 252
    51da:	96 e0       	ldi	r25, 0x06	; 6
    51dc:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    51e0:	85 e0       	ldi	r24, 0x05	; 5
    51e2:	97 e0       	ldi	r25, 0x07	; 7
    51e4:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    51e8:	8f e0       	ldi	r24, 0x0F	; 15
    51ea:	97 e0       	ldi	r25, 0x07	; 7
    51ec:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    51f0:	86 ee       	ldi	r24, 0xE6	; 230
    51f2:	96 e0       	ldi	r25, 0x06	; 6
    51f4:	90 93 f9 06 	sts	0x06F9, r25	; 0x8006f9 <pxDelayedTaskList+0x1>
    51f8:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    51fc:	8f ee       	ldi	r24, 0xEF	; 239
    51fe:	96 e0       	ldi	r25, 0x06	; 6
    5200:	90 93 fb 06 	sts	0x06FB, r25	; 0x8006fb <pxOverflowDelayedTaskList+0x1>
    5204:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <pxOverflowDelayedTaskList>
}
    5208:	00 00       	nop
    520a:	0f 90       	pop	r0
    520c:	df 91       	pop	r29
    520e:	cf 91       	pop	r28
    5210:	08 95       	ret

00005212 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5212:	cf 93       	push	r28
    5214:	df 93       	push	r29
    5216:	00 d0       	rcall	.+0      	; 0x5218 <prvCheckTasksWaitingTermination+0x6>
    5218:	cd b7       	in	r28, 0x3d	; 61
    521a:	de b7       	in	r29, 0x3e	; 62
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    521c:	21 c0       	rjmp	.+66     	; 0x5260 <prvCheckTasksWaitingTermination+0x4e>
		{
			taskENTER_CRITICAL();
    521e:	0f b6       	in	r0, 0x3f	; 63
    5220:	f8 94       	cli
    5222:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5224:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTasksWaitingTermination+0x5>
    5228:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTasksWaitingTermination+0x6>
    522c:	fc 01       	movw	r30, r24
    522e:	86 81       	ldd	r24, Z+6	; 0x06
    5230:	97 81       	ldd	r25, Z+7	; 0x07
    5232:	9a 83       	std	Y+2, r25	; 0x02
    5234:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5236:	89 81       	ldd	r24, Y+1	; 0x01
    5238:	9a 81       	ldd	r25, Y+2	; 0x02
    523a:	02 96       	adiw	r24, 0x02	; 2
    523c:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
				--uxCurrentNumberOfTasks;
    5240:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <uxCurrentNumberOfTasks>
    5244:	81 50       	subi	r24, 0x01	; 1
    5246:	80 93 18 07 	sts	0x0718, r24	; 0x800718 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
    524a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxDeletedTasksWaitingCleanUp>
    524e:	81 50       	subi	r24, 0x01	; 1
    5250:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
    5254:	0f 90       	pop	r0
    5256:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    5258:	89 81       	ldd	r24, Y+1	; 0x01
    525a:	9a 81       	ldd	r25, Y+2	; 0x02
    525c:	0e 94 3a 29 	call	0x5274	; 0x5274 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5260:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxDeletedTasksWaitingCleanUp>
    5264:	88 23       	and	r24, r24
    5266:	d9 f6       	brne	.-74     	; 0x521e <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5268:	00 00       	nop
    526a:	0f 90       	pop	r0
    526c:	0f 90       	pop	r0
    526e:	df 91       	pop	r29
    5270:	cf 91       	pop	r28
    5272:	08 95       	ret

00005274 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5274:	cf 93       	push	r28
    5276:	df 93       	push	r29
    5278:	00 d0       	rcall	.+0      	; 0x527a <prvDeleteTCB+0x6>
    527a:	cd b7       	in	r28, 0x3d	; 61
    527c:	de b7       	in	r29, 0x3e	; 62
    527e:	9a 83       	std	Y+2, r25	; 0x02
    5280:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5282:	89 81       	ldd	r24, Y+1	; 0x01
    5284:	9a 81       	ldd	r25, Y+2	; 0x02
    5286:	fc 01       	movw	r30, r24
    5288:	87 89       	ldd	r24, Z+23	; 0x17
    528a:	90 8d       	ldd	r25, Z+24	; 0x18
    528c:	0e 94 bf 12 	call	0x257e	; 0x257e <vPortFree>
			vPortFree( pxTCB );
    5290:	89 81       	ldd	r24, Y+1	; 0x01
    5292:	9a 81       	ldd	r25, Y+2	; 0x02
    5294:	0e 94 bf 12 	call	0x257e	; 0x257e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5298:	00 00       	nop
    529a:	0f 90       	pop	r0
    529c:	0f 90       	pop	r0
    529e:	df 91       	pop	r29
    52a0:	cf 91       	pop	r28
    52a2:	08 95       	ret

000052a4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    52a4:	cf 93       	push	r28
    52a6:	df 93       	push	r29
    52a8:	00 d0       	rcall	.+0      	; 0x52aa <prvResetNextTaskUnblockTime+0x6>
    52aa:	cd b7       	in	r28, 0x3d	; 61
    52ac:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    52ae:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    52b2:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    52b6:	fc 01       	movw	r30, r24
    52b8:	80 81       	ld	r24, Z
    52ba:	88 23       	and	r24, r24
    52bc:	39 f4       	brne	.+14     	; 0x52cc <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    52be:	8f ef       	ldi	r24, 0xFF	; 255
    52c0:	9f ef       	ldi	r25, 0xFF	; 255
    52c2:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <xNextTaskUnblockTime+0x1>
    52c6:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xNextTaskUnblockTime>
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
    52ca:	15 c0       	rjmp	.+42     	; 0x52f6 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    52cc:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    52d0:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    52d4:	fc 01       	movw	r30, r24
    52d6:	85 81       	ldd	r24, Z+5	; 0x05
    52d8:	96 81       	ldd	r25, Z+6	; 0x06
    52da:	fc 01       	movw	r30, r24
    52dc:	86 81       	ldd	r24, Z+6	; 0x06
    52de:	97 81       	ldd	r25, Z+7	; 0x07
    52e0:	9a 83       	std	Y+2, r25	; 0x02
    52e2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    52e4:	89 81       	ldd	r24, Y+1	; 0x01
    52e6:	9a 81       	ldd	r25, Y+2	; 0x02
    52e8:	fc 01       	movw	r30, r24
    52ea:	82 81       	ldd	r24, Z+2	; 0x02
    52ec:	93 81       	ldd	r25, Z+3	; 0x03
    52ee:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <xNextTaskUnblockTime+0x1>
    52f2:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xNextTaskUnblockTime>
	}
}
    52f6:	00 00       	nop
    52f8:	0f 90       	pop	r0
    52fa:	0f 90       	pop	r0
    52fc:	df 91       	pop	r29
    52fe:	cf 91       	pop	r28
    5300:	08 95       	ret

00005302 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5302:	cf 93       	push	r28
    5304:	df 93       	push	r29
    5306:	00 d0       	rcall	.+0      	; 0x5308 <xTaskGetCurrentTaskHandle+0x6>
    5308:	cd b7       	in	r28, 0x3d	; 61
    530a:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    530c:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5310:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5314:	9a 83       	std	Y+2, r25	; 0x02
    5316:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5318:	89 81       	ldd	r24, Y+1	; 0x01
    531a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    531c:	0f 90       	pop	r0
    531e:	0f 90       	pop	r0
    5320:	df 91       	pop	r29
    5322:	cf 91       	pop	r28
    5324:	08 95       	ret

00005326 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    5326:	cf 93       	push	r28
    5328:	df 93       	push	r29
    532a:	00 d0       	rcall	.+0      	; 0x532c <xTaskPriorityInherit+0x6>
    532c:	00 d0       	rcall	.+0      	; 0x532e <xTaskPriorityInherit+0x8>
    532e:	1f 92       	push	r1
    5330:	cd b7       	in	r28, 0x3d	; 61
    5332:	de b7       	in	r29, 0x3e	; 62
    5334:	9d 83       	std	Y+5, r25	; 0x05
    5336:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    5338:	8c 81       	ldd	r24, Y+4	; 0x04
    533a:	9d 81       	ldd	r25, Y+5	; 0x05
    533c:	9b 83       	std	Y+3, r25	; 0x03
    533e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    5340:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    5342:	8c 81       	ldd	r24, Y+4	; 0x04
    5344:	9d 81       	ldd	r25, Y+5	; 0x05
    5346:	89 2b       	or	r24, r25
    5348:	09 f4       	brne	.+2      	; 0x534c <xTaskPriorityInherit+0x26>
    534a:	90 c0       	rjmp	.+288    	; 0x546c <xTaskPriorityInherit+0x146>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    534c:	8a 81       	ldd	r24, Y+2	; 0x02
    534e:	9b 81       	ldd	r25, Y+3	; 0x03
    5350:	fc 01       	movw	r30, r24
    5352:	26 89       	ldd	r18, Z+22	; 0x16
    5354:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5358:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    535c:	fc 01       	movw	r30, r24
    535e:	86 89       	ldd	r24, Z+22	; 0x16
    5360:	28 17       	cp	r18, r24
    5362:	08 f0       	brcs	.+2      	; 0x5366 <xTaskPriorityInherit+0x40>
    5364:	75 c0       	rjmp	.+234    	; 0x5450 <xTaskPriorityInherit+0x12a>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    5366:	8a 81       	ldd	r24, Y+2	; 0x02
    5368:	9b 81       	ldd	r25, Y+3	; 0x03
    536a:	fc 01       	movw	r30, r24
    536c:	84 85       	ldd	r24, Z+12	; 0x0c
    536e:	95 85       	ldd	r25, Z+13	; 0x0d
    5370:	99 23       	and	r25, r25
    5372:	8c f0       	brlt	.+34     	; 0x5396 <xTaskPriorityInherit+0x70>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5374:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5378:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    537c:	fc 01       	movw	r30, r24
    537e:	86 89       	ldd	r24, Z+22	; 0x16
    5380:	88 2f       	mov	r24, r24
    5382:	90 e0       	ldi	r25, 0x00	; 0
    5384:	25 e0       	ldi	r18, 0x05	; 5
    5386:	30 e0       	ldi	r19, 0x00	; 0
    5388:	28 1b       	sub	r18, r24
    538a:	39 0b       	sbc	r19, r25
    538c:	8a 81       	ldd	r24, Y+2	; 0x02
    538e:	9b 81       	ldd	r25, Y+3	; 0x03
    5390:	fc 01       	movw	r30, r24
    5392:	35 87       	std	Z+13, r19	; 0x0d
    5394:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    5396:	8a 81       	ldd	r24, Y+2	; 0x02
    5398:	9b 81       	ldd	r25, Y+3	; 0x03
    539a:	fc 01       	movw	r30, r24
    539c:	42 85       	ldd	r20, Z+10	; 0x0a
    539e:	53 85       	ldd	r21, Z+11	; 0x0b
    53a0:	8a 81       	ldd	r24, Y+2	; 0x02
    53a2:	9b 81       	ldd	r25, Y+3	; 0x03
    53a4:	fc 01       	movw	r30, r24
    53a6:	86 89       	ldd	r24, Z+22	; 0x16
    53a8:	28 2f       	mov	r18, r24
    53aa:	30 e0       	ldi	r19, 0x00	; 0
    53ac:	c9 01       	movw	r24, r18
    53ae:	88 0f       	add	r24, r24
    53b0:	99 1f       	adc	r25, r25
    53b2:	88 0f       	add	r24, r24
    53b4:	99 1f       	adc	r25, r25
    53b6:	88 0f       	add	r24, r24
    53b8:	99 1f       	adc	r25, r25
    53ba:	82 0f       	add	r24, r18
    53bc:	93 1f       	adc	r25, r19
    53be:	87 54       	subi	r24, 0x47	; 71
    53c0:	99 4f       	sbci	r25, 0xF9	; 249
    53c2:	48 17       	cp	r20, r24
    53c4:	59 07       	cpc	r21, r25
    53c6:	b9 f5       	brne	.+110    	; 0x5436 <xTaskPriorityInherit+0x110>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    53c8:	8a 81       	ldd	r24, Y+2	; 0x02
    53ca:	9b 81       	ldd	r25, Y+3	; 0x03
    53cc:	02 96       	adiw	r24, 0x02	; 2
    53ce:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    53d2:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    53d6:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    53da:	fc 01       	movw	r30, r24
    53dc:	26 89       	ldd	r18, Z+22	; 0x16
    53de:	8a 81       	ldd	r24, Y+2	; 0x02
    53e0:	9b 81       	ldd	r25, Y+3	; 0x03
    53e2:	fc 01       	movw	r30, r24
    53e4:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    53e6:	8a 81       	ldd	r24, Y+2	; 0x02
    53e8:	9b 81       	ldd	r25, Y+3	; 0x03
    53ea:	fc 01       	movw	r30, r24
    53ec:	96 89       	ldd	r25, Z+22	; 0x16
    53ee:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    53f2:	89 17       	cp	r24, r25
    53f4:	30 f4       	brcc	.+12     	; 0x5402 <xTaskPriorityInherit+0xdc>
    53f6:	8a 81       	ldd	r24, Y+2	; 0x02
    53f8:	9b 81       	ldd	r25, Y+3	; 0x03
    53fa:	fc 01       	movw	r30, r24
    53fc:	86 89       	ldd	r24, Z+22	; 0x16
    53fe:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    5402:	8a 81       	ldd	r24, Y+2	; 0x02
    5404:	9b 81       	ldd	r25, Y+3	; 0x03
    5406:	ac 01       	movw	r20, r24
    5408:	4e 5f       	subi	r20, 0xFE	; 254
    540a:	5f 4f       	sbci	r21, 0xFF	; 255
    540c:	8a 81       	ldd	r24, Y+2	; 0x02
    540e:	9b 81       	ldd	r25, Y+3	; 0x03
    5410:	fc 01       	movw	r30, r24
    5412:	86 89       	ldd	r24, Z+22	; 0x16
    5414:	28 2f       	mov	r18, r24
    5416:	30 e0       	ldi	r19, 0x00	; 0
    5418:	c9 01       	movw	r24, r18
    541a:	88 0f       	add	r24, r24
    541c:	99 1f       	adc	r25, r25
    541e:	88 0f       	add	r24, r24
    5420:	99 1f       	adc	r25, r25
    5422:	88 0f       	add	r24, r24
    5424:	99 1f       	adc	r25, r25
    5426:	82 0f       	add	r24, r18
    5428:	93 1f       	adc	r25, r19
    542a:	87 54       	subi	r24, 0x47	; 71
    542c:	99 4f       	sbci	r25, 0xF9	; 249
    542e:	ba 01       	movw	r22, r20
    5430:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
    5434:	0a c0       	rjmp	.+20     	; 0x544a <xTaskPriorityInherit+0x124>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    5436:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    543a:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    543e:	fc 01       	movw	r30, r24
    5440:	26 89       	ldd	r18, Z+22	; 0x16
    5442:	8a 81       	ldd	r24, Y+2	; 0x02
    5444:	9b 81       	ldd	r25, Y+3	; 0x03
    5446:	fc 01       	movw	r30, r24
    5448:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    544a:	81 e0       	ldi	r24, 0x01	; 1
    544c:	89 83       	std	Y+1, r24	; 0x01
    544e:	0e c0       	rjmp	.+28     	; 0x546c <xTaskPriorityInherit+0x146>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    5450:	8a 81       	ldd	r24, Y+2	; 0x02
    5452:	9b 81       	ldd	r25, Y+3	; 0x03
    5454:	fc 01       	movw	r30, r24
    5456:	21 a1       	ldd	r18, Z+33	; 0x21
    5458:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    545c:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5460:	fc 01       	movw	r30, r24
    5462:	86 89       	ldd	r24, Z+22	; 0x16
    5464:	28 17       	cp	r18, r24
    5466:	10 f4       	brcc	.+4      	; 0x546c <xTaskPriorityInherit+0x146>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    5468:	81 e0       	ldi	r24, 0x01	; 1
    546a:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    546c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    546e:	0f 90       	pop	r0
    5470:	0f 90       	pop	r0
    5472:	0f 90       	pop	r0
    5474:	0f 90       	pop	r0
    5476:	0f 90       	pop	r0
    5478:	df 91       	pop	r29
    547a:	cf 91       	pop	r28
    547c:	08 95       	ret

0000547e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    547e:	cf 93       	push	r28
    5480:	df 93       	push	r29
    5482:	00 d0       	rcall	.+0      	; 0x5484 <xTaskPriorityDisinherit+0x6>
    5484:	00 d0       	rcall	.+0      	; 0x5486 <xTaskPriorityDisinherit+0x8>
    5486:	1f 92       	push	r1
    5488:	cd b7       	in	r28, 0x3d	; 61
    548a:	de b7       	in	r29, 0x3e	; 62
    548c:	9d 83       	std	Y+5, r25	; 0x05
    548e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    5490:	8c 81       	ldd	r24, Y+4	; 0x04
    5492:	9d 81       	ldd	r25, Y+5	; 0x05
    5494:	9b 83       	std	Y+3, r25	; 0x03
    5496:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    5498:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    549a:	8c 81       	ldd	r24, Y+4	; 0x04
    549c:	9d 81       	ldd	r25, Y+5	; 0x05
    549e:	89 2b       	or	r24, r25
    54a0:	09 f4       	brne	.+2      	; 0x54a4 <xTaskPriorityDisinherit+0x26>
    54a2:	61 c0       	rjmp	.+194    	; 0x5566 <xTaskPriorityDisinherit+0xe8>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    54a4:	8a 81       	ldd	r24, Y+2	; 0x02
    54a6:	9b 81       	ldd	r25, Y+3	; 0x03
    54a8:	fc 01       	movw	r30, r24
    54aa:	82 a1       	ldd	r24, Z+34	; 0x22
    54ac:	2f ef       	ldi	r18, 0xFF	; 255
    54ae:	28 0f       	add	r18, r24
    54b0:	8a 81       	ldd	r24, Y+2	; 0x02
    54b2:	9b 81       	ldd	r25, Y+3	; 0x03
    54b4:	fc 01       	movw	r30, r24
    54b6:	22 a3       	std	Z+34, r18	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    54b8:	8a 81       	ldd	r24, Y+2	; 0x02
    54ba:	9b 81       	ldd	r25, Y+3	; 0x03
    54bc:	fc 01       	movw	r30, r24
    54be:	26 89       	ldd	r18, Z+22	; 0x16
    54c0:	8a 81       	ldd	r24, Y+2	; 0x02
    54c2:	9b 81       	ldd	r25, Y+3	; 0x03
    54c4:	fc 01       	movw	r30, r24
    54c6:	81 a1       	ldd	r24, Z+33	; 0x21
    54c8:	28 17       	cp	r18, r24
    54ca:	09 f4       	brne	.+2      	; 0x54ce <xTaskPriorityDisinherit+0x50>
    54cc:	4c c0       	rjmp	.+152    	; 0x5566 <xTaskPriorityDisinherit+0xe8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    54ce:	8a 81       	ldd	r24, Y+2	; 0x02
    54d0:	9b 81       	ldd	r25, Y+3	; 0x03
    54d2:	fc 01       	movw	r30, r24
    54d4:	82 a1       	ldd	r24, Z+34	; 0x22
    54d6:	88 23       	and	r24, r24
    54d8:	09 f0       	breq	.+2      	; 0x54dc <xTaskPriorityDisinherit+0x5e>
    54da:	45 c0       	rjmp	.+138    	; 0x5566 <xTaskPriorityDisinherit+0xe8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    54dc:	8a 81       	ldd	r24, Y+2	; 0x02
    54de:	9b 81       	ldd	r25, Y+3	; 0x03
    54e0:	02 96       	adiw	r24, 0x02	; 2
    54e2:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    54e6:	8a 81       	ldd	r24, Y+2	; 0x02
    54e8:	9b 81       	ldd	r25, Y+3	; 0x03
    54ea:	fc 01       	movw	r30, r24
    54ec:	21 a1       	ldd	r18, Z+33	; 0x21
    54ee:	8a 81       	ldd	r24, Y+2	; 0x02
    54f0:	9b 81       	ldd	r25, Y+3	; 0x03
    54f2:	fc 01       	movw	r30, r24
    54f4:	26 8b       	std	Z+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    54f6:	8a 81       	ldd	r24, Y+2	; 0x02
    54f8:	9b 81       	ldd	r25, Y+3	; 0x03
    54fa:	fc 01       	movw	r30, r24
    54fc:	86 89       	ldd	r24, Z+22	; 0x16
    54fe:	88 2f       	mov	r24, r24
    5500:	90 e0       	ldi	r25, 0x00	; 0
    5502:	25 e0       	ldi	r18, 0x05	; 5
    5504:	30 e0       	ldi	r19, 0x00	; 0
    5506:	28 1b       	sub	r18, r24
    5508:	39 0b       	sbc	r19, r25
    550a:	8a 81       	ldd	r24, Y+2	; 0x02
    550c:	9b 81       	ldd	r25, Y+3	; 0x03
    550e:	fc 01       	movw	r30, r24
    5510:	35 87       	std	Z+13, r19	; 0x0d
    5512:	24 87       	std	Z+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    5514:	8a 81       	ldd	r24, Y+2	; 0x02
    5516:	9b 81       	ldd	r25, Y+3	; 0x03
    5518:	fc 01       	movw	r30, r24
    551a:	96 89       	ldd	r25, Z+22	; 0x16
    551c:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    5520:	89 17       	cp	r24, r25
    5522:	30 f4       	brcc	.+12     	; 0x5530 <xTaskPriorityDisinherit+0xb2>
    5524:	8a 81       	ldd	r24, Y+2	; 0x02
    5526:	9b 81       	ldd	r25, Y+3	; 0x03
    5528:	fc 01       	movw	r30, r24
    552a:	86 89       	ldd	r24, Z+22	; 0x16
    552c:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    5530:	8a 81       	ldd	r24, Y+2	; 0x02
    5532:	9b 81       	ldd	r25, Y+3	; 0x03
    5534:	ac 01       	movw	r20, r24
    5536:	4e 5f       	subi	r20, 0xFE	; 254
    5538:	5f 4f       	sbci	r21, 0xFF	; 255
    553a:	8a 81       	ldd	r24, Y+2	; 0x02
    553c:	9b 81       	ldd	r25, Y+3	; 0x03
    553e:	fc 01       	movw	r30, r24
    5540:	86 89       	ldd	r24, Z+22	; 0x16
    5542:	28 2f       	mov	r18, r24
    5544:	30 e0       	ldi	r19, 0x00	; 0
    5546:	c9 01       	movw	r24, r18
    5548:	88 0f       	add	r24, r24
    554a:	99 1f       	adc	r25, r25
    554c:	88 0f       	add	r24, r24
    554e:	99 1f       	adc	r25, r25
    5550:	88 0f       	add	r24, r24
    5552:	99 1f       	adc	r25, r25
    5554:	82 0f       	add	r24, r18
    5556:	93 1f       	adc	r25, r19
    5558:	87 54       	subi	r24, 0x47	; 71
    555a:	99 4f       	sbci	r25, 0xF9	; 249
    555c:	ba 01       	movw	r22, r20
    555e:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    5562:	81 e0       	ldi	r24, 0x01	; 1
    5564:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5566:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5568:	0f 90       	pop	r0
    556a:	0f 90       	pop	r0
    556c:	0f 90       	pop	r0
    556e:	0f 90       	pop	r0
    5570:	0f 90       	pop	r0
    5572:	df 91       	pop	r29
    5574:	cf 91       	pop	r28
    5576:	08 95       	ret

00005578 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    5578:	cf 93       	push	r28
    557a:	df 93       	push	r29
    557c:	cd b7       	in	r28, 0x3d	; 61
    557e:	de b7       	in	r29, 0x3e	; 62
    5580:	28 97       	sbiw	r28, 0x08	; 8
    5582:	0f b6       	in	r0, 0x3f	; 63
    5584:	f8 94       	cli
    5586:	de bf       	out	0x3e, r29	; 62
    5588:	0f be       	out	0x3f, r0	; 63
    558a:	cd bf       	out	0x3d, r28	; 61
    558c:	9f 83       	std	Y+7, r25	; 0x07
    558e:	8e 83       	std	Y+6, r24	; 0x06
    5590:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    5592:	8e 81       	ldd	r24, Y+6	; 0x06
    5594:	9f 81       	ldd	r25, Y+7	; 0x07
    5596:	9b 83       	std	Y+3, r25	; 0x03
    5598:	8a 83       	std	Y+2, r24	; 0x02
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    559a:	81 e0       	ldi	r24, 0x01	; 1
    559c:	8c 83       	std	Y+4, r24	; 0x04

		if( pxMutexHolder != NULL )
    559e:	8e 81       	ldd	r24, Y+6	; 0x06
    55a0:	9f 81       	ldd	r25, Y+7	; 0x07
    55a2:	89 2b       	or	r24, r25
    55a4:	09 f4       	brne	.+2      	; 0x55a8 <vTaskPriorityDisinheritAfterTimeout+0x30>
    55a6:	7e c0       	rjmp	.+252    	; 0x56a4 <vTaskPriorityDisinheritAfterTimeout+0x12c>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    55a8:	8a 81       	ldd	r24, Y+2	; 0x02
    55aa:	9b 81       	ldd	r25, Y+3	; 0x03
    55ac:	fc 01       	movw	r30, r24
    55ae:	91 a1       	ldd	r25, Z+33	; 0x21
    55b0:	88 85       	ldd	r24, Y+8	; 0x08
    55b2:	98 17       	cp	r25, r24
    55b4:	18 f4       	brcc	.+6      	; 0x55bc <vTaskPriorityDisinheritAfterTimeout+0x44>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    55b6:	88 85       	ldd	r24, Y+8	; 0x08
    55b8:	89 83       	std	Y+1, r24	; 0x01
    55ba:	05 c0       	rjmp	.+10     	; 0x55c6 <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    55bc:	8a 81       	ldd	r24, Y+2	; 0x02
    55be:	9b 81       	ldd	r25, Y+3	; 0x03
    55c0:	fc 01       	movw	r30, r24
    55c2:	81 a1       	ldd	r24, Z+33	; 0x21
    55c4:	89 83       	std	Y+1, r24	; 0x01
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    55c6:	8a 81       	ldd	r24, Y+2	; 0x02
    55c8:	9b 81       	ldd	r25, Y+3	; 0x03
    55ca:	fc 01       	movw	r30, r24
    55cc:	96 89       	ldd	r25, Z+22	; 0x16
    55ce:	89 81       	ldd	r24, Y+1	; 0x01
    55d0:	98 17       	cp	r25, r24
    55d2:	09 f4       	brne	.+2      	; 0x55d6 <vTaskPriorityDisinheritAfterTimeout+0x5e>
    55d4:	67 c0       	rjmp	.+206    	; 0x56a4 <vTaskPriorityDisinheritAfterTimeout+0x12c>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    55d6:	8a 81       	ldd	r24, Y+2	; 0x02
    55d8:	9b 81       	ldd	r25, Y+3	; 0x03
    55da:	fc 01       	movw	r30, r24
    55dc:	92 a1       	ldd	r25, Z+34	; 0x22
    55de:	8c 81       	ldd	r24, Y+4	; 0x04
    55e0:	98 17       	cp	r25, r24
    55e2:	09 f0       	breq	.+2      	; 0x55e6 <vTaskPriorityDisinheritAfterTimeout+0x6e>
    55e4:	5f c0       	rjmp	.+190    	; 0x56a4 <vTaskPriorityDisinheritAfterTimeout+0x12c>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    55e6:	8a 81       	ldd	r24, Y+2	; 0x02
    55e8:	9b 81       	ldd	r25, Y+3	; 0x03
    55ea:	fc 01       	movw	r30, r24
    55ec:	86 89       	ldd	r24, Z+22	; 0x16
    55ee:	8d 83       	std	Y+5, r24	; 0x05
					pxTCB->uxPriority = uxPriorityToUse;
    55f0:	8a 81       	ldd	r24, Y+2	; 0x02
    55f2:	9b 81       	ldd	r25, Y+3	; 0x03
    55f4:	29 81       	ldd	r18, Y+1	; 0x01
    55f6:	fc 01       	movw	r30, r24
    55f8:	26 8b       	std	Z+22, r18	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    55fa:	8a 81       	ldd	r24, Y+2	; 0x02
    55fc:	9b 81       	ldd	r25, Y+3	; 0x03
    55fe:	fc 01       	movw	r30, r24
    5600:	84 85       	ldd	r24, Z+12	; 0x0c
    5602:	95 85       	ldd	r25, Z+13	; 0x0d
    5604:	99 23       	and	r25, r25
    5606:	64 f0       	brlt	.+24     	; 0x5620 <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5608:	89 81       	ldd	r24, Y+1	; 0x01
    560a:	88 2f       	mov	r24, r24
    560c:	90 e0       	ldi	r25, 0x00	; 0
    560e:	25 e0       	ldi	r18, 0x05	; 5
    5610:	30 e0       	ldi	r19, 0x00	; 0
    5612:	28 1b       	sub	r18, r24
    5614:	39 0b       	sbc	r19, r25
    5616:	8a 81       	ldd	r24, Y+2	; 0x02
    5618:	9b 81       	ldd	r25, Y+3	; 0x03
    561a:	fc 01       	movw	r30, r24
    561c:	35 87       	std	Z+13, r19	; 0x0d
    561e:	24 87       	std	Z+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    5620:	8a 81       	ldd	r24, Y+2	; 0x02
    5622:	9b 81       	ldd	r25, Y+3	; 0x03
    5624:	fc 01       	movw	r30, r24
    5626:	42 85       	ldd	r20, Z+10	; 0x0a
    5628:	53 85       	ldd	r21, Z+11	; 0x0b
    562a:	8d 81       	ldd	r24, Y+5	; 0x05
    562c:	28 2f       	mov	r18, r24
    562e:	30 e0       	ldi	r19, 0x00	; 0
    5630:	c9 01       	movw	r24, r18
    5632:	88 0f       	add	r24, r24
    5634:	99 1f       	adc	r25, r25
    5636:	88 0f       	add	r24, r24
    5638:	99 1f       	adc	r25, r25
    563a:	88 0f       	add	r24, r24
    563c:	99 1f       	adc	r25, r25
    563e:	82 0f       	add	r24, r18
    5640:	93 1f       	adc	r25, r19
    5642:	87 54       	subi	r24, 0x47	; 71
    5644:	99 4f       	sbci	r25, 0xF9	; 249
    5646:	48 17       	cp	r20, r24
    5648:	59 07       	cpc	r21, r25
    564a:	61 f5       	brne	.+88     	; 0x56a4 <vTaskPriorityDisinheritAfterTimeout+0x12c>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    564c:	8a 81       	ldd	r24, Y+2	; 0x02
    564e:	9b 81       	ldd	r25, Y+3	; 0x03
    5650:	02 96       	adiw	r24, 0x02	; 2
    5652:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    5656:	8a 81       	ldd	r24, Y+2	; 0x02
    5658:	9b 81       	ldd	r25, Y+3	; 0x03
    565a:	fc 01       	movw	r30, r24
    565c:	96 89       	ldd	r25, Z+22	; 0x16
    565e:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    5662:	89 17       	cp	r24, r25
    5664:	30 f4       	brcc	.+12     	; 0x5672 <vTaskPriorityDisinheritAfterTimeout+0xfa>
    5666:	8a 81       	ldd	r24, Y+2	; 0x02
    5668:	9b 81       	ldd	r25, Y+3	; 0x03
    566a:	fc 01       	movw	r30, r24
    566c:	86 89       	ldd	r24, Z+22	; 0x16
    566e:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    5672:	8a 81       	ldd	r24, Y+2	; 0x02
    5674:	9b 81       	ldd	r25, Y+3	; 0x03
    5676:	ac 01       	movw	r20, r24
    5678:	4e 5f       	subi	r20, 0xFE	; 254
    567a:	5f 4f       	sbci	r21, 0xFF	; 255
    567c:	8a 81       	ldd	r24, Y+2	; 0x02
    567e:	9b 81       	ldd	r25, Y+3	; 0x03
    5680:	fc 01       	movw	r30, r24
    5682:	86 89       	ldd	r24, Z+22	; 0x16
    5684:	28 2f       	mov	r18, r24
    5686:	30 e0       	ldi	r19, 0x00	; 0
    5688:	c9 01       	movw	r24, r18
    568a:	88 0f       	add	r24, r24
    568c:	99 1f       	adc	r25, r25
    568e:	88 0f       	add	r24, r24
    5690:	99 1f       	adc	r25, r25
    5692:	88 0f       	add	r24, r24
    5694:	99 1f       	adc	r25, r25
    5696:	82 0f       	add	r24, r18
    5698:	93 1f       	adc	r25, r19
    569a:	87 54       	subi	r24, 0x47	; 71
    569c:	99 4f       	sbci	r25, 0xF9	; 249
    569e:	ba 01       	movw	r22, r20
    56a0:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    56a4:	00 00       	nop
    56a6:	28 96       	adiw	r28, 0x08	; 8
    56a8:	0f b6       	in	r0, 0x3f	; 63
    56aa:	f8 94       	cli
    56ac:	de bf       	out	0x3e, r29	; 62
    56ae:	0f be       	out	0x3f, r0	; 63
    56b0:	cd bf       	out	0x3d, r28	; 61
    56b2:	df 91       	pop	r29
    56b4:	cf 91       	pop	r28
    56b6:	08 95       	ret

000056b8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    56b8:	cf 93       	push	r28
    56ba:	df 93       	push	r29
    56bc:	00 d0       	rcall	.+0      	; 0x56be <uxTaskResetEventItemValue+0x6>
    56be:	cd b7       	in	r28, 0x3d	; 61
    56c0:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    56c2:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    56c6:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    56ca:	fc 01       	movw	r30, r24
    56cc:	84 85       	ldd	r24, Z+12	; 0x0c
    56ce:	95 85       	ldd	r25, Z+13	; 0x0d
    56d0:	9a 83       	std	Y+2, r25	; 0x02
    56d2:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    56d4:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    56d8:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    56dc:	20 91 b7 06 	lds	r18, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    56e0:	30 91 b8 06 	lds	r19, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    56e4:	f9 01       	movw	r30, r18
    56e6:	26 89       	ldd	r18, Z+22	; 0x16
    56e8:	22 2f       	mov	r18, r18
    56ea:	30 e0       	ldi	r19, 0x00	; 0
    56ec:	45 e0       	ldi	r20, 0x05	; 5
    56ee:	50 e0       	ldi	r21, 0x00	; 0
    56f0:	ba 01       	movw	r22, r20
    56f2:	62 1b       	sub	r22, r18
    56f4:	73 0b       	sbc	r23, r19
    56f6:	9b 01       	movw	r18, r22
    56f8:	fc 01       	movw	r30, r24
    56fa:	35 87       	std	Z+13, r19	; 0x0d
    56fc:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    56fe:	89 81       	ldd	r24, Y+1	; 0x01
    5700:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5702:	0f 90       	pop	r0
    5704:	0f 90       	pop	r0
    5706:	df 91       	pop	r29
    5708:	cf 91       	pop	r28
    570a:	08 95       	ret

0000570c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    570c:	cf 93       	push	r28
    570e:	df 93       	push	r29
    5710:	cd b7       	in	r28, 0x3d	; 61
    5712:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    5714:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5718:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    571c:	89 2b       	or	r24, r25
    571e:	49 f0       	breq	.+18     	; 0x5732 <pvTaskIncrementMutexHeldCount+0x26>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    5720:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5724:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5728:	fc 01       	movw	r30, r24
    572a:	22 a1       	ldd	r18, Z+34	; 0x22
    572c:	2f 5f       	subi	r18, 0xFF	; 255
    572e:	fc 01       	movw	r30, r24
    5730:	22 a3       	std	Z+34, r18	; 0x22
		}

		return pxCurrentTCB;
    5732:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5736:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
	}
    573a:	df 91       	pop	r29
    573c:	cf 91       	pop	r28
    573e:	08 95       	ret

00005740 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    5740:	cf 93       	push	r28
    5742:	df 93       	push	r29
    5744:	cd b7       	in	r28, 0x3d	; 61
    5746:	de b7       	in	r29, 0x3e	; 62
    5748:	27 97       	sbiw	r28, 0x07	; 7
    574a:	0f b6       	in	r0, 0x3f	; 63
    574c:	f8 94       	cli
    574e:	de bf       	out	0x3e, r29	; 62
    5750:	0f be       	out	0x3f, r0	; 63
    5752:	cd bf       	out	0x3d, r28	; 61
    5754:	8d 83       	std	Y+5, r24	; 0x05
    5756:	7f 83       	std	Y+7, r23	; 0x07
    5758:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    575a:	0f b6       	in	r0, 0x3f	; 63
    575c:	f8 94       	cli
    575e:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    5760:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5764:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5768:	fc 01       	movw	r30, r24
    576a:	83 a1       	ldd	r24, Z+35	; 0x23
    576c:	94 a1       	ldd	r25, Z+36	; 0x24
    576e:	a5 a1       	ldd	r26, Z+37	; 0x25
    5770:	b6 a1       	ldd	r27, Z+38	; 0x26
    5772:	89 2b       	or	r24, r25
    5774:	8a 2b       	or	r24, r26
    5776:	8b 2b       	or	r24, r27
    5778:	91 f4       	brne	.+36     	; 0x579e <ulTaskNotifyTake+0x5e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    577a:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    577e:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5782:	21 e0       	ldi	r18, 0x01	; 1
    5784:	fc 01       	movw	r30, r24
    5786:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5788:	8e 81       	ldd	r24, Y+6	; 0x06
    578a:	9f 81       	ldd	r25, Y+7	; 0x07
    578c:	89 2b       	or	r24, r25
    578e:	39 f0       	breq	.+14     	; 0x579e <ulTaskNotifyTake+0x5e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5790:	8e 81       	ldd	r24, Y+6	; 0x06
    5792:	9f 81       	ldd	r25, Y+7	; 0x07
    5794:	61 e0       	ldi	r22, 0x01	; 1
    5796:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    579a:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    579e:	0f 90       	pop	r0
    57a0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    57a2:	0f b6       	in	r0, 0x3f	; 63
    57a4:	f8 94       	cli
    57a6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    57a8:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    57ac:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    57b0:	fc 01       	movw	r30, r24
    57b2:	83 a1       	ldd	r24, Z+35	; 0x23
    57b4:	94 a1       	ldd	r25, Z+36	; 0x24
    57b6:	a5 a1       	ldd	r26, Z+37	; 0x25
    57b8:	b6 a1       	ldd	r27, Z+38	; 0x26
    57ba:	89 83       	std	Y+1, r24	; 0x01
    57bc:	9a 83       	std	Y+2, r25	; 0x02
    57be:	ab 83       	std	Y+3, r26	; 0x03
    57c0:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    57c2:	89 81       	ldd	r24, Y+1	; 0x01
    57c4:	9a 81       	ldd	r25, Y+2	; 0x02
    57c6:	ab 81       	ldd	r26, Y+3	; 0x03
    57c8:	bc 81       	ldd	r27, Y+4	; 0x04
    57ca:	89 2b       	or	r24, r25
    57cc:	8a 2b       	or	r24, r26
    57ce:	8b 2b       	or	r24, r27
    57d0:	e9 f0       	breq	.+58     	; 0x580c <ulTaskNotifyTake+0xcc>
			{
				if( xClearCountOnExit != pdFALSE )
    57d2:	8d 81       	ldd	r24, Y+5	; 0x05
    57d4:	88 23       	and	r24, r24
    57d6:	51 f0       	breq	.+20     	; 0x57ec <ulTaskNotifyTake+0xac>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    57d8:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    57dc:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    57e0:	fc 01       	movw	r30, r24
    57e2:	13 a2       	std	Z+35, r1	; 0x23
    57e4:	14 a2       	std	Z+36, r1	; 0x24
    57e6:	15 a2       	std	Z+37, r1	; 0x25
    57e8:	16 a2       	std	Z+38, r1	; 0x26
    57ea:	10 c0       	rjmp	.+32     	; 0x580c <ulTaskNotifyTake+0xcc>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    57ec:	20 91 b7 06 	lds	r18, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    57f0:	30 91 b8 06 	lds	r19, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    57f4:	89 81       	ldd	r24, Y+1	; 0x01
    57f6:	9a 81       	ldd	r25, Y+2	; 0x02
    57f8:	ab 81       	ldd	r26, Y+3	; 0x03
    57fa:	bc 81       	ldd	r27, Y+4	; 0x04
    57fc:	01 97       	sbiw	r24, 0x01	; 1
    57fe:	a1 09       	sbc	r26, r1
    5800:	b1 09       	sbc	r27, r1
    5802:	f9 01       	movw	r30, r18
    5804:	83 a3       	std	Z+35, r24	; 0x23
    5806:	94 a3       	std	Z+36, r25	; 0x24
    5808:	a5 a3       	std	Z+37, r26	; 0x25
    580a:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    580c:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5810:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5814:	fc 01       	movw	r30, r24
    5816:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5818:	0f 90       	pop	r0
    581a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    581c:	89 81       	ldd	r24, Y+1	; 0x01
    581e:	9a 81       	ldd	r25, Y+2	; 0x02
    5820:	ab 81       	ldd	r26, Y+3	; 0x03
    5822:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5824:	bc 01       	movw	r22, r24
    5826:	cd 01       	movw	r24, r26
    5828:	27 96       	adiw	r28, 0x07	; 7
    582a:	0f b6       	in	r0, 0x3f	; 63
    582c:	f8 94       	cli
    582e:	de bf       	out	0x3e, r29	; 62
    5830:	0f be       	out	0x3f, r0	; 63
    5832:	cd bf       	out	0x3d, r28	; 61
    5834:	df 91       	pop	r29
    5836:	cf 91       	pop	r28
    5838:	08 95       	ret

0000583a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    583a:	ef 92       	push	r14
    583c:	ff 92       	push	r15
    583e:	0f 93       	push	r16
    5840:	1f 93       	push	r17
    5842:	cf 93       	push	r28
    5844:	df 93       	push	r29
    5846:	cd b7       	in	r28, 0x3d	; 61
    5848:	de b7       	in	r29, 0x3e	; 62
    584a:	2d 97       	sbiw	r28, 0x0d	; 13
    584c:	0f b6       	in	r0, 0x3f	; 63
    584e:	f8 94       	cli
    5850:	de bf       	out	0x3e, r29	; 62
    5852:	0f be       	out	0x3f, r0	; 63
    5854:	cd bf       	out	0x3d, r28	; 61
    5856:	6a 83       	std	Y+2, r22	; 0x02
    5858:	7b 83       	std	Y+3, r23	; 0x03
    585a:	8c 83       	std	Y+4, r24	; 0x04
    585c:	9d 83       	std	Y+5, r25	; 0x05
    585e:	2e 83       	std	Y+6, r18	; 0x06
    5860:	3f 83       	std	Y+7, r19	; 0x07
    5862:	48 87       	std	Y+8, r20	; 0x08
    5864:	59 87       	std	Y+9, r21	; 0x09
    5866:	1b 87       	std	Y+11, r17	; 0x0b
    5868:	0a 87       	std	Y+10, r16	; 0x0a
    586a:	fd 86       	std	Y+13, r15	; 0x0d
    586c:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    586e:	0f b6       	in	r0, 0x3f	; 63
    5870:	f8 94       	cli
    5872:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5874:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5878:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    587c:	fc 01       	movw	r30, r24
    587e:	87 a1       	ldd	r24, Z+39	; 0x27
    5880:	82 30       	cpi	r24, 0x02	; 2
    5882:	61 f1       	breq	.+88     	; 0x58dc <xTaskNotifyWait+0xa2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5884:	60 91 b7 06 	lds	r22, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5888:	70 91 b8 06 	lds	r23, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    588c:	fb 01       	movw	r30, r22
    588e:	23 a1       	ldd	r18, Z+35	; 0x23
    5890:	34 a1       	ldd	r19, Z+36	; 0x24
    5892:	45 a1       	ldd	r20, Z+37	; 0x25
    5894:	56 a1       	ldd	r21, Z+38	; 0x26
    5896:	8a 81       	ldd	r24, Y+2	; 0x02
    5898:	9b 81       	ldd	r25, Y+3	; 0x03
    589a:	ac 81       	ldd	r26, Y+4	; 0x04
    589c:	bd 81       	ldd	r27, Y+5	; 0x05
    589e:	80 95       	com	r24
    58a0:	90 95       	com	r25
    58a2:	a0 95       	com	r26
    58a4:	b0 95       	com	r27
    58a6:	82 23       	and	r24, r18
    58a8:	93 23       	and	r25, r19
    58aa:	a4 23       	and	r26, r20
    58ac:	b5 23       	and	r27, r21
    58ae:	fb 01       	movw	r30, r22
    58b0:	83 a3       	std	Z+35, r24	; 0x23
    58b2:	94 a3       	std	Z+36, r25	; 0x24
    58b4:	a5 a3       	std	Z+37, r26	; 0x25
    58b6:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    58b8:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    58bc:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    58c0:	21 e0       	ldi	r18, 0x01	; 1
    58c2:	fc 01       	movw	r30, r24
    58c4:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    58c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    58c8:	9d 85       	ldd	r25, Y+13	; 0x0d
    58ca:	89 2b       	or	r24, r25
    58cc:	39 f0       	breq	.+14     	; 0x58dc <xTaskNotifyWait+0xa2>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    58ce:	8c 85       	ldd	r24, Y+12	; 0x0c
    58d0:	9d 85       	ldd	r25, Y+13	; 0x0d
    58d2:	61 e0       	ldi	r22, 0x01	; 1
    58d4:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    58d8:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    58dc:	0f 90       	pop	r0
    58de:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    58e0:	0f b6       	in	r0, 0x3f	; 63
    58e2:	f8 94       	cli
    58e4:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    58e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    58e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    58ea:	89 2b       	or	r24, r25
    58ec:	81 f0       	breq	.+32     	; 0x590e <xTaskNotifyWait+0xd4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    58ee:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    58f2:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    58f6:	fc 01       	movw	r30, r24
    58f8:	83 a1       	ldd	r24, Z+35	; 0x23
    58fa:	94 a1       	ldd	r25, Z+36	; 0x24
    58fc:	a5 a1       	ldd	r26, Z+37	; 0x25
    58fe:	b6 a1       	ldd	r27, Z+38	; 0x26
    5900:	2a 85       	ldd	r18, Y+10	; 0x0a
    5902:	3b 85       	ldd	r19, Y+11	; 0x0b
    5904:	f9 01       	movw	r30, r18
    5906:	80 83       	st	Z, r24
    5908:	91 83       	std	Z+1, r25	; 0x01
    590a:	a2 83       	std	Z+2, r26	; 0x02
    590c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    590e:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5912:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5916:	fc 01       	movw	r30, r24
    5918:	87 a1       	ldd	r24, Z+39	; 0x27
    591a:	82 30       	cpi	r24, 0x02	; 2
    591c:	11 f0       	breq	.+4      	; 0x5922 <xTaskNotifyWait+0xe8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    591e:	19 82       	std	Y+1, r1	; 0x01
    5920:	1c c0       	rjmp	.+56     	; 0x595a <xTaskNotifyWait+0x120>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5922:	60 91 b7 06 	lds	r22, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5926:	70 91 b8 06 	lds	r23, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    592a:	fb 01       	movw	r30, r22
    592c:	23 a1       	ldd	r18, Z+35	; 0x23
    592e:	34 a1       	ldd	r19, Z+36	; 0x24
    5930:	45 a1       	ldd	r20, Z+37	; 0x25
    5932:	56 a1       	ldd	r21, Z+38	; 0x26
    5934:	8e 81       	ldd	r24, Y+6	; 0x06
    5936:	9f 81       	ldd	r25, Y+7	; 0x07
    5938:	a8 85       	ldd	r26, Y+8	; 0x08
    593a:	b9 85       	ldd	r27, Y+9	; 0x09
    593c:	80 95       	com	r24
    593e:	90 95       	com	r25
    5940:	a0 95       	com	r26
    5942:	b0 95       	com	r27
    5944:	82 23       	and	r24, r18
    5946:	93 23       	and	r25, r19
    5948:	a4 23       	and	r26, r20
    594a:	b5 23       	and	r27, r21
    594c:	fb 01       	movw	r30, r22
    594e:	83 a3       	std	Z+35, r24	; 0x23
    5950:	94 a3       	std	Z+36, r25	; 0x24
    5952:	a5 a3       	std	Z+37, r26	; 0x25
    5954:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    5956:	81 e0       	ldi	r24, 0x01	; 1
    5958:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    595a:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    595e:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5962:	fc 01       	movw	r30, r24
    5964:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5966:	0f 90       	pop	r0
    5968:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    596a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    596c:	2d 96       	adiw	r28, 0x0d	; 13
    596e:	0f b6       	in	r0, 0x3f	; 63
    5970:	f8 94       	cli
    5972:	de bf       	out	0x3e, r29	; 62
    5974:	0f be       	out	0x3f, r0	; 63
    5976:	cd bf       	out	0x3d, r28	; 61
    5978:	df 91       	pop	r29
    597a:	cf 91       	pop	r28
    597c:	1f 91       	pop	r17
    597e:	0f 91       	pop	r16
    5980:	ff 90       	pop	r15
    5982:	ef 90       	pop	r14
    5984:	08 95       	ret

00005986 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5986:	0f 93       	push	r16
    5988:	1f 93       	push	r17
    598a:	cf 93       	push	r28
    598c:	df 93       	push	r29
    598e:	cd b7       	in	r28, 0x3d	; 61
    5990:	de b7       	in	r29, 0x3e	; 62
    5992:	2d 97       	sbiw	r28, 0x0d	; 13
    5994:	0f b6       	in	r0, 0x3f	; 63
    5996:	f8 94       	cli
    5998:	de bf       	out	0x3e, r29	; 62
    599a:	0f be       	out	0x3f, r0	; 63
    599c:	cd bf       	out	0x3d, r28	; 61
    599e:	9e 83       	std	Y+6, r25	; 0x06
    59a0:	8d 83       	std	Y+5, r24	; 0x05
    59a2:	4f 83       	std	Y+7, r20	; 0x07
    59a4:	58 87       	std	Y+8, r21	; 0x08
    59a6:	69 87       	std	Y+9, r22	; 0x09
    59a8:	7a 87       	std	Y+10, r23	; 0x0a
    59aa:	2b 87       	std	Y+11, r18	; 0x0b
    59ac:	1d 87       	std	Y+13, r17	; 0x0d
    59ae:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    59b0:	81 e0       	ldi	r24, 0x01	; 1
    59b2:	89 83       	std	Y+1, r24	; 0x01
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    59b4:	8d 81       	ldd	r24, Y+5	; 0x05
    59b6:	9e 81       	ldd	r25, Y+6	; 0x06
    59b8:	9b 83       	std	Y+3, r25	; 0x03
    59ba:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    59bc:	0f b6       	in	r0, 0x3f	; 63
    59be:	f8 94       	cli
    59c0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    59c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    59c4:	9d 85       	ldd	r25, Y+13	; 0x0d
    59c6:	89 2b       	or	r24, r25
    59c8:	71 f0       	breq	.+28     	; 0x59e6 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    59ca:	8a 81       	ldd	r24, Y+2	; 0x02
    59cc:	9b 81       	ldd	r25, Y+3	; 0x03
    59ce:	fc 01       	movw	r30, r24
    59d0:	83 a1       	ldd	r24, Z+35	; 0x23
    59d2:	94 a1       	ldd	r25, Z+36	; 0x24
    59d4:	a5 a1       	ldd	r26, Z+37	; 0x25
    59d6:	b6 a1       	ldd	r27, Z+38	; 0x26
    59d8:	2c 85       	ldd	r18, Y+12	; 0x0c
    59da:	3d 85       	ldd	r19, Y+13	; 0x0d
    59dc:	f9 01       	movw	r30, r18
    59de:	80 83       	st	Z, r24
    59e0:	91 83       	std	Z+1, r25	; 0x01
    59e2:	a2 83       	std	Z+2, r26	; 0x02
    59e4:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    59e6:	8a 81       	ldd	r24, Y+2	; 0x02
    59e8:	9b 81       	ldd	r25, Y+3	; 0x03
    59ea:	fc 01       	movw	r30, r24
    59ec:	87 a1       	ldd	r24, Z+39	; 0x27
    59ee:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    59f0:	8a 81       	ldd	r24, Y+2	; 0x02
    59f2:	9b 81       	ldd	r25, Y+3	; 0x03
    59f4:	22 e0       	ldi	r18, 0x02	; 2
    59f6:	fc 01       	movw	r30, r24
    59f8:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    59fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    59fc:	88 2f       	mov	r24, r24
    59fe:	90 e0       	ldi	r25, 0x00	; 0
    5a00:	82 30       	cpi	r24, 0x02	; 2
    5a02:	91 05       	cpc	r25, r1
    5a04:	31 f1       	breq	.+76     	; 0x5a52 <xTaskGenericNotify+0xcc>
    5a06:	83 30       	cpi	r24, 0x03	; 3
    5a08:	91 05       	cpc	r25, r1
    5a0a:	34 f4       	brge	.+12     	; 0x5a18 <xTaskGenericNotify+0x92>
    5a0c:	00 97       	sbiw	r24, 0x00	; 0
    5a0e:	09 f4       	brne	.+2      	; 0x5a12 <xTaskGenericNotify+0x8c>
    5a10:	4f c0       	rjmp	.+158    	; 0x5ab0 <xTaskGenericNotify+0x12a>
    5a12:	01 97       	sbiw	r24, 0x01	; 1
    5a14:	39 f0       	breq	.+14     	; 0x5a24 <xTaskGenericNotify+0x9e>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a16:	4d c0       	rjmp	.+154    	; 0x5ab2 <xTaskGenericNotify+0x12c>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5a18:	83 30       	cpi	r24, 0x03	; 3
    5a1a:	91 05       	cpc	r25, r1
    5a1c:	61 f1       	breq	.+88     	; 0x5a76 <xTaskGenericNotify+0xf0>
    5a1e:	04 97       	sbiw	r24, 0x04	; 4
    5a20:	b1 f1       	breq	.+108    	; 0x5a8e <xTaskGenericNotify+0x108>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a22:	47 c0       	rjmp	.+142    	; 0x5ab2 <xTaskGenericNotify+0x12c>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5a24:	8a 81       	ldd	r24, Y+2	; 0x02
    5a26:	9b 81       	ldd	r25, Y+3	; 0x03
    5a28:	fc 01       	movw	r30, r24
    5a2a:	23 a1       	ldd	r18, Z+35	; 0x23
    5a2c:	34 a1       	ldd	r19, Z+36	; 0x24
    5a2e:	45 a1       	ldd	r20, Z+37	; 0x25
    5a30:	56 a1       	ldd	r21, Z+38	; 0x26
    5a32:	8f 81       	ldd	r24, Y+7	; 0x07
    5a34:	98 85       	ldd	r25, Y+8	; 0x08
    5a36:	a9 85       	ldd	r26, Y+9	; 0x09
    5a38:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a3a:	82 2b       	or	r24, r18
    5a3c:	93 2b       	or	r25, r19
    5a3e:	a4 2b       	or	r26, r20
    5a40:	b5 2b       	or	r27, r21
    5a42:	2a 81       	ldd	r18, Y+2	; 0x02
    5a44:	3b 81       	ldd	r19, Y+3	; 0x03
    5a46:	f9 01       	movw	r30, r18
    5a48:	83 a3       	std	Z+35, r24	; 0x23
    5a4a:	94 a3       	std	Z+36, r25	; 0x24
    5a4c:	a5 a3       	std	Z+37, r26	; 0x25
    5a4e:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5a50:	30 c0       	rjmp	.+96     	; 0x5ab2 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5a52:	8a 81       	ldd	r24, Y+2	; 0x02
    5a54:	9b 81       	ldd	r25, Y+3	; 0x03
    5a56:	fc 01       	movw	r30, r24
    5a58:	83 a1       	ldd	r24, Z+35	; 0x23
    5a5a:	94 a1       	ldd	r25, Z+36	; 0x24
    5a5c:	a5 a1       	ldd	r26, Z+37	; 0x25
    5a5e:	b6 a1       	ldd	r27, Z+38	; 0x26
    5a60:	01 96       	adiw	r24, 0x01	; 1
    5a62:	a1 1d       	adc	r26, r1
    5a64:	b1 1d       	adc	r27, r1
    5a66:	2a 81       	ldd	r18, Y+2	; 0x02
    5a68:	3b 81       	ldd	r19, Y+3	; 0x03
    5a6a:	f9 01       	movw	r30, r18
    5a6c:	83 a3       	std	Z+35, r24	; 0x23
    5a6e:	94 a3       	std	Z+36, r25	; 0x24
    5a70:	a5 a3       	std	Z+37, r26	; 0x25
    5a72:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5a74:	1e c0       	rjmp	.+60     	; 0x5ab2 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5a76:	2a 81       	ldd	r18, Y+2	; 0x02
    5a78:	3b 81       	ldd	r19, Y+3	; 0x03
    5a7a:	8f 81       	ldd	r24, Y+7	; 0x07
    5a7c:	98 85       	ldd	r25, Y+8	; 0x08
    5a7e:	a9 85       	ldd	r26, Y+9	; 0x09
    5a80:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a82:	f9 01       	movw	r30, r18
    5a84:	83 a3       	std	Z+35, r24	; 0x23
    5a86:	94 a3       	std	Z+36, r25	; 0x24
    5a88:	a5 a3       	std	Z+37, r26	; 0x25
    5a8a:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5a8c:	12 c0       	rjmp	.+36     	; 0x5ab2 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5a8e:	8c 81       	ldd	r24, Y+4	; 0x04
    5a90:	82 30       	cpi	r24, 0x02	; 2
    5a92:	61 f0       	breq	.+24     	; 0x5aac <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5a94:	2a 81       	ldd	r18, Y+2	; 0x02
    5a96:	3b 81       	ldd	r19, Y+3	; 0x03
    5a98:	8f 81       	ldd	r24, Y+7	; 0x07
    5a9a:	98 85       	ldd	r25, Y+8	; 0x08
    5a9c:	a9 85       	ldd	r26, Y+9	; 0x09
    5a9e:	ba 85       	ldd	r27, Y+10	; 0x0a
    5aa0:	f9 01       	movw	r30, r18
    5aa2:	83 a3       	std	Z+35, r24	; 0x23
    5aa4:	94 a3       	std	Z+36, r25	; 0x24
    5aa6:	a5 a3       	std	Z+37, r26	; 0x25
    5aa8:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5aaa:	03 c0       	rjmp	.+6      	; 0x5ab2 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5aac:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5aae:	01 c0       	rjmp	.+2      	; 0x5ab2 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    5ab0:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5ab2:	8c 81       	ldd	r24, Y+4	; 0x04
    5ab4:	81 30       	cpi	r24, 0x01	; 1
    5ab6:	d1 f5       	brne	.+116    	; 0x5b2c <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    5aba:	9b 81       	ldd	r25, Y+3	; 0x03
    5abc:	02 96       	adiw	r24, 0x02	; 2
    5abe:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ac4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ac6:	fc 01       	movw	r30, r24
    5ac8:	96 89       	ldd	r25, Z+22	; 0x16
    5aca:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    5ace:	89 17       	cp	r24, r25
    5ad0:	30 f4       	brcc	.+12     	; 0x5ade <xTaskGenericNotify+0x158>
    5ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ad6:	fc 01       	movw	r30, r24
    5ad8:	86 89       	ldd	r24, Z+22	; 0x16
    5ada:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    5ade:	8a 81       	ldd	r24, Y+2	; 0x02
    5ae0:	9b 81       	ldd	r25, Y+3	; 0x03
    5ae2:	ac 01       	movw	r20, r24
    5ae4:	4e 5f       	subi	r20, 0xFE	; 254
    5ae6:	5f 4f       	sbci	r21, 0xFF	; 255
    5ae8:	8a 81       	ldd	r24, Y+2	; 0x02
    5aea:	9b 81       	ldd	r25, Y+3	; 0x03
    5aec:	fc 01       	movw	r30, r24
    5aee:	86 89       	ldd	r24, Z+22	; 0x16
    5af0:	28 2f       	mov	r18, r24
    5af2:	30 e0       	ldi	r19, 0x00	; 0
    5af4:	c9 01       	movw	r24, r18
    5af6:	88 0f       	add	r24, r24
    5af8:	99 1f       	adc	r25, r25
    5afa:	88 0f       	add	r24, r24
    5afc:	99 1f       	adc	r25, r25
    5afe:	88 0f       	add	r24, r24
    5b00:	99 1f       	adc	r25, r25
    5b02:	82 0f       	add	r24, r18
    5b04:	93 1f       	adc	r25, r19
    5b06:	87 54       	subi	r24, 0x47	; 71
    5b08:	99 4f       	sbci	r25, 0xF9	; 249
    5b0a:	ba 01       	movw	r22, r20
    5b0c:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5b10:	8a 81       	ldd	r24, Y+2	; 0x02
    5b12:	9b 81       	ldd	r25, Y+3	; 0x03
    5b14:	fc 01       	movw	r30, r24
    5b16:	26 89       	ldd	r18, Z+22	; 0x16
    5b18:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5b1c:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5b20:	fc 01       	movw	r30, r24
    5b22:	86 89       	ldd	r24, Z+22	; 0x16
    5b24:	82 17       	cp	r24, r18
    5b26:	10 f4       	brcc	.+4      	; 0x5b2c <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5b28:	0e 94 89 16 	call	0x2d12	; 0x2d12 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5b2c:	0f 90       	pop	r0
    5b2e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5b30:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5b32:	2d 96       	adiw	r28, 0x0d	; 13
    5b34:	0f b6       	in	r0, 0x3f	; 63
    5b36:	f8 94       	cli
    5b38:	de bf       	out	0x3e, r29	; 62
    5b3a:	0f be       	out	0x3f, r0	; 63
    5b3c:	cd bf       	out	0x3d, r28	; 61
    5b3e:	df 91       	pop	r29
    5b40:	cf 91       	pop	r28
    5b42:	1f 91       	pop	r17
    5b44:	0f 91       	pop	r16
    5b46:	08 95       	ret

00005b48 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5b48:	ef 92       	push	r14
    5b4a:	ff 92       	push	r15
    5b4c:	0f 93       	push	r16
    5b4e:	1f 93       	push	r17
    5b50:	cf 93       	push	r28
    5b52:	df 93       	push	r29
    5b54:	cd b7       	in	r28, 0x3d	; 61
    5b56:	de b7       	in	r29, 0x3e	; 62
    5b58:	60 97       	sbiw	r28, 0x10	; 16
    5b5a:	0f b6       	in	r0, 0x3f	; 63
    5b5c:	f8 94       	cli
    5b5e:	de bf       	out	0x3e, r29	; 62
    5b60:	0f be       	out	0x3f, r0	; 63
    5b62:	cd bf       	out	0x3d, r28	; 61
    5b64:	9f 83       	std	Y+7, r25	; 0x07
    5b66:	8e 83       	std	Y+6, r24	; 0x06
    5b68:	48 87       	std	Y+8, r20	; 0x08
    5b6a:	59 87       	std	Y+9, r21	; 0x09
    5b6c:	6a 87       	std	Y+10, r22	; 0x0a
    5b6e:	7b 87       	std	Y+11, r23	; 0x0b
    5b70:	2c 87       	std	Y+12, r18	; 0x0c
    5b72:	1e 87       	std	Y+14, r17	; 0x0e
    5b74:	0d 87       	std	Y+13, r16	; 0x0d
    5b76:	f8 8a       	std	Y+16, r15	; 0x10
    5b78:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5b7a:	81 e0       	ldi	r24, 0x01	; 1
    5b7c:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5b7e:	8e 81       	ldd	r24, Y+6	; 0x06
    5b80:	9f 81       	ldd	r25, Y+7	; 0x07
    5b82:	9b 83       	std	Y+3, r25	; 0x03
    5b84:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5b86:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    5b88:	8d 85       	ldd	r24, Y+13	; 0x0d
    5b8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    5b8c:	89 2b       	or	r24, r25
    5b8e:	71 f0       	breq	.+28     	; 0x5bac <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5b90:	8a 81       	ldd	r24, Y+2	; 0x02
    5b92:	9b 81       	ldd	r25, Y+3	; 0x03
    5b94:	fc 01       	movw	r30, r24
    5b96:	83 a1       	ldd	r24, Z+35	; 0x23
    5b98:	94 a1       	ldd	r25, Z+36	; 0x24
    5b9a:	a5 a1       	ldd	r26, Z+37	; 0x25
    5b9c:	b6 a1       	ldd	r27, Z+38	; 0x26
    5b9e:	2d 85       	ldd	r18, Y+13	; 0x0d
    5ba0:	3e 85       	ldd	r19, Y+14	; 0x0e
    5ba2:	f9 01       	movw	r30, r18
    5ba4:	80 83       	st	Z, r24
    5ba6:	91 83       	std	Z+1, r25	; 0x01
    5ba8:	a2 83       	std	Z+2, r26	; 0x02
    5baa:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5bac:	8a 81       	ldd	r24, Y+2	; 0x02
    5bae:	9b 81       	ldd	r25, Y+3	; 0x03
    5bb0:	fc 01       	movw	r30, r24
    5bb2:	87 a1       	ldd	r24, Z+39	; 0x27
    5bb4:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5bb6:	8a 81       	ldd	r24, Y+2	; 0x02
    5bb8:	9b 81       	ldd	r25, Y+3	; 0x03
    5bba:	22 e0       	ldi	r18, 0x02	; 2
    5bbc:	fc 01       	movw	r30, r24
    5bbe:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5bc0:	8c 85       	ldd	r24, Y+12	; 0x0c
    5bc2:	88 2f       	mov	r24, r24
    5bc4:	90 e0       	ldi	r25, 0x00	; 0
    5bc6:	82 30       	cpi	r24, 0x02	; 2
    5bc8:	91 05       	cpc	r25, r1
    5bca:	31 f1       	breq	.+76     	; 0x5c18 <xTaskGenericNotifyFromISR+0xd0>
    5bcc:	83 30       	cpi	r24, 0x03	; 3
    5bce:	91 05       	cpc	r25, r1
    5bd0:	34 f4       	brge	.+12     	; 0x5bde <xTaskGenericNotifyFromISR+0x96>
    5bd2:	00 97       	sbiw	r24, 0x00	; 0
    5bd4:	09 f4       	brne	.+2      	; 0x5bd8 <xTaskGenericNotifyFromISR+0x90>
    5bd6:	4f c0       	rjmp	.+158    	; 0x5c76 <xTaskGenericNotifyFromISR+0x12e>
    5bd8:	01 97       	sbiw	r24, 0x01	; 1
    5bda:	39 f0       	breq	.+14     	; 0x5bea <xTaskGenericNotifyFromISR+0xa2>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5bdc:	4d c0       	rjmp	.+154    	; 0x5c78 <xTaskGenericNotifyFromISR+0x130>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5bde:	83 30       	cpi	r24, 0x03	; 3
    5be0:	91 05       	cpc	r25, r1
    5be2:	61 f1       	breq	.+88     	; 0x5c3c <xTaskGenericNotifyFromISR+0xf4>
    5be4:	04 97       	sbiw	r24, 0x04	; 4
    5be6:	b1 f1       	breq	.+108    	; 0x5c54 <xTaskGenericNotifyFromISR+0x10c>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5be8:	47 c0       	rjmp	.+142    	; 0x5c78 <xTaskGenericNotifyFromISR+0x130>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5bea:	8a 81       	ldd	r24, Y+2	; 0x02
    5bec:	9b 81       	ldd	r25, Y+3	; 0x03
    5bee:	fc 01       	movw	r30, r24
    5bf0:	23 a1       	ldd	r18, Z+35	; 0x23
    5bf2:	34 a1       	ldd	r19, Z+36	; 0x24
    5bf4:	45 a1       	ldd	r20, Z+37	; 0x25
    5bf6:	56 a1       	ldd	r21, Z+38	; 0x26
    5bf8:	88 85       	ldd	r24, Y+8	; 0x08
    5bfa:	99 85       	ldd	r25, Y+9	; 0x09
    5bfc:	aa 85       	ldd	r26, Y+10	; 0x0a
    5bfe:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c00:	82 2b       	or	r24, r18
    5c02:	93 2b       	or	r25, r19
    5c04:	a4 2b       	or	r26, r20
    5c06:	b5 2b       	or	r27, r21
    5c08:	2a 81       	ldd	r18, Y+2	; 0x02
    5c0a:	3b 81       	ldd	r19, Y+3	; 0x03
    5c0c:	f9 01       	movw	r30, r18
    5c0e:	83 a3       	std	Z+35, r24	; 0x23
    5c10:	94 a3       	std	Z+36, r25	; 0x24
    5c12:	a5 a3       	std	Z+37, r26	; 0x25
    5c14:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c16:	30 c0       	rjmp	.+96     	; 0x5c78 <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5c18:	8a 81       	ldd	r24, Y+2	; 0x02
    5c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c1c:	fc 01       	movw	r30, r24
    5c1e:	83 a1       	ldd	r24, Z+35	; 0x23
    5c20:	94 a1       	ldd	r25, Z+36	; 0x24
    5c22:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c24:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c26:	01 96       	adiw	r24, 0x01	; 1
    5c28:	a1 1d       	adc	r26, r1
    5c2a:	b1 1d       	adc	r27, r1
    5c2c:	2a 81       	ldd	r18, Y+2	; 0x02
    5c2e:	3b 81       	ldd	r19, Y+3	; 0x03
    5c30:	f9 01       	movw	r30, r18
    5c32:	83 a3       	std	Z+35, r24	; 0x23
    5c34:	94 a3       	std	Z+36, r25	; 0x24
    5c36:	a5 a3       	std	Z+37, r26	; 0x25
    5c38:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c3a:	1e c0       	rjmp	.+60     	; 0x5c78 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5c3c:	2a 81       	ldd	r18, Y+2	; 0x02
    5c3e:	3b 81       	ldd	r19, Y+3	; 0x03
    5c40:	88 85       	ldd	r24, Y+8	; 0x08
    5c42:	99 85       	ldd	r25, Y+9	; 0x09
    5c44:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c46:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c48:	f9 01       	movw	r30, r18
    5c4a:	83 a3       	std	Z+35, r24	; 0x23
    5c4c:	94 a3       	std	Z+36, r25	; 0x24
    5c4e:	a5 a3       	std	Z+37, r26	; 0x25
    5c50:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c52:	12 c0       	rjmp	.+36     	; 0x5c78 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5c54:	8d 81       	ldd	r24, Y+5	; 0x05
    5c56:	82 30       	cpi	r24, 0x02	; 2
    5c58:	61 f0       	breq	.+24     	; 0x5c72 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5c5a:	2a 81       	ldd	r18, Y+2	; 0x02
    5c5c:	3b 81       	ldd	r19, Y+3	; 0x03
    5c5e:	88 85       	ldd	r24, Y+8	; 0x08
    5c60:	99 85       	ldd	r25, Y+9	; 0x09
    5c62:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c64:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c66:	f9 01       	movw	r30, r18
    5c68:	83 a3       	std	Z+35, r24	; 0x23
    5c6a:	94 a3       	std	Z+36, r25	; 0x24
    5c6c:	a5 a3       	std	Z+37, r26	; 0x25
    5c6e:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5c70:	03 c0       	rjmp	.+6      	; 0x5c78 <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5c72:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5c74:	01 c0       	rjmp	.+2      	; 0x5c78 <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    5c76:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5c78:	8d 81       	ldd	r24, Y+5	; 0x05
    5c7a:	81 30       	cpi	r24, 0x01	; 1
    5c7c:	09 f0       	breq	.+2      	; 0x5c80 <xTaskGenericNotifyFromISR+0x138>
    5c7e:	51 c0       	rjmp	.+162    	; 0x5d22 <xTaskGenericNotifyFromISR+0x1da>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c80:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    5c84:	88 23       	and	r24, r24
    5c86:	69 f5       	brne	.+90     	; 0x5ce2 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5c88:	8a 81       	ldd	r24, Y+2	; 0x02
    5c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c8c:	02 96       	adiw	r24, 0x02	; 2
    5c8e:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5c92:	8a 81       	ldd	r24, Y+2	; 0x02
    5c94:	9b 81       	ldd	r25, Y+3	; 0x03
    5c96:	fc 01       	movw	r30, r24
    5c98:	96 89       	ldd	r25, Z+22	; 0x16
    5c9a:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    5c9e:	89 17       	cp	r24, r25
    5ca0:	30 f4       	brcc	.+12     	; 0x5cae <xTaskGenericNotifyFromISR+0x166>
    5ca2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ca4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ca6:	fc 01       	movw	r30, r24
    5ca8:	86 89       	ldd	r24, Z+22	; 0x16
    5caa:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    5cae:	8a 81       	ldd	r24, Y+2	; 0x02
    5cb0:	9b 81       	ldd	r25, Y+3	; 0x03
    5cb2:	ac 01       	movw	r20, r24
    5cb4:	4e 5f       	subi	r20, 0xFE	; 254
    5cb6:	5f 4f       	sbci	r21, 0xFF	; 255
    5cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    5cba:	9b 81       	ldd	r25, Y+3	; 0x03
    5cbc:	fc 01       	movw	r30, r24
    5cbe:	86 89       	ldd	r24, Z+22	; 0x16
    5cc0:	28 2f       	mov	r18, r24
    5cc2:	30 e0       	ldi	r19, 0x00	; 0
    5cc4:	c9 01       	movw	r24, r18
    5cc6:	88 0f       	add	r24, r24
    5cc8:	99 1f       	adc	r25, r25
    5cca:	88 0f       	add	r24, r24
    5ccc:	99 1f       	adc	r25, r25
    5cce:	88 0f       	add	r24, r24
    5cd0:	99 1f       	adc	r25, r25
    5cd2:	82 0f       	add	r24, r18
    5cd4:	93 1f       	adc	r25, r19
    5cd6:	87 54       	subi	r24, 0x47	; 71
    5cd8:	99 4f       	sbci	r25, 0xF9	; 249
    5cda:	ba 01       	movw	r22, r20
    5cdc:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
    5ce0:	08 c0       	rjmp	.+16     	; 0x5cf2 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ce4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ce6:	0c 96       	adiw	r24, 0x0c	; 12
    5ce8:	bc 01       	movw	r22, r24
    5cea:	8c ef       	ldi	r24, 0xFC	; 252
    5cec:	96 e0       	ldi	r25, 0x06	; 6
    5cee:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5cf2:	8a 81       	ldd	r24, Y+2	; 0x02
    5cf4:	9b 81       	ldd	r25, Y+3	; 0x03
    5cf6:	fc 01       	movw	r30, r24
    5cf8:	26 89       	ldd	r18, Z+22	; 0x16
    5cfa:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5cfe:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5d02:	fc 01       	movw	r30, r24
    5d04:	86 89       	ldd	r24, Z+22	; 0x16
    5d06:	82 17       	cp	r24, r18
    5d08:	60 f4       	brcc	.+24     	; 0x5d22 <xTaskGenericNotifyFromISR+0x1da>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5d0a:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d0c:	98 89       	ldd	r25, Y+16	; 0x10
    5d0e:	89 2b       	or	r24, r25
    5d10:	29 f0       	breq	.+10     	; 0x5d1c <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5d12:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d14:	98 89       	ldd	r25, Y+16	; 0x10
    5d16:	21 e0       	ldi	r18, 0x01	; 1
    5d18:	fc 01       	movw	r30, r24
    5d1a:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5d1c:	81 e0       	ldi	r24, 0x01	; 1
    5d1e:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5d22:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5d24:	60 96       	adiw	r28, 0x10	; 16
    5d26:	0f b6       	in	r0, 0x3f	; 63
    5d28:	f8 94       	cli
    5d2a:	de bf       	out	0x3e, r29	; 62
    5d2c:	0f be       	out	0x3f, r0	; 63
    5d2e:	cd bf       	out	0x3d, r28	; 61
    5d30:	df 91       	pop	r29
    5d32:	cf 91       	pop	r28
    5d34:	1f 91       	pop	r17
    5d36:	0f 91       	pop	r16
    5d38:	ff 90       	pop	r15
    5d3a:	ef 90       	pop	r14
    5d3c:	08 95       	ret

00005d3e <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5d3e:	cf 93       	push	r28
    5d40:	df 93       	push	r29
    5d42:	cd b7       	in	r28, 0x3d	; 61
    5d44:	de b7       	in	r29, 0x3e	; 62
    5d46:	28 97       	sbiw	r28, 0x08	; 8
    5d48:	0f b6       	in	r0, 0x3f	; 63
    5d4a:	f8 94       	cli
    5d4c:	de bf       	out	0x3e, r29	; 62
    5d4e:	0f be       	out	0x3f, r0	; 63
    5d50:	cd bf       	out	0x3d, r28	; 61
    5d52:	9e 83       	std	Y+6, r25	; 0x06
    5d54:	8d 83       	std	Y+5, r24	; 0x05
    5d56:	78 87       	std	Y+8, r23	; 0x08
    5d58:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5d5a:	8d 81       	ldd	r24, Y+5	; 0x05
    5d5c:	9e 81       	ldd	r25, Y+6	; 0x06
    5d5e:	9a 83       	std	Y+2, r25	; 0x02
    5d60:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5d62:	1b 82       	std	Y+3, r1	; 0x03
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5d64:	89 81       	ldd	r24, Y+1	; 0x01
    5d66:	9a 81       	ldd	r25, Y+2	; 0x02
    5d68:	fc 01       	movw	r30, r24
    5d6a:	87 a1       	ldd	r24, Z+39	; 0x27
    5d6c:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5d6e:	89 81       	ldd	r24, Y+1	; 0x01
    5d70:	9a 81       	ldd	r25, Y+2	; 0x02
    5d72:	22 e0       	ldi	r18, 0x02	; 2
    5d74:	fc 01       	movw	r30, r24
    5d76:	27 a3       	std	Z+39, r18	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5d78:	89 81       	ldd	r24, Y+1	; 0x01
    5d7a:	9a 81       	ldd	r25, Y+2	; 0x02
    5d7c:	fc 01       	movw	r30, r24
    5d7e:	83 a1       	ldd	r24, Z+35	; 0x23
    5d80:	94 a1       	ldd	r25, Z+36	; 0x24
    5d82:	a5 a1       	ldd	r26, Z+37	; 0x25
    5d84:	b6 a1       	ldd	r27, Z+38	; 0x26
    5d86:	01 96       	adiw	r24, 0x01	; 1
    5d88:	a1 1d       	adc	r26, r1
    5d8a:	b1 1d       	adc	r27, r1
    5d8c:	29 81       	ldd	r18, Y+1	; 0x01
    5d8e:	3a 81       	ldd	r19, Y+2	; 0x02
    5d90:	f9 01       	movw	r30, r18
    5d92:	83 a3       	std	Z+35, r24	; 0x23
    5d94:	94 a3       	std	Z+36, r25	; 0x24
    5d96:	a5 a3       	std	Z+37, r26	; 0x25
    5d98:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5d9a:	8c 81       	ldd	r24, Y+4	; 0x04
    5d9c:	81 30       	cpi	r24, 0x01	; 1
    5d9e:	09 f0       	breq	.+2      	; 0x5da2 <vTaskNotifyGiveFromISR+0x64>
    5da0:	51 c0       	rjmp	.+162    	; 0x5e44 <vTaskNotifyGiveFromISR+0x106>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5da2:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <uxSchedulerSuspended>
    5da6:	88 23       	and	r24, r24
    5da8:	69 f5       	brne	.+90     	; 0x5e04 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5daa:	89 81       	ldd	r24, Y+1	; 0x01
    5dac:	9a 81       	ldd	r25, Y+2	; 0x02
    5dae:	02 96       	adiw	r24, 0x02	; 2
    5db0:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5db4:	89 81       	ldd	r24, Y+1	; 0x01
    5db6:	9a 81       	ldd	r25, Y+2	; 0x02
    5db8:	fc 01       	movw	r30, r24
    5dba:	96 89       	ldd	r25, Z+22	; 0x16
    5dbc:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <uxTopReadyPriority>
    5dc0:	89 17       	cp	r24, r25
    5dc2:	30 f4       	brcc	.+12     	; 0x5dd0 <vTaskNotifyGiveFromISR+0x92>
    5dc4:	89 81       	ldd	r24, Y+1	; 0x01
    5dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    5dc8:	fc 01       	movw	r30, r24
    5dca:	86 89       	ldd	r24, Z+22	; 0x16
    5dcc:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <uxTopReadyPriority>
    5dd0:	89 81       	ldd	r24, Y+1	; 0x01
    5dd2:	9a 81       	ldd	r25, Y+2	; 0x02
    5dd4:	ac 01       	movw	r20, r24
    5dd6:	4e 5f       	subi	r20, 0xFE	; 254
    5dd8:	5f 4f       	sbci	r21, 0xFF	; 255
    5dda:	89 81       	ldd	r24, Y+1	; 0x01
    5ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    5dde:	fc 01       	movw	r30, r24
    5de0:	86 89       	ldd	r24, Z+22	; 0x16
    5de2:	28 2f       	mov	r18, r24
    5de4:	30 e0       	ldi	r19, 0x00	; 0
    5de6:	c9 01       	movw	r24, r18
    5de8:	88 0f       	add	r24, r24
    5dea:	99 1f       	adc	r25, r25
    5dec:	88 0f       	add	r24, r24
    5dee:	99 1f       	adc	r25, r25
    5df0:	88 0f       	add	r24, r24
    5df2:	99 1f       	adc	r25, r25
    5df4:	82 0f       	add	r24, r18
    5df6:	93 1f       	adc	r25, r19
    5df8:	87 54       	subi	r24, 0x47	; 71
    5dfa:	99 4f       	sbci	r25, 0xF9	; 249
    5dfc:	ba 01       	movw	r22, r20
    5dfe:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
    5e02:	08 c0       	rjmp	.+16     	; 0x5e14 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5e04:	89 81       	ldd	r24, Y+1	; 0x01
    5e06:	9a 81       	ldd	r25, Y+2	; 0x02
    5e08:	0c 96       	adiw	r24, 0x0c	; 12
    5e0a:	bc 01       	movw	r22, r24
    5e0c:	8c ef       	ldi	r24, 0xFC	; 252
    5e0e:	96 e0       	ldi	r25, 0x06	; 6
    5e10:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5e14:	89 81       	ldd	r24, Y+1	; 0x01
    5e16:	9a 81       	ldd	r25, Y+2	; 0x02
    5e18:	fc 01       	movw	r30, r24
    5e1a:	26 89       	ldd	r18, Z+22	; 0x16
    5e1c:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5e20:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5e24:	fc 01       	movw	r30, r24
    5e26:	86 89       	ldd	r24, Z+22	; 0x16
    5e28:	82 17       	cp	r24, r18
    5e2a:	60 f4       	brcc	.+24     	; 0x5e44 <vTaskNotifyGiveFromISR+0x106>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5e2c:	8f 81       	ldd	r24, Y+7	; 0x07
    5e2e:	98 85       	ldd	r25, Y+8	; 0x08
    5e30:	89 2b       	or	r24, r25
    5e32:	29 f0       	breq	.+10     	; 0x5e3e <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5e34:	8f 81       	ldd	r24, Y+7	; 0x07
    5e36:	98 85       	ldd	r25, Y+8	; 0x08
    5e38:	21 e0       	ldi	r18, 0x01	; 1
    5e3a:	fc 01       	movw	r30, r24
    5e3c:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5e3e:	81 e0       	ldi	r24, 0x01	; 1
    5e40:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5e44:	00 00       	nop
    5e46:	28 96       	adiw	r28, 0x08	; 8
    5e48:	0f b6       	in	r0, 0x3f	; 63
    5e4a:	f8 94       	cli
    5e4c:	de bf       	out	0x3e, r29	; 62
    5e4e:	0f be       	out	0x3f, r0	; 63
    5e50:	cd bf       	out	0x3d, r28	; 61
    5e52:	df 91       	pop	r29
    5e54:	cf 91       	pop	r28
    5e56:	08 95       	ret

00005e58 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5e58:	cf 93       	push	r28
    5e5a:	df 93       	push	r29
    5e5c:	00 d0       	rcall	.+0      	; 0x5e5e <xTaskNotifyStateClear+0x6>
    5e5e:	00 d0       	rcall	.+0      	; 0x5e60 <xTaskNotifyStateClear+0x8>
    5e60:	1f 92       	push	r1
    5e62:	cd b7       	in	r28, 0x3d	; 61
    5e64:	de b7       	in	r29, 0x3e	; 62
    5e66:	9d 83       	std	Y+5, r25	; 0x05
    5e68:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5e6a:	8c 81       	ldd	r24, Y+4	; 0x04
    5e6c:	9d 81       	ldd	r25, Y+5	; 0x05
    5e6e:	89 2b       	or	r24, r25
    5e70:	29 f4       	brne	.+10     	; 0x5e7c <xTaskNotifyStateClear+0x24>
    5e72:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5e76:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5e7a:	02 c0       	rjmp	.+4      	; 0x5e80 <xTaskNotifyStateClear+0x28>
    5e7c:	8c 81       	ldd	r24, Y+4	; 0x04
    5e7e:	9d 81       	ldd	r25, Y+5	; 0x05
    5e80:	9b 83       	std	Y+3, r25	; 0x03
    5e82:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5e84:	0f b6       	in	r0, 0x3f	; 63
    5e86:	f8 94       	cli
    5e88:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    5e8c:	9b 81       	ldd	r25, Y+3	; 0x03
    5e8e:	fc 01       	movw	r30, r24
    5e90:	87 a1       	ldd	r24, Z+39	; 0x27
    5e92:	82 30       	cpi	r24, 0x02	; 2
    5e94:	39 f4       	brne	.+14     	; 0x5ea4 <xTaskNotifyStateClear+0x4c>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5e96:	8a 81       	ldd	r24, Y+2	; 0x02
    5e98:	9b 81       	ldd	r25, Y+3	; 0x03
    5e9a:	fc 01       	movw	r30, r24
    5e9c:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5e9e:	81 e0       	ldi	r24, 0x01	; 1
    5ea0:	89 83       	std	Y+1, r24	; 0x01
    5ea2:	01 c0       	rjmp	.+2      	; 0x5ea6 <xTaskNotifyStateClear+0x4e>
			}
			else
			{
				xReturn = pdFAIL;
    5ea4:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5ea6:	0f 90       	pop	r0
    5ea8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5eaa:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5eac:	0f 90       	pop	r0
    5eae:	0f 90       	pop	r0
    5eb0:	0f 90       	pop	r0
    5eb2:	0f 90       	pop	r0
    5eb4:	0f 90       	pop	r0
    5eb6:	df 91       	pop	r29
    5eb8:	cf 91       	pop	r28
    5eba:	08 95       	ret

00005ebc <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5ebc:	cf 93       	push	r28
    5ebe:	df 93       	push	r29
    5ec0:	cd b7       	in	r28, 0x3d	; 61
    5ec2:	de b7       	in	r29, 0x3e	; 62
    5ec4:	27 97       	sbiw	r28, 0x07	; 7
    5ec6:	0f b6       	in	r0, 0x3f	; 63
    5ec8:	f8 94       	cli
    5eca:	de bf       	out	0x3e, r29	; 62
    5ecc:	0f be       	out	0x3f, r0	; 63
    5ece:	cd bf       	out	0x3d, r28	; 61
    5ed0:	9e 83       	std	Y+6, r25	; 0x06
    5ed2:	8d 83       	std	Y+5, r24	; 0x05
    5ed4:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5ed6:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <xTickCount>
    5eda:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <xTickCount+0x1>
    5ede:	9a 83       	std	Y+2, r25	; 0x02
    5ee0:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5ee2:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5ee6:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5eea:	02 96       	adiw	r24, 0x02	; 2
    5eec:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5ef0:	8d 81       	ldd	r24, Y+5	; 0x05
    5ef2:	9e 81       	ldd	r25, Y+6	; 0x06
    5ef4:	01 96       	adiw	r24, 0x01	; 1
    5ef6:	71 f4       	brne	.+28     	; 0x5f14 <prvAddCurrentTaskToDelayedList+0x58>
    5ef8:	8f 81       	ldd	r24, Y+7	; 0x07
    5efa:	88 23       	and	r24, r24
    5efc:	59 f0       	breq	.+22     	; 0x5f14 <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5efe:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5f02:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5f06:	02 96       	adiw	r24, 0x02	; 2
    5f08:	bc 01       	movw	r22, r24
    5f0a:	8f e0       	ldi	r24, 0x0F	; 15
    5f0c:	97 e0       	ldi	r25, 0x07	; 7
    5f0e:	0e 94 31 13 	call	0x2662	; 0x2662 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f12:	44 c0       	rjmp	.+136    	; 0x5f9c <prvAddCurrentTaskToDelayedList+0xe0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    5f14:	29 81       	ldd	r18, Y+1	; 0x01
    5f16:	3a 81       	ldd	r19, Y+2	; 0x02
    5f18:	8d 81       	ldd	r24, Y+5	; 0x05
    5f1a:	9e 81       	ldd	r25, Y+6	; 0x06
    5f1c:	82 0f       	add	r24, r18
    5f1e:	93 1f       	adc	r25, r19
    5f20:	9c 83       	std	Y+4, r25	; 0x04
    5f22:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5f24:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5f28:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5f2c:	2b 81       	ldd	r18, Y+3	; 0x03
    5f2e:	3c 81       	ldd	r19, Y+4	; 0x04
    5f30:	fc 01       	movw	r30, r24
    5f32:	33 83       	std	Z+3, r19	; 0x03
    5f34:	22 83       	std	Z+2, r18	; 0x02

			if( xTimeToWake < xConstTickCount )
    5f36:	2b 81       	ldd	r18, Y+3	; 0x03
    5f38:	3c 81       	ldd	r19, Y+4	; 0x04
    5f3a:	89 81       	ldd	r24, Y+1	; 0x01
    5f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    5f3e:	28 17       	cp	r18, r24
    5f40:	39 07       	cpc	r19, r25
    5f42:	78 f4       	brcc	.+30     	; 0x5f62 <prvAddCurrentTaskToDelayedList+0xa6>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5f44:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5f48:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5f4c:	9c 01       	movw	r18, r24
    5f4e:	2e 5f       	subi	r18, 0xFE	; 254
    5f50:	3f 4f       	sbci	r19, 0xFF	; 255
    5f52:	80 91 fa 06 	lds	r24, 0x06FA	; 0x8006fa <pxOverflowDelayedTaskList>
    5f56:	90 91 fb 06 	lds	r25, 0x06FB	; 0x8006fb <pxOverflowDelayedTaskList+0x1>
    5f5a:	b9 01       	movw	r22, r18
    5f5c:	0e 94 80 13 	call	0x2700	; 0x2700 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f60:	1d c0       	rjmp	.+58     	; 0x5f9c <prvAddCurrentTaskToDelayedList+0xe0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5f62:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <pxCurrentTCB>
    5f66:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <pxCurrentTCB+0x1>
    5f6a:	9c 01       	movw	r18, r24
    5f6c:	2e 5f       	subi	r18, 0xFE	; 254
    5f6e:	3f 4f       	sbci	r19, 0xFF	; 255
    5f70:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    5f74:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    5f78:	b9 01       	movw	r22, r18
    5f7a:	0e 94 80 13 	call	0x2700	; 0x2700 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5f7e:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <xNextTaskUnblockTime>
    5f82:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <xNextTaskUnblockTime+0x1>
    5f86:	2b 81       	ldd	r18, Y+3	; 0x03
    5f88:	3c 81       	ldd	r19, Y+4	; 0x04
    5f8a:	28 17       	cp	r18, r24
    5f8c:	39 07       	cpc	r19, r25
    5f8e:	30 f4       	brcc	.+12     	; 0x5f9c <prvAddCurrentTaskToDelayedList+0xe0>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5f90:	8b 81       	ldd	r24, Y+3	; 0x03
    5f92:	9c 81       	ldd	r25, Y+4	; 0x04
    5f94:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <xNextTaskUnblockTime+0x1>
    5f98:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f9c:	00 00       	nop
    5f9e:	27 96       	adiw	r28, 0x07	; 7
    5fa0:	0f b6       	in	r0, 0x3f	; 63
    5fa2:	f8 94       	cli
    5fa4:	de bf       	out	0x3e, r29	; 62
    5fa6:	0f be       	out	0x3f, r0	; 63
    5fa8:	cd bf       	out	0x3d, r28	; 61
    5faa:	df 91       	pop	r29
    5fac:	cf 91       	pop	r28
    5fae:	08 95       	ret

00005fb0 <__umulhisi3>:
    5fb0:	a2 9f       	mul	r26, r18
    5fb2:	b0 01       	movw	r22, r0
    5fb4:	b3 9f       	mul	r27, r19
    5fb6:	c0 01       	movw	r24, r0
    5fb8:	a3 9f       	mul	r26, r19
    5fba:	70 0d       	add	r23, r0
    5fbc:	81 1d       	adc	r24, r1
    5fbe:	11 24       	eor	r1, r1
    5fc0:	91 1d       	adc	r25, r1
    5fc2:	b2 9f       	mul	r27, r18
    5fc4:	70 0d       	add	r23, r0
    5fc6:	81 1d       	adc	r24, r1
    5fc8:	11 24       	eor	r1, r1
    5fca:	91 1d       	adc	r25, r1
    5fcc:	08 95       	ret

00005fce <__subsf3>:
    5fce:	50 58       	subi	r21, 0x80	; 128

00005fd0 <__addsf3>:
    5fd0:	bb 27       	eor	r27, r27
    5fd2:	aa 27       	eor	r26, r26
    5fd4:	0e 94 ff 2f 	call	0x5ffe	; 0x5ffe <__addsf3x>
    5fd8:	0c 94 35 31 	jmp	0x626a	; 0x626a <__fp_round>
    5fdc:	0e 94 27 31 	call	0x624e	; 0x624e <__fp_pscA>
    5fe0:	38 f0       	brcs	.+14     	; 0x5ff0 <__addsf3+0x20>
    5fe2:	0e 94 2e 31 	call	0x625c	; 0x625c <__fp_pscB>
    5fe6:	20 f0       	brcs	.+8      	; 0x5ff0 <__addsf3+0x20>
    5fe8:	39 f4       	brne	.+14     	; 0x5ff8 <__addsf3+0x28>
    5fea:	9f 3f       	cpi	r25, 0xFF	; 255
    5fec:	19 f4       	brne	.+6      	; 0x5ff4 <__addsf3+0x24>
    5fee:	26 f4       	brtc	.+8      	; 0x5ff8 <__addsf3+0x28>
    5ff0:	0c 94 24 31 	jmp	0x6248	; 0x6248 <__fp_nan>
    5ff4:	0e f4       	brtc	.+2      	; 0x5ff8 <__addsf3+0x28>
    5ff6:	e0 95       	com	r30
    5ff8:	e7 fb       	bst	r30, 7
    5ffa:	0c 94 1e 31 	jmp	0x623c	; 0x623c <__fp_inf>

00005ffe <__addsf3x>:
    5ffe:	e9 2f       	mov	r30, r25
    6000:	0e 94 46 31 	call	0x628c	; 0x628c <__fp_split3>
    6004:	58 f3       	brcs	.-42     	; 0x5fdc <__addsf3+0xc>
    6006:	ba 17       	cp	r27, r26
    6008:	62 07       	cpc	r22, r18
    600a:	73 07       	cpc	r23, r19
    600c:	84 07       	cpc	r24, r20
    600e:	95 07       	cpc	r25, r21
    6010:	20 f0       	brcs	.+8      	; 0x601a <__addsf3x+0x1c>
    6012:	79 f4       	brne	.+30     	; 0x6032 <__addsf3x+0x34>
    6014:	a6 f5       	brtc	.+104    	; 0x607e <__addsf3x+0x80>
    6016:	0c 94 68 31 	jmp	0x62d0	; 0x62d0 <__fp_zero>
    601a:	0e f4       	brtc	.+2      	; 0x601e <__addsf3x+0x20>
    601c:	e0 95       	com	r30
    601e:	0b 2e       	mov	r0, r27
    6020:	ba 2f       	mov	r27, r26
    6022:	a0 2d       	mov	r26, r0
    6024:	0b 01       	movw	r0, r22
    6026:	b9 01       	movw	r22, r18
    6028:	90 01       	movw	r18, r0
    602a:	0c 01       	movw	r0, r24
    602c:	ca 01       	movw	r24, r20
    602e:	a0 01       	movw	r20, r0
    6030:	11 24       	eor	r1, r1
    6032:	ff 27       	eor	r31, r31
    6034:	59 1b       	sub	r21, r25
    6036:	99 f0       	breq	.+38     	; 0x605e <__addsf3x+0x60>
    6038:	59 3f       	cpi	r21, 0xF9	; 249
    603a:	50 f4       	brcc	.+20     	; 0x6050 <__addsf3x+0x52>
    603c:	50 3e       	cpi	r21, 0xE0	; 224
    603e:	68 f1       	brcs	.+90     	; 0x609a <__addsf3x+0x9c>
    6040:	1a 16       	cp	r1, r26
    6042:	f0 40       	sbci	r31, 0x00	; 0
    6044:	a2 2f       	mov	r26, r18
    6046:	23 2f       	mov	r18, r19
    6048:	34 2f       	mov	r19, r20
    604a:	44 27       	eor	r20, r20
    604c:	58 5f       	subi	r21, 0xF8	; 248
    604e:	f3 cf       	rjmp	.-26     	; 0x6036 <__addsf3x+0x38>
    6050:	46 95       	lsr	r20
    6052:	37 95       	ror	r19
    6054:	27 95       	ror	r18
    6056:	a7 95       	ror	r26
    6058:	f0 40       	sbci	r31, 0x00	; 0
    605a:	53 95       	inc	r21
    605c:	c9 f7       	brne	.-14     	; 0x6050 <__addsf3x+0x52>
    605e:	7e f4       	brtc	.+30     	; 0x607e <__addsf3x+0x80>
    6060:	1f 16       	cp	r1, r31
    6062:	ba 0b       	sbc	r27, r26
    6064:	62 0b       	sbc	r22, r18
    6066:	73 0b       	sbc	r23, r19
    6068:	84 0b       	sbc	r24, r20
    606a:	ba f0       	brmi	.+46     	; 0x609a <__addsf3x+0x9c>
    606c:	91 50       	subi	r25, 0x01	; 1
    606e:	a1 f0       	breq	.+40     	; 0x6098 <__addsf3x+0x9a>
    6070:	ff 0f       	add	r31, r31
    6072:	bb 1f       	adc	r27, r27
    6074:	66 1f       	adc	r22, r22
    6076:	77 1f       	adc	r23, r23
    6078:	88 1f       	adc	r24, r24
    607a:	c2 f7       	brpl	.-16     	; 0x606c <__addsf3x+0x6e>
    607c:	0e c0       	rjmp	.+28     	; 0x609a <__addsf3x+0x9c>
    607e:	ba 0f       	add	r27, r26
    6080:	62 1f       	adc	r22, r18
    6082:	73 1f       	adc	r23, r19
    6084:	84 1f       	adc	r24, r20
    6086:	48 f4       	brcc	.+18     	; 0x609a <__addsf3x+0x9c>
    6088:	87 95       	ror	r24
    608a:	77 95       	ror	r23
    608c:	67 95       	ror	r22
    608e:	b7 95       	ror	r27
    6090:	f7 95       	ror	r31
    6092:	9e 3f       	cpi	r25, 0xFE	; 254
    6094:	08 f0       	brcs	.+2      	; 0x6098 <__addsf3x+0x9a>
    6096:	b0 cf       	rjmp	.-160    	; 0x5ff8 <__addsf3+0x28>
    6098:	93 95       	inc	r25
    609a:	88 0f       	add	r24, r24
    609c:	08 f0       	brcs	.+2      	; 0x60a0 <__addsf3x+0xa2>
    609e:	99 27       	eor	r25, r25
    60a0:	ee 0f       	add	r30, r30
    60a2:	97 95       	ror	r25
    60a4:	87 95       	ror	r24
    60a6:	08 95       	ret

000060a8 <__cmpsf2>:
    60a8:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fp_cmp>
    60ac:	08 f4       	brcc	.+2      	; 0x60b0 <__cmpsf2+0x8>
    60ae:	81 e0       	ldi	r24, 0x01	; 1
    60b0:	08 95       	ret

000060b2 <__divsf3>:
    60b2:	0e 94 6d 30 	call	0x60da	; 0x60da <__divsf3x>
    60b6:	0c 94 35 31 	jmp	0x626a	; 0x626a <__fp_round>
    60ba:	0e 94 2e 31 	call	0x625c	; 0x625c <__fp_pscB>
    60be:	58 f0       	brcs	.+22     	; 0x60d6 <__divsf3+0x24>
    60c0:	0e 94 27 31 	call	0x624e	; 0x624e <__fp_pscA>
    60c4:	40 f0       	brcs	.+16     	; 0x60d6 <__divsf3+0x24>
    60c6:	29 f4       	brne	.+10     	; 0x60d2 <__divsf3+0x20>
    60c8:	5f 3f       	cpi	r21, 0xFF	; 255
    60ca:	29 f0       	breq	.+10     	; 0x60d6 <__divsf3+0x24>
    60cc:	0c 94 1e 31 	jmp	0x623c	; 0x623c <__fp_inf>
    60d0:	51 11       	cpse	r21, r1
    60d2:	0c 94 69 31 	jmp	0x62d2	; 0x62d2 <__fp_szero>
    60d6:	0c 94 24 31 	jmp	0x6248	; 0x6248 <__fp_nan>

000060da <__divsf3x>:
    60da:	0e 94 46 31 	call	0x628c	; 0x628c <__fp_split3>
    60de:	68 f3       	brcs	.-38     	; 0x60ba <__divsf3+0x8>

000060e0 <__divsf3_pse>:
    60e0:	99 23       	and	r25, r25
    60e2:	b1 f3       	breq	.-20     	; 0x60d0 <__divsf3+0x1e>
    60e4:	55 23       	and	r21, r21
    60e6:	91 f3       	breq	.-28     	; 0x60cc <__divsf3+0x1a>
    60e8:	95 1b       	sub	r25, r21
    60ea:	55 0b       	sbc	r21, r21
    60ec:	bb 27       	eor	r27, r27
    60ee:	aa 27       	eor	r26, r26
    60f0:	62 17       	cp	r22, r18
    60f2:	73 07       	cpc	r23, r19
    60f4:	84 07       	cpc	r24, r20
    60f6:	38 f0       	brcs	.+14     	; 0x6106 <__divsf3_pse+0x26>
    60f8:	9f 5f       	subi	r25, 0xFF	; 255
    60fa:	5f 4f       	sbci	r21, 0xFF	; 255
    60fc:	22 0f       	add	r18, r18
    60fe:	33 1f       	adc	r19, r19
    6100:	44 1f       	adc	r20, r20
    6102:	aa 1f       	adc	r26, r26
    6104:	a9 f3       	breq	.-22     	; 0x60f0 <__divsf3_pse+0x10>
    6106:	35 d0       	rcall	.+106    	; 0x6172 <__divsf3_pse+0x92>
    6108:	0e 2e       	mov	r0, r30
    610a:	3a f0       	brmi	.+14     	; 0x611a <__divsf3_pse+0x3a>
    610c:	e0 e8       	ldi	r30, 0x80	; 128
    610e:	32 d0       	rcall	.+100    	; 0x6174 <__divsf3_pse+0x94>
    6110:	91 50       	subi	r25, 0x01	; 1
    6112:	50 40       	sbci	r21, 0x00	; 0
    6114:	e6 95       	lsr	r30
    6116:	00 1c       	adc	r0, r0
    6118:	ca f7       	brpl	.-14     	; 0x610c <__divsf3_pse+0x2c>
    611a:	2b d0       	rcall	.+86     	; 0x6172 <__divsf3_pse+0x92>
    611c:	fe 2f       	mov	r31, r30
    611e:	29 d0       	rcall	.+82     	; 0x6172 <__divsf3_pse+0x92>
    6120:	66 0f       	add	r22, r22
    6122:	77 1f       	adc	r23, r23
    6124:	88 1f       	adc	r24, r24
    6126:	bb 1f       	adc	r27, r27
    6128:	26 17       	cp	r18, r22
    612a:	37 07       	cpc	r19, r23
    612c:	48 07       	cpc	r20, r24
    612e:	ab 07       	cpc	r26, r27
    6130:	b0 e8       	ldi	r27, 0x80	; 128
    6132:	09 f0       	breq	.+2      	; 0x6136 <__divsf3_pse+0x56>
    6134:	bb 0b       	sbc	r27, r27
    6136:	80 2d       	mov	r24, r0
    6138:	bf 01       	movw	r22, r30
    613a:	ff 27       	eor	r31, r31
    613c:	93 58       	subi	r25, 0x83	; 131
    613e:	5f 4f       	sbci	r21, 0xFF	; 255
    6140:	3a f0       	brmi	.+14     	; 0x6150 <__divsf3_pse+0x70>
    6142:	9e 3f       	cpi	r25, 0xFE	; 254
    6144:	51 05       	cpc	r21, r1
    6146:	78 f0       	brcs	.+30     	; 0x6166 <__divsf3_pse+0x86>
    6148:	0c 94 1e 31 	jmp	0x623c	; 0x623c <__fp_inf>
    614c:	0c 94 69 31 	jmp	0x62d2	; 0x62d2 <__fp_szero>
    6150:	5f 3f       	cpi	r21, 0xFF	; 255
    6152:	e4 f3       	brlt	.-8      	; 0x614c <__divsf3_pse+0x6c>
    6154:	98 3e       	cpi	r25, 0xE8	; 232
    6156:	d4 f3       	brlt	.-12     	; 0x614c <__divsf3_pse+0x6c>
    6158:	86 95       	lsr	r24
    615a:	77 95       	ror	r23
    615c:	67 95       	ror	r22
    615e:	b7 95       	ror	r27
    6160:	f7 95       	ror	r31
    6162:	9f 5f       	subi	r25, 0xFF	; 255
    6164:	c9 f7       	brne	.-14     	; 0x6158 <__divsf3_pse+0x78>
    6166:	88 0f       	add	r24, r24
    6168:	91 1d       	adc	r25, r1
    616a:	96 95       	lsr	r25
    616c:	87 95       	ror	r24
    616e:	97 f9       	bld	r25, 7
    6170:	08 95       	ret
    6172:	e1 e0       	ldi	r30, 0x01	; 1
    6174:	66 0f       	add	r22, r22
    6176:	77 1f       	adc	r23, r23
    6178:	88 1f       	adc	r24, r24
    617a:	bb 1f       	adc	r27, r27
    617c:	62 17       	cp	r22, r18
    617e:	73 07       	cpc	r23, r19
    6180:	84 07       	cpc	r24, r20
    6182:	ba 07       	cpc	r27, r26
    6184:	20 f0       	brcs	.+8      	; 0x618e <__divsf3_pse+0xae>
    6186:	62 1b       	sub	r22, r18
    6188:	73 0b       	sbc	r23, r19
    618a:	84 0b       	sbc	r24, r20
    618c:	ba 0b       	sbc	r27, r26
    618e:	ee 1f       	adc	r30, r30
    6190:	88 f7       	brcc	.-30     	; 0x6174 <__divsf3_pse+0x94>
    6192:	e0 95       	com	r30
    6194:	08 95       	ret

00006196 <__fixunssfsi>:
    6196:	0e 94 4e 31 	call	0x629c	; 0x629c <__fp_splitA>
    619a:	88 f0       	brcs	.+34     	; 0x61be <__fixunssfsi+0x28>
    619c:	9f 57       	subi	r25, 0x7F	; 127
    619e:	98 f0       	brcs	.+38     	; 0x61c6 <__fixunssfsi+0x30>
    61a0:	b9 2f       	mov	r27, r25
    61a2:	99 27       	eor	r25, r25
    61a4:	b7 51       	subi	r27, 0x17	; 23
    61a6:	b0 f0       	brcs	.+44     	; 0x61d4 <__fixunssfsi+0x3e>
    61a8:	e1 f0       	breq	.+56     	; 0x61e2 <__fixunssfsi+0x4c>
    61aa:	66 0f       	add	r22, r22
    61ac:	77 1f       	adc	r23, r23
    61ae:	88 1f       	adc	r24, r24
    61b0:	99 1f       	adc	r25, r25
    61b2:	1a f0       	brmi	.+6      	; 0x61ba <__fixunssfsi+0x24>
    61b4:	ba 95       	dec	r27
    61b6:	c9 f7       	brne	.-14     	; 0x61aa <__fixunssfsi+0x14>
    61b8:	14 c0       	rjmp	.+40     	; 0x61e2 <__fixunssfsi+0x4c>
    61ba:	b1 30       	cpi	r27, 0x01	; 1
    61bc:	91 f0       	breq	.+36     	; 0x61e2 <__fixunssfsi+0x4c>
    61be:	0e 94 68 31 	call	0x62d0	; 0x62d0 <__fp_zero>
    61c2:	b1 e0       	ldi	r27, 0x01	; 1
    61c4:	08 95       	ret
    61c6:	0c 94 68 31 	jmp	0x62d0	; 0x62d0 <__fp_zero>
    61ca:	67 2f       	mov	r22, r23
    61cc:	78 2f       	mov	r23, r24
    61ce:	88 27       	eor	r24, r24
    61d0:	b8 5f       	subi	r27, 0xF8	; 248
    61d2:	39 f0       	breq	.+14     	; 0x61e2 <__fixunssfsi+0x4c>
    61d4:	b9 3f       	cpi	r27, 0xF9	; 249
    61d6:	cc f3       	brlt	.-14     	; 0x61ca <__fixunssfsi+0x34>
    61d8:	86 95       	lsr	r24
    61da:	77 95       	ror	r23
    61dc:	67 95       	ror	r22
    61de:	b3 95       	inc	r27
    61e0:	d9 f7       	brne	.-10     	; 0x61d8 <__fixunssfsi+0x42>
    61e2:	3e f4       	brtc	.+14     	; 0x61f2 <__fixunssfsi+0x5c>
    61e4:	90 95       	com	r25
    61e6:	80 95       	com	r24
    61e8:	70 95       	com	r23
    61ea:	61 95       	neg	r22
    61ec:	7f 4f       	sbci	r23, 0xFF	; 255
    61ee:	8f 4f       	sbci	r24, 0xFF	; 255
    61f0:	9f 4f       	sbci	r25, 0xFF	; 255
    61f2:	08 95       	ret

000061f4 <__fp_cmp>:
    61f4:	99 0f       	add	r25, r25
    61f6:	00 08       	sbc	r0, r0
    61f8:	55 0f       	add	r21, r21
    61fa:	aa 0b       	sbc	r26, r26
    61fc:	e0 e8       	ldi	r30, 0x80	; 128
    61fe:	fe ef       	ldi	r31, 0xFE	; 254
    6200:	16 16       	cp	r1, r22
    6202:	17 06       	cpc	r1, r23
    6204:	e8 07       	cpc	r30, r24
    6206:	f9 07       	cpc	r31, r25
    6208:	c0 f0       	brcs	.+48     	; 0x623a <__fp_cmp+0x46>
    620a:	12 16       	cp	r1, r18
    620c:	13 06       	cpc	r1, r19
    620e:	e4 07       	cpc	r30, r20
    6210:	f5 07       	cpc	r31, r21
    6212:	98 f0       	brcs	.+38     	; 0x623a <__fp_cmp+0x46>
    6214:	62 1b       	sub	r22, r18
    6216:	73 0b       	sbc	r23, r19
    6218:	84 0b       	sbc	r24, r20
    621a:	95 0b       	sbc	r25, r21
    621c:	39 f4       	brne	.+14     	; 0x622c <__fp_cmp+0x38>
    621e:	0a 26       	eor	r0, r26
    6220:	61 f0       	breq	.+24     	; 0x623a <__fp_cmp+0x46>
    6222:	23 2b       	or	r18, r19
    6224:	24 2b       	or	r18, r20
    6226:	25 2b       	or	r18, r21
    6228:	21 f4       	brne	.+8      	; 0x6232 <__fp_cmp+0x3e>
    622a:	08 95       	ret
    622c:	0a 26       	eor	r0, r26
    622e:	09 f4       	brne	.+2      	; 0x6232 <__fp_cmp+0x3e>
    6230:	a1 40       	sbci	r26, 0x01	; 1
    6232:	a6 95       	lsr	r26
    6234:	8f ef       	ldi	r24, 0xFF	; 255
    6236:	81 1d       	adc	r24, r1
    6238:	81 1d       	adc	r24, r1
    623a:	08 95       	ret

0000623c <__fp_inf>:
    623c:	97 f9       	bld	r25, 7
    623e:	9f 67       	ori	r25, 0x7F	; 127
    6240:	80 e8       	ldi	r24, 0x80	; 128
    6242:	70 e0       	ldi	r23, 0x00	; 0
    6244:	60 e0       	ldi	r22, 0x00	; 0
    6246:	08 95       	ret

00006248 <__fp_nan>:
    6248:	9f ef       	ldi	r25, 0xFF	; 255
    624a:	80 ec       	ldi	r24, 0xC0	; 192
    624c:	08 95       	ret

0000624e <__fp_pscA>:
    624e:	00 24       	eor	r0, r0
    6250:	0a 94       	dec	r0
    6252:	16 16       	cp	r1, r22
    6254:	17 06       	cpc	r1, r23
    6256:	18 06       	cpc	r1, r24
    6258:	09 06       	cpc	r0, r25
    625a:	08 95       	ret

0000625c <__fp_pscB>:
    625c:	00 24       	eor	r0, r0
    625e:	0a 94       	dec	r0
    6260:	12 16       	cp	r1, r18
    6262:	13 06       	cpc	r1, r19
    6264:	14 06       	cpc	r1, r20
    6266:	05 06       	cpc	r0, r21
    6268:	08 95       	ret

0000626a <__fp_round>:
    626a:	09 2e       	mov	r0, r25
    626c:	03 94       	inc	r0
    626e:	00 0c       	add	r0, r0
    6270:	11 f4       	brne	.+4      	; 0x6276 <__fp_round+0xc>
    6272:	88 23       	and	r24, r24
    6274:	52 f0       	brmi	.+20     	; 0x628a <__fp_round+0x20>
    6276:	bb 0f       	add	r27, r27
    6278:	40 f4       	brcc	.+16     	; 0x628a <__fp_round+0x20>
    627a:	bf 2b       	or	r27, r31
    627c:	11 f4       	brne	.+4      	; 0x6282 <__fp_round+0x18>
    627e:	60 ff       	sbrs	r22, 0
    6280:	04 c0       	rjmp	.+8      	; 0x628a <__fp_round+0x20>
    6282:	6f 5f       	subi	r22, 0xFF	; 255
    6284:	7f 4f       	sbci	r23, 0xFF	; 255
    6286:	8f 4f       	sbci	r24, 0xFF	; 255
    6288:	9f 4f       	sbci	r25, 0xFF	; 255
    628a:	08 95       	ret

0000628c <__fp_split3>:
    628c:	57 fd       	sbrc	r21, 7
    628e:	90 58       	subi	r25, 0x80	; 128
    6290:	44 0f       	add	r20, r20
    6292:	55 1f       	adc	r21, r21
    6294:	59 f0       	breq	.+22     	; 0x62ac <__fp_splitA+0x10>
    6296:	5f 3f       	cpi	r21, 0xFF	; 255
    6298:	71 f0       	breq	.+28     	; 0x62b6 <__fp_splitA+0x1a>
    629a:	47 95       	ror	r20

0000629c <__fp_splitA>:
    629c:	88 0f       	add	r24, r24
    629e:	97 fb       	bst	r25, 7
    62a0:	99 1f       	adc	r25, r25
    62a2:	61 f0       	breq	.+24     	; 0x62bc <__fp_splitA+0x20>
    62a4:	9f 3f       	cpi	r25, 0xFF	; 255
    62a6:	79 f0       	breq	.+30     	; 0x62c6 <__fp_splitA+0x2a>
    62a8:	87 95       	ror	r24
    62aa:	08 95       	ret
    62ac:	12 16       	cp	r1, r18
    62ae:	13 06       	cpc	r1, r19
    62b0:	14 06       	cpc	r1, r20
    62b2:	55 1f       	adc	r21, r21
    62b4:	f2 cf       	rjmp	.-28     	; 0x629a <__fp_split3+0xe>
    62b6:	46 95       	lsr	r20
    62b8:	f1 df       	rcall	.-30     	; 0x629c <__fp_splitA>
    62ba:	08 c0       	rjmp	.+16     	; 0x62cc <__fp_splitA+0x30>
    62bc:	16 16       	cp	r1, r22
    62be:	17 06       	cpc	r1, r23
    62c0:	18 06       	cpc	r1, r24
    62c2:	99 1f       	adc	r25, r25
    62c4:	f1 cf       	rjmp	.-30     	; 0x62a8 <__fp_splitA+0xc>
    62c6:	86 95       	lsr	r24
    62c8:	71 05       	cpc	r23, r1
    62ca:	61 05       	cpc	r22, r1
    62cc:	08 94       	sec
    62ce:	08 95       	ret

000062d0 <__fp_zero>:
    62d0:	e8 94       	clt

000062d2 <__fp_szero>:
    62d2:	bb 27       	eor	r27, r27
    62d4:	66 27       	eor	r22, r22
    62d6:	77 27       	eor	r23, r23
    62d8:	cb 01       	movw	r24, r22
    62da:	97 f9       	bld	r25, 7
    62dc:	08 95       	ret

000062de <__gesf2>:
    62de:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__fp_cmp>
    62e2:	08 f4       	brcc	.+2      	; 0x62e6 <__gesf2+0x8>
    62e4:	8f ef       	ldi	r24, 0xFF	; 255
    62e6:	08 95       	ret

000062e8 <__mulsf3>:
    62e8:	0e 94 87 31 	call	0x630e	; 0x630e <__mulsf3x>
    62ec:	0c 94 35 31 	jmp	0x626a	; 0x626a <__fp_round>
    62f0:	0e 94 27 31 	call	0x624e	; 0x624e <__fp_pscA>
    62f4:	38 f0       	brcs	.+14     	; 0x6304 <__mulsf3+0x1c>
    62f6:	0e 94 2e 31 	call	0x625c	; 0x625c <__fp_pscB>
    62fa:	20 f0       	brcs	.+8      	; 0x6304 <__mulsf3+0x1c>
    62fc:	95 23       	and	r25, r21
    62fe:	11 f0       	breq	.+4      	; 0x6304 <__mulsf3+0x1c>
    6300:	0c 94 1e 31 	jmp	0x623c	; 0x623c <__fp_inf>
    6304:	0c 94 24 31 	jmp	0x6248	; 0x6248 <__fp_nan>
    6308:	11 24       	eor	r1, r1
    630a:	0c 94 69 31 	jmp	0x62d2	; 0x62d2 <__fp_szero>

0000630e <__mulsf3x>:
    630e:	0e 94 46 31 	call	0x628c	; 0x628c <__fp_split3>
    6312:	70 f3       	brcs	.-36     	; 0x62f0 <__mulsf3+0x8>

00006314 <__mulsf3_pse>:
    6314:	95 9f       	mul	r25, r21
    6316:	c1 f3       	breq	.-16     	; 0x6308 <__mulsf3+0x20>
    6318:	95 0f       	add	r25, r21
    631a:	50 e0       	ldi	r21, 0x00	; 0
    631c:	55 1f       	adc	r21, r21
    631e:	62 9f       	mul	r22, r18
    6320:	f0 01       	movw	r30, r0
    6322:	72 9f       	mul	r23, r18
    6324:	bb 27       	eor	r27, r27
    6326:	f0 0d       	add	r31, r0
    6328:	b1 1d       	adc	r27, r1
    632a:	63 9f       	mul	r22, r19
    632c:	aa 27       	eor	r26, r26
    632e:	f0 0d       	add	r31, r0
    6330:	b1 1d       	adc	r27, r1
    6332:	aa 1f       	adc	r26, r26
    6334:	64 9f       	mul	r22, r20
    6336:	66 27       	eor	r22, r22
    6338:	b0 0d       	add	r27, r0
    633a:	a1 1d       	adc	r26, r1
    633c:	66 1f       	adc	r22, r22
    633e:	82 9f       	mul	r24, r18
    6340:	22 27       	eor	r18, r18
    6342:	b0 0d       	add	r27, r0
    6344:	a1 1d       	adc	r26, r1
    6346:	62 1f       	adc	r22, r18
    6348:	73 9f       	mul	r23, r19
    634a:	b0 0d       	add	r27, r0
    634c:	a1 1d       	adc	r26, r1
    634e:	62 1f       	adc	r22, r18
    6350:	83 9f       	mul	r24, r19
    6352:	a0 0d       	add	r26, r0
    6354:	61 1d       	adc	r22, r1
    6356:	22 1f       	adc	r18, r18
    6358:	74 9f       	mul	r23, r20
    635a:	33 27       	eor	r19, r19
    635c:	a0 0d       	add	r26, r0
    635e:	61 1d       	adc	r22, r1
    6360:	23 1f       	adc	r18, r19
    6362:	84 9f       	mul	r24, r20
    6364:	60 0d       	add	r22, r0
    6366:	21 1d       	adc	r18, r1
    6368:	82 2f       	mov	r24, r18
    636a:	76 2f       	mov	r23, r22
    636c:	6a 2f       	mov	r22, r26
    636e:	11 24       	eor	r1, r1
    6370:	9f 57       	subi	r25, 0x7F	; 127
    6372:	50 40       	sbci	r21, 0x00	; 0
    6374:	9a f0       	brmi	.+38     	; 0x639c <__mulsf3_pse+0x88>
    6376:	f1 f0       	breq	.+60     	; 0x63b4 <__mulsf3_pse+0xa0>
    6378:	88 23       	and	r24, r24
    637a:	4a f0       	brmi	.+18     	; 0x638e <__mulsf3_pse+0x7a>
    637c:	ee 0f       	add	r30, r30
    637e:	ff 1f       	adc	r31, r31
    6380:	bb 1f       	adc	r27, r27
    6382:	66 1f       	adc	r22, r22
    6384:	77 1f       	adc	r23, r23
    6386:	88 1f       	adc	r24, r24
    6388:	91 50       	subi	r25, 0x01	; 1
    638a:	50 40       	sbci	r21, 0x00	; 0
    638c:	a9 f7       	brne	.-22     	; 0x6378 <__mulsf3_pse+0x64>
    638e:	9e 3f       	cpi	r25, 0xFE	; 254
    6390:	51 05       	cpc	r21, r1
    6392:	80 f0       	brcs	.+32     	; 0x63b4 <__mulsf3_pse+0xa0>
    6394:	0c 94 1e 31 	jmp	0x623c	; 0x623c <__fp_inf>
    6398:	0c 94 69 31 	jmp	0x62d2	; 0x62d2 <__fp_szero>
    639c:	5f 3f       	cpi	r21, 0xFF	; 255
    639e:	e4 f3       	brlt	.-8      	; 0x6398 <__mulsf3_pse+0x84>
    63a0:	98 3e       	cpi	r25, 0xE8	; 232
    63a2:	d4 f3       	brlt	.-12     	; 0x6398 <__mulsf3_pse+0x84>
    63a4:	86 95       	lsr	r24
    63a6:	77 95       	ror	r23
    63a8:	67 95       	ror	r22
    63aa:	b7 95       	ror	r27
    63ac:	f7 95       	ror	r31
    63ae:	e7 95       	ror	r30
    63b0:	9f 5f       	subi	r25, 0xFF	; 255
    63b2:	c1 f7       	brne	.-16     	; 0x63a4 <__mulsf3_pse+0x90>
    63b4:	fe 2b       	or	r31, r30
    63b6:	88 0f       	add	r24, r24
    63b8:	91 1d       	adc	r25, r1
    63ba:	96 95       	lsr	r25
    63bc:	87 95       	ror	r24
    63be:	97 f9       	bld	r25, 7
    63c0:	08 95       	ret

000063c2 <memcpy>:
    63c2:	fb 01       	movw	r30, r22
    63c4:	dc 01       	movw	r26, r24
    63c6:	02 c0       	rjmp	.+4      	; 0x63cc <memcpy+0xa>
    63c8:	01 90       	ld	r0, Z+
    63ca:	0d 92       	st	X+, r0
    63cc:	41 50       	subi	r20, 0x01	; 1
    63ce:	50 40       	sbci	r21, 0x00	; 0
    63d0:	d8 f7       	brcc	.-10     	; 0x63c8 <memcpy+0x6>
    63d2:	08 95       	ret

000063d4 <_exit>:
    63d4:	f8 94       	cli

000063d6 <__stop_program>:
    63d6:	ff cf       	rjmp	.-2      	; 0x63d6 <__stop_program>

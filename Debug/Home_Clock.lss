
Home_Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006448  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000005a  00800060  00006448  000064dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000065e  008000ba  008000ba  00006536  2**0
                  ALLOC
  3 .stab         0000aeb4  00000000  00000000  00006538  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004dc6  00000000  00000000  000113ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000161b2  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000161c4  2**2
                  CONTENTS, READONLY
  7 .debug_info   000004e6  00000000  00000000  00016200  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004a3  00000000  00000000  000166e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00016b89  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000196  00000000  00000000  00016ba3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 db 17 	jmp	0x2fb6	; 0x2fb6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e4       	ldi	r30, 0x48	; 72
      68:	f4 e6       	ldi	r31, 0x64	; 100
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 3b       	cpi	r26, 0xBA	; 186
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	aa eb       	ldi	r26, 0xBA	; 186
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 31       	cpi	r26, 0x18	; 24
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 87 14 	call	0x290e	; 0x290e <main>
      8a:	0c 94 22 32 	jmp	0x6444	; 0x6444 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Clock_Print_Default_Interface>:
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	80 e0       	ldi	r24, 0x00	; 0
      9c:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
      a0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <Hours>
      a4:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <LCD_Void_Write_Number_2>
      a8:	82 e0       	ldi	r24, 0x02	; 2
      aa:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
      ae:	8a e3       	ldi	r24, 0x3A	; 58
      b0:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
      b4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <Minutes>
      b8:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <LCD_Void_Write_Number_2>
      bc:	85 e0       	ldi	r24, 0x05	; 5
      be:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
      c2:	8a e3       	ldi	r24, 0x3A	; 58
      c4:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
      c8:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <__data_end>
      cc:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <LCD_Void_Write_Number_2>
      d0:	00 00       	nop
      d2:	df 91       	pop	r29
      d4:	cf 91       	pop	r28
      d6:	08 95       	ret

000000d8 <Clock_Second>:
	LCD_Void_Write_Number_2(Seconds);

}

void Clock_Second(void *pvParameters)
{
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	00 d0       	rcall	.+0      	; 0xde <Clock_Second+0x6>
      de:	00 d0       	rcall	.+0      	; 0xe0 <Clock_Second+0x8>
      e0:	cd b7       	in	r28, 0x3d	; 61
      e2:	de b7       	in	r29, 0x3e	; 62
      e4:	9c 83       	std	Y+4, r25	; 0x04
      e6:	8b 83       	std	Y+3, r24	; 0x03
	LCD = xSemaphoreCreateMutex();
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	0e 94 2a 19 	call	0x3254	; 0x3254 <xQueueCreateMutex>
      ee:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <LCD+0x1>
      f2:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <LCD>
	TickType_t MyLastUnblockS;
	MyLastUnblockS = xTaskGetTickCount();
      f6:	0e 94 59 25 	call	0x4ab2	; 0x4ab2 <xTaskGetTickCount>
      fa:	9a 83       	std	Y+2, r25	; 0x02
      fc:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(seconds_position-1);
      fe:	85 e0       	ldi	r24, 0x05	; 5
     100:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     104:	8a e3       	ldi	r24, 0x3A	; 58
     106:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     10a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     10e:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     112:	6a e0       	ldi	r22, 0x0A	; 10
     114:	70 e0       	ldi	r23, 0x00	; 0
     116:	0e 94 65 1b 	call	0x36ca	; 0x36ca <xQueueSemaphoreTake>
     11a:	88 23       	and	r24, r24
     11c:	91 f0       	breq	.+36     	; 0x142 <Clock_Second+0x6a>
		{
			LCD_Set_Block(seconds_position);
     11e:	86 e0       	ldi	r24, 0x06	; 6
     120:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
			LCD_Void_Write_Number_2(Seconds);
     124:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <__data_end>
     128:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     12c:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     130:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     134:	20 e0       	ldi	r18, 0x00	; 0
     136:	40 e0       	ldi	r20, 0x00	; 0
     138:	50 e0       	ldi	r21, 0x00	; 0
     13a:	60 e0       	ldi	r22, 0x00	; 0
     13c:	70 e0       	ldi	r23, 0x00	; 0
     13e:	0e 94 4a 19 	call	0x3294	; 0x3294 <xQueueGenericSend>
		}
		vTaskDelayUntil(&MyLastUnblockS,seconds_frequency);
     142:	65 e0       	ldi	r22, 0x05	; 5
     144:	70 e0       	ldi	r23, 0x00	; 0
     146:	ce 01       	movw	r24, r28
     148:	01 96       	adiw	r24, 0x01	; 1
     14a:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <vTaskDelayUntil>
		Seconds++;
     14e:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <__data_end>
     152:	8f 5f       	subi	r24, 0xFF	; 255
     154:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__data_end>
		Seconds %= 60;
     158:	90 91 ba 00 	lds	r25, 0x00BA	; 0x8000ba <__data_end>
     15c:	89 e8       	ldi	r24, 0x89	; 137
     15e:	98 9f       	mul	r25, r24
     160:	81 2d       	mov	r24, r1
     162:	11 24       	eor	r1, r1
     164:	82 95       	swap	r24
     166:	86 95       	lsr	r24
     168:	87 70       	andi	r24, 0x07	; 7
     16a:	2c e3       	ldi	r18, 0x3C	; 60
     16c:	82 9f       	mul	r24, r18
     16e:	80 2d       	mov	r24, r0
     170:	11 24       	eor	r1, r1
     172:	29 2f       	mov	r18, r25
     174:	28 1b       	sub	r18, r24
     176:	82 2f       	mov	r24, r18
     178:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__data_end>
	}
     17c:	c6 cf       	rjmp	.-116    	; 0x10a <Clock_Second+0x32>

0000017e <Clock_Minute>:
}

void Clock_Minute(void *pvParameters)
{
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
     182:	00 d0       	rcall	.+0      	; 0x184 <Clock_Minute+0x6>
     184:	00 d0       	rcall	.+0      	; 0x186 <Clock_Minute+0x8>
     186:	cd b7       	in	r28, 0x3d	; 61
     188:	de b7       	in	r29, 0x3e	; 62
     18a:	9c 83       	std	Y+4, r25	; 0x04
     18c:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockM;
	MyLastUnblockM = xTaskGetTickCount();
     18e:	0e 94 59 25 	call	0x4ab2	; 0x4ab2 <xTaskGetTickCount>
     192:	9a 83       	std	Y+2, r25	; 0x02
     194:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     196:	82 e0       	ldi	r24, 0x02	; 2
     198:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     19c:	8a e3       	ldi	r24, 0x3A	; 58
     19e:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     1a2:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     1a6:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     1aa:	6a e0       	ldi	r22, 0x0A	; 10
     1ac:	70 e0       	ldi	r23, 0x00	; 0
     1ae:	0e 94 65 1b 	call	0x36ca	; 0x36ca <xQueueSemaphoreTake>
     1b2:	88 23       	and	r24, r24
     1b4:	91 f0       	breq	.+36     	; 0x1da <Clock_Minute+0x5c>
		{
			LCD_Set_Block(minutes_position);
     1b6:	83 e0       	ldi	r24, 0x03	; 3
     1b8:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
			LCD_Void_Write_Number_2(Minutes);
     1bc:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <Minutes>
     1c0:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     1c4:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     1c8:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     1cc:	20 e0       	ldi	r18, 0x00	; 0
     1ce:	40 e0       	ldi	r20, 0x00	; 0
     1d0:	50 e0       	ldi	r21, 0x00	; 0
     1d2:	60 e0       	ldi	r22, 0x00	; 0
     1d4:	70 e0       	ldi	r23, 0x00	; 0
     1d6:	0e 94 4a 19 	call	0x3294	; 0x3294 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockM,minutes_frequency);
     1da:	6c e2       	ldi	r22, 0x2C	; 44
     1dc:	71 e0       	ldi	r23, 0x01	; 1
     1de:	ce 01       	movw	r24, r28
     1e0:	01 96       	adiw	r24, 0x01	; 1
     1e2:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <vTaskDelayUntil>
		Minutes++;
     1e6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <Minutes>
     1ea:	8f 5f       	subi	r24, 0xFF	; 255
     1ec:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <Minutes>
		Minutes %= 60;
     1f0:	90 91 bb 00 	lds	r25, 0x00BB	; 0x8000bb <Minutes>
     1f4:	89 e8       	ldi	r24, 0x89	; 137
     1f6:	98 9f       	mul	r25, r24
     1f8:	81 2d       	mov	r24, r1
     1fa:	11 24       	eor	r1, r1
     1fc:	82 95       	swap	r24
     1fe:	86 95       	lsr	r24
     200:	87 70       	andi	r24, 0x07	; 7
     202:	2c e3       	ldi	r18, 0x3C	; 60
     204:	82 9f       	mul	r24, r18
     206:	80 2d       	mov	r24, r0
     208:	11 24       	eor	r1, r1
     20a:	29 2f       	mov	r18, r25
     20c:	28 1b       	sub	r18, r24
     20e:	82 2f       	mov	r24, r18
     210:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <Minutes>
	}
     214:	c6 cf       	rjmp	.-116    	; 0x1a2 <Clock_Minute+0x24>

00000216 <Clock_Hours>:
}
void Clock_Hours(void *pvParameters)
{
     216:	cf 93       	push	r28
     218:	df 93       	push	r29
     21a:	00 d0       	rcall	.+0      	; 0x21c <Clock_Hours+0x6>
     21c:	00 d0       	rcall	.+0      	; 0x21e <Clock_Hours+0x8>
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
     222:	9c 83       	std	Y+4, r25	; 0x04
     224:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockH;
	MyLastUnblockH = xTaskGetTickCount();
     226:	0e 94 59 25 	call	0x4ab2	; 0x4ab2 <xTaskGetTickCount>
     22a:	9a 83       	std	Y+2, r25	; 0x02
     22c:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     22e:	82 e0       	ldi	r24, 0x02	; 2
     230:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     234:	8a e3       	ldi	r24, 0x3A	; 58
     236:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     23a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     23e:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     242:	6a e0       	ldi	r22, 0x0A	; 10
     244:	70 e0       	ldi	r23, 0x00	; 0
     246:	0e 94 65 1b 	call	0x36ca	; 0x36ca <xQueueSemaphoreTake>
     24a:	88 23       	and	r24, r24
     24c:	19 f1       	breq	.+70     	; 0x294 <Clock_Hours+0x7e>
		{
			LCD_Set_Block(hours_position);
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
			LCD_Void_Write_Number_2((Hours%12)+1);
     254:	20 91 bc 00 	lds	r18, 0x00BC	; 0x8000bc <Hours>
     258:	8b ea       	ldi	r24, 0xAB	; 171
     25a:	28 9f       	mul	r18, r24
     25c:	81 2d       	mov	r24, r1
     25e:	11 24       	eor	r1, r1
     260:	98 2f       	mov	r25, r24
     262:	96 95       	lsr	r25
     264:	96 95       	lsr	r25
     266:	96 95       	lsr	r25
     268:	89 2f       	mov	r24, r25
     26a:	88 0f       	add	r24, r24
     26c:	89 0f       	add	r24, r25
     26e:	88 0f       	add	r24, r24
     270:	88 0f       	add	r24, r24
     272:	92 2f       	mov	r25, r18
     274:	98 1b       	sub	r25, r24
     276:	81 e0       	ldi	r24, 0x01	; 1
     278:	89 0f       	add	r24, r25
     27a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     27e:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     282:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     286:	20 e0       	ldi	r18, 0x00	; 0
     288:	40 e0       	ldi	r20, 0x00	; 0
     28a:	50 e0       	ldi	r21, 0x00	; 0
     28c:	60 e0       	ldi	r22, 0x00	; 0
     28e:	70 e0       	ldi	r23, 0x00	; 0
     290:	0e 94 4a 19 	call	0x3294	; 0x3294 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockH,hours_frequency);
     294:	60 e5       	ldi	r22, 0x50	; 80
     296:	76 e4       	ldi	r23, 0x46	; 70
     298:	ce 01       	movw	r24, r28
     29a:	01 96       	adiw	r24, 0x01	; 1
     29c:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <vTaskDelayUntil>
		Hours++;
     2a0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <Hours>
     2a4:	8f 5f       	subi	r24, 0xFF	; 255
     2a6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <Hours>
		Hours %= 24;
     2aa:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <Hours>
     2ae:	8b ea       	ldi	r24, 0xAB	; 171
     2b0:	98 9f       	mul	r25, r24
     2b2:	81 2d       	mov	r24, r1
     2b4:	11 24       	eor	r1, r1
     2b6:	82 95       	swap	r24
     2b8:	8f 70       	andi	r24, 0x0F	; 15
     2ba:	28 e1       	ldi	r18, 0x18	; 24
     2bc:	82 9f       	mul	r24, r18
     2be:	80 2d       	mov	r24, r0
     2c0:	11 24       	eor	r1, r1
     2c2:	29 2f       	mov	r18, r25
     2c4:	28 1b       	sub	r18, r24
     2c6:	82 2f       	mov	r24, r18
     2c8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <Hours>
	}
     2cc:	b6 cf       	rjmp	.-148    	; 0x23a <Clock_Hours+0x24>

000002ce <Clock_Check_KPD>:
}

void Clock_Check_KPD(void *pvParameters)
{
     2ce:	cf 93       	push	r28
     2d0:	df 93       	push	r29
     2d2:	cd b7       	in	r28, 0x3d	; 61
     2d4:	de b7       	in	r29, 0x3e	; 62
     2d6:	65 97       	sbiw	r28, 0x15	; 21
     2d8:	0f b6       	in	r0, 0x3f	; 63
     2da:	f8 94       	cli
     2dc:	de bf       	out	0x3e, r29	; 62
     2de:	0f be       	out	0x3f, r0	; 63
     2e0:	cd bf       	out	0x3d, r28	; 61
     2e2:	9d 8b       	std	Y+21, r25	; 0x15
     2e4:	8c 8b       	std	Y+20, r24	; 0x14
	KPD_input = xQueueCreate(1,sizeof(u8));
     2e6:	40 e0       	ldi	r20, 0x00	; 0
     2e8:	61 e0       	ldi	r22, 0x01	; 1
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	0e 94 72 18 	call	0x30e4	; 0x30e4 <xQueueGenericCreate>
     2f0:	90 93 be 00 	sts	0x00BE, r25	; 0x8000be <KPD_input+0x1>
     2f4:	80 93 bd 00 	sts	0x00BD, r24	; 0x8000bd <KPD_input>
	TickType_t MyLastUnblockKPD;
	MyLastUnblockKPD = xTaskGetTickCount();
     2f8:	0e 94 59 25 	call	0x4ab2	; 0x4ab2 <xTaskGetTickCount>
     2fc:	9a 83       	std	Y+2, r25	; 0x02
     2fe:	89 83       	std	Y+1, r24	; 0x01
	u8 keys[16];
	u8 pressed;
	while(1)
	{	pressed = KBD_u8GetKeyPadState(keys);
     300:	ce 01       	movw	r24, r28
     302:	03 96       	adiw	r24, 0x03	; 3
     304:	0e 94 6d 05 	call	0xada	; 0xada <KBD_u8GetKeyPadState>
     308:	8b 8b       	std	Y+19, r24	; 0x13
		if(pressed != 0xff)
     30a:	8b 89       	ldd	r24, Y+19	; 0x13
     30c:	8f 3f       	cpi	r24, 0xFF	; 255
     30e:	61 f0       	breq	.+24     	; 0x328 <Clock_Check_KPD+0x5a>
		{
			xQueueSend(KPD_input,&pressed,10);
     310:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <KPD_input>
     314:	90 91 be 00 	lds	r25, 0x00BE	; 0x8000be <KPD_input+0x1>
     318:	be 01       	movw	r22, r28
     31a:	6d 5e       	subi	r22, 0xED	; 237
     31c:	7f 4f       	sbci	r23, 0xFF	; 255
     31e:	20 e0       	ldi	r18, 0x00	; 0
     320:	4a e0       	ldi	r20, 0x0A	; 10
     322:	50 e0       	ldi	r21, 0x00	; 0
     324:	0e 94 4a 19 	call	0x3294	; 0x3294 <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockKPD,KPD_Check_frequency);
     328:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <KPD_Check_frequency>
     32c:	88 2f       	mov	r24, r24
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	bc 01       	movw	r22, r24
     332:	ce 01       	movw	r24, r28
     334:	01 96       	adiw	r24, 0x01	; 1
     336:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <vTaskDelayUntil>
	}
     33a:	e2 cf       	rjmp	.-60     	; 0x300 <Clock_Check_KPD+0x32>

0000033c <Clock_Enter_Typing_Mode>:
}

void Clock_Enter_Typing_Mode(void *pvParameters)
{
     33c:	cf 93       	push	r28
     33e:	df 93       	push	r29
     340:	00 d0       	rcall	.+0      	; 0x342 <Clock_Enter_Typing_Mode+0x6>
     342:	00 d0       	rcall	.+0      	; 0x344 <Clock_Enter_Typing_Mode+0x8>
     344:	00 d0       	rcall	.+0      	; 0x346 <Clock_Enter_Typing_Mode+0xa>
     346:	cd b7       	in	r28, 0x3d	; 61
     348:	de b7       	in	r29, 0x3e	; 62
     34a:	9e 83       	std	Y+6, r25	; 0x06
     34c:	8d 83       	std	Y+5, r24	; 0x05
	u8 pressed  = 0xff;
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	8c 83       	std	Y+4, r24	; 0x04
	u8 take_lach = 0;
     352:	19 82       	std	Y+1, r1	; 0x01
	u8 current_block = 26;
     354:	8a e1       	ldi	r24, 0x1A	; 26
     356:	8b 83       	std	Y+3, r24	; 0x03
	u8 take_lcd = 0;
     358:	1a 82       	std	Y+2, r1	; 0x02
	while(1)
	{
		if(xQueueReceive(KPD_input,&pressed,10))
     35a:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <KPD_input>
     35e:	90 91 be 00 	lds	r25, 0x00BE	; 0x8000be <KPD_input+0x1>
     362:	9e 01       	movw	r18, r28
     364:	2c 5f       	subi	r18, 0xFC	; 252
     366:	3f 4f       	sbci	r19, 0xFF	; 255
     368:	4a e0       	ldi	r20, 0x0A	; 10
     36a:	50 e0       	ldi	r21, 0x00	; 0
     36c:	b9 01       	movw	r22, r18
     36e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <xQueueReceive>
     372:	88 23       	and	r24, r24
     374:	91 f3       	breq	.-28     	; 0x35a <Clock_Enter_Typing_Mode+0x1e>
		{
			if((take_lach)&&(pressed != '*'))
     376:	89 81       	ldd	r24, Y+1	; 0x01
     378:	88 23       	and	r24, r24
     37a:	51 f0       	breq	.+20     	; 0x390 <Clock_Enter_Typing_Mode+0x54>
     37c:	8c 81       	ldd	r24, Y+4	; 0x04
     37e:	8a 32       	cpi	r24, 0x2A	; 42
     380:	39 f0       	breq	.+14     	; 0x390 <Clock_Enter_Typing_Mode+0x54>
			{
				LCD_Set_Block(current_block);
     382:	8b 81       	ldd	r24, Y+3	; 0x03
     384:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
				LCD_Void_Write_Data(pressed);
     388:	8c 81       	ldd	r24, Y+4	; 0x04
     38a:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
				continue;
     38e:	48 c0       	rjmp	.+144    	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
			}
			switch (pressed)
     390:	8c 81       	ldd	r24, Y+4	; 0x04
     392:	88 2f       	mov	r24, r24
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	8a 97       	sbiw	r24, 0x2a	; 42
     398:	09 f0       	breq	.+2      	; 0x39c <Clock_Enter_Typing_Mode+0x60>
     39a:	42 c0       	rjmp	.+132    	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
			{
			case '*':
				if((take_lcd%2)==0)
     39c:	8a 81       	ldd	r24, Y+2	; 0x02
     39e:	81 70       	andi	r24, 0x01	; 1
     3a0:	88 23       	and	r24, r24
     3a2:	f1 f4       	brne	.+60     	; 0x3e0 <Clock_Enter_Typing_Mode+0xa4>
				{
					if(xSemaphoreTake(LCD,10))
     3a4:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     3a8:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     3ac:	6a e0       	ldi	r22, 0x0A	; 10
     3ae:	70 e0       	ldi	r23, 0x00	; 0
     3b0:	0e 94 65 1b 	call	0x36ca	; 0x36ca <xQueueSemaphoreTake>
     3b4:	88 23       	and	r24, r24
     3b6:	99 f1       	breq	.+102    	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
					{
						LCD_Set_Block(16);
     3b8:	80 e1       	ldi	r24, 0x10	; 16
     3ba:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
						LCD_Void_Write_String("taken  ");
     3be:	81 e7       	ldi	r24, 0x71	; 113
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	0e 94 95 0c 	call	0x192a	; 0x192a <LCD_Void_Write_String>
						take_lach = 1;
     3c6:	81 e0       	ldi	r24, 0x01	; 1
     3c8:	89 83       	std	Y+1, r24	; 0x01
						vTaskDelay(configTICK_RATE_HZ);
     3ca:	85 e0       	ldi	r24, 0x05	; 5
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <vTaskDelay>
						take_lcd++;
     3d2:	8a 81       	ldd	r24, Y+2	; 0x02
     3d4:	8f 5f       	subi	r24, 0xFF	; 255
     3d6:	8a 83       	std	Y+2, r24	; 0x02
						KPD_Check_frequency = 1;
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
					KPD_Check_frequency = configTICK_RATE_HZ*2;
					vTaskDelay(configTICK_RATE_HZ);
					take_lcd++;

				}
				break;
     3de:	1f c0       	rjmp	.+62     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>

					}
				}
				else
				{
					xSemaphoreGive(LCD);
     3e0:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <LCD>
     3e4:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <LCD+0x1>
     3e8:	20 e0       	ldi	r18, 0x00	; 0
     3ea:	40 e0       	ldi	r20, 0x00	; 0
     3ec:	50 e0       	ldi	r21, 0x00	; 0
     3ee:	60 e0       	ldi	r22, 0x00	; 0
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 4a 19 	call	0x3294	; 0x3294 <xQueueGenericSend>
					LCD_Set_Block(16);
     3f6:	80 e1       	ldi	r24, 0x10	; 16
     3f8:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
					LCD_Void_Write_String("released");
     3fc:	89 e7       	ldi	r24, 0x79	; 121
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	0e 94 95 0c 	call	0x192a	; 0x192a <LCD_Void_Write_String>
					take_lach = 0;
     404:	19 82       	std	Y+1, r1	; 0x01
					Clock_Print_Default_Interface();
     406:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
					KPD_Check_frequency = configTICK_RATE_HZ*2;
     40a:	8a e0       	ldi	r24, 0x0A	; 10
     40c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <KPD_Check_frequency>
					vTaskDelay(configTICK_RATE_HZ);
     410:	85 e0       	ldi	r24, 0x05	; 5
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <vTaskDelay>
					take_lcd++;
     418:	8a 81       	ldd	r24, Y+2	; 0x02
     41a:	8f 5f       	subi	r24, 0xFF	; 255
     41c:	8a 83       	std	Y+2, r24	; 0x02

				}
				break;
     41e:	00 00       	nop
			}

		}

	}
     420:	9c cf       	rjmp	.-200    	; 0x35a <Clock_Enter_Typing_Mode+0x1e>

00000422 <DIO_voidInitialize>:

/* Description: This function shall initialize the     */
/*              direction and initial value for DIO    */
/*              pins                                   */
void DIO_voidInitialize(void)
{
     422:	cf 93       	push	r28
     424:	df 93       	push	r29
     426:	cd b7       	in	r28, 0x3d	; 61
     428:	de b7       	in	r29, 0x3e	; 62
	DIO_u8_DDRA->ByteAccess = CONC_8BIT(DIO_u8_PIN0_DIR,
     42a:	8a e3       	ldi	r24, 0x3A	; 58
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	fc 01       	movw	r30, r24
     430:	10 82       	st	Z, r1
										DIO_u8_PIN4_DIR,
										DIO_u8_PIN5_DIR,
										DIO_u8_PIN6_DIR,
										DIO_u8_PIN7_DIR);

	DIO_u8_DDRB->ByteAccess = CONC_8BIT(DIO_u8_PIN8_DIR,
     432:	87 e3       	ldi	r24, 0x37	; 55
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	fc 01       	movw	r30, r24
     438:	10 82       	st	Z, r1
										DIO_u8_PIN12_DIR,
										DIO_u8_PIN13_DIR,
										DIO_u8_PIN14_DIR,
										DIO_u8_PIN15_DIR);

	DIO_u8_DDRC->ByteAccess = CONC_8BIT(DIO_u8_PIN16_DIR,
     43a:	84 e3       	ldi	r24, 0x34	; 52
     43c:	90 e0       	ldi	r25, 0x00	; 0
     43e:	fc 01       	movw	r30, r24
     440:	10 82       	st	Z, r1
										DIO_u8_PIN20_DIR,
										DIO_u8_PIN21_DIR,
										DIO_u8_PIN22_DIR,
										DIO_u8_PIN23_DIR);

	DIO_u8_DDRD->ByteAccess = CONC_8BIT(DIO_u8_PIN24_DIR,
     442:	81 e3       	ldi	r24, 0x31	; 49
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	fc 01       	movw	r30, r24
     448:	10 82       	st	Z, r1
										DIO_u8_PIN27_DIR,
										DIO_u8_PIN28_DIR,
										DIO_u8_PIN29_DIR,
										DIO_u8_PIN30_DIR,
										DIO_u8_PIN31_DIR);
}
     44a:	00 00       	nop
     44c:	df 91       	pop	r29
     44e:	cf 91       	pop	r28
     450:	08 95       	ret

00000452 <DIO_u8SetPinDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_pin           */
u8 DIO_u8SetPinDirection(u8 Copy_u8PinNB, u8 Copy_u8PinDirection)
{
     452:	cf 93       	push	r28
     454:	df 93       	push	r29
     456:	00 d0       	rcall	.+0      	; 0x458 <DIO_u8SetPinDirection+0x6>
     458:	00 d0       	rcall	.+0      	; 0x45a <DIO_u8SetPinDirection+0x8>
     45a:	1f 92       	push	r1
     45c:	cd b7       	in	r28, 0x3d	; 61
     45e:	de b7       	in	r29, 0x3e	; 62
     460:	8c 83       	std	Y+4, r24	; 0x04
     462:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     464:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     466:	8c 81       	ldd	r24, Y+4	; 0x04
     468:	80 32       	cpi	r24, 0x20	; 32
     46a:	18 f0       	brcs	.+6      	; 0x472 <DIO_u8SetPinDirection+0x20>
	{
		u8ErrorState = 1;
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	89 83       	std	Y+1, r24	; 0x01
     470:	dd c0       	rjmp	.+442    	; 0x62c <DIO_u8SetPinDirection+0x1da>
	}else if ((Copy_u8PinDirection != DIO_u8_INPUT) && (Copy_u8PinDirection != DIO_u8_OUTPUT))
     472:	8d 81       	ldd	r24, Y+5	; 0x05
     474:	88 23       	and	r24, r24
     476:	31 f0       	breq	.+12     	; 0x484 <DIO_u8SetPinDirection+0x32>
     478:	8d 81       	ldd	r24, Y+5	; 0x05
     47a:	81 30       	cpi	r24, 0x01	; 1
     47c:	19 f0       	breq	.+6      	; 0x484 <DIO_u8SetPinDirection+0x32>
	{
		u8ErrorState = 1;
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	89 83       	std	Y+1, r24	; 0x01
     482:	d4 c0       	rjmp	.+424    	; 0x62c <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     484:	8c 81       	ldd	r24, Y+4	; 0x04
     486:	86 95       	lsr	r24
     488:	86 95       	lsr	r24
     48a:	86 95       	lsr	r24
     48c:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     48e:	8c 81       	ldd	r24, Y+4	; 0x04
     490:	87 70       	andi	r24, 0x07	; 7
     492:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     494:	8a 81       	ldd	r24, Y+2	; 0x02
     496:	88 2f       	mov	r24, r24
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	81 30       	cpi	r24, 0x01	; 1
     49c:	91 05       	cpc	r25, r1
     49e:	e1 f1       	breq	.+120    	; 0x518 <DIO_u8SetPinDirection+0xc6>
     4a0:	82 30       	cpi	r24, 0x02	; 2
     4a2:	91 05       	cpc	r25, r1
     4a4:	1c f4       	brge	.+6      	; 0x4ac <DIO_u8SetPinDirection+0x5a>
     4a6:	89 2b       	or	r24, r25
     4a8:	49 f0       	breq	.+18     	; 0x4bc <DIO_u8SetPinDirection+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     4aa:	c0 c0       	rjmp	.+384    	; 0x62c <DIO_u8SetPinDirection+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     4ac:	82 30       	cpi	r24, 0x02	; 2
     4ae:	91 05       	cpc	r25, r1
     4b0:	09 f4       	brne	.+2      	; 0x4b4 <DIO_u8SetPinDirection+0x62>
     4b2:	60 c0       	rjmp	.+192    	; 0x574 <DIO_u8SetPinDirection+0x122>
     4b4:	03 97       	sbiw	r24, 0x03	; 3
     4b6:	09 f4       	brne	.+2      	; 0x4ba <DIO_u8SetPinDirection+0x68>
     4b8:	8b c0       	rjmp	.+278    	; 0x5d0 <DIO_u8SetPinDirection+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     4ba:	b8 c0       	rjmp	.+368    	; 0x62c <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     4bc:	8d 81       	ldd	r24, Y+5	; 0x05
     4be:	81 30       	cpi	r24, 0x01	; 1
     4c0:	a9 f4       	brne	.+42     	; 0x4ec <DIO_u8SetPinDirection+0x9a>
     4c2:	8a e3       	ldi	r24, 0x3A	; 58
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	2a e3       	ldi	r18, 0x3A	; 58
     4c8:	30 e0       	ldi	r19, 0x00	; 0
     4ca:	f9 01       	movw	r30, r18
     4cc:	20 81       	ld	r18, Z
     4ce:	62 2f       	mov	r22, r18
     4d0:	2b 81       	ldd	r18, Y+3	; 0x03
     4d2:	42 2f       	mov	r20, r18
     4d4:	50 e0       	ldi	r21, 0x00	; 0
     4d6:	21 e0       	ldi	r18, 0x01	; 1
     4d8:	30 e0       	ldi	r19, 0x00	; 0
     4da:	02 c0       	rjmp	.+4      	; 0x4e0 <DIO_u8SetPinDirection+0x8e>
     4dc:	22 0f       	add	r18, r18
     4de:	33 1f       	adc	r19, r19
     4e0:	4a 95       	dec	r20
     4e2:	e2 f7       	brpl	.-8      	; 0x4dc <DIO_u8SetPinDirection+0x8a>
     4e4:	26 2b       	or	r18, r22
     4e6:	fc 01       	movw	r30, r24
     4e8:	20 83       	st	Z, r18
			break;
     4ea:	a0 c0       	rjmp	.+320    	; 0x62c <DIO_u8SetPinDirection+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     4ec:	8a e3       	ldi	r24, 0x3A	; 58
     4ee:	90 e0       	ldi	r25, 0x00	; 0
     4f0:	2a e3       	ldi	r18, 0x3A	; 58
     4f2:	30 e0       	ldi	r19, 0x00	; 0
     4f4:	f9 01       	movw	r30, r18
     4f6:	20 81       	ld	r18, Z
     4f8:	62 2f       	mov	r22, r18
     4fa:	2b 81       	ldd	r18, Y+3	; 0x03
     4fc:	42 2f       	mov	r20, r18
     4fe:	50 e0       	ldi	r21, 0x00	; 0
     500:	21 e0       	ldi	r18, 0x01	; 1
     502:	30 e0       	ldi	r19, 0x00	; 0
     504:	02 c0       	rjmp	.+4      	; 0x50a <DIO_u8SetPinDirection+0xb8>
     506:	22 0f       	add	r18, r18
     508:	33 1f       	adc	r19, r19
     50a:	4a 95       	dec	r20
     50c:	e2 f7       	brpl	.-8      	; 0x506 <DIO_u8SetPinDirection+0xb4>
     50e:	20 95       	com	r18
     510:	26 23       	and	r18, r22
     512:	fc 01       	movw	r30, r24
     514:	20 83       	st	Z, r18
			break;
     516:	8a c0       	rjmp	.+276    	; 0x62c <DIO_u8SetPinDirection+0x1da>
		case GROUP_B :
			if(Copy_u8PinDirection == DIO_u8_INPUT)
     518:	8d 81       	ldd	r24, Y+5	; 0x05
     51a:	88 23       	and	r24, r24
     51c:	b1 f4       	brne	.+44     	; 0x54a <DIO_u8SetPinDirection+0xf8>
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     51e:	87 e3       	ldi	r24, 0x37	; 55
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	27 e3       	ldi	r18, 0x37	; 55
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	f9 01       	movw	r30, r18
     528:	20 81       	ld	r18, Z
     52a:	62 2f       	mov	r22, r18
     52c:	2b 81       	ldd	r18, Y+3	; 0x03
     52e:	42 2f       	mov	r20, r18
     530:	50 e0       	ldi	r21, 0x00	; 0
     532:	21 e0       	ldi	r18, 0x01	; 1
     534:	30 e0       	ldi	r19, 0x00	; 0
     536:	02 c0       	rjmp	.+4      	; 0x53c <DIO_u8SetPinDirection+0xea>
     538:	22 0f       	add	r18, r18
     53a:	33 1f       	adc	r19, r19
     53c:	4a 95       	dec	r20
     53e:	e2 f7       	brpl	.-8      	; 0x538 <DIO_u8SetPinDirection+0xe6>
     540:	20 95       	com	r18
     542:	26 23       	and	r18, r22
     544:	fc 01       	movw	r30, r24
     546:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
     548:	71 c0       	rjmp	.+226    	; 0x62c <DIO_u8SetPinDirection+0x1da>
			if(Copy_u8PinDirection == DIO_u8_INPUT)
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     54a:	87 e3       	ldi	r24, 0x37	; 55
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	27 e3       	ldi	r18, 0x37	; 55
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	f9 01       	movw	r30, r18
     554:	20 81       	ld	r18, Z
     556:	62 2f       	mov	r22, r18
     558:	2b 81       	ldd	r18, Y+3	; 0x03
     55a:	42 2f       	mov	r20, r18
     55c:	50 e0       	ldi	r21, 0x00	; 0
     55e:	21 e0       	ldi	r18, 0x01	; 1
     560:	30 e0       	ldi	r19, 0x00	; 0
     562:	02 c0       	rjmp	.+4      	; 0x568 <DIO_u8SetPinDirection+0x116>
     564:	22 0f       	add	r18, r18
     566:	33 1f       	adc	r19, r19
     568:	4a 95       	dec	r20
     56a:	e2 f7       	brpl	.-8      	; 0x564 <DIO_u8SetPinDirection+0x112>
     56c:	26 2b       	or	r18, r22
     56e:	fc 01       	movw	r30, r24
     570:	20 83       	st	Z, r18
			}
			break;
     572:	5c c0       	rjmp	.+184    	; 0x62c <DIO_u8SetPinDirection+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     574:	8d 81       	ldd	r24, Y+5	; 0x05
     576:	81 30       	cpi	r24, 0x01	; 1
     578:	a9 f4       	brne	.+42     	; 0x5a4 <DIO_u8SetPinDirection+0x152>
     57a:	84 e3       	ldi	r24, 0x34	; 52
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	24 e3       	ldi	r18, 0x34	; 52
     580:	30 e0       	ldi	r19, 0x00	; 0
     582:	f9 01       	movw	r30, r18
     584:	20 81       	ld	r18, Z
     586:	62 2f       	mov	r22, r18
     588:	2b 81       	ldd	r18, Y+3	; 0x03
     58a:	42 2f       	mov	r20, r18
     58c:	50 e0       	ldi	r21, 0x00	; 0
     58e:	21 e0       	ldi	r18, 0x01	; 1
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	02 c0       	rjmp	.+4      	; 0x598 <DIO_u8SetPinDirection+0x146>
     594:	22 0f       	add	r18, r18
     596:	33 1f       	adc	r19, r19
     598:	4a 95       	dec	r20
     59a:	e2 f7       	brpl	.-8      	; 0x594 <DIO_u8SetPinDirection+0x142>
     59c:	26 2b       	or	r18, r22
     59e:	fc 01       	movw	r30, r24
     5a0:	20 83       	st	Z, r18
			break;
     5a2:	44 c0       	rjmp	.+136    	; 0x62c <DIO_u8SetPinDirection+0x1da>
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     5a4:	84 e3       	ldi	r24, 0x34	; 52
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	24 e3       	ldi	r18, 0x34	; 52
     5aa:	30 e0       	ldi	r19, 0x00	; 0
     5ac:	f9 01       	movw	r30, r18
     5ae:	20 81       	ld	r18, Z
     5b0:	62 2f       	mov	r22, r18
     5b2:	2b 81       	ldd	r18, Y+3	; 0x03
     5b4:	42 2f       	mov	r20, r18
     5b6:	50 e0       	ldi	r21, 0x00	; 0
     5b8:	21 e0       	ldi	r18, 0x01	; 1
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	02 c0       	rjmp	.+4      	; 0x5c2 <DIO_u8SetPinDirection+0x170>
     5be:	22 0f       	add	r18, r18
     5c0:	33 1f       	adc	r19, r19
     5c2:	4a 95       	dec	r20
     5c4:	e2 f7       	brpl	.-8      	; 0x5be <DIO_u8SetPinDirection+0x16c>
     5c6:	20 95       	com	r18
     5c8:	26 23       	and	r18, r22
     5ca:	fc 01       	movw	r30, r24
     5cc:	20 83       	st	Z, r18
			break;
     5ce:	2e c0       	rjmp	.+92     	; 0x62c <DIO_u8SetPinDirection+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     5d0:	8d 81       	ldd	r24, Y+5	; 0x05
     5d2:	81 30       	cpi	r24, 0x01	; 1
     5d4:	a9 f4       	brne	.+42     	; 0x600 <DIO_u8SetPinDirection+0x1ae>
     5d6:	81 e3       	ldi	r24, 0x31	; 49
     5d8:	90 e0       	ldi	r25, 0x00	; 0
     5da:	21 e3       	ldi	r18, 0x31	; 49
     5dc:	30 e0       	ldi	r19, 0x00	; 0
     5de:	f9 01       	movw	r30, r18
     5e0:	20 81       	ld	r18, Z
     5e2:	62 2f       	mov	r22, r18
     5e4:	2b 81       	ldd	r18, Y+3	; 0x03
     5e6:	42 2f       	mov	r20, r18
     5e8:	50 e0       	ldi	r21, 0x00	; 0
     5ea:	21 e0       	ldi	r18, 0x01	; 1
     5ec:	30 e0       	ldi	r19, 0x00	; 0
     5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <DIO_u8SetPinDirection+0x1a2>
     5f0:	22 0f       	add	r18, r18
     5f2:	33 1f       	adc	r19, r19
     5f4:	4a 95       	dec	r20
     5f6:	e2 f7       	brpl	.-8      	; 0x5f0 <DIO_u8SetPinDirection+0x19e>
     5f8:	26 2b       	or	r18, r22
     5fa:	fc 01       	movw	r30, r24
     5fc:	20 83       	st	Z, r18
			break;
     5fe:	15 c0       	rjmp	.+42     	; 0x62a <DIO_u8SetPinDirection+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     600:	81 e3       	ldi	r24, 0x31	; 49
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	21 e3       	ldi	r18, 0x31	; 49
     606:	30 e0       	ldi	r19, 0x00	; 0
     608:	f9 01       	movw	r30, r18
     60a:	20 81       	ld	r18, Z
     60c:	62 2f       	mov	r22, r18
     60e:	2b 81       	ldd	r18, Y+3	; 0x03
     610:	42 2f       	mov	r20, r18
     612:	50 e0       	ldi	r21, 0x00	; 0
     614:	21 e0       	ldi	r18, 0x01	; 1
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	02 c0       	rjmp	.+4      	; 0x61e <DIO_u8SetPinDirection+0x1cc>
     61a:	22 0f       	add	r18, r18
     61c:	33 1f       	adc	r19, r19
     61e:	4a 95       	dec	r20
     620:	e2 f7       	brpl	.-8      	; 0x61a <DIO_u8SetPinDirection+0x1c8>
     622:	20 95       	com	r18
     624:	26 23       	and	r18, r22
     626:	fc 01       	movw	r30, r24
     628:	20 83       	st	Z, r18
			break;
     62a:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     62c:	89 81       	ldd	r24, Y+1	; 0x01
}
     62e:	0f 90       	pop	r0
     630:	0f 90       	pop	r0
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	df 91       	pop	r29
     63a:	cf 91       	pop	r28
     63c:	08 95       	ret

0000063e <DIO_u8SetPinValue>:
/* Description: This function shall set certain value  */
/*              to certain DIO pin                     */
u8 DIO_u8SetPinValue(u8 Copy_u8PinNB, u8 Copy_u8PinValue)
{
     63e:	cf 93       	push	r28
     640:	df 93       	push	r29
     642:	00 d0       	rcall	.+0      	; 0x644 <DIO_u8SetPinValue+0x6>
     644:	00 d0       	rcall	.+0      	; 0x646 <DIO_u8SetPinValue+0x8>
     646:	1f 92       	push	r1
     648:	cd b7       	in	r28, 0x3d	; 61
     64a:	de b7       	in	r29, 0x3e	; 62
     64c:	8c 83       	std	Y+4, r24	; 0x04
     64e:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     650:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     652:	8c 81       	ldd	r24, Y+4	; 0x04
     654:	80 32       	cpi	r24, 0x20	; 32
     656:	18 f0       	brcs	.+6      	; 0x65e <DIO_u8SetPinValue+0x20>
	{
		u8ErrorState = 1;
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	89 83       	std	Y+1, r24	; 0x01
     65c:	dd c0       	rjmp	.+442    	; 0x818 <DIO_u8SetPinValue+0x1da>
	}else if ((Copy_u8PinValue != DIO_u8_HIGH) && (Copy_u8PinValue != DIO_u8_LOW))
     65e:	8d 81       	ldd	r24, Y+5	; 0x05
     660:	81 30       	cpi	r24, 0x01	; 1
     662:	31 f0       	breq	.+12     	; 0x670 <DIO_u8SetPinValue+0x32>
     664:	8d 81       	ldd	r24, Y+5	; 0x05
     666:	88 23       	and	r24, r24
     668:	19 f0       	breq	.+6      	; 0x670 <DIO_u8SetPinValue+0x32>
	{
		u8ErrorState = 1;
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	89 83       	std	Y+1, r24	; 0x01
     66e:	d4 c0       	rjmp	.+424    	; 0x818 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     670:	8c 81       	ldd	r24, Y+4	; 0x04
     672:	86 95       	lsr	r24
     674:	86 95       	lsr	r24
     676:	86 95       	lsr	r24
     678:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     67a:	8c 81       	ldd	r24, Y+4	; 0x04
     67c:	87 70       	andi	r24, 0x07	; 7
     67e:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     680:	8a 81       	ldd	r24, Y+2	; 0x02
     682:	88 2f       	mov	r24, r24
     684:	90 e0       	ldi	r25, 0x00	; 0
     686:	81 30       	cpi	r24, 0x01	; 1
     688:	91 05       	cpc	r25, r1
     68a:	e1 f1       	breq	.+120    	; 0x704 <DIO_u8SetPinValue+0xc6>
     68c:	82 30       	cpi	r24, 0x02	; 2
     68e:	91 05       	cpc	r25, r1
     690:	1c f4       	brge	.+6      	; 0x698 <DIO_u8SetPinValue+0x5a>
     692:	89 2b       	or	r24, r25
     694:	49 f0       	breq	.+18     	; 0x6a8 <DIO_u8SetPinValue+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     696:	c0 c0       	rjmp	.+384    	; 0x818 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     698:	82 30       	cpi	r24, 0x02	; 2
     69a:	91 05       	cpc	r25, r1
     69c:	09 f4       	brne	.+2      	; 0x6a0 <DIO_u8SetPinValue+0x62>
     69e:	60 c0       	rjmp	.+192    	; 0x760 <DIO_u8SetPinValue+0x122>
     6a0:	03 97       	sbiw	r24, 0x03	; 3
     6a2:	09 f4       	brne	.+2      	; 0x6a6 <DIO_u8SetPinValue+0x68>
     6a4:	8b c0       	rjmp	.+278    	; 0x7bc <DIO_u8SetPinValue+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     6a6:	b8 c0       	rjmp	.+368    	; 0x818 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     6a8:	8d 81       	ldd	r24, Y+5	; 0x05
     6aa:	81 30       	cpi	r24, 0x01	; 1
     6ac:	a9 f4       	brne	.+42     	; 0x6d8 <DIO_u8SetPinValue+0x9a>
     6ae:	8b e3       	ldi	r24, 0x3B	; 59
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	2b e3       	ldi	r18, 0x3B	; 59
     6b4:	30 e0       	ldi	r19, 0x00	; 0
     6b6:	f9 01       	movw	r30, r18
     6b8:	20 81       	ld	r18, Z
     6ba:	62 2f       	mov	r22, r18
     6bc:	2b 81       	ldd	r18, Y+3	; 0x03
     6be:	42 2f       	mov	r20, r18
     6c0:	50 e0       	ldi	r21, 0x00	; 0
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	02 c0       	rjmp	.+4      	; 0x6cc <DIO_u8SetPinValue+0x8e>
     6c8:	22 0f       	add	r18, r18
     6ca:	33 1f       	adc	r19, r19
     6cc:	4a 95       	dec	r20
     6ce:	e2 f7       	brpl	.-8      	; 0x6c8 <DIO_u8SetPinValue+0x8a>
     6d0:	26 2b       	or	r18, r22
     6d2:	fc 01       	movw	r30, r24
     6d4:	20 83       	st	Z, r18
			break;
     6d6:	a0 c0       	rjmp	.+320    	; 0x818 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     6d8:	8b e3       	ldi	r24, 0x3B	; 59
     6da:	90 e0       	ldi	r25, 0x00	; 0
     6dc:	2b e3       	ldi	r18, 0x3B	; 59
     6de:	30 e0       	ldi	r19, 0x00	; 0
     6e0:	f9 01       	movw	r30, r18
     6e2:	20 81       	ld	r18, Z
     6e4:	62 2f       	mov	r22, r18
     6e6:	2b 81       	ldd	r18, Y+3	; 0x03
     6e8:	42 2f       	mov	r20, r18
     6ea:	50 e0       	ldi	r21, 0x00	; 0
     6ec:	21 e0       	ldi	r18, 0x01	; 1
     6ee:	30 e0       	ldi	r19, 0x00	; 0
     6f0:	02 c0       	rjmp	.+4      	; 0x6f6 <DIO_u8SetPinValue+0xb8>
     6f2:	22 0f       	add	r18, r18
     6f4:	33 1f       	adc	r19, r19
     6f6:	4a 95       	dec	r20
     6f8:	e2 f7       	brpl	.-8      	; 0x6f2 <DIO_u8SetPinValue+0xb4>
     6fa:	20 95       	com	r18
     6fc:	26 23       	and	r18, r22
     6fe:	fc 01       	movw	r30, r24
     700:	20 83       	st	Z, r18
			break;
     702:	8a c0       	rjmp	.+276    	; 0x818 <DIO_u8SetPinValue+0x1da>
		case GROUP_B :
			if(Copy_u8PinValue == DIO_u8_LOW)
     704:	8d 81       	ldd	r24, Y+5	; 0x05
     706:	88 23       	and	r24, r24
     708:	b1 f4       	brne	.+44     	; 0x736 <DIO_u8SetPinValue+0xf8>
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     70a:	88 e3       	ldi	r24, 0x38	; 56
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	28 e3       	ldi	r18, 0x38	; 56
     710:	30 e0       	ldi	r19, 0x00	; 0
     712:	f9 01       	movw	r30, r18
     714:	20 81       	ld	r18, Z
     716:	62 2f       	mov	r22, r18
     718:	2b 81       	ldd	r18, Y+3	; 0x03
     71a:	42 2f       	mov	r20, r18
     71c:	50 e0       	ldi	r21, 0x00	; 0
     71e:	21 e0       	ldi	r18, 0x01	; 1
     720:	30 e0       	ldi	r19, 0x00	; 0
     722:	02 c0       	rjmp	.+4      	; 0x728 <DIO_u8SetPinValue+0xea>
     724:	22 0f       	add	r18, r18
     726:	33 1f       	adc	r19, r19
     728:	4a 95       	dec	r20
     72a:	e2 f7       	brpl	.-8      	; 0x724 <DIO_u8SetPinValue+0xe6>
     72c:	20 95       	com	r18
     72e:	26 23       	and	r18, r22
     730:	fc 01       	movw	r30, r24
     732:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
     734:	71 c0       	rjmp	.+226    	; 0x818 <DIO_u8SetPinValue+0x1da>
			if(Copy_u8PinValue == DIO_u8_LOW)
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     736:	88 e3       	ldi	r24, 0x38	; 56
     738:	90 e0       	ldi	r25, 0x00	; 0
     73a:	28 e3       	ldi	r18, 0x38	; 56
     73c:	30 e0       	ldi	r19, 0x00	; 0
     73e:	f9 01       	movw	r30, r18
     740:	20 81       	ld	r18, Z
     742:	62 2f       	mov	r22, r18
     744:	2b 81       	ldd	r18, Y+3	; 0x03
     746:	42 2f       	mov	r20, r18
     748:	50 e0       	ldi	r21, 0x00	; 0
     74a:	21 e0       	ldi	r18, 0x01	; 1
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	02 c0       	rjmp	.+4      	; 0x754 <DIO_u8SetPinValue+0x116>
     750:	22 0f       	add	r18, r18
     752:	33 1f       	adc	r19, r19
     754:	4a 95       	dec	r20
     756:	e2 f7       	brpl	.-8      	; 0x750 <DIO_u8SetPinValue+0x112>
     758:	26 2b       	or	r18, r22
     75a:	fc 01       	movw	r30, r24
     75c:	20 83       	st	Z, r18
			}
			break;
     75e:	5c c0       	rjmp	.+184    	; 0x818 <DIO_u8SetPinValue+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     760:	8d 81       	ldd	r24, Y+5	; 0x05
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	a9 f4       	brne	.+42     	; 0x790 <DIO_u8SetPinValue+0x152>
     766:	85 e3       	ldi	r24, 0x35	; 53
     768:	90 e0       	ldi	r25, 0x00	; 0
     76a:	25 e3       	ldi	r18, 0x35	; 53
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	f9 01       	movw	r30, r18
     770:	20 81       	ld	r18, Z
     772:	62 2f       	mov	r22, r18
     774:	2b 81       	ldd	r18, Y+3	; 0x03
     776:	42 2f       	mov	r20, r18
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	21 e0       	ldi	r18, 0x01	; 1
     77c:	30 e0       	ldi	r19, 0x00	; 0
     77e:	02 c0       	rjmp	.+4      	; 0x784 <DIO_u8SetPinValue+0x146>
     780:	22 0f       	add	r18, r18
     782:	33 1f       	adc	r19, r19
     784:	4a 95       	dec	r20
     786:	e2 f7       	brpl	.-8      	; 0x780 <DIO_u8SetPinValue+0x142>
     788:	26 2b       	or	r18, r22
     78a:	fc 01       	movw	r30, r24
     78c:	20 83       	st	Z, r18
			break;
     78e:	44 c0       	rjmp	.+136    	; 0x818 <DIO_u8SetPinValue+0x1da>
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     790:	85 e3       	ldi	r24, 0x35	; 53
     792:	90 e0       	ldi	r25, 0x00	; 0
     794:	25 e3       	ldi	r18, 0x35	; 53
     796:	30 e0       	ldi	r19, 0x00	; 0
     798:	f9 01       	movw	r30, r18
     79a:	20 81       	ld	r18, Z
     79c:	62 2f       	mov	r22, r18
     79e:	2b 81       	ldd	r18, Y+3	; 0x03
     7a0:	42 2f       	mov	r20, r18
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	21 e0       	ldi	r18, 0x01	; 1
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	02 c0       	rjmp	.+4      	; 0x7ae <DIO_u8SetPinValue+0x170>
     7aa:	22 0f       	add	r18, r18
     7ac:	33 1f       	adc	r19, r19
     7ae:	4a 95       	dec	r20
     7b0:	e2 f7       	brpl	.-8      	; 0x7aa <DIO_u8SetPinValue+0x16c>
     7b2:	20 95       	com	r18
     7b4:	26 23       	and	r18, r22
     7b6:	fc 01       	movw	r30, r24
     7b8:	20 83       	st	Z, r18
			break;
     7ba:	2e c0       	rjmp	.+92     	; 0x818 <DIO_u8SetPinValue+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     7bc:	8d 81       	ldd	r24, Y+5	; 0x05
     7be:	81 30       	cpi	r24, 0x01	; 1
     7c0:	a9 f4       	brne	.+42     	; 0x7ec <DIO_u8SetPinValue+0x1ae>
     7c2:	82 e3       	ldi	r24, 0x32	; 50
     7c4:	90 e0       	ldi	r25, 0x00	; 0
     7c6:	22 e3       	ldi	r18, 0x32	; 50
     7c8:	30 e0       	ldi	r19, 0x00	; 0
     7ca:	f9 01       	movw	r30, r18
     7cc:	20 81       	ld	r18, Z
     7ce:	62 2f       	mov	r22, r18
     7d0:	2b 81       	ldd	r18, Y+3	; 0x03
     7d2:	42 2f       	mov	r20, r18
     7d4:	50 e0       	ldi	r21, 0x00	; 0
     7d6:	21 e0       	ldi	r18, 0x01	; 1
     7d8:	30 e0       	ldi	r19, 0x00	; 0
     7da:	02 c0       	rjmp	.+4      	; 0x7e0 <DIO_u8SetPinValue+0x1a2>
     7dc:	22 0f       	add	r18, r18
     7de:	33 1f       	adc	r19, r19
     7e0:	4a 95       	dec	r20
     7e2:	e2 f7       	brpl	.-8      	; 0x7dc <DIO_u8SetPinValue+0x19e>
     7e4:	26 2b       	or	r18, r22
     7e6:	fc 01       	movw	r30, r24
     7e8:	20 83       	st	Z, r18
			break;
     7ea:	15 c0       	rjmp	.+42     	; 0x816 <DIO_u8SetPinValue+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     7ec:	82 e3       	ldi	r24, 0x32	; 50
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	22 e3       	ldi	r18, 0x32	; 50
     7f2:	30 e0       	ldi	r19, 0x00	; 0
     7f4:	f9 01       	movw	r30, r18
     7f6:	20 81       	ld	r18, Z
     7f8:	62 2f       	mov	r22, r18
     7fa:	2b 81       	ldd	r18, Y+3	; 0x03
     7fc:	42 2f       	mov	r20, r18
     7fe:	50 e0       	ldi	r21, 0x00	; 0
     800:	21 e0       	ldi	r18, 0x01	; 1
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	02 c0       	rjmp	.+4      	; 0x80a <DIO_u8SetPinValue+0x1cc>
     806:	22 0f       	add	r18, r18
     808:	33 1f       	adc	r19, r19
     80a:	4a 95       	dec	r20
     80c:	e2 f7       	brpl	.-8      	; 0x806 <DIO_u8SetPinValue+0x1c8>
     80e:	20 95       	com	r18
     810:	26 23       	and	r18, r22
     812:	fc 01       	movw	r30, r24
     814:	20 83       	st	Z, r18
			break;
     816:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     818:	89 81       	ldd	r24, Y+1	; 0x01
}
     81a:	0f 90       	pop	r0
     81c:	0f 90       	pop	r0
     81e:	0f 90       	pop	r0
     820:	0f 90       	pop	r0
     822:	0f 90       	pop	r0
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	08 95       	ret

0000082a <DIO_u8SetPortDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_port          */
u8 DIO_u8SetPortDirection(u8 Copy_u8PortNB, u8 Copy_u8PortDirection)
{
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	00 d0       	rcall	.+0      	; 0x830 <DIO_u8SetPortDirection+0x6>
     830:	1f 92       	push	r1
     832:	cd b7       	in	r28, 0x3d	; 61
     834:	de b7       	in	r29, 0x3e	; 62
     836:	8a 83       	std	Y+2, r24	; 0x02
     838:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     83a:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
		if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     83c:	8a 81       	ldd	r24, Y+2	; 0x02
     83e:	84 30       	cpi	r24, 0x04	; 4
     840:	18 f0       	brcs	.+6      	; 0x848 <DIO_u8SetPortDirection+0x1e>
		{
			u8ErrorState = 1;
     842:	81 e0       	ldi	r24, 0x01	; 1
     844:	89 83       	std	Y+1, r24	; 0x01
     846:	2a c0       	rjmp	.+84     	; 0x89c <__stack+0x3d>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     848:	8a 81       	ldd	r24, Y+2	; 0x02
     84a:	88 2f       	mov	r24, r24
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	81 30       	cpi	r24, 0x01	; 1
     850:	91 05       	cpc	r25, r1
     852:	91 f0       	breq	.+36     	; 0x878 <__stack+0x19>
     854:	82 30       	cpi	r24, 0x02	; 2
     856:	91 05       	cpc	r25, r1
     858:	1c f4       	brge	.+6      	; 0x860 <__stack+0x1>
     85a:	89 2b       	or	r24, r25
     85c:	39 f0       	breq	.+14     	; 0x86c <__stack+0xd>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     85e:	1e c0       	rjmp	.+60     	; 0x89c <__stack+0x3d>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     860:	82 30       	cpi	r24, 0x02	; 2
     862:	91 05       	cpc	r25, r1
     864:	79 f0       	breq	.+30     	; 0x884 <__stack+0x25>
     866:	03 97       	sbiw	r24, 0x03	; 3
     868:	99 f0       	breq	.+38     	; 0x890 <__stack+0x31>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     86a:	18 c0       	rjmp	.+48     	; 0x89c <__stack+0x3d>
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
			{
			case GROUP_A :
				DIO_u8_DDRA->ByteAccess = Copy_u8PortDirection;
     86c:	8a e3       	ldi	r24, 0x3A	; 58
     86e:	90 e0       	ldi	r25, 0x00	; 0
     870:	2b 81       	ldd	r18, Y+3	; 0x03
     872:	fc 01       	movw	r30, r24
     874:	20 83       	st	Z, r18
				break;
     876:	12 c0       	rjmp	.+36     	; 0x89c <__stack+0x3d>
			case GROUP_B :
				DIO_u8_DDRB->ByteAccess = Copy_u8PortDirection;
     878:	87 e3       	ldi	r24, 0x37	; 55
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	2b 81       	ldd	r18, Y+3	; 0x03
     87e:	fc 01       	movw	r30, r24
     880:	20 83       	st	Z, r18
				break;
     882:	0c c0       	rjmp	.+24     	; 0x89c <__stack+0x3d>
			case GROUP_C :
				DIO_u8_DDRC->ByteAccess = Copy_u8PortDirection;
     884:	84 e3       	ldi	r24, 0x34	; 52
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	2b 81       	ldd	r18, Y+3	; 0x03
     88a:	fc 01       	movw	r30, r24
     88c:	20 83       	st	Z, r18
				break;
     88e:	06 c0       	rjmp	.+12     	; 0x89c <__stack+0x3d>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
     890:	81 e3       	ldi	r24, 0x31	; 49
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	2b 81       	ldd	r18, Y+3	; 0x03
     896:	fc 01       	movw	r30, r24
     898:	20 83       	st	Z, r18
				break;
     89a:	00 00       	nop

				break;
			}
		}
	/*Function return*/
	return u8ErrorState;
     89c:	89 81       	ldd	r24, Y+1	; 0x01
}
     89e:	0f 90       	pop	r0
     8a0:	0f 90       	pop	r0
     8a2:	0f 90       	pop	r0
     8a4:	df 91       	pop	r29
     8a6:	cf 91       	pop	r28
     8a8:	08 95       	ret

000008aa <DIO_u8SetPortValue>:

/* Description: This function shall set certain        */
/*              value to certain DIO_port              */
u8 DIO_u8SetPortValue(u8 Copy_u8PortNB, u8 Copy_u8PortValue)
{
     8aa:	cf 93       	push	r28
     8ac:	df 93       	push	r29
     8ae:	00 d0       	rcall	.+0      	; 0x8b0 <DIO_u8SetPortValue+0x6>
     8b0:	1f 92       	push	r1
     8b2:	cd b7       	in	r28, 0x3d	; 61
     8b4:	de b7       	in	r29, 0x3e	; 62
     8b6:	8a 83       	std	Y+2, r24	; 0x02
     8b8:	6b 83       	std	Y+3, r22	; 0x03
		/*Local variables*/
		u8 u8ErrorState = 0;
     8ba:	19 82       	std	Y+1, r1	; 0x01

		/*validate inputs*/
			if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     8bc:	8a 81       	ldd	r24, Y+2	; 0x02
     8be:	84 30       	cpi	r24, 0x04	; 4
     8c0:	18 f0       	brcs	.+6      	; 0x8c8 <DIO_u8SetPortValue+0x1e>
			{
				u8ErrorState = 1;
     8c2:	81 e0       	ldi	r24, 0x01	; 1
     8c4:	89 83       	std	Y+1, r24	; 0x01
     8c6:	2a c0       	rjmp	.+84     	; 0x91c <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     8c8:	8a 81       	ldd	r24, Y+2	; 0x02
     8ca:	88 2f       	mov	r24, r24
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	81 30       	cpi	r24, 0x01	; 1
     8d0:	91 05       	cpc	r25, r1
     8d2:	91 f0       	breq	.+36     	; 0x8f8 <DIO_u8SetPortValue+0x4e>
     8d4:	82 30       	cpi	r24, 0x02	; 2
     8d6:	91 05       	cpc	r25, r1
     8d8:	1c f4       	brge	.+6      	; 0x8e0 <DIO_u8SetPortValue+0x36>
     8da:	89 2b       	or	r24, r25
     8dc:	39 f0       	breq	.+14     	; 0x8ec <DIO_u8SetPortValue+0x42>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     8de:	1e c0       	rjmp	.+60     	; 0x91c <DIO_u8SetPortValue+0x72>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     8e0:	82 30       	cpi	r24, 0x02	; 2
     8e2:	91 05       	cpc	r25, r1
     8e4:	79 f0       	breq	.+30     	; 0x904 <DIO_u8SetPortValue+0x5a>
     8e6:	03 97       	sbiw	r24, 0x03	; 3
     8e8:	99 f0       	breq	.+38     	; 0x910 <DIO_u8SetPortValue+0x66>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     8ea:	18 c0       	rjmp	.+48     	; 0x91c <DIO_u8SetPortValue+0x72>
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
				{
				case GROUP_A :
					DIO_u8_PORTA->ByteAccess = Copy_u8PortValue;
     8ec:	8b e3       	ldi	r24, 0x3B	; 59
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	2b 81       	ldd	r18, Y+3	; 0x03
     8f2:	fc 01       	movw	r30, r24
     8f4:	20 83       	st	Z, r18
					break;
     8f6:	12 c0       	rjmp	.+36     	; 0x91c <DIO_u8SetPortValue+0x72>
				case GROUP_B :
					DIO_u8_PORTB->ByteAccess = Copy_u8PortValue;
     8f8:	88 e3       	ldi	r24, 0x38	; 56
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	2b 81       	ldd	r18, Y+3	; 0x03
     8fe:	fc 01       	movw	r30, r24
     900:	20 83       	st	Z, r18
					break;
     902:	0c c0       	rjmp	.+24     	; 0x91c <DIO_u8SetPortValue+0x72>
				case GROUP_C :
					DIO_u8_PORTC->ByteAccess = Copy_u8PortValue;
     904:	85 e3       	ldi	r24, 0x35	; 53
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	2b 81       	ldd	r18, Y+3	; 0x03
     90a:	fc 01       	movw	r30, r24
     90c:	20 83       	st	Z, r18
					break;
     90e:	06 c0       	rjmp	.+12     	; 0x91c <DIO_u8SetPortValue+0x72>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
     910:	82 e3       	ldi	r24, 0x32	; 50
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	2b 81       	ldd	r18, Y+3	; 0x03
     916:	fc 01       	movw	r30, r24
     918:	20 83       	st	Z, r18
					break;
     91a:	00 00       	nop

					break;
				}
			}
		/*Function return*/
		return u8ErrorState;
     91c:	89 81       	ldd	r24, Y+1	; 0x01
}
     91e:	0f 90       	pop	r0
     920:	0f 90       	pop	r0
     922:	0f 90       	pop	r0
     924:	df 91       	pop	r29
     926:	cf 91       	pop	r28
     928:	08 95       	ret

0000092a <DIO_u8GetPinValue>:

/* */
/* */
u8 DIO_u8GetPinValue(u8 Copy_u8PinNB, u8 *Copy_u8PinValue)
{
     92a:	cf 93       	push	r28
     92c:	df 93       	push	r29
     92e:	00 d0       	rcall	.+0      	; 0x930 <DIO_u8GetPinValue+0x6>
     930:	00 d0       	rcall	.+0      	; 0x932 <DIO_u8GetPinValue+0x8>
     932:	00 d0       	rcall	.+0      	; 0x934 <DIO_u8GetPinValue+0xa>
     934:	cd b7       	in	r28, 0x3d	; 61
     936:	de b7       	in	r29, 0x3e	; 62
     938:	8c 83       	std	Y+4, r24	; 0x04
     93a:	7e 83       	std	Y+6, r23	; 0x06
     93c:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     93e:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     940:	8c 81       	ldd	r24, Y+4	; 0x04
     942:	80 32       	cpi	r24, 0x20	; 32
     944:	18 f0       	brcs	.+6      	; 0x94c <DIO_u8GetPinValue+0x22>
	{
		u8ErrorState = 1;
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	89 83       	std	Y+1, r24	; 0x01
     94a:	6f c0       	rjmp	.+222    	; 0xa2a <DIO_u8GetPinValue+0x100>
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     94c:	8c 81       	ldd	r24, Y+4	; 0x04
     94e:	86 95       	lsr	r24
     950:	86 95       	lsr	r24
     952:	86 95       	lsr	r24
     954:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     956:	8c 81       	ldd	r24, Y+4	; 0x04
     958:	87 70       	andi	r24, 0x07	; 7
     95a:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     95c:	8a 81       	ldd	r24, Y+2	; 0x02
     95e:	88 2f       	mov	r24, r24
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	81 30       	cpi	r24, 0x01	; 1
     964:	91 05       	cpc	r25, r1
     966:	11 f1       	breq	.+68     	; 0x9ac <DIO_u8GetPinValue+0x82>
     968:	82 30       	cpi	r24, 0x02	; 2
     96a:	91 05       	cpc	r25, r1
     96c:	1c f4       	brge	.+6      	; 0x974 <DIO_u8GetPinValue+0x4a>
     96e:	89 2b       	or	r24, r25
     970:	41 f0       	breq	.+16     	; 0x982 <DIO_u8GetPinValue+0x58>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     972:	5b c0       	rjmp	.+182    	; 0xa2a <DIO_u8GetPinValue+0x100>
		u8ErrorState = 1;
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     974:	82 30       	cpi	r24, 0x02	; 2
     976:	91 05       	cpc	r25, r1
     978:	71 f1       	breq	.+92     	; 0x9d6 <DIO_u8GetPinValue+0xac>
     97a:	03 97       	sbiw	r24, 0x03	; 3
     97c:	09 f4       	brne	.+2      	; 0x980 <DIO_u8GetPinValue+0x56>
     97e:	40 c0       	rjmp	.+128    	; 0xa00 <DIO_u8GetPinValue+0xd6>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     980:	54 c0       	rjmp	.+168    	; 0xa2a <DIO_u8GetPinValue+0x100>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINA -> ByteAccess, u8PIN_ID);
     982:	89 e3       	ldi	r24, 0x39	; 57
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	fc 01       	movw	r30, r24
     988:	80 81       	ld	r24, Z
     98a:	88 2f       	mov	r24, r24
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	2b 81       	ldd	r18, Y+3	; 0x03
     990:	22 2f       	mov	r18, r18
     992:	30 e0       	ldi	r19, 0x00	; 0
     994:	02 c0       	rjmp	.+4      	; 0x99a <DIO_u8GetPinValue+0x70>
     996:	95 95       	asr	r25
     998:	87 95       	ror	r24
     99a:	2a 95       	dec	r18
     99c:	e2 f7       	brpl	.-8      	; 0x996 <DIO_u8GetPinValue+0x6c>
     99e:	28 2f       	mov	r18, r24
     9a0:	21 70       	andi	r18, 0x01	; 1
     9a2:	8d 81       	ldd	r24, Y+5	; 0x05
     9a4:	9e 81       	ldd	r25, Y+6	; 0x06
     9a6:	fc 01       	movw	r30, r24
     9a8:	20 83       	st	Z, r18
			break;
     9aa:	3f c0       	rjmp	.+126    	; 0xa2a <DIO_u8GetPinValue+0x100>
		case GROUP_B :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINB -> ByteAccess, u8PIN_ID);
     9ac:	86 e3       	ldi	r24, 0x36	; 54
     9ae:	90 e0       	ldi	r25, 0x00	; 0
     9b0:	fc 01       	movw	r30, r24
     9b2:	80 81       	ld	r24, Z
     9b4:	88 2f       	mov	r24, r24
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	2b 81       	ldd	r18, Y+3	; 0x03
     9ba:	22 2f       	mov	r18, r18
     9bc:	30 e0       	ldi	r19, 0x00	; 0
     9be:	02 c0       	rjmp	.+4      	; 0x9c4 <DIO_u8GetPinValue+0x9a>
     9c0:	95 95       	asr	r25
     9c2:	87 95       	ror	r24
     9c4:	2a 95       	dec	r18
     9c6:	e2 f7       	brpl	.-8      	; 0x9c0 <DIO_u8GetPinValue+0x96>
     9c8:	28 2f       	mov	r18, r24
     9ca:	21 70       	andi	r18, 0x01	; 1
     9cc:	8d 81       	ldd	r24, Y+5	; 0x05
     9ce:	9e 81       	ldd	r25, Y+6	; 0x06
     9d0:	fc 01       	movw	r30, r24
     9d2:	20 83       	st	Z, r18
			break;
     9d4:	2a c0       	rjmp	.+84     	; 0xa2a <DIO_u8GetPinValue+0x100>
		case GROUP_C :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINC -> ByteAccess, u8PIN_ID);
     9d6:	83 e3       	ldi	r24, 0x33	; 51
     9d8:	90 e0       	ldi	r25, 0x00	; 0
     9da:	fc 01       	movw	r30, r24
     9dc:	80 81       	ld	r24, Z
     9de:	88 2f       	mov	r24, r24
     9e0:	90 e0       	ldi	r25, 0x00	; 0
     9e2:	2b 81       	ldd	r18, Y+3	; 0x03
     9e4:	22 2f       	mov	r18, r18
     9e6:	30 e0       	ldi	r19, 0x00	; 0
     9e8:	02 c0       	rjmp	.+4      	; 0x9ee <DIO_u8GetPinValue+0xc4>
     9ea:	95 95       	asr	r25
     9ec:	87 95       	ror	r24
     9ee:	2a 95       	dec	r18
     9f0:	e2 f7       	brpl	.-8      	; 0x9ea <DIO_u8GetPinValue+0xc0>
     9f2:	28 2f       	mov	r18, r24
     9f4:	21 70       	andi	r18, 0x01	; 1
     9f6:	8d 81       	ldd	r24, Y+5	; 0x05
     9f8:	9e 81       	ldd	r25, Y+6	; 0x06
     9fa:	fc 01       	movw	r30, r24
     9fc:	20 83       	st	Z, r18
			break;
     9fe:	15 c0       	rjmp	.+42     	; 0xa2a <DIO_u8GetPinValue+0x100>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
     a00:	80 e3       	ldi	r24, 0x30	; 48
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	fc 01       	movw	r30, r24
     a06:	80 81       	ld	r24, Z
     a08:	88 2f       	mov	r24, r24
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	2b 81       	ldd	r18, Y+3	; 0x03
     a0e:	22 2f       	mov	r18, r18
     a10:	30 e0       	ldi	r19, 0x00	; 0
     a12:	02 c0       	rjmp	.+4      	; 0xa18 <DIO_u8GetPinValue+0xee>
     a14:	95 95       	asr	r25
     a16:	87 95       	ror	r24
     a18:	2a 95       	dec	r18
     a1a:	e2 f7       	brpl	.-8      	; 0xa14 <DIO_u8GetPinValue+0xea>
     a1c:	28 2f       	mov	r18, r24
     a1e:	21 70       	andi	r18, 0x01	; 1
     a20:	8d 81       	ldd	r24, Y+5	; 0x05
     a22:	9e 81       	ldd	r25, Y+6	; 0x06
     a24:	fc 01       	movw	r30, r24
     a26:	20 83       	st	Z, r18
			break;
     a28:	00 00       	nop

			break;
		}
	}
	/*Function return*/
	return u8ErrorState;
     a2a:	89 81       	ldd	r24, Y+1	; 0x01
}
     a2c:	26 96       	adiw	r28, 0x06	; 6
     a2e:	0f b6       	in	r0, 0x3f	; 63
     a30:	f8 94       	cli
     a32:	de bf       	out	0x3e, r29	; 62
     a34:	0f be       	out	0x3f, r0	; 63
     a36:	cd bf       	out	0x3d, r28	; 61
     a38:	df 91       	pop	r29
     a3a:	cf 91       	pop	r28
     a3c:	08 95       	ret

00000a3e <DIO_u8GetPortValue>:

/* */
/* */
u8 DIO_u8GetPortValue(u8 Copy_u8PortNB, u8 *Copy_u8PortValue)
{
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
     a42:	00 d0       	rcall	.+0      	; 0xa44 <DIO_u8GetPortValue+0x6>
     a44:	00 d0       	rcall	.+0      	; 0xa46 <DIO_u8GetPortValue+0x8>
     a46:	cd b7       	in	r28, 0x3d	; 61
     a48:	de b7       	in	r29, 0x3e	; 62
     a4a:	8a 83       	std	Y+2, r24	; 0x02
     a4c:	7c 83       	std	Y+4, r23	; 0x04
     a4e:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     a50:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
	if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     a52:	8a 81       	ldd	r24, Y+2	; 0x02
     a54:	84 30       	cpi	r24, 0x04	; 4
     a56:	18 f0       	brcs	.+6      	; 0xa5e <DIO_u8GetPortValue+0x20>
	{
		u8ErrorState = 1;
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	89 83       	std	Y+1, r24	; 0x01
     a5c:	36 c0       	rjmp	.+108    	; 0xaca <DIO_u8GetPortValue+0x8c>
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a5e:	8a 81       	ldd	r24, Y+2	; 0x02
     a60:	88 2f       	mov	r24, r24
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	81 30       	cpi	r24, 0x01	; 1
     a66:	91 05       	cpc	r25, r1
     a68:	a9 f0       	breq	.+42     	; 0xa94 <DIO_u8GetPortValue+0x56>
     a6a:	82 30       	cpi	r24, 0x02	; 2
     a6c:	91 05       	cpc	r25, r1
     a6e:	1c f4       	brge	.+6      	; 0xa76 <DIO_u8GetPortValue+0x38>
     a70:	89 2b       	or	r24, r25
     a72:	39 f0       	breq	.+14     	; 0xa82 <DIO_u8GetPortValue+0x44>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     a74:	2a c0       	rjmp	.+84     	; 0xaca <DIO_u8GetPortValue+0x8c>
		u8ErrorState = 1;
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     a76:	82 30       	cpi	r24, 0x02	; 2
     a78:	91 05       	cpc	r25, r1
     a7a:	a9 f0       	breq	.+42     	; 0xaa6 <DIO_u8GetPortValue+0x68>
     a7c:	03 97       	sbiw	r24, 0x03	; 3
     a7e:	e1 f0       	breq	.+56     	; 0xab8 <DIO_u8GetPortValue+0x7a>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     a80:	24 c0       	rjmp	.+72     	; 0xaca <DIO_u8GetPortValue+0x8c>
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
		{
			case GROUP_A :
				*Copy_u8PortValue = DIO_u8_PINA->ByteAccess;
     a82:	89 e3       	ldi	r24, 0x39	; 57
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	fc 01       	movw	r30, r24
     a88:	20 81       	ld	r18, Z
     a8a:	8b 81       	ldd	r24, Y+3	; 0x03
     a8c:	9c 81       	ldd	r25, Y+4	; 0x04
     a8e:	fc 01       	movw	r30, r24
     a90:	20 83       	st	Z, r18
				break;
     a92:	1b c0       	rjmp	.+54     	; 0xaca <DIO_u8GetPortValue+0x8c>
			case GROUP_B :
				*Copy_u8PortValue = DIO_u8_PINB->ByteAccess;
     a94:	86 e3       	ldi	r24, 0x36	; 54
     a96:	90 e0       	ldi	r25, 0x00	; 0
     a98:	fc 01       	movw	r30, r24
     a9a:	20 81       	ld	r18, Z
     a9c:	8b 81       	ldd	r24, Y+3	; 0x03
     a9e:	9c 81       	ldd	r25, Y+4	; 0x04
     aa0:	fc 01       	movw	r30, r24
     aa2:	20 83       	st	Z, r18
				break;
     aa4:	12 c0       	rjmp	.+36     	; 0xaca <DIO_u8GetPortValue+0x8c>
			case GROUP_C :
				*Copy_u8PortValue = DIO_u8_PINC->ByteAccess;
     aa6:	83 e3       	ldi	r24, 0x33	; 51
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	fc 01       	movw	r30, r24
     aac:	20 81       	ld	r18, Z
     aae:	8b 81       	ldd	r24, Y+3	; 0x03
     ab0:	9c 81       	ldd	r25, Y+4	; 0x04
     ab2:	fc 01       	movw	r30, r24
     ab4:	20 83       	st	Z, r18
				break;
     ab6:	09 c0       	rjmp	.+18     	; 0xaca <DIO_u8GetPortValue+0x8c>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
     ab8:	80 e3       	ldi	r24, 0x30	; 48
     aba:	90 e0       	ldi	r25, 0x00	; 0
     abc:	fc 01       	movw	r30, r24
     abe:	20 81       	ld	r18, Z
     ac0:	8b 81       	ldd	r24, Y+3	; 0x03
     ac2:	9c 81       	ldd	r25, Y+4	; 0x04
     ac4:	fc 01       	movw	r30, r24
     ac6:	20 83       	st	Z, r18
				break;
     ac8:	00 00       	nop
				break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     aca:	89 81       	ldd	r24, Y+1	; 0x01
}
     acc:	0f 90       	pop	r0
     ace:	0f 90       	pop	r0
     ad0:	0f 90       	pop	r0
     ad2:	0f 90       	pop	r0
     ad4:	df 91       	pop	r29
     ad6:	cf 91       	pop	r28
     ad8:	08 95       	ret

00000ada <KBD_u8GetKeyPadState>:
#include "KBD_interface.h"
#include "KBD_private.h"


u8 KBD_u8GetKeyPadState(u8* Copy_Au8KeysState/*[KBD_u8_KEYS_NB]*/)
{
     ada:	cf 93       	push	r28
     adc:	df 93       	push	r29
     ade:	cd b7       	in	r28, 0x3d	; 61
     ae0:	de b7       	in	r29, 0x3e	; 62
     ae2:	27 97       	sbiw	r28, 0x07	; 7
     ae4:	0f b6       	in	r0, 0x3f	; 63
     ae6:	f8 94       	cli
     ae8:	de bf       	out	0x3e, r29	; 62
     aea:	0f be       	out	0x3f, r0	; 63
     aec:	cd bf       	out	0x3d, r28	; 61
     aee:	9f 83       	std	Y+7, r25	; 0x07
     af0:	8e 83       	std	Y+6, r24	; 0x06
	u8 LOCAL_u8ColIndex = 0;
     af2:	19 82       	std	Y+1, r1	; 0x01
	u8 LOCAL_u8RowIndex = 0;
     af4:	1a 82       	std	Y+2, r1	; 0x02
	
	u8 Local_u8CurrentPinValue=0;
     af6:	1d 82       	std	Y+5, r1	; 0x05
	u8 Local_u8KeyIndex=0;
     af8:	1c 82       	std	Y+4, r1	; 0x04
	u8 pressed = 0xff;
     afa:	8f ef       	ldi	r24, 0xFF	; 255
     afc:	8b 83       	std	Y+3, r24	; 0x03
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     afe:	19 82       	std	Y+1, r1	; 0x01
     b00:	52 c0       	rjmp	.+164    	; 0xba6 <KBD_u8GetKeyPadState+0xcc>
		{
			//activate current col
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
     b02:	89 81       	ldd	r24, Y+1	; 0x01
     b04:	88 2f       	mov	r24, r24
     b06:	90 e0       	ldi	r25, 0x00	; 0
     b08:	80 5f       	subi	r24, 0xF0	; 240
     b0a:	98 4f       	sbci	r25, 0xF8	; 248
     b0c:	fc 01       	movw	r30, r24
     b0e:	80 81       	ld	r24, Z
     b10:	60 e0       	ldi	r22, 0x00	; 0
     b12:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     b16:	1a 82       	std	Y+2, r1	; 0x02
     b18:	36 c0       	rjmp	.+108    	; 0xb86 <KBD_u8GetKeyPadState+0xac>
			{
				DIO_u8GetPinValue(KBD_Au8RowsPins[LOCAL_u8RowIndex], &Local_u8CurrentPinValue);
     b1a:	8a 81       	ldd	r24, Y+2	; 0x02
     b1c:	88 2f       	mov	r24, r24
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	8c 5e       	subi	r24, 0xEC	; 236
     b22:	98 4f       	sbci	r25, 0xF8	; 248
     b24:	fc 01       	movw	r30, r24
     b26:	20 81       	ld	r18, Z
     b28:	ce 01       	movw	r24, r28
     b2a:	05 96       	adiw	r24, 0x05	; 5
     b2c:	bc 01       	movw	r22, r24
     b2e:	82 2f       	mov	r24, r18
     b30:	0e 94 95 04 	call	0x92a	; 0x92a <DIO_u8GetPinValue>
				
				Local_u8KeyIndex = LOCAL_u8ColIndex + (LOCAL_u8RowIndex*KBD_u8_COL);
     b34:	8a 81       	ldd	r24, Y+2	; 0x02
     b36:	98 2f       	mov	r25, r24
     b38:	99 0f       	add	r25, r25
     b3a:	99 0f       	add	r25, r25
     b3c:	89 81       	ldd	r24, Y+1	; 0x01
     b3e:	89 0f       	add	r24, r25
     b40:	8c 83       	std	Y+4, r24	; 0x04
				
				if(Local_u8CurrentPinValue == DIO_u8_HIGH)
     b42:	8d 81       	ldd	r24, Y+5	; 0x05
     b44:	81 30       	cpi	r24, 0x01	; 1
     b46:	51 f4       	brne	.+20     	; 0xb5c <KBD_u8GetKeyPadState+0x82>
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Not Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
     b48:	8c 81       	ldd	r24, Y+4	; 0x04
     b4a:	88 2f       	mov	r24, r24
     b4c:	90 e0       	ldi	r25, 0x00	; 0
     b4e:	2e 81       	ldd	r18, Y+6	; 0x06
     b50:	3f 81       	ldd	r19, Y+7	; 0x07
     b52:	82 0f       	add	r24, r18
     b54:	93 1f       	adc	r25, r19
     b56:	fc 01       	movw	r30, r24
     b58:	10 82       	st	Z, r1
     b5a:	12 c0       	rjmp	.+36     	; 0xb80 <KBD_u8GetKeyPadState+0xa6>
					#endif
				}else
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_PRESSED;
     b5c:	8c 81       	ldd	r24, Y+4	; 0x04
     b5e:	88 2f       	mov	r24, r24
     b60:	90 e0       	ldi	r25, 0x00	; 0
     b62:	2e 81       	ldd	r18, Y+6	; 0x06
     b64:	3f 81       	ldd	r19, Y+7	; 0x07
     b66:	82 0f       	add	r24, r18
     b68:	93 1f       	adc	r25, r19
     b6a:	21 e0       	ldi	r18, 0x01	; 1
     b6c:	fc 01       	movw	r30, r24
     b6e:	20 83       	st	Z, r18
						pressed = key_map[Local_u8KeyIndex];
     b70:	8c 81       	ldd	r24, Y+4	; 0x04
     b72:	88 2f       	mov	r24, r24
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	8f 59       	subi	r24, 0x9F	; 159
     b78:	9f 4f       	sbci	r25, 0xFF	; 255
     b7a:	fc 01       	movw	r30, r24
     b7c:	80 81       	ld	r24, Z
     b7e:	8b 83       	std	Y+3, r24	; 0x03
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     b80:	8a 81       	ldd	r24, Y+2	; 0x02
     b82:	8f 5f       	subi	r24, 0xFF	; 255
     b84:	8a 83       	std	Y+2, r24	; 0x02
     b86:	8a 81       	ldd	r24, Y+2	; 0x02
     b88:	84 30       	cpi	r24, 0x04	; 4
     b8a:	38 f2       	brcs	.-114    	; 0xb1a <KBD_u8GetKeyPadState+0x40>
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
					#endif
				}
			}
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
     b8c:	89 81       	ldd	r24, Y+1	; 0x01
     b8e:	88 2f       	mov	r24, r24
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	80 5f       	subi	r24, 0xF0	; 240
     b94:	98 4f       	sbci	r25, 0xF8	; 248
     b96:	fc 01       	movw	r30, r24
     b98:	80 81       	ld	r24, Z
     b9a:	61 e0       	ldi	r22, 0x01	; 1
     b9c:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	u8 Local_u8CurrentPinValue=0;
	u8 Local_u8KeyIndex=0;
	u8 pressed = 0xff;
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	8f 5f       	subi	r24, 0xFF	; 255
     ba4:	89 83       	std	Y+1, r24	; 0x01
     ba6:	89 81       	ldd	r24, Y+1	; 0x01
     ba8:	84 30       	cpi	r24, 0x04	; 4
     baa:	08 f4       	brcc	.+2      	; 0xbae <KBD_u8GetKeyPadState+0xd4>
     bac:	aa cf       	rjmp	.-172    	; 0xb02 <KBD_u8GetKeyPadState+0x28>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#else
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
			#endif
		}
		return pressed;
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
			#endif
		}

	#endif

}
     bb0:	27 96       	adiw	r28, 0x07	; 7
     bb2:	0f b6       	in	r0, 0x3f	; 63
     bb4:	f8 94       	cli
     bb6:	de bf       	out	0x3e, r29	; 62
     bb8:	0f be       	out	0x3f, r0	; 63
     bba:	cd bf       	out	0x3d, r28	; 61
     bbc:	df 91       	pop	r29
     bbe:	cf 91       	pop	r28
     bc0:	08 95       	ret

00000bc2 <KBD_u8Initialize>:
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
     bc2:	cf 93       	push	r28
     bc4:	df 93       	push	r29
     bc6:	cd b7       	in	r28, 0x3d	; 61
     bc8:	de b7       	in	r29, 0x3e	; 62
     bca:	29 97       	sbiw	r28, 0x09	; 9
     bcc:	0f b6       	in	r0, 0x3f	; 63
     bce:	f8 94       	cli
     bd0:	de bf       	out	0x3e, r29	; 62
     bd2:	0f be       	out	0x3f, r0	; 63
     bd4:	cd bf       	out	0x3d, r28	; 61
     bd6:	89 87       	std	Y+9, r24	; 0x09
		switch (group_nb)
     bd8:	89 85       	ldd	r24, Y+9	; 0x09
     bda:	88 2f       	mov	r24, r24
     bdc:	90 e0       	ldi	r25, 0x00	; 0
     bde:	81 30       	cpi	r24, 0x01	; 1
     be0:	91 05       	cpc	r25, r1
     be2:	09 f4       	brne	.+2      	; 0xbe6 <KBD_u8Initialize+0x24>
     be4:	42 c0       	rjmp	.+132    	; 0xc6a <KBD_u8Initialize+0xa8>
     be6:	82 30       	cpi	r24, 0x02	; 2
     be8:	91 05       	cpc	r25, r1
     bea:	1c f4       	brge	.+6      	; 0xbf2 <KBD_u8Initialize+0x30>
     bec:	89 2b       	or	r24, r25
     bee:	49 f0       	breq	.+18     	; 0xc02 <KBD_u8Initialize+0x40>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     bf0:	d8 c0       	rjmp	.+432    	; 0xda2 <KBD_u8Initialize+0x1e0>
	#endif

}
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
     bf2:	82 30       	cpi	r24, 0x02	; 2
     bf4:	91 05       	cpc	r25, r1
     bf6:	09 f4       	brne	.+2      	; 0xbfa <KBD_u8Initialize+0x38>
     bf8:	6c c0       	rjmp	.+216    	; 0xcd2 <KBD_u8Initialize+0x110>
     bfa:	03 97       	sbiw	r24, 0x03	; 3
     bfc:	09 f4       	brne	.+2      	; 0xc00 <KBD_u8Initialize+0x3e>
     bfe:	9d c0       	rjmp	.+314    	; 0xd3a <KBD_u8Initialize+0x178>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     c00:	d0 c0       	rjmp	.+416    	; 0xda2 <KBD_u8Initialize+0x1e0>
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
		{
		case 0:
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
     c02:	6f e0       	ldi	r22, 0x0F	; 15
     c04:	80 e0       	ldi	r24, 0x00	; 0
     c06:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(A4,1);
     c0a:	61 e0       	ldi	r22, 0x01	; 1
     c0c:	84 e0       	ldi	r24, 0x04	; 4
     c0e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A5,1);
     c12:	61 e0       	ldi	r22, 0x01	; 1
     c14:	85 e0       	ldi	r24, 0x05	; 5
     c16:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A6,1);
     c1a:	61 e0       	ldi	r22, 0x01	; 1
     c1c:	86 e0       	ldi	r24, 0x06	; 6
     c1e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A7,1);
     c22:	61 e0       	ldi	r22, 0x01	; 1
     c24:	87 e0       	ldi	r24, 0x07	; 7
     c26:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c2a:	1a 82       	std	Y+2, r1	; 0x02
     c2c:	19 82       	std	Y+1, r1	; 0x01
     c2e:	18 c0       	rjmp	.+48     	; 0xc60 <KBD_u8Initialize+0x9e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
     c30:	89 81       	ldd	r24, Y+1	; 0x01
     c32:	24 e0       	ldi	r18, 0x04	; 4
     c34:	28 0f       	add	r18, r24
     c36:	89 81       	ldd	r24, Y+1	; 0x01
     c38:	9a 81       	ldd	r25, Y+2	; 0x02
     c3a:	8c 5e       	subi	r24, 0xEC	; 236
     c3c:	98 4f       	sbci	r25, 0xF8	; 248
     c3e:	fc 01       	movw	r30, r24
     c40:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = A3 - i;
     c42:	89 81       	ldd	r24, Y+1	; 0x01
     c44:	93 e0       	ldi	r25, 0x03	; 3
     c46:	29 2f       	mov	r18, r25
     c48:	28 1b       	sub	r18, r24
     c4a:	89 81       	ldd	r24, Y+1	; 0x01
     c4c:	9a 81       	ldd	r25, Y+2	; 0x02
     c4e:	80 5f       	subi	r24, 0xF0	; 240
     c50:	98 4f       	sbci	r25, 0xF8	; 248
     c52:	fc 01       	movw	r30, r24
     c54:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
			DIO_u8SetPinValue(A4,1);
			DIO_u8SetPinValue(A5,1);
			DIO_u8SetPinValue(A6,1);
			DIO_u8SetPinValue(A7,1);
			for (int i=0;i<4;i++)
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	9a 81       	ldd	r25, Y+2	; 0x02
     c5a:	01 96       	adiw	r24, 0x01	; 1
     c5c:	9a 83       	std	Y+2, r25	; 0x02
     c5e:	89 83       	std	Y+1, r24	; 0x01
     c60:	89 81       	ldd	r24, Y+1	; 0x01
     c62:	9a 81       	ldd	r25, Y+2	; 0x02
     c64:	04 97       	sbiw	r24, 0x04	; 4
     c66:	24 f3       	brlt	.-56     	; 0xc30 <KBD_u8Initialize+0x6e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
				KBD_Au8ColsPins[i] = A3 - i;
			}
			break;
     c68:	9c c0       	rjmp	.+312    	; 0xda2 <KBD_u8Initialize+0x1e0>
		case 1:
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
     c6a:	6f e0       	ldi	r22, 0x0F	; 15
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(B4,1);
     c72:	61 e0       	ldi	r22, 0x01	; 1
     c74:	8c e0       	ldi	r24, 0x0C	; 12
     c76:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B5,1);
     c7a:	61 e0       	ldi	r22, 0x01	; 1
     c7c:	8d e0       	ldi	r24, 0x0D	; 13
     c7e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B6,1);
     c82:	61 e0       	ldi	r22, 0x01	; 1
     c84:	8e e0       	ldi	r24, 0x0E	; 14
     c86:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B7,1);
     c8a:	61 e0       	ldi	r22, 0x01	; 1
     c8c:	8f e0       	ldi	r24, 0x0F	; 15
     c8e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c92:	1c 82       	std	Y+4, r1	; 0x04
     c94:	1b 82       	std	Y+3, r1	; 0x03
     c96:	18 c0       	rjmp	.+48     	; 0xcc8 <KBD_u8Initialize+0x106>
			{
				KBD_Au8RowsPins[i] = B4 + i;
     c98:	8b 81       	ldd	r24, Y+3	; 0x03
     c9a:	2c e0       	ldi	r18, 0x0C	; 12
     c9c:	28 0f       	add	r18, r24
     c9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ca0:	9c 81       	ldd	r25, Y+4	; 0x04
     ca2:	8c 5e       	subi	r24, 0xEC	; 236
     ca4:	98 4f       	sbci	r25, 0xF8	; 248
     ca6:	fc 01       	movw	r30, r24
     ca8:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = B3 - i;
     caa:	8b 81       	ldd	r24, Y+3	; 0x03
     cac:	9b e0       	ldi	r25, 0x0B	; 11
     cae:	29 2f       	mov	r18, r25
     cb0:	28 1b       	sub	r18, r24
     cb2:	8b 81       	ldd	r24, Y+3	; 0x03
     cb4:	9c 81       	ldd	r25, Y+4	; 0x04
     cb6:	80 5f       	subi	r24, 0xF0	; 240
     cb8:	98 4f       	sbci	r25, 0xF8	; 248
     cba:	fc 01       	movw	r30, r24
     cbc:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
			DIO_u8SetPinValue(B4,1);
			DIO_u8SetPinValue(B5,1);
			DIO_u8SetPinValue(B6,1);
			DIO_u8SetPinValue(B7,1);
			for (int i=0;i<4;i++)
     cbe:	8b 81       	ldd	r24, Y+3	; 0x03
     cc0:	9c 81       	ldd	r25, Y+4	; 0x04
     cc2:	01 96       	adiw	r24, 0x01	; 1
     cc4:	9c 83       	std	Y+4, r25	; 0x04
     cc6:	8b 83       	std	Y+3, r24	; 0x03
     cc8:	8b 81       	ldd	r24, Y+3	; 0x03
     cca:	9c 81       	ldd	r25, Y+4	; 0x04
     ccc:	04 97       	sbiw	r24, 0x04	; 4
     cce:	24 f3       	brlt	.-56     	; 0xc98 <KBD_u8Initialize+0xd6>
			{
				KBD_Au8RowsPins[i] = B4 + i;
				KBD_Au8ColsPins[i] = B3 - i;
			}
			break;
     cd0:	68 c0       	rjmp	.+208    	; 0xda2 <KBD_u8Initialize+0x1e0>
		case 2:
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
     cd2:	6f e0       	ldi	r22, 0x0F	; 15
     cd4:	82 e0       	ldi	r24, 0x02	; 2
     cd6:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(C4,1);
     cda:	61 e0       	ldi	r22, 0x01	; 1
     cdc:	84 e1       	ldi	r24, 0x14	; 20
     cde:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C5,1);
     ce2:	61 e0       	ldi	r22, 0x01	; 1
     ce4:	85 e1       	ldi	r24, 0x15	; 21
     ce6:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C6,1);
     cea:	61 e0       	ldi	r22, 0x01	; 1
     cec:	86 e1       	ldi	r24, 0x16	; 22
     cee:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C7,1);
     cf2:	61 e0       	ldi	r22, 0x01	; 1
     cf4:	87 e1       	ldi	r24, 0x17	; 23
     cf6:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     cfa:	1e 82       	std	Y+6, r1	; 0x06
     cfc:	1d 82       	std	Y+5, r1	; 0x05
     cfe:	18 c0       	rjmp	.+48     	; 0xd30 <KBD_u8Initialize+0x16e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	24 e1       	ldi	r18, 0x14	; 20
     d04:	28 0f       	add	r18, r24
     d06:	8d 81       	ldd	r24, Y+5	; 0x05
     d08:	9e 81       	ldd	r25, Y+6	; 0x06
     d0a:	8c 5e       	subi	r24, 0xEC	; 236
     d0c:	98 4f       	sbci	r25, 0xF8	; 248
     d0e:	fc 01       	movw	r30, r24
     d10:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = C3 - i;
     d12:	8d 81       	ldd	r24, Y+5	; 0x05
     d14:	93 e1       	ldi	r25, 0x13	; 19
     d16:	29 2f       	mov	r18, r25
     d18:	28 1b       	sub	r18, r24
     d1a:	8d 81       	ldd	r24, Y+5	; 0x05
     d1c:	9e 81       	ldd	r25, Y+6	; 0x06
     d1e:	80 5f       	subi	r24, 0xF0	; 240
     d20:	98 4f       	sbci	r25, 0xF8	; 248
     d22:	fc 01       	movw	r30, r24
     d24:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
			DIO_u8SetPinValue(C4,1);
			DIO_u8SetPinValue(C5,1);
			DIO_u8SetPinValue(C6,1);
			DIO_u8SetPinValue(C7,1);
			for (int i=0;i<4;i++)
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	01 96       	adiw	r24, 0x01	; 1
     d2c:	9e 83       	std	Y+6, r25	; 0x06
     d2e:	8d 83       	std	Y+5, r24	; 0x05
     d30:	8d 81       	ldd	r24, Y+5	; 0x05
     d32:	9e 81       	ldd	r25, Y+6	; 0x06
     d34:	04 97       	sbiw	r24, 0x04	; 4
     d36:	24 f3       	brlt	.-56     	; 0xd00 <KBD_u8Initialize+0x13e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
				KBD_Au8ColsPins[i] = C3 - i;
			}
			break;
     d38:	34 c0       	rjmp	.+104    	; 0xda2 <KBD_u8Initialize+0x1e0>
		case 3:
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
     d3a:	6f e0       	ldi	r22, 0x0F	; 15
     d3c:	83 e0       	ldi	r24, 0x03	; 3
     d3e:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(D4,1);
     d42:	61 e0       	ldi	r22, 0x01	; 1
     d44:	8c e1       	ldi	r24, 0x1C	; 28
     d46:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D5,1);
     d4a:	61 e0       	ldi	r22, 0x01	; 1
     d4c:	8d e1       	ldi	r24, 0x1D	; 29
     d4e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D6,1);
     d52:	61 e0       	ldi	r22, 0x01	; 1
     d54:	8e e1       	ldi	r24, 0x1E	; 30
     d56:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D7,1);
     d5a:	61 e0       	ldi	r22, 0x01	; 1
     d5c:	8f e1       	ldi	r24, 0x1F	; 31
     d5e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     d62:	18 86       	std	Y+8, r1	; 0x08
     d64:	1f 82       	std	Y+7, r1	; 0x07
     d66:	18 c0       	rjmp	.+48     	; 0xd98 <KBD_u8Initialize+0x1d6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
     d68:	8f 81       	ldd	r24, Y+7	; 0x07
     d6a:	2c e1       	ldi	r18, 0x1C	; 28
     d6c:	28 0f       	add	r18, r24
     d6e:	8f 81       	ldd	r24, Y+7	; 0x07
     d70:	98 85       	ldd	r25, Y+8	; 0x08
     d72:	8c 5e       	subi	r24, 0xEC	; 236
     d74:	98 4f       	sbci	r25, 0xF8	; 248
     d76:	fc 01       	movw	r30, r24
     d78:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = D3 - i;
     d7a:	8f 81       	ldd	r24, Y+7	; 0x07
     d7c:	9b e1       	ldi	r25, 0x1B	; 27
     d7e:	29 2f       	mov	r18, r25
     d80:	28 1b       	sub	r18, r24
     d82:	8f 81       	ldd	r24, Y+7	; 0x07
     d84:	98 85       	ldd	r25, Y+8	; 0x08
     d86:	80 5f       	subi	r24, 0xF0	; 240
     d88:	98 4f       	sbci	r25, 0xF8	; 248
     d8a:	fc 01       	movw	r30, r24
     d8c:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
			DIO_u8SetPinValue(D4,1);
			DIO_u8SetPinValue(D5,1);
			DIO_u8SetPinValue(D6,1);
			DIO_u8SetPinValue(D7,1);
			for (int i=0;i<4;i++)
     d8e:	8f 81       	ldd	r24, Y+7	; 0x07
     d90:	98 85       	ldd	r25, Y+8	; 0x08
     d92:	01 96       	adiw	r24, 0x01	; 1
     d94:	98 87       	std	Y+8, r25	; 0x08
     d96:	8f 83       	std	Y+7, r24	; 0x07
     d98:	8f 81       	ldd	r24, Y+7	; 0x07
     d9a:	98 85       	ldd	r25, Y+8	; 0x08
     d9c:	04 97       	sbiw	r24, 0x04	; 4
     d9e:	24 f3       	brlt	.-56     	; 0xd68 <KBD_u8Initialize+0x1a6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
     da0:	00 00       	nop
		}
	}
     da2:	00 00       	nop
     da4:	29 96       	adiw	r28, 0x09	; 9
     da6:	0f b6       	in	r0, 0x3f	; 63
     da8:	f8 94       	cli
     daa:	de bf       	out	0x3e, r29	; 62
     dac:	0f be       	out	0x3f, r0	; 63
     dae:	cd bf       	out	0x3d, r28	; 61
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	08 95       	ret

00000db6 <KBD_keys_map>:
u8 KBD_keys_map(u8* keys)
{
     db6:	cf 93       	push	r28
     db8:	df 93       	push	r29
     dba:	00 d0       	rcall	.+0      	; 0xdbc <KBD_keys_map+0x6>
     dbc:	1f 92       	push	r1
     dbe:	cd b7       	in	r28, 0x3d	; 61
     dc0:	de b7       	in	r29, 0x3e	; 62
     dc2:	9b 83       	std	Y+3, r25	; 0x03
     dc4:	8a 83       	std	Y+2, r24	; 0x02
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     dc6:	19 82       	std	Y+1, r1	; 0x01
     dc8:	16 c0       	rjmp	.+44     	; 0xdf6 <KBD_keys_map+0x40>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
     dca:	89 81       	ldd	r24, Y+1	; 0x01
     dcc:	88 2f       	mov	r24, r24
     dce:	90 e0       	ldi	r25, 0x00	; 0
     dd0:	2a 81       	ldd	r18, Y+2	; 0x02
     dd2:	3b 81       	ldd	r19, Y+3	; 0x03
     dd4:	82 0f       	add	r24, r18
     dd6:	93 1f       	adc	r25, r19
     dd8:	fc 01       	movw	r30, r24
     dda:	80 81       	ld	r24, Z
     ddc:	81 30       	cpi	r24, 0x01	; 1
     dde:	41 f4       	brne	.+16     	; 0xdf0 <KBD_keys_map+0x3a>
     de0:	89 81       	ldd	r24, Y+1	; 0x01
     de2:	88 2f       	mov	r24, r24
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	8f 59       	subi	r24, 0x9F	; 159
     de8:	9f 4f       	sbci	r25, 0xFF	; 255
     dea:	fc 01       	movw	r30, r24
     dec:	80 81       	ld	r24, Z
     dee:	07 c0       	rjmp	.+14     	; 0xdfe <KBD_keys_map+0x48>
		}
	}
u8 KBD_keys_map(u8* keys)
{
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     df0:	89 81       	ldd	r24, Y+1	; 0x01
     df2:	8f 5f       	subi	r24, 0xFF	; 255
     df4:	89 83       	std	Y+1, r24	; 0x01
     df6:	89 81       	ldd	r24, Y+1	; 0x01
     df8:	80 31       	cpi	r24, 0x10	; 16
     dfa:	38 f3       	brcs	.-50     	; 0xdca <KBD_keys_map+0x14>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
    }
    return 0xff;
     dfc:	8f ef       	ldi	r24, 0xFF	; 255
}
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	08 95       	ret

00000e0a <LCD_Void_Write>:
#define F_CPU 8000000
#include "avr/delay.h"

static void LCD_Void_Write(u8 copy_u8_value) // the user wont use this func because only other functions will use it so the prototype will be in private.h
//and to make this func visible only in this file not on the whole project we will put static in front of it
{
     e0a:	cf 93       	push	r28
     e0c:	df 93       	push	r29
     e0e:	cd b7       	in	r28, 0x3d	; 61
     e10:	de b7       	in	r29, 0x3e	; 62
     e12:	2f 97       	sbiw	r28, 0x0f	; 15
     e14:	0f b6       	in	r0, 0x3f	; 63
     e16:	f8 94       	cli
     e18:	de bf       	out	0x3e, r29	; 62
     e1a:	0f be       	out	0x3f, r0	; 63
     e1c:	cd bf       	out	0x3d, r28	; 61
     e1e:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_u8SetPinValue(LCD_u8_RW_Pin,DIO_u8_LOW);
     e20:	60 e0       	ldi	r22, 0x00	; 0
     e22:	81 e1       	ldi	r24, 0x11	; 17
     e24:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D0_Pin,Get_Bit(copy_u8_value,0));
     e28:	8f 85       	ldd	r24, Y+15	; 0x0f
     e2a:	81 70       	andi	r24, 0x01	; 1
     e2c:	68 2f       	mov	r22, r24
     e2e:	87 e0       	ldi	r24, 0x07	; 7
     e30:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D1_Pin,Get_Bit(copy_u8_value,1));
     e34:	8f 85       	ldd	r24, Y+15	; 0x0f
     e36:	86 95       	lsr	r24
     e38:	81 70       	andi	r24, 0x01	; 1
     e3a:	68 2f       	mov	r22, r24
     e3c:	86 e0       	ldi	r24, 0x06	; 6
     e3e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D2_Pin,Get_Bit(copy_u8_value,2));
     e42:	8f 85       	ldd	r24, Y+15	; 0x0f
     e44:	86 95       	lsr	r24
     e46:	86 95       	lsr	r24
     e48:	81 70       	andi	r24, 0x01	; 1
     e4a:	68 2f       	mov	r22, r24
     e4c:	85 e0       	ldi	r24, 0x05	; 5
     e4e:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D3_Pin,Get_Bit(copy_u8_value,3));
     e52:	8f 85       	ldd	r24, Y+15	; 0x0f
     e54:	86 95       	lsr	r24
     e56:	86 95       	lsr	r24
     e58:	86 95       	lsr	r24
     e5a:	81 70       	andi	r24, 0x01	; 1
     e5c:	68 2f       	mov	r22, r24
     e5e:	84 e0       	ldi	r24, 0x04	; 4
     e60:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D4_Pin,Get_Bit(copy_u8_value,4));
     e64:	8f 85       	ldd	r24, Y+15	; 0x0f
     e66:	82 95       	swap	r24
     e68:	8f 70       	andi	r24, 0x0F	; 15
     e6a:	81 70       	andi	r24, 0x01	; 1
     e6c:	68 2f       	mov	r22, r24
     e6e:	83 e0       	ldi	r24, 0x03	; 3
     e70:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D5_Pin,Get_Bit(copy_u8_value,5));
     e74:	8f 85       	ldd	r24, Y+15	; 0x0f
     e76:	82 95       	swap	r24
     e78:	86 95       	lsr	r24
     e7a:	87 70       	andi	r24, 0x07	; 7
     e7c:	81 70       	andi	r24, 0x01	; 1
     e7e:	68 2f       	mov	r22, r24
     e80:	82 e0       	ldi	r24, 0x02	; 2
     e82:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D6_Pin,Get_Bit(copy_u8_value,6));
     e86:	8f 85       	ldd	r24, Y+15	; 0x0f
     e88:	82 95       	swap	r24
     e8a:	86 95       	lsr	r24
     e8c:	86 95       	lsr	r24
     e8e:	83 70       	andi	r24, 0x03	; 3
     e90:	81 70       	andi	r24, 0x01	; 1
     e92:	68 2f       	mov	r22, r24
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D7_Pin,Get_Bit(copy_u8_value,7));
     e9a:	8f 85       	ldd	r24, Y+15	; 0x0f
     e9c:	88 1f       	adc	r24, r24
     e9e:	88 27       	eor	r24, r24
     ea0:	88 1f       	adc	r24, r24
     ea2:	68 2f       	mov	r22, r24
     ea4:	80 e0       	ldi	r24, 0x00	; 0
     ea6:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_HIGH);
     eaa:	61 e0       	ldi	r22, 0x01	; 1
     eac:	82 e1       	ldi	r24, 0x12	; 18
     eae:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	a0 e8       	ldi	r26, 0x80	; 128
     eb8:	bf e3       	ldi	r27, 0x3F	; 63
     eba:	89 83       	std	Y+1, r24	; 0x01
     ebc:	9a 83       	std	Y+2, r25	; 0x02
     ebe:	ab 83       	std	Y+3, r26	; 0x03
     ec0:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     ec2:	20 e0       	ldi	r18, 0x00	; 0
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	4a ef       	ldi	r20, 0xFA	; 250
     ec8:	54 e4       	ldi	r21, 0x44	; 68
     eca:	69 81       	ldd	r22, Y+1	; 0x01
     ecc:	7a 81       	ldd	r23, Y+2	; 0x02
     ece:	8b 81       	ldd	r24, Y+3	; 0x03
     ed0:	9c 81       	ldd	r25, Y+4	; 0x04
     ed2:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
     ed6:	dc 01       	movw	r26, r24
     ed8:	cb 01       	movw	r24, r22
     eda:	8d 83       	std	Y+5, r24	; 0x05
     edc:	9e 83       	std	Y+6, r25	; 0x06
     ede:	af 83       	std	Y+7, r26	; 0x07
     ee0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     ee2:	20 e0       	ldi	r18, 0x00	; 0
     ee4:	30 e0       	ldi	r19, 0x00	; 0
     ee6:	40 e8       	ldi	r20, 0x80	; 128
     ee8:	5f e3       	ldi	r21, 0x3F	; 63
     eea:	6d 81       	ldd	r22, Y+5	; 0x05
     eec:	7e 81       	ldd	r23, Y+6	; 0x06
     eee:	8f 81       	ldd	r24, Y+7	; 0x07
     ef0:	98 85       	ldd	r25, Y+8	; 0x08
     ef2:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
     ef6:	88 23       	and	r24, r24
     ef8:	2c f4       	brge	.+10     	; 0xf04 <LCD_Void_Write+0xfa>
		__ticks = 1;
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	9a 87       	std	Y+10, r25	; 0x0a
     f00:	89 87       	std	Y+9, r24	; 0x09
     f02:	3f c0       	rjmp	.+126    	; 0xf82 <LCD_Void_Write+0x178>
	else if (__tmp > 65535)
     f04:	20 e0       	ldi	r18, 0x00	; 0
     f06:	3f ef       	ldi	r19, 0xFF	; 255
     f08:	4f e7       	ldi	r20, 0x7F	; 127
     f0a:	57 e4       	ldi	r21, 0x47	; 71
     f0c:	6d 81       	ldd	r22, Y+5	; 0x05
     f0e:	7e 81       	ldd	r23, Y+6	; 0x06
     f10:	8f 81       	ldd	r24, Y+7	; 0x07
     f12:	98 85       	ldd	r25, Y+8	; 0x08
     f14:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
     f18:	18 16       	cp	r1, r24
     f1a:	4c f5       	brge	.+82     	; 0xf6e <LCD_Void_Write+0x164>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f1c:	20 e0       	ldi	r18, 0x00	; 0
     f1e:	30 e0       	ldi	r19, 0x00	; 0
     f20:	40 e2       	ldi	r20, 0x20	; 32
     f22:	51 e4       	ldi	r21, 0x41	; 65
     f24:	69 81       	ldd	r22, Y+1	; 0x01
     f26:	7a 81       	ldd	r23, Y+2	; 0x02
     f28:	8b 81       	ldd	r24, Y+3	; 0x03
     f2a:	9c 81       	ldd	r25, Y+4	; 0x04
     f2c:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
     f30:	dc 01       	movw	r26, r24
     f32:	cb 01       	movw	r24, r22
     f34:	bc 01       	movw	r22, r24
     f36:	cd 01       	movw	r24, r26
     f38:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
     f3c:	dc 01       	movw	r26, r24
     f3e:	cb 01       	movw	r24, r22
     f40:	9a 87       	std	Y+10, r25	; 0x0a
     f42:	89 87       	std	Y+9, r24	; 0x09
     f44:	0f c0       	rjmp	.+30     	; 0xf64 <LCD_Void_Write+0x15a>
     f46:	88 ec       	ldi	r24, 0xC8	; 200
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	9c 87       	std	Y+12, r25	; 0x0c
     f4c:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     f4e:	8b 85       	ldd	r24, Y+11	; 0x0b
     f50:	9c 85       	ldd	r25, Y+12	; 0x0c
     f52:	01 97       	sbiw	r24, 0x01	; 1
     f54:	f1 f7       	brne	.-4      	; 0xf52 <LCD_Void_Write+0x148>
     f56:	9c 87       	std	Y+12, r25	; 0x0c
     f58:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f5a:	89 85       	ldd	r24, Y+9	; 0x09
     f5c:	9a 85       	ldd	r25, Y+10	; 0x0a
     f5e:	01 97       	sbiw	r24, 0x01	; 1
     f60:	9a 87       	std	Y+10, r25	; 0x0a
     f62:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	9a 85       	ldd	r25, Y+10	; 0x0a
     f68:	89 2b       	or	r24, r25
     f6a:	69 f7       	brne	.-38     	; 0xf46 <LCD_Void_Write+0x13c>
     f6c:	14 c0       	rjmp	.+40     	; 0xf96 <LCD_Void_Write+0x18c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f6e:	6d 81       	ldd	r22, Y+5	; 0x05
     f70:	7e 81       	ldd	r23, Y+6	; 0x06
     f72:	8f 81       	ldd	r24, Y+7	; 0x07
     f74:	98 85       	ldd	r25, Y+8	; 0x08
     f76:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
     f7a:	dc 01       	movw	r26, r24
     f7c:	cb 01       	movw	r24, r22
     f7e:	9a 87       	std	Y+10, r25	; 0x0a
     f80:	89 87       	std	Y+9, r24	; 0x09
     f82:	89 85       	ldd	r24, Y+9	; 0x09
     f84:	9a 85       	ldd	r25, Y+10	; 0x0a
     f86:	9e 87       	std	Y+14, r25	; 0x0e
     f88:	8d 87       	std	Y+13, r24	; 0x0d
     f8a:	8d 85       	ldd	r24, Y+13	; 0x0d
     f8c:	9e 85       	ldd	r25, Y+14	; 0x0e
     f8e:	01 97       	sbiw	r24, 0x01	; 1
     f90:	f1 f7       	brne	.-4      	; 0xf8e <LCD_Void_Write+0x184>
     f92:	9e 87       	std	Y+14, r25	; 0x0e
     f94:	8d 87       	std	Y+13, r24	; 0x0d
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_LOW);
     f96:	60 e0       	ldi	r22, 0x00	; 0
     f98:	82 e1       	ldi	r24, 0x12	; 18
     f9a:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
}
     f9e:	00 00       	nop
     fa0:	2f 96       	adiw	r28, 0x0f	; 15
     fa2:	0f b6       	in	r0, 0x3f	; 63
     fa4:	f8 94       	cli
     fa6:	de bf       	out	0x3e, r29	; 62
     fa8:	0f be       	out	0x3f, r0	; 63
     faa:	cd bf       	out	0x3d, r28	; 61
     fac:	df 91       	pop	r29
     fae:	cf 91       	pop	r28
     fb0:	08 95       	ret

00000fb2 <LCD_Void_Write_Cmd>:

void LCD_Void_Write_Cmd(u8 copy_u8_cmd)
{
     fb2:	cf 93       	push	r28
     fb4:	df 93       	push	r29
     fb6:	1f 92       	push	r1
     fb8:	cd b7       	in	r28, 0x3d	; 61
     fba:	de b7       	in	r29, 0x3e	; 62
     fbc:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue (LCD_u8_RS_Pin,DIO_u8_LOW);
     fbe:	60 e0       	ldi	r22, 0x00	; 0
     fc0:	80 e1       	ldi	r24, 0x10	; 16
     fc2:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_cmd);
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	0e 94 05 07 	call	0xe0a	; 0xe0a <LCD_Void_Write>
}
     fcc:	00 00       	nop
     fce:	0f 90       	pop	r0
     fd0:	df 91       	pop	r29
     fd2:	cf 91       	pop	r28
     fd4:	08 95       	ret

00000fd6 <LCD_Void_Write_Data>:

void LCD_Void_Write_Data(u8 copy_u8_data)
{
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
     fda:	1f 92       	push	r1
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
     fe0:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue(LCD_u8_RS_Pin,DIO_u8_HIGH);
     fe2:	61 e0       	ldi	r22, 0x01	; 1
     fe4:	80 e1       	ldi	r24, 0x10	; 16
     fe6:	0e 94 1f 03 	call	0x63e	; 0x63e <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_data);
     fea:	89 81       	ldd	r24, Y+1	; 0x01
     fec:	0e 94 05 07 	call	0xe0a	; 0xe0a <LCD_Void_Write>
}
     ff0:	00 00       	nop
     ff2:	0f 90       	pop	r0
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	08 95       	ret

00000ffa <LCD_initialize>:


void LCD_initialize(void)
{
     ffa:	0f 93       	push	r16
     ffc:	1f 93       	push	r17
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    1002:	cd b7       	in	r28, 0x3d	; 61
    1004:	de b7       	in	r29, 0x3e	; 62
    1006:	ca 56       	subi	r28, 0x6A	; 106
    1008:	d1 09       	sbc	r29, r1
    100a:	0f b6       	in	r0, 0x3f	; 63
    100c:	f8 94       	cli
    100e:	de bf       	out	0x3e, r29	; 62
    1010:	0f be       	out	0x3f, r0	; 63
    1012:	cd bf       	out	0x3d, r28	; 61
	DIO_u8SetPinDirection(LCD_u8_RS_Pin,1);
    1014:	61 e0       	ldi	r22, 0x01	; 1
    1016:	80 e1       	ldi	r24, 0x10	; 16
    1018:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_RW_Pin,1);
    101c:	61 e0       	ldi	r22, 0x01	; 1
    101e:	81 e1       	ldi	r24, 0x11	; 17
    1020:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_E_Pin,1);
    1024:	61 e0       	ldi	r22, 0x01	; 1
    1026:	82 e1       	ldi	r24, 0x12	; 18
    1028:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D0_Pin,1);
    102c:	61 e0       	ldi	r22, 0x01	; 1
    102e:	87 e0       	ldi	r24, 0x07	; 7
    1030:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D1_Pin,1);
    1034:	61 e0       	ldi	r22, 0x01	; 1
    1036:	86 e0       	ldi	r24, 0x06	; 6
    1038:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D2_Pin,1);
    103c:	61 e0       	ldi	r22, 0x01	; 1
    103e:	85 e0       	ldi	r24, 0x05	; 5
    1040:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D3_Pin,1);
    1044:	61 e0       	ldi	r22, 0x01	; 1
    1046:	84 e0       	ldi	r24, 0x04	; 4
    1048:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D4_Pin,1);
    104c:	61 e0       	ldi	r22, 0x01	; 1
    104e:	83 e0       	ldi	r24, 0x03	; 3
    1050:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D5_Pin,1);
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	82 e0       	ldi	r24, 0x02	; 2
    1058:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D6_Pin,1);
    105c:	61 e0       	ldi	r22, 0x01	; 1
    105e:	81 e0       	ldi	r24, 0x01	; 1
    1060:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D7_Pin,1);
    1064:	61 e0       	ldi	r22, 0x01	; 1
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	0e 94 29 02 	call	0x452	; 0x452 <DIO_u8SetPinDirection>
    106c:	80 e0       	ldi	r24, 0x00	; 0
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	a8 e4       	ldi	r26, 0x48	; 72
    1072:	b2 e4       	ldi	r27, 0x42	; 66
    1074:	89 83       	std	Y+1, r24	; 0x01
    1076:	9a 83       	std	Y+2, r25	; 0x02
    1078:	ab 83       	std	Y+3, r26	; 0x03
    107a:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    107c:	8e 01       	movw	r16, r28
    107e:	0f 59       	subi	r16, 0x9F	; 159
    1080:	1f 4f       	sbci	r17, 0xFF	; 255
    1082:	20 e0       	ldi	r18, 0x00	; 0
    1084:	30 e0       	ldi	r19, 0x00	; 0
    1086:	4a ef       	ldi	r20, 0xFA	; 250
    1088:	54 e4       	ldi	r21, 0x44	; 68
    108a:	69 81       	ldd	r22, Y+1	; 0x01
    108c:	7a 81       	ldd	r23, Y+2	; 0x02
    108e:	8b 81       	ldd	r24, Y+3	; 0x03
    1090:	9c 81       	ldd	r25, Y+4	; 0x04
    1092:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1096:	dc 01       	movw	r26, r24
    1098:	cb 01       	movw	r24, r22
    109a:	f8 01       	movw	r30, r16
    109c:	80 83       	st	Z, r24
    109e:	91 83       	std	Z+1, r25	; 0x01
    10a0:	a2 83       	std	Z+2, r26	; 0x02
    10a2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    10a4:	ce 01       	movw	r24, r28
    10a6:	8f 59       	subi	r24, 0x9F	; 159
    10a8:	9f 4f       	sbci	r25, 0xFF	; 255
    10aa:	20 e0       	ldi	r18, 0x00	; 0
    10ac:	30 e0       	ldi	r19, 0x00	; 0
    10ae:	40 e8       	ldi	r20, 0x80	; 128
    10b0:	5f e3       	ldi	r21, 0x3F	; 63
    10b2:	fc 01       	movw	r30, r24
    10b4:	60 81       	ld	r22, Z
    10b6:	71 81       	ldd	r23, Z+1	; 0x01
    10b8:	82 81       	ldd	r24, Z+2	; 0x02
    10ba:	93 81       	ldd	r25, Z+3	; 0x03
    10bc:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    10c0:	88 23       	and	r24, r24
    10c2:	4c f4       	brge	.+18     	; 0x10d6 <LCD_initialize+0xdc>
		__ticks = 1;
    10c4:	ce 01       	movw	r24, r28
    10c6:	8b 59       	subi	r24, 0x9B	; 155
    10c8:	9f 4f       	sbci	r25, 0xFF	; 255
    10ca:	21 e0       	ldi	r18, 0x01	; 1
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	fc 01       	movw	r30, r24
    10d0:	31 83       	std	Z+1, r19	; 0x01
    10d2:	20 83       	st	Z, r18
    10d4:	69 c0       	rjmp	.+210    	; 0x11a8 <LCD_initialize+0x1ae>
	else if (__tmp > 65535)
    10d6:	ce 01       	movw	r24, r28
    10d8:	8f 59       	subi	r24, 0x9F	; 159
    10da:	9f 4f       	sbci	r25, 0xFF	; 255
    10dc:	20 e0       	ldi	r18, 0x00	; 0
    10de:	3f ef       	ldi	r19, 0xFF	; 255
    10e0:	4f e7       	ldi	r20, 0x7F	; 127
    10e2:	57 e4       	ldi	r21, 0x47	; 71
    10e4:	fc 01       	movw	r30, r24
    10e6:	60 81       	ld	r22, Z
    10e8:	71 81       	ldd	r23, Z+1	; 0x01
    10ea:	82 81       	ldd	r24, Z+2	; 0x02
    10ec:	93 81       	ldd	r25, Z+3	; 0x03
    10ee:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    10f2:	18 16       	cp	r1, r24
    10f4:	0c f0       	brlt	.+2      	; 0x10f8 <LCD_initialize+0xfe>
    10f6:	46 c0       	rjmp	.+140    	; 0x1184 <LCD_initialize+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10f8:	20 e0       	ldi	r18, 0x00	; 0
    10fa:	30 e0       	ldi	r19, 0x00	; 0
    10fc:	40 e2       	ldi	r20, 0x20	; 32
    10fe:	51 e4       	ldi	r21, 0x41	; 65
    1100:	69 81       	ldd	r22, Y+1	; 0x01
    1102:	7a 81       	ldd	r23, Y+2	; 0x02
    1104:	8b 81       	ldd	r24, Y+3	; 0x03
    1106:	9c 81       	ldd	r25, Y+4	; 0x04
    1108:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    110c:	dc 01       	movw	r26, r24
    110e:	cb 01       	movw	r24, r22
    1110:	8e 01       	movw	r16, r28
    1112:	0b 59       	subi	r16, 0x9B	; 155
    1114:	1f 4f       	sbci	r17, 0xFF	; 255
    1116:	bc 01       	movw	r22, r24
    1118:	cd 01       	movw	r24, r26
    111a:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    111e:	dc 01       	movw	r26, r24
    1120:	cb 01       	movw	r24, r22
    1122:	f8 01       	movw	r30, r16
    1124:	91 83       	std	Z+1, r25	; 0x01
    1126:	80 83       	st	Z, r24
    1128:	24 c0       	rjmp	.+72     	; 0x1172 <LCD_initialize+0x178>
    112a:	ce 01       	movw	r24, r28
    112c:	89 59       	subi	r24, 0x99	; 153
    112e:	9f 4f       	sbci	r25, 0xFF	; 255
    1130:	28 ec       	ldi	r18, 0xC8	; 200
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	fc 01       	movw	r30, r24
    1136:	31 83       	std	Z+1, r19	; 0x01
    1138:	20 83       	st	Z, r18
    113a:	ce 01       	movw	r24, r28
    113c:	89 59       	subi	r24, 0x99	; 153
    113e:	9f 4f       	sbci	r25, 0xFF	; 255
    1140:	fc 01       	movw	r30, r24
    1142:	80 81       	ld	r24, Z
    1144:	91 81       	ldd	r25, Z+1	; 0x01
    1146:	01 97       	sbiw	r24, 0x01	; 1
    1148:	f1 f7       	brne	.-4      	; 0x1146 <LCD_initialize+0x14c>
    114a:	9e 01       	movw	r18, r28
    114c:	29 59       	subi	r18, 0x99	; 153
    114e:	3f 4f       	sbci	r19, 0xFF	; 255
    1150:	f9 01       	movw	r30, r18
    1152:	91 83       	std	Z+1, r25	; 0x01
    1154:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1156:	ce 01       	movw	r24, r28
    1158:	8b 59       	subi	r24, 0x9B	; 155
    115a:	9f 4f       	sbci	r25, 0xFF	; 255
    115c:	9e 01       	movw	r18, r28
    115e:	2b 59       	subi	r18, 0x9B	; 155
    1160:	3f 4f       	sbci	r19, 0xFF	; 255
    1162:	f9 01       	movw	r30, r18
    1164:	20 81       	ld	r18, Z
    1166:	31 81       	ldd	r19, Z+1	; 0x01
    1168:	21 50       	subi	r18, 0x01	; 1
    116a:	31 09       	sbc	r19, r1
    116c:	fc 01       	movw	r30, r24
    116e:	31 83       	std	Z+1, r19	; 0x01
    1170:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1172:	ce 01       	movw	r24, r28
    1174:	8b 59       	subi	r24, 0x9B	; 155
    1176:	9f 4f       	sbci	r25, 0xFF	; 255
    1178:	fc 01       	movw	r30, r24
    117a:	80 81       	ld	r24, Z
    117c:	91 81       	ldd	r25, Z+1	; 0x01
    117e:	89 2b       	or	r24, r25
    1180:	a1 f6       	brne	.-88     	; 0x112a <LCD_initialize+0x130>
    1182:	2c c0       	rjmp	.+88     	; 0x11dc <LCD_initialize+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1184:	8e 01       	movw	r16, r28
    1186:	0b 59       	subi	r16, 0x9B	; 155
    1188:	1f 4f       	sbci	r17, 0xFF	; 255
    118a:	ce 01       	movw	r24, r28
    118c:	8f 59       	subi	r24, 0x9F	; 159
    118e:	9f 4f       	sbci	r25, 0xFF	; 255
    1190:	fc 01       	movw	r30, r24
    1192:	60 81       	ld	r22, Z
    1194:	71 81       	ldd	r23, Z+1	; 0x01
    1196:	82 81       	ldd	r24, Z+2	; 0x02
    1198:	93 81       	ldd	r25, Z+3	; 0x03
    119a:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    119e:	dc 01       	movw	r26, r24
    11a0:	cb 01       	movw	r24, r22
    11a2:	f8 01       	movw	r30, r16
    11a4:	91 83       	std	Z+1, r25	; 0x01
    11a6:	80 83       	st	Z, r24
    11a8:	ce 01       	movw	r24, r28
    11aa:	87 59       	subi	r24, 0x97	; 151
    11ac:	9f 4f       	sbci	r25, 0xFF	; 255
    11ae:	9e 01       	movw	r18, r28
    11b0:	2b 59       	subi	r18, 0x9B	; 155
    11b2:	3f 4f       	sbci	r19, 0xFF	; 255
    11b4:	f9 01       	movw	r30, r18
    11b6:	20 81       	ld	r18, Z
    11b8:	31 81       	ldd	r19, Z+1	; 0x01
    11ba:	fc 01       	movw	r30, r24
    11bc:	31 83       	std	Z+1, r19	; 0x01
    11be:	20 83       	st	Z, r18
    11c0:	ce 01       	movw	r24, r28
    11c2:	87 59       	subi	r24, 0x97	; 151
    11c4:	9f 4f       	sbci	r25, 0xFF	; 255
    11c6:	fc 01       	movw	r30, r24
    11c8:	80 81       	ld	r24, Z
    11ca:	91 81       	ldd	r25, Z+1	; 0x01
    11cc:	01 97       	sbiw	r24, 0x01	; 1
    11ce:	f1 f7       	brne	.-4      	; 0x11cc <LCD_initialize+0x1d2>
    11d0:	9e 01       	movw	r18, r28
    11d2:	27 59       	subi	r18, 0x97	; 151
    11d4:	3f 4f       	sbci	r19, 0xFF	; 255
    11d6:	f9 01       	movw	r30, r18
    11d8:	91 83       	std	Z+1, r25	; 0x01
    11da:	80 83       	st	Z, r24
    11dc:	80 e0       	ldi	r24, 0x00	; 0
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	a0 e2       	ldi	r26, 0x20	; 32
    11e2:	b2 e4       	ldi	r27, 0x42	; 66
    11e4:	8d 83       	std	Y+5, r24	; 0x05
    11e6:	9e 83       	std	Y+6, r25	; 0x06
    11e8:	af 83       	std	Y+7, r26	; 0x07
    11ea:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    11ec:	8e 01       	movw	r16, r28
    11ee:	09 5a       	subi	r16, 0xA9	; 169
    11f0:	1f 4f       	sbci	r17, 0xFF	; 255
    11f2:	20 e0       	ldi	r18, 0x00	; 0
    11f4:	30 e0       	ldi	r19, 0x00	; 0
    11f6:	4a ef       	ldi	r20, 0xFA	; 250
    11f8:	54 e4       	ldi	r21, 0x44	; 68
    11fa:	6d 81       	ldd	r22, Y+5	; 0x05
    11fc:	7e 81       	ldd	r23, Y+6	; 0x06
    11fe:	8f 81       	ldd	r24, Y+7	; 0x07
    1200:	98 85       	ldd	r25, Y+8	; 0x08
    1202:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1206:	dc 01       	movw	r26, r24
    1208:	cb 01       	movw	r24, r22
    120a:	f8 01       	movw	r30, r16
    120c:	80 83       	st	Z, r24
    120e:	91 83       	std	Z+1, r25	; 0x01
    1210:	a2 83       	std	Z+2, r26	; 0x02
    1212:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1214:	ce 01       	movw	r24, r28
    1216:	89 5a       	subi	r24, 0xA9	; 169
    1218:	9f 4f       	sbci	r25, 0xFF	; 255
    121a:	20 e0       	ldi	r18, 0x00	; 0
    121c:	30 e0       	ldi	r19, 0x00	; 0
    121e:	40 e8       	ldi	r20, 0x80	; 128
    1220:	5f e3       	ldi	r21, 0x3F	; 63
    1222:	fc 01       	movw	r30, r24
    1224:	60 81       	ld	r22, Z
    1226:	71 81       	ldd	r23, Z+1	; 0x01
    1228:	82 81       	ldd	r24, Z+2	; 0x02
    122a:	93 81       	ldd	r25, Z+3	; 0x03
    122c:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    1230:	88 23       	and	r24, r24
    1232:	4c f4       	brge	.+18     	; 0x1246 <LCD_initialize+0x24c>
		__ticks = 1;
    1234:	ce 01       	movw	r24, r28
    1236:	85 5a       	subi	r24, 0xA5	; 165
    1238:	9f 4f       	sbci	r25, 0xFF	; 255
    123a:	21 e0       	ldi	r18, 0x01	; 1
    123c:	30 e0       	ldi	r19, 0x00	; 0
    123e:	fc 01       	movw	r30, r24
    1240:	31 83       	std	Z+1, r19	; 0x01
    1242:	20 83       	st	Z, r18
    1244:	69 c0       	rjmp	.+210    	; 0x1318 <LCD_initialize+0x31e>
	else if (__tmp > 65535)
    1246:	ce 01       	movw	r24, r28
    1248:	89 5a       	subi	r24, 0xA9	; 169
    124a:	9f 4f       	sbci	r25, 0xFF	; 255
    124c:	20 e0       	ldi	r18, 0x00	; 0
    124e:	3f ef       	ldi	r19, 0xFF	; 255
    1250:	4f e7       	ldi	r20, 0x7F	; 127
    1252:	57 e4       	ldi	r21, 0x47	; 71
    1254:	fc 01       	movw	r30, r24
    1256:	60 81       	ld	r22, Z
    1258:	71 81       	ldd	r23, Z+1	; 0x01
    125a:	82 81       	ldd	r24, Z+2	; 0x02
    125c:	93 81       	ldd	r25, Z+3	; 0x03
    125e:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    1262:	18 16       	cp	r1, r24
    1264:	0c f0       	brlt	.+2      	; 0x1268 <LCD_initialize+0x26e>
    1266:	46 c0       	rjmp	.+140    	; 0x12f4 <LCD_initialize+0x2fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1268:	20 e0       	ldi	r18, 0x00	; 0
    126a:	30 e0       	ldi	r19, 0x00	; 0
    126c:	40 e2       	ldi	r20, 0x20	; 32
    126e:	51 e4       	ldi	r21, 0x41	; 65
    1270:	6d 81       	ldd	r22, Y+5	; 0x05
    1272:	7e 81       	ldd	r23, Y+6	; 0x06
    1274:	8f 81       	ldd	r24, Y+7	; 0x07
    1276:	98 85       	ldd	r25, Y+8	; 0x08
    1278:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    127c:	dc 01       	movw	r26, r24
    127e:	cb 01       	movw	r24, r22
    1280:	8e 01       	movw	r16, r28
    1282:	05 5a       	subi	r16, 0xA5	; 165
    1284:	1f 4f       	sbci	r17, 0xFF	; 255
    1286:	bc 01       	movw	r22, r24
    1288:	cd 01       	movw	r24, r26
    128a:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    128e:	dc 01       	movw	r26, r24
    1290:	cb 01       	movw	r24, r22
    1292:	f8 01       	movw	r30, r16
    1294:	91 83       	std	Z+1, r25	; 0x01
    1296:	80 83       	st	Z, r24
    1298:	24 c0       	rjmp	.+72     	; 0x12e2 <LCD_initialize+0x2e8>
    129a:	ce 01       	movw	r24, r28
    129c:	83 5a       	subi	r24, 0xA3	; 163
    129e:	9f 4f       	sbci	r25, 0xFF	; 255
    12a0:	28 ec       	ldi	r18, 0xC8	; 200
    12a2:	30 e0       	ldi	r19, 0x00	; 0
    12a4:	fc 01       	movw	r30, r24
    12a6:	31 83       	std	Z+1, r19	; 0x01
    12a8:	20 83       	st	Z, r18
    12aa:	ce 01       	movw	r24, r28
    12ac:	83 5a       	subi	r24, 0xA3	; 163
    12ae:	9f 4f       	sbci	r25, 0xFF	; 255
    12b0:	fc 01       	movw	r30, r24
    12b2:	80 81       	ld	r24, Z
    12b4:	91 81       	ldd	r25, Z+1	; 0x01
    12b6:	01 97       	sbiw	r24, 0x01	; 1
    12b8:	f1 f7       	brne	.-4      	; 0x12b6 <LCD_initialize+0x2bc>
    12ba:	9e 01       	movw	r18, r28
    12bc:	23 5a       	subi	r18, 0xA3	; 163
    12be:	3f 4f       	sbci	r19, 0xFF	; 255
    12c0:	f9 01       	movw	r30, r18
    12c2:	91 83       	std	Z+1, r25	; 0x01
    12c4:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12c6:	ce 01       	movw	r24, r28
    12c8:	85 5a       	subi	r24, 0xA5	; 165
    12ca:	9f 4f       	sbci	r25, 0xFF	; 255
    12cc:	9e 01       	movw	r18, r28
    12ce:	25 5a       	subi	r18, 0xA5	; 165
    12d0:	3f 4f       	sbci	r19, 0xFF	; 255
    12d2:	f9 01       	movw	r30, r18
    12d4:	20 81       	ld	r18, Z
    12d6:	31 81       	ldd	r19, Z+1	; 0x01
    12d8:	21 50       	subi	r18, 0x01	; 1
    12da:	31 09       	sbc	r19, r1
    12dc:	fc 01       	movw	r30, r24
    12de:	31 83       	std	Z+1, r19	; 0x01
    12e0:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12e2:	ce 01       	movw	r24, r28
    12e4:	85 5a       	subi	r24, 0xA5	; 165
    12e6:	9f 4f       	sbci	r25, 0xFF	; 255
    12e8:	fc 01       	movw	r30, r24
    12ea:	80 81       	ld	r24, Z
    12ec:	91 81       	ldd	r25, Z+1	; 0x01
    12ee:	89 2b       	or	r24, r25
    12f0:	a1 f6       	brne	.-88     	; 0x129a <LCD_initialize+0x2a0>
    12f2:	2c c0       	rjmp	.+88     	; 0x134c <LCD_initialize+0x352>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    12f4:	8e 01       	movw	r16, r28
    12f6:	05 5a       	subi	r16, 0xA5	; 165
    12f8:	1f 4f       	sbci	r17, 0xFF	; 255
    12fa:	ce 01       	movw	r24, r28
    12fc:	89 5a       	subi	r24, 0xA9	; 169
    12fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1300:	fc 01       	movw	r30, r24
    1302:	60 81       	ld	r22, Z
    1304:	71 81       	ldd	r23, Z+1	; 0x01
    1306:	82 81       	ldd	r24, Z+2	; 0x02
    1308:	93 81       	ldd	r25, Z+3	; 0x03
    130a:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    130e:	dc 01       	movw	r26, r24
    1310:	cb 01       	movw	r24, r22
    1312:	f8 01       	movw	r30, r16
    1314:	91 83       	std	Z+1, r25	; 0x01
    1316:	80 83       	st	Z, r24
    1318:	ce 01       	movw	r24, r28
    131a:	81 5a       	subi	r24, 0xA1	; 161
    131c:	9f 4f       	sbci	r25, 0xFF	; 255
    131e:	9e 01       	movw	r18, r28
    1320:	25 5a       	subi	r18, 0xA5	; 165
    1322:	3f 4f       	sbci	r19, 0xFF	; 255
    1324:	f9 01       	movw	r30, r18
    1326:	20 81       	ld	r18, Z
    1328:	31 81       	ldd	r19, Z+1	; 0x01
    132a:	fc 01       	movw	r30, r24
    132c:	31 83       	std	Z+1, r19	; 0x01
    132e:	20 83       	st	Z, r18
    1330:	ce 01       	movw	r24, r28
    1332:	81 5a       	subi	r24, 0xA1	; 161
    1334:	9f 4f       	sbci	r25, 0xFF	; 255
    1336:	fc 01       	movw	r30, r24
    1338:	80 81       	ld	r24, Z
    133a:	91 81       	ldd	r25, Z+1	; 0x01
    133c:	01 97       	sbiw	r24, 0x01	; 1
    133e:	f1 f7       	brne	.-4      	; 0x133c <LCD_initialize+0x342>
    1340:	9e 01       	movw	r18, r28
    1342:	21 5a       	subi	r18, 0xA1	; 161
    1344:	3f 4f       	sbci	r19, 0xFF	; 255
    1346:	f9 01       	movw	r30, r18
    1348:	91 83       	std	Z+1, r25	; 0x01
    134a:	80 83       	st	Z, r24
	_delay_ms(50);
	_delay_ms(40);
	LCD_Void_Write_Cmd(0b00111000);
    134c:	88 e3       	ldi	r24, 0x38	; 56
    134e:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
    1352:	80 e0       	ldi	r24, 0x00	; 0
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	a8 e4       	ldi	r26, 0x48	; 72
    1358:	b2 e4       	ldi	r27, 0x42	; 66
    135a:	89 87       	std	Y+9, r24	; 0x09
    135c:	9a 87       	std	Y+10, r25	; 0x0a
    135e:	ab 87       	std	Y+11, r26	; 0x0b
    1360:	bc 87       	std	Y+12, r27	; 0x0c
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    1362:	2b ea       	ldi	r18, 0xAB	; 171
    1364:	3a ea       	ldi	r19, 0xAA	; 170
    1366:	4a e2       	ldi	r20, 0x2A	; 42
    1368:	50 e4       	ldi	r21, 0x40	; 64
    136a:	69 85       	ldd	r22, Y+9	; 0x09
    136c:	7a 85       	ldd	r23, Y+10	; 0x0a
    136e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1370:	9c 85       	ldd	r25, Y+12	; 0x0c
    1372:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1376:	dc 01       	movw	r26, r24
    1378:	cb 01       	movw	r24, r22
    137a:	8b af       	std	Y+59, r24	; 0x3b
    137c:	9c af       	std	Y+60, r25	; 0x3c
    137e:	ad af       	std	Y+61, r26	; 0x3d
    1380:	be af       	std	Y+62, r27	; 0x3e
	__tmp2 = ((F_CPU) / 4e6) * __us;
    1382:	8e 01       	movw	r16, r28
    1384:	01 5c       	subi	r16, 0xC1	; 193
    1386:	1f 4f       	sbci	r17, 0xFF	; 255
    1388:	89 85       	ldd	r24, Y+9	; 0x09
    138a:	9a 85       	ldd	r25, Y+10	; 0x0a
    138c:	ab 85       	ldd	r26, Y+11	; 0x0b
    138e:	bc 85       	ldd	r27, Y+12	; 0x0c
    1390:	9c 01       	movw	r18, r24
    1392:	ad 01       	movw	r20, r26
    1394:	bc 01       	movw	r22, r24
    1396:	cd 01       	movw	r24, r26
    1398:	0e 94 20 30 	call	0x6040	; 0x6040 <__addsf3>
    139c:	dc 01       	movw	r26, r24
    139e:	cb 01       	movw	r24, r22
    13a0:	f8 01       	movw	r30, r16
    13a2:	80 83       	st	Z, r24
    13a4:	91 83       	std	Z+1, r25	; 0x01
    13a6:	a2 83       	std	Z+2, r26	; 0x02
    13a8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    13aa:	20 e0       	ldi	r18, 0x00	; 0
    13ac:	30 e0       	ldi	r19, 0x00	; 0
    13ae:	40 e8       	ldi	r20, 0x80	; 128
    13b0:	5f e3       	ldi	r21, 0x3F	; 63
    13b2:	6b ad       	ldd	r22, Y+59	; 0x3b
    13b4:	7c ad       	ldd	r23, Y+60	; 0x3c
    13b6:	8d ad       	ldd	r24, Y+61	; 0x3d
    13b8:	9e ad       	ldd	r25, Y+62	; 0x3e
    13ba:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    13be:	88 23       	and	r24, r24
    13c0:	3c f4       	brge	.+14     	; 0x13d0 <LCD_initialize+0x3d6>
		__ticks = 1;
    13c2:	ce 01       	movw	r24, r28
    13c4:	8d 5b       	subi	r24, 0xBD	; 189
    13c6:	9f 4f       	sbci	r25, 0xFF	; 255
    13c8:	21 e0       	ldi	r18, 0x01	; 1
    13ca:	fc 01       	movw	r30, r24
    13cc:	20 83       	st	Z, r18
    13ce:	22 c1       	rjmp	.+580    	; 0x1614 <LCD_initialize+0x61a>
	else if (__tmp2 > 65535)
    13d0:	ce 01       	movw	r24, r28
    13d2:	cf 96       	adiw	r24, 0x3f	; 63
    13d4:	20 e0       	ldi	r18, 0x00	; 0
    13d6:	3f ef       	ldi	r19, 0xFF	; 255
    13d8:	4f e7       	ldi	r20, 0x7F	; 127
    13da:	57 e4       	ldi	r21, 0x47	; 71
    13dc:	fc 01       	movw	r30, r24
    13de:	60 81       	ld	r22, Z
    13e0:	71 81       	ldd	r23, Z+1	; 0x01
    13e2:	82 81       	ldd	r24, Z+2	; 0x02
    13e4:	93 81       	ldd	r25, Z+3	; 0x03
    13e6:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    13ea:	18 16       	cp	r1, r24
    13ec:	0c f0       	brlt	.+2      	; 0x13f0 <LCD_initialize+0x3f6>
    13ee:	cd c0       	rjmp	.+410    	; 0x158a <LCD_initialize+0x590>
	{
		_delay_ms(__us / 1000.0);
    13f0:	20 e0       	ldi	r18, 0x00	; 0
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	4a e7       	ldi	r20, 0x7A	; 122
    13f6:	54 e4       	ldi	r21, 0x44	; 68
    13f8:	69 85       	ldd	r22, Y+9	; 0x09
    13fa:	7a 85       	ldd	r23, Y+10	; 0x0a
    13fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    13fe:	9c 85       	ldd	r25, Y+12	; 0x0c
    1400:	0e 94 91 30 	call	0x6122	; 0x6122 <__divsf3>
    1404:	dc 01       	movw	r26, r24
    1406:	cb 01       	movw	r24, r22
    1408:	9e 01       	movw	r18, r28
    140a:	2c 5b       	subi	r18, 0xBC	; 188
    140c:	3f 4f       	sbci	r19, 0xFF	; 255
    140e:	f9 01       	movw	r30, r18
    1410:	80 83       	st	Z, r24
    1412:	91 83       	std	Z+1, r25	; 0x01
    1414:	a2 83       	std	Z+2, r26	; 0x02
    1416:	b3 83       	std	Z+3, r27	; 0x03

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1418:	8e 01       	movw	r16, r28
    141a:	08 5b       	subi	r16, 0xB8	; 184
    141c:	1f 4f       	sbci	r17, 0xFF	; 255
    141e:	ce 01       	movw	r24, r28
    1420:	8c 5b       	subi	r24, 0xBC	; 188
    1422:	9f 4f       	sbci	r25, 0xFF	; 255
    1424:	20 e0       	ldi	r18, 0x00	; 0
    1426:	30 e0       	ldi	r19, 0x00	; 0
    1428:	4a ef       	ldi	r20, 0xFA	; 250
    142a:	54 e4       	ldi	r21, 0x44	; 68
    142c:	fc 01       	movw	r30, r24
    142e:	60 81       	ld	r22, Z
    1430:	71 81       	ldd	r23, Z+1	; 0x01
    1432:	82 81       	ldd	r24, Z+2	; 0x02
    1434:	93 81       	ldd	r25, Z+3	; 0x03
    1436:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    143a:	dc 01       	movw	r26, r24
    143c:	cb 01       	movw	r24, r22
    143e:	f8 01       	movw	r30, r16
    1440:	80 83       	st	Z, r24
    1442:	91 83       	std	Z+1, r25	; 0x01
    1444:	a2 83       	std	Z+2, r26	; 0x02
    1446:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1448:	ce 01       	movw	r24, r28
    144a:	88 5b       	subi	r24, 0xB8	; 184
    144c:	9f 4f       	sbci	r25, 0xFF	; 255
    144e:	20 e0       	ldi	r18, 0x00	; 0
    1450:	30 e0       	ldi	r19, 0x00	; 0
    1452:	40 e8       	ldi	r20, 0x80	; 128
    1454:	5f e3       	ldi	r21, 0x3F	; 63
    1456:	fc 01       	movw	r30, r24
    1458:	60 81       	ld	r22, Z
    145a:	71 81       	ldd	r23, Z+1	; 0x01
    145c:	82 81       	ldd	r24, Z+2	; 0x02
    145e:	93 81       	ldd	r25, Z+3	; 0x03
    1460:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    1464:	88 23       	and	r24, r24
    1466:	4c f4       	brge	.+18     	; 0x147a <LCD_initialize+0x480>
		__ticks = 1;
    1468:	ce 01       	movw	r24, r28
    146a:	84 5b       	subi	r24, 0xB4	; 180
    146c:	9f 4f       	sbci	r25, 0xFF	; 255
    146e:	21 e0       	ldi	r18, 0x01	; 1
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	fc 01       	movw	r30, r24
    1474:	31 83       	std	Z+1, r19	; 0x01
    1476:	20 83       	st	Z, r18
    1478:	6d c0       	rjmp	.+218    	; 0x1554 <LCD_initialize+0x55a>
	else if (__tmp > 65535)
    147a:	ce 01       	movw	r24, r28
    147c:	88 5b       	subi	r24, 0xB8	; 184
    147e:	9f 4f       	sbci	r25, 0xFF	; 255
    1480:	20 e0       	ldi	r18, 0x00	; 0
    1482:	3f ef       	ldi	r19, 0xFF	; 255
    1484:	4f e7       	ldi	r20, 0x7F	; 127
    1486:	57 e4       	ldi	r21, 0x47	; 71
    1488:	fc 01       	movw	r30, r24
    148a:	60 81       	ld	r22, Z
    148c:	71 81       	ldd	r23, Z+1	; 0x01
    148e:	82 81       	ldd	r24, Z+2	; 0x02
    1490:	93 81       	ldd	r25, Z+3	; 0x03
    1492:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    1496:	18 16       	cp	r1, r24
    1498:	0c f0       	brlt	.+2      	; 0x149c <LCD_initialize+0x4a2>
    149a:	4a c0       	rjmp	.+148    	; 0x1530 <LCD_initialize+0x536>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    149c:	ce 01       	movw	r24, r28
    149e:	8c 5b       	subi	r24, 0xBC	; 188
    14a0:	9f 4f       	sbci	r25, 0xFF	; 255
    14a2:	20 e0       	ldi	r18, 0x00	; 0
    14a4:	30 e0       	ldi	r19, 0x00	; 0
    14a6:	40 e2       	ldi	r20, 0x20	; 32
    14a8:	51 e4       	ldi	r21, 0x41	; 65
    14aa:	fc 01       	movw	r30, r24
    14ac:	60 81       	ld	r22, Z
    14ae:	71 81       	ldd	r23, Z+1	; 0x01
    14b0:	82 81       	ldd	r24, Z+2	; 0x02
    14b2:	93 81       	ldd	r25, Z+3	; 0x03
    14b4:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    14b8:	dc 01       	movw	r26, r24
    14ba:	cb 01       	movw	r24, r22
    14bc:	8e 01       	movw	r16, r28
    14be:	04 5b       	subi	r16, 0xB4	; 180
    14c0:	1f 4f       	sbci	r17, 0xFF	; 255
    14c2:	bc 01       	movw	r22, r24
    14c4:	cd 01       	movw	r24, r26
    14c6:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    14ca:	dc 01       	movw	r26, r24
    14cc:	cb 01       	movw	r24, r22
    14ce:	f8 01       	movw	r30, r16
    14d0:	91 83       	std	Z+1, r25	; 0x01
    14d2:	80 83       	st	Z, r24
    14d4:	24 c0       	rjmp	.+72     	; 0x151e <LCD_initialize+0x524>
    14d6:	ce 01       	movw	r24, r28
    14d8:	82 5b       	subi	r24, 0xB2	; 178
    14da:	9f 4f       	sbci	r25, 0xFF	; 255
    14dc:	28 ec       	ldi	r18, 0xC8	; 200
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	fc 01       	movw	r30, r24
    14e2:	31 83       	std	Z+1, r19	; 0x01
    14e4:	20 83       	st	Z, r18
    14e6:	ce 01       	movw	r24, r28
    14e8:	82 5b       	subi	r24, 0xB2	; 178
    14ea:	9f 4f       	sbci	r25, 0xFF	; 255
    14ec:	fc 01       	movw	r30, r24
    14ee:	80 81       	ld	r24, Z
    14f0:	91 81       	ldd	r25, Z+1	; 0x01
    14f2:	01 97       	sbiw	r24, 0x01	; 1
    14f4:	f1 f7       	brne	.-4      	; 0x14f2 <LCD_initialize+0x4f8>
    14f6:	9e 01       	movw	r18, r28
    14f8:	22 5b       	subi	r18, 0xB2	; 178
    14fa:	3f 4f       	sbci	r19, 0xFF	; 255
    14fc:	f9 01       	movw	r30, r18
    14fe:	91 83       	std	Z+1, r25	; 0x01
    1500:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1502:	ce 01       	movw	r24, r28
    1504:	84 5b       	subi	r24, 0xB4	; 180
    1506:	9f 4f       	sbci	r25, 0xFF	; 255
    1508:	9e 01       	movw	r18, r28
    150a:	24 5b       	subi	r18, 0xB4	; 180
    150c:	3f 4f       	sbci	r19, 0xFF	; 255
    150e:	f9 01       	movw	r30, r18
    1510:	20 81       	ld	r18, Z
    1512:	31 81       	ldd	r19, Z+1	; 0x01
    1514:	21 50       	subi	r18, 0x01	; 1
    1516:	31 09       	sbc	r19, r1
    1518:	fc 01       	movw	r30, r24
    151a:	31 83       	std	Z+1, r19	; 0x01
    151c:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    151e:	ce 01       	movw	r24, r28
    1520:	84 5b       	subi	r24, 0xB4	; 180
    1522:	9f 4f       	sbci	r25, 0xFF	; 255
    1524:	fc 01       	movw	r30, r24
    1526:	80 81       	ld	r24, Z
    1528:	91 81       	ldd	r25, Z+1	; 0x01
    152a:	89 2b       	or	r24, r25
    152c:	a1 f6       	brne	.-88     	; 0x14d6 <LCD_initialize+0x4dc>
    152e:	72 c0       	rjmp	.+228    	; 0x1614 <LCD_initialize+0x61a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1530:	8e 01       	movw	r16, r28
    1532:	04 5b       	subi	r16, 0xB4	; 180
    1534:	1f 4f       	sbci	r17, 0xFF	; 255
    1536:	ce 01       	movw	r24, r28
    1538:	88 5b       	subi	r24, 0xB8	; 184
    153a:	9f 4f       	sbci	r25, 0xFF	; 255
    153c:	fc 01       	movw	r30, r24
    153e:	60 81       	ld	r22, Z
    1540:	71 81       	ldd	r23, Z+1	; 0x01
    1542:	82 81       	ldd	r24, Z+2	; 0x02
    1544:	93 81       	ldd	r25, Z+3	; 0x03
    1546:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    154a:	dc 01       	movw	r26, r24
    154c:	cb 01       	movw	r24, r22
    154e:	f8 01       	movw	r30, r16
    1550:	91 83       	std	Z+1, r25	; 0x01
    1552:	80 83       	st	Z, r24
    1554:	ce 01       	movw	r24, r28
    1556:	80 5b       	subi	r24, 0xB0	; 176
    1558:	9f 4f       	sbci	r25, 0xFF	; 255
    155a:	9e 01       	movw	r18, r28
    155c:	24 5b       	subi	r18, 0xB4	; 180
    155e:	3f 4f       	sbci	r19, 0xFF	; 255
    1560:	f9 01       	movw	r30, r18
    1562:	20 81       	ld	r18, Z
    1564:	31 81       	ldd	r19, Z+1	; 0x01
    1566:	fc 01       	movw	r30, r24
    1568:	31 83       	std	Z+1, r19	; 0x01
    156a:	20 83       	st	Z, r18
    156c:	ce 01       	movw	r24, r28
    156e:	80 5b       	subi	r24, 0xB0	; 176
    1570:	9f 4f       	sbci	r25, 0xFF	; 255
    1572:	fc 01       	movw	r30, r24
    1574:	80 81       	ld	r24, Z
    1576:	91 81       	ldd	r25, Z+1	; 0x01
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	f1 f7       	brne	.-4      	; 0x1578 <LCD_initialize+0x57e>
    157c:	9e 01       	movw	r18, r28
    157e:	20 5b       	subi	r18, 0xB0	; 176
    1580:	3f 4f       	sbci	r19, 0xFF	; 255
    1582:	f9 01       	movw	r30, r18
    1584:	91 83       	std	Z+1, r25	; 0x01
    1586:	80 83       	st	Z, r24
    1588:	45 c0       	rjmp	.+138    	; 0x1614 <LCD_initialize+0x61a>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    158a:	20 e0       	ldi	r18, 0x00	; 0
    158c:	30 e0       	ldi	r19, 0x00	; 0
    158e:	4f e7       	ldi	r20, 0x7F	; 127
    1590:	53 e4       	ldi	r21, 0x43	; 67
    1592:	6b ad       	ldd	r22, Y+59	; 0x3b
    1594:	7c ad       	ldd	r23, Y+60	; 0x3c
    1596:	8d ad       	ldd	r24, Y+61	; 0x3d
    1598:	9e ad       	ldd	r25, Y+62	; 0x3e
    159a:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    159e:	18 16       	cp	r1, r24
    15a0:	64 f5       	brge	.+88     	; 0x15fa <LCD_initialize+0x600>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    15a2:	8e 01       	movw	r16, r28
    15a4:	0e 5a       	subi	r16, 0xAE	; 174
    15a6:	1f 4f       	sbci	r17, 0xFF	; 255
    15a8:	ce 01       	movw	r24, r28
    15aa:	cf 96       	adiw	r24, 0x3f	; 63
    15ac:	fc 01       	movw	r30, r24
    15ae:	60 81       	ld	r22, Z
    15b0:	71 81       	ldd	r23, Z+1	; 0x01
    15b2:	82 81       	ldd	r24, Z+2	; 0x02
    15b4:	93 81       	ldd	r25, Z+3	; 0x03
    15b6:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    15ba:	dc 01       	movw	r26, r24
    15bc:	cb 01       	movw	r24, r22
    15be:	f8 01       	movw	r30, r16
    15c0:	91 83       	std	Z+1, r25	; 0x01
    15c2:	80 83       	st	Z, r24
    15c4:	ce 01       	movw	r24, r28
    15c6:	8c 5a       	subi	r24, 0xAC	; 172
    15c8:	9f 4f       	sbci	r25, 0xFF	; 255
    15ca:	9e 01       	movw	r18, r28
    15cc:	2e 5a       	subi	r18, 0xAE	; 174
    15ce:	3f 4f       	sbci	r19, 0xFF	; 255
    15d0:	f9 01       	movw	r30, r18
    15d2:	20 81       	ld	r18, Z
    15d4:	31 81       	ldd	r19, Z+1	; 0x01
    15d6:	fc 01       	movw	r30, r24
    15d8:	31 83       	std	Z+1, r19	; 0x01
    15da:	20 83       	st	Z, r18
    15dc:	ce 01       	movw	r24, r28
    15de:	8c 5a       	subi	r24, 0xAC	; 172
    15e0:	9f 4f       	sbci	r25, 0xFF	; 255
    15e2:	fc 01       	movw	r30, r24
    15e4:	80 81       	ld	r24, Z
    15e6:	91 81       	ldd	r25, Z+1	; 0x01
    15e8:	01 97       	sbiw	r24, 0x01	; 1
    15ea:	f1 f7       	brne	.-4      	; 0x15e8 <LCD_initialize+0x5ee>
    15ec:	9e 01       	movw	r18, r28
    15ee:	2c 5a       	subi	r18, 0xAC	; 172
    15f0:	3f 4f       	sbci	r19, 0xFF	; 255
    15f2:	f9 01       	movw	r30, r18
    15f4:	91 83       	std	Z+1, r25	; 0x01
    15f6:	80 83       	st	Z, r24
    15f8:	24 c0       	rjmp	.+72     	; 0x1642 <LCD_initialize+0x648>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    15fa:	8e 01       	movw	r16, r28
    15fc:	0d 5b       	subi	r16, 0xBD	; 189
    15fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1600:	6b ad       	ldd	r22, Y+59	; 0x3b
    1602:	7c ad       	ldd	r23, Y+60	; 0x3c
    1604:	8d ad       	ldd	r24, Y+61	; 0x3d
    1606:	9e ad       	ldd	r25, Y+62	; 0x3e
    1608:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    160c:	dc 01       	movw	r26, r24
    160e:	cb 01       	movw	r24, r22
    1610:	f8 01       	movw	r30, r16
    1612:	80 83       	st	Z, r24
    1614:	ce 01       	movw	r24, r28
    1616:	8a 5a       	subi	r24, 0xAA	; 170
    1618:	9f 4f       	sbci	r25, 0xFF	; 255
    161a:	9e 01       	movw	r18, r28
    161c:	2d 5b       	subi	r18, 0xBD	; 189
    161e:	3f 4f       	sbci	r19, 0xFF	; 255
    1620:	f9 01       	movw	r30, r18
    1622:	20 81       	ld	r18, Z
    1624:	fc 01       	movw	r30, r24
    1626:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1628:	ce 01       	movw	r24, r28
    162a:	8a 5a       	subi	r24, 0xAA	; 170
    162c:	9f 4f       	sbci	r25, 0xFF	; 255
    162e:	fc 01       	movw	r30, r24
    1630:	80 81       	ld	r24, Z
    1632:	28 2f       	mov	r18, r24
    1634:	2a 95       	dec	r18
    1636:	f1 f7       	brne	.-4      	; 0x1634 <LCD_initialize+0x63a>
    1638:	ce 01       	movw	r24, r28
    163a:	8a 5a       	subi	r24, 0xAA	; 170
    163c:	9f 4f       	sbci	r25, 0xFF	; 255
    163e:	fc 01       	movw	r30, r24
    1640:	20 83       	st	Z, r18
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00001100);
    1642:	8c e0       	ldi	r24, 0x0C	; 12
    1644:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	a8 e4       	ldi	r26, 0x48	; 72
    164e:	b2 e4       	ldi	r27, 0x42	; 66
    1650:	8d 87       	std	Y+13, r24	; 0x0d
    1652:	9e 87       	std	Y+14, r25	; 0x0e
    1654:	af 87       	std	Y+15, r26	; 0x0f
    1656:	b8 8b       	std	Y+16, r27	; 0x10
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    1658:	2b ea       	ldi	r18, 0xAB	; 171
    165a:	3a ea       	ldi	r19, 0xAA	; 170
    165c:	4a e2       	ldi	r20, 0x2A	; 42
    165e:	50 e4       	ldi	r21, 0x40	; 64
    1660:	6d 85       	ldd	r22, Y+13	; 0x0d
    1662:	7e 85       	ldd	r23, Y+14	; 0x0e
    1664:	8f 85       	ldd	r24, Y+15	; 0x0f
    1666:	98 89       	ldd	r25, Y+16	; 0x10
    1668:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    166c:	dc 01       	movw	r26, r24
    166e:	cb 01       	movw	r24, r22
    1670:	8f 8f       	std	Y+31, r24	; 0x1f
    1672:	98 a3       	std	Y+32, r25	; 0x20
    1674:	a9 a3       	std	Y+33, r26	; 0x21
    1676:	ba a3       	std	Y+34, r27	; 0x22
	__tmp2 = ((F_CPU) / 4e6) * __us;
    1678:	8d 85       	ldd	r24, Y+13	; 0x0d
    167a:	9e 85       	ldd	r25, Y+14	; 0x0e
    167c:	af 85       	ldd	r26, Y+15	; 0x0f
    167e:	b8 89       	ldd	r27, Y+16	; 0x10
    1680:	9c 01       	movw	r18, r24
    1682:	ad 01       	movw	r20, r26
    1684:	bc 01       	movw	r22, r24
    1686:	cd 01       	movw	r24, r26
    1688:	0e 94 20 30 	call	0x6040	; 0x6040 <__addsf3>
    168c:	dc 01       	movw	r26, r24
    168e:	cb 01       	movw	r24, r22
    1690:	8b a3       	std	Y+35, r24	; 0x23
    1692:	9c a3       	std	Y+36, r25	; 0x24
    1694:	ad a3       	std	Y+37, r26	; 0x25
    1696:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1698:	20 e0       	ldi	r18, 0x00	; 0
    169a:	30 e0       	ldi	r19, 0x00	; 0
    169c:	40 e8       	ldi	r20, 0x80	; 128
    169e:	5f e3       	ldi	r21, 0x3F	; 63
    16a0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    16a2:	78 a1       	ldd	r23, Y+32	; 0x20
    16a4:	89 a1       	ldd	r24, Y+33	; 0x21
    16a6:	9a a1       	ldd	r25, Y+34	; 0x22
    16a8:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    16ac:	88 23       	and	r24, r24
    16ae:	1c f4       	brge	.+6      	; 0x16b6 <LCD_initialize+0x6bc>
		__ticks = 1;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	8f a3       	std	Y+39, r24	; 0x27
    16b4:	b2 c0       	rjmp	.+356    	; 0x181a <LCD_initialize+0x820>
	else if (__tmp2 > 65535)
    16b6:	20 e0       	ldi	r18, 0x00	; 0
    16b8:	3f ef       	ldi	r19, 0xFF	; 255
    16ba:	4f e7       	ldi	r20, 0x7F	; 127
    16bc:	57 e4       	ldi	r21, 0x47	; 71
    16be:	6b a1       	ldd	r22, Y+35	; 0x23
    16c0:	7c a1       	ldd	r23, Y+36	; 0x24
    16c2:	8d a1       	ldd	r24, Y+37	; 0x25
    16c4:	9e a1       	ldd	r25, Y+38	; 0x26
    16c6:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    16ca:	18 16       	cp	r1, r24
    16cc:	0c f0       	brlt	.+2      	; 0x16d0 <LCD_initialize+0x6d6>
    16ce:	7b c0       	rjmp	.+246    	; 0x17c6 <LCD_initialize+0x7cc>
	{
		_delay_ms(__us / 1000.0);
    16d0:	20 e0       	ldi	r18, 0x00	; 0
    16d2:	30 e0       	ldi	r19, 0x00	; 0
    16d4:	4a e7       	ldi	r20, 0x7A	; 122
    16d6:	54 e4       	ldi	r21, 0x44	; 68
    16d8:	6d 85       	ldd	r22, Y+13	; 0x0d
    16da:	7e 85       	ldd	r23, Y+14	; 0x0e
    16dc:	8f 85       	ldd	r24, Y+15	; 0x0f
    16de:	98 89       	ldd	r25, Y+16	; 0x10
    16e0:	0e 94 91 30 	call	0x6122	; 0x6122 <__divsf3>
    16e4:	dc 01       	movw	r26, r24
    16e6:	cb 01       	movw	r24, r22
    16e8:	88 a7       	std	Y+40, r24	; 0x28
    16ea:	99 a7       	std	Y+41, r25	; 0x29
    16ec:	aa a7       	std	Y+42, r26	; 0x2a
    16ee:	bb a7       	std	Y+43, r27	; 0x2b

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    16f0:	20 e0       	ldi	r18, 0x00	; 0
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	4a ef       	ldi	r20, 0xFA	; 250
    16f6:	54 e4       	ldi	r21, 0x44	; 68
    16f8:	68 a5       	ldd	r22, Y+40	; 0x28
    16fa:	79 a5       	ldd	r23, Y+41	; 0x29
    16fc:	8a a5       	ldd	r24, Y+42	; 0x2a
    16fe:	9b a5       	ldd	r25, Y+43	; 0x2b
    1700:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1704:	dc 01       	movw	r26, r24
    1706:	cb 01       	movw	r24, r22
    1708:	8c a7       	std	Y+44, r24	; 0x2c
    170a:	9d a7       	std	Y+45, r25	; 0x2d
    170c:	ae a7       	std	Y+46, r26	; 0x2e
    170e:	bf a7       	std	Y+47, r27	; 0x2f
	if (__tmp < 1.0)
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	40 e8       	ldi	r20, 0x80	; 128
    1716:	5f e3       	ldi	r21, 0x3F	; 63
    1718:	6c a5       	ldd	r22, Y+44	; 0x2c
    171a:	7d a5       	ldd	r23, Y+45	; 0x2d
    171c:	8e a5       	ldd	r24, Y+46	; 0x2e
    171e:	9f a5       	ldd	r25, Y+47	; 0x2f
    1720:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    1724:	88 23       	and	r24, r24
    1726:	2c f4       	brge	.+10     	; 0x1732 <LCD_initialize+0x738>
		__ticks = 1;
    1728:	81 e0       	ldi	r24, 0x01	; 1
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	99 ab       	std	Y+49, r25	; 0x31
    172e:	88 ab       	std	Y+48, r24	; 0x30
    1730:	3f c0       	rjmp	.+126    	; 0x17b0 <LCD_initialize+0x7b6>
	else if (__tmp > 65535)
    1732:	20 e0       	ldi	r18, 0x00	; 0
    1734:	3f ef       	ldi	r19, 0xFF	; 255
    1736:	4f e7       	ldi	r20, 0x7F	; 127
    1738:	57 e4       	ldi	r21, 0x47	; 71
    173a:	6c a5       	ldd	r22, Y+44	; 0x2c
    173c:	7d a5       	ldd	r23, Y+45	; 0x2d
    173e:	8e a5       	ldd	r24, Y+46	; 0x2e
    1740:	9f a5       	ldd	r25, Y+47	; 0x2f
    1742:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    1746:	18 16       	cp	r1, r24
    1748:	4c f5       	brge	.+82     	; 0x179c <LCD_initialize+0x7a2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    174a:	20 e0       	ldi	r18, 0x00	; 0
    174c:	30 e0       	ldi	r19, 0x00	; 0
    174e:	40 e2       	ldi	r20, 0x20	; 32
    1750:	51 e4       	ldi	r21, 0x41	; 65
    1752:	68 a5       	ldd	r22, Y+40	; 0x28
    1754:	79 a5       	ldd	r23, Y+41	; 0x29
    1756:	8a a5       	ldd	r24, Y+42	; 0x2a
    1758:	9b a5       	ldd	r25, Y+43	; 0x2b
    175a:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    175e:	dc 01       	movw	r26, r24
    1760:	cb 01       	movw	r24, r22
    1762:	bc 01       	movw	r22, r24
    1764:	cd 01       	movw	r24, r26
    1766:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    176a:	dc 01       	movw	r26, r24
    176c:	cb 01       	movw	r24, r22
    176e:	99 ab       	std	Y+49, r25	; 0x31
    1770:	88 ab       	std	Y+48, r24	; 0x30
    1772:	0f c0       	rjmp	.+30     	; 0x1792 <LCD_initialize+0x798>
    1774:	88 ec       	ldi	r24, 0xC8	; 200
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	9b ab       	std	Y+51, r25	; 0x33
    177a:	8a ab       	std	Y+50, r24	; 0x32
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    177c:	8a a9       	ldd	r24, Y+50	; 0x32
    177e:	9b a9       	ldd	r25, Y+51	; 0x33
    1780:	01 97       	sbiw	r24, 0x01	; 1
    1782:	f1 f7       	brne	.-4      	; 0x1780 <LCD_initialize+0x786>
    1784:	9b ab       	std	Y+51, r25	; 0x33
    1786:	8a ab       	std	Y+50, r24	; 0x32
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1788:	88 a9       	ldd	r24, Y+48	; 0x30
    178a:	99 a9       	ldd	r25, Y+49	; 0x31
    178c:	01 97       	sbiw	r24, 0x01	; 1
    178e:	99 ab       	std	Y+49, r25	; 0x31
    1790:	88 ab       	std	Y+48, r24	; 0x30
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1792:	88 a9       	ldd	r24, Y+48	; 0x30
    1794:	99 a9       	ldd	r25, Y+49	; 0x31
    1796:	89 2b       	or	r24, r25
    1798:	69 f7       	brne	.-38     	; 0x1774 <LCD_initialize+0x77a>
    179a:	3f c0       	rjmp	.+126    	; 0x181a <LCD_initialize+0x820>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    179c:	6c a5       	ldd	r22, Y+44	; 0x2c
    179e:	7d a5       	ldd	r23, Y+45	; 0x2d
    17a0:	8e a5       	ldd	r24, Y+46	; 0x2e
    17a2:	9f a5       	ldd	r25, Y+47	; 0x2f
    17a4:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    17a8:	dc 01       	movw	r26, r24
    17aa:	cb 01       	movw	r24, r22
    17ac:	99 ab       	std	Y+49, r25	; 0x31
    17ae:	88 ab       	std	Y+48, r24	; 0x30
    17b0:	88 a9       	ldd	r24, Y+48	; 0x30
    17b2:	99 a9       	ldd	r25, Y+49	; 0x31
    17b4:	9d ab       	std	Y+53, r25	; 0x35
    17b6:	8c ab       	std	Y+52, r24	; 0x34
    17b8:	8c a9       	ldd	r24, Y+52	; 0x34
    17ba:	9d a9       	ldd	r25, Y+53	; 0x35
    17bc:	01 97       	sbiw	r24, 0x01	; 1
    17be:	f1 f7       	brne	.-4      	; 0x17bc <LCD_initialize+0x7c2>
    17c0:	9d ab       	std	Y+53, r25	; 0x35
    17c2:	8c ab       	std	Y+52, r24	; 0x34
    17c4:	2a c0       	rjmp	.+84     	; 0x181a <LCD_initialize+0x820>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    17c6:	20 e0       	ldi	r18, 0x00	; 0
    17c8:	30 e0       	ldi	r19, 0x00	; 0
    17ca:	4f e7       	ldi	r20, 0x7F	; 127
    17cc:	53 e4       	ldi	r21, 0x43	; 67
    17ce:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17d0:	78 a1       	ldd	r23, Y+32	; 0x20
    17d2:	89 a1       	ldd	r24, Y+33	; 0x21
    17d4:	9a a1       	ldd	r25, Y+34	; 0x22
    17d6:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    17da:	18 16       	cp	r1, r24
    17dc:	ac f4       	brge	.+42     	; 0x1808 <LCD_initialize+0x80e>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    17de:	6b a1       	ldd	r22, Y+35	; 0x23
    17e0:	7c a1       	ldd	r23, Y+36	; 0x24
    17e2:	8d a1       	ldd	r24, Y+37	; 0x25
    17e4:	9e a1       	ldd	r25, Y+38	; 0x26
    17e6:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    17ea:	dc 01       	movw	r26, r24
    17ec:	cb 01       	movw	r24, r22
    17ee:	9f ab       	std	Y+55, r25	; 0x37
    17f0:	8e ab       	std	Y+54, r24	; 0x36
    17f2:	8e a9       	ldd	r24, Y+54	; 0x36
    17f4:	9f a9       	ldd	r25, Y+55	; 0x37
    17f6:	99 af       	std	Y+57, r25	; 0x39
    17f8:	88 af       	std	Y+56, r24	; 0x38
    17fa:	88 ad       	ldd	r24, Y+56	; 0x38
    17fc:	99 ad       	ldd	r25, Y+57	; 0x39
    17fe:	01 97       	sbiw	r24, 0x01	; 1
    1800:	f1 f7       	brne	.-4      	; 0x17fe <LCD_initialize+0x804>
    1802:	99 af       	std	Y+57, r25	; 0x39
    1804:	88 af       	std	Y+56, r24	; 0x38
    1806:	0f c0       	rjmp	.+30     	; 0x1826 <LCD_initialize+0x82c>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1808:	6f 8d       	ldd	r22, Y+31	; 0x1f
    180a:	78 a1       	ldd	r23, Y+32	; 0x20
    180c:	89 a1       	ldd	r24, Y+33	; 0x21
    180e:	9a a1       	ldd	r25, Y+34	; 0x22
    1810:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    1814:	dc 01       	movw	r26, r24
    1816:	cb 01       	movw	r24, r22
    1818:	8f a3       	std	Y+39, r24	; 0x27
    181a:	8f a1       	ldd	r24, Y+39	; 0x27
    181c:	8a af       	std	Y+58, r24	; 0x3a
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    181e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1820:	8a 95       	dec	r24
    1822:	f1 f7       	brne	.-4      	; 0x1820 <LCD_initialize+0x826>
    1824:	8a af       	std	Y+58, r24	; 0x3a
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00000001);
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
    182c:	80 e0       	ldi	r24, 0x00	; 0
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	a0 e0       	ldi	r26, 0x00	; 0
    1832:	b0 e4       	ldi	r27, 0x40	; 64
    1834:	89 8b       	std	Y+17, r24	; 0x11
    1836:	9a 8b       	std	Y+18, r25	; 0x12
    1838:	ab 8b       	std	Y+19, r26	; 0x13
    183a:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    183c:	20 e0       	ldi	r18, 0x00	; 0
    183e:	30 e0       	ldi	r19, 0x00	; 0
    1840:	4a ef       	ldi	r20, 0xFA	; 250
    1842:	54 e4       	ldi	r21, 0x44	; 68
    1844:	69 89       	ldd	r22, Y+17	; 0x11
    1846:	7a 89       	ldd	r23, Y+18	; 0x12
    1848:	8b 89       	ldd	r24, Y+19	; 0x13
    184a:	9c 89       	ldd	r25, Y+20	; 0x14
    184c:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1850:	dc 01       	movw	r26, r24
    1852:	cb 01       	movw	r24, r22
    1854:	8d 8b       	std	Y+21, r24	; 0x15
    1856:	9e 8b       	std	Y+22, r25	; 0x16
    1858:	af 8b       	std	Y+23, r26	; 0x17
    185a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    185c:	20 e0       	ldi	r18, 0x00	; 0
    185e:	30 e0       	ldi	r19, 0x00	; 0
    1860:	40 e8       	ldi	r20, 0x80	; 128
    1862:	5f e3       	ldi	r21, 0x3F	; 63
    1864:	6d 89       	ldd	r22, Y+21	; 0x15
    1866:	7e 89       	ldd	r23, Y+22	; 0x16
    1868:	8f 89       	ldd	r24, Y+23	; 0x17
    186a:	98 8d       	ldd	r25, Y+24	; 0x18
    186c:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    1870:	88 23       	and	r24, r24
    1872:	2c f4       	brge	.+10     	; 0x187e <LCD_initialize+0x884>
		__ticks = 1;
    1874:	81 e0       	ldi	r24, 0x01	; 1
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	9a 8f       	std	Y+26, r25	; 0x1a
    187a:	89 8f       	std	Y+25, r24	; 0x19
    187c:	3f c0       	rjmp	.+126    	; 0x18fc <LCD_initialize+0x902>
	else if (__tmp > 65535)
    187e:	20 e0       	ldi	r18, 0x00	; 0
    1880:	3f ef       	ldi	r19, 0xFF	; 255
    1882:	4f e7       	ldi	r20, 0x7F	; 127
    1884:	57 e4       	ldi	r21, 0x47	; 71
    1886:	6d 89       	ldd	r22, Y+21	; 0x15
    1888:	7e 89       	ldd	r23, Y+22	; 0x16
    188a:	8f 89       	ldd	r24, Y+23	; 0x17
    188c:	98 8d       	ldd	r25, Y+24	; 0x18
    188e:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    1892:	18 16       	cp	r1, r24
    1894:	4c f5       	brge	.+82     	; 0x18e8 <LCD_initialize+0x8ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1896:	20 e0       	ldi	r18, 0x00	; 0
    1898:	30 e0       	ldi	r19, 0x00	; 0
    189a:	40 e2       	ldi	r20, 0x20	; 32
    189c:	51 e4       	ldi	r21, 0x41	; 65
    189e:	69 89       	ldd	r22, Y+17	; 0x11
    18a0:	7a 89       	ldd	r23, Y+18	; 0x12
    18a2:	8b 89       	ldd	r24, Y+19	; 0x13
    18a4:	9c 89       	ldd	r25, Y+20	; 0x14
    18a6:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    18aa:	dc 01       	movw	r26, r24
    18ac:	cb 01       	movw	r24, r22
    18ae:	bc 01       	movw	r22, r24
    18b0:	cd 01       	movw	r24, r26
    18b2:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    18b6:	dc 01       	movw	r26, r24
    18b8:	cb 01       	movw	r24, r22
    18ba:	9a 8f       	std	Y+26, r25	; 0x1a
    18bc:	89 8f       	std	Y+25, r24	; 0x19
    18be:	0f c0       	rjmp	.+30     	; 0x18de <LCD_initialize+0x8e4>
    18c0:	88 ec       	ldi	r24, 0xC8	; 200
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	9c 8f       	std	Y+28, r25	; 0x1c
    18c6:	8b 8f       	std	Y+27, r24	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    18c8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18ca:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18cc:	01 97       	sbiw	r24, 0x01	; 1
    18ce:	f1 f7       	brne	.-4      	; 0x18cc <LCD_initialize+0x8d2>
    18d0:	9c 8f       	std	Y+28, r25	; 0x1c
    18d2:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18d4:	89 8d       	ldd	r24, Y+25	; 0x19
    18d6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18d8:	01 97       	sbiw	r24, 0x01	; 1
    18da:	9a 8f       	std	Y+26, r25	; 0x1a
    18dc:	89 8f       	std	Y+25, r24	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18de:	89 8d       	ldd	r24, Y+25	; 0x19
    18e0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18e2:	89 2b       	or	r24, r25
    18e4:	69 f7       	brne	.-38     	; 0x18c0 <LCD_initialize+0x8c6>
	_delay_ms(2);

}
    18e6:	14 c0       	rjmp	.+40     	; 0x1910 <LCD_initialize+0x916>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18e8:	6d 89       	ldd	r22, Y+21	; 0x15
    18ea:	7e 89       	ldd	r23, Y+22	; 0x16
    18ec:	8f 89       	ldd	r24, Y+23	; 0x17
    18ee:	98 8d       	ldd	r25, Y+24	; 0x18
    18f0:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    18f4:	dc 01       	movw	r26, r24
    18f6:	cb 01       	movw	r24, r22
    18f8:	9a 8f       	std	Y+26, r25	; 0x1a
    18fa:	89 8f       	std	Y+25, r24	; 0x19
    18fc:	89 8d       	ldd	r24, Y+25	; 0x19
    18fe:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1900:	9e 8f       	std	Y+30, r25	; 0x1e
    1902:	8d 8f       	std	Y+29, r24	; 0x1d
    1904:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1906:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1908:	01 97       	sbiw	r24, 0x01	; 1
    190a:	f1 f7       	brne	.-4      	; 0x1908 <LCD_initialize+0x90e>
    190c:	9e 8f       	std	Y+30, r25	; 0x1e
    190e:	8d 8f       	std	Y+29, r24	; 0x1d
    1910:	00 00       	nop
    1912:	c6 59       	subi	r28, 0x96	; 150
    1914:	df 4f       	sbci	r29, 0xFF	; 255
    1916:	0f b6       	in	r0, 0x3f	; 63
    1918:	f8 94       	cli
    191a:	de bf       	out	0x3e, r29	; 62
    191c:	0f be       	out	0x3f, r0	; 63
    191e:	cd bf       	out	0x3d, r28	; 61
    1920:	df 91       	pop	r29
    1922:	cf 91       	pop	r28
    1924:	1f 91       	pop	r17
    1926:	0f 91       	pop	r16
    1928:	08 95       	ret

0000192a <LCD_Void_Write_String>:

void LCD_Void_Write_String(u8* copy_string)
{
    192a:	cf 93       	push	r28
    192c:	df 93       	push	r29
    192e:	00 d0       	rcall	.+0      	; 0x1930 <LCD_Void_Write_String+0x6>
    1930:	1f 92       	push	r1
    1932:	cd b7       	in	r28, 0x3d	; 61
    1934:	de b7       	in	r29, 0x3e	; 62
    1936:	9b 83       	std	Y+3, r25	; 0x03
    1938:	8a 83       	std	Y+2, r24	; 0x02
	u8 i = 0;
    193a:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    193c:	14 c0       	rjmp	.+40     	; 0x1966 <LCD_Void_Write_String+0x3c>
	{	if(i==16)
    193e:	89 81       	ldd	r24, Y+1	; 0x01
    1940:	80 31       	cpi	r24, 0x10	; 16
    1942:	19 f4       	brne	.+6      	; 0x194a <LCD_Void_Write_String+0x20>
		{
			LCD_Set_Block(16);
    1944:	80 e1       	ldi	r24, 0x10	; 16
    1946:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
		}
		LCD_Void_Write_Data(copy_string[i]);
    194a:	89 81       	ldd	r24, Y+1	; 0x01
    194c:	88 2f       	mov	r24, r24
    194e:	90 e0       	ldi	r25, 0x00	; 0
    1950:	2a 81       	ldd	r18, Y+2	; 0x02
    1952:	3b 81       	ldd	r19, Y+3	; 0x03
    1954:	82 0f       	add	r24, r18
    1956:	93 1f       	adc	r25, r19
    1958:	fc 01       	movw	r30, r24
    195a:	80 81       	ld	r24, Z
    195c:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
		i++;
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	8f 5f       	subi	r24, 0xFF	; 255
    1964:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1966:	89 81       	ldd	r24, Y+1	; 0x01
    1968:	88 2f       	mov	r24, r24
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	2a 81       	ldd	r18, Y+2	; 0x02
    196e:	3b 81       	ldd	r19, Y+3	; 0x03
    1970:	82 0f       	add	r24, r18
    1972:	93 1f       	adc	r25, r19
    1974:	fc 01       	movw	r30, r24
    1976:	80 81       	ld	r24, Z
    1978:	88 23       	and	r24, r24
    197a:	09 f7       	brne	.-62     	; 0x193e <LCD_Void_Write_String+0x14>
			LCD_Set_Block(16);
		}
		LCD_Void_Write_Data(copy_string[i]);
		i++;
	}
}
    197c:	00 00       	nop
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	df 91       	pop	r29
    1986:	cf 91       	pop	r28
    1988:	08 95       	ret

0000198a <LCD_Void_Clear>:

void LCD_Void_Clear(void)
{
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29
    198e:	cd b7       	in	r28, 0x3d	; 61
    1990:	de b7       	in	r29, 0x3e	; 62
	LCD_Void_Write_Cmd(0b00000001);
    1992:	81 e0       	ldi	r24, 0x01	; 1
    1994:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
}
    1998:	00 00       	nop
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	08 95       	ret

000019a0 <LCD_Void_Write_Blinking_String>:

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
    19a0:	cf 93       	push	r28
    19a2:	df 93       	push	r29
    19a4:	cd b7       	in	r28, 0x3d	; 61
    19a6:	de b7       	in	r29, 0x3e	; 62
    19a8:	61 97       	sbiw	r28, 0x11	; 17
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	f8 94       	cli
    19ae:	de bf       	out	0x3e, r29	; 62
    19b0:	0f be       	out	0x3f, r0	; 63
    19b2:	cd bf       	out	0x3d, r28	; 61
    19b4:	99 8b       	std	Y+17, r25	; 0x11
    19b6:	88 8b       	std	Y+16, r24	; 0x10
	u8 i = 0;
    19b8:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    19ba:	80 c0       	rjmp	.+256    	; 0x1abc <LCD_Void_Write_Blinking_String+0x11c>
	{
		LCD_Void_Write_Data(copy_string[i]);
    19bc:	89 81       	ldd	r24, Y+1	; 0x01
    19be:	88 2f       	mov	r24, r24
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	28 89       	ldd	r18, Y+16	; 0x10
    19c4:	39 89       	ldd	r19, Y+17	; 0x11
    19c6:	82 0f       	add	r24, r18
    19c8:	93 1f       	adc	r25, r19
    19ca:	fc 01       	movw	r30, r24
    19cc:	80 81       	ld	r24, Z
    19ce:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
    19d2:	80 e0       	ldi	r24, 0x00	; 0
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	aa ef       	ldi	r26, 0xFA	; 250
    19d8:	b3 e4       	ldi	r27, 0x43	; 67
    19da:	8a 83       	std	Y+2, r24	; 0x02
    19dc:	9b 83       	std	Y+3, r25	; 0x03
    19de:	ac 83       	std	Y+4, r26	; 0x04
    19e0:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    19e2:	20 e0       	ldi	r18, 0x00	; 0
    19e4:	30 e0       	ldi	r19, 0x00	; 0
    19e6:	4a ef       	ldi	r20, 0xFA	; 250
    19e8:	54 e4       	ldi	r21, 0x44	; 68
    19ea:	6a 81       	ldd	r22, Y+2	; 0x02
    19ec:	7b 81       	ldd	r23, Y+3	; 0x03
    19ee:	8c 81       	ldd	r24, Y+4	; 0x04
    19f0:	9d 81       	ldd	r25, Y+5	; 0x05
    19f2:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    19f6:	dc 01       	movw	r26, r24
    19f8:	cb 01       	movw	r24, r22
    19fa:	8e 83       	std	Y+6, r24	; 0x06
    19fc:	9f 83       	std	Y+7, r25	; 0x07
    19fe:	a8 87       	std	Y+8, r26	; 0x08
    1a00:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    1a02:	20 e0       	ldi	r18, 0x00	; 0
    1a04:	30 e0       	ldi	r19, 0x00	; 0
    1a06:	40 e8       	ldi	r20, 0x80	; 128
    1a08:	5f e3       	ldi	r21, 0x3F	; 63
    1a0a:	6e 81       	ldd	r22, Y+6	; 0x06
    1a0c:	7f 81       	ldd	r23, Y+7	; 0x07
    1a0e:	88 85       	ldd	r24, Y+8	; 0x08
    1a10:	99 85       	ldd	r25, Y+9	; 0x09
    1a12:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    1a16:	88 23       	and	r24, r24
    1a18:	2c f4       	brge	.+10     	; 0x1a24 <LCD_Void_Write_Blinking_String+0x84>
		__ticks = 1;
    1a1a:	81 e0       	ldi	r24, 0x01	; 1
    1a1c:	90 e0       	ldi	r25, 0x00	; 0
    1a1e:	9b 87       	std	Y+11, r25	; 0x0b
    1a20:	8a 87       	std	Y+10, r24	; 0x0a
    1a22:	3f c0       	rjmp	.+126    	; 0x1aa2 <LCD_Void_Write_Blinking_String+0x102>
	else if (__tmp > 65535)
    1a24:	20 e0       	ldi	r18, 0x00	; 0
    1a26:	3f ef       	ldi	r19, 0xFF	; 255
    1a28:	4f e7       	ldi	r20, 0x7F	; 127
    1a2a:	57 e4       	ldi	r21, 0x47	; 71
    1a2c:	6e 81       	ldd	r22, Y+6	; 0x06
    1a2e:	7f 81       	ldd	r23, Y+7	; 0x07
    1a30:	88 85       	ldd	r24, Y+8	; 0x08
    1a32:	99 85       	ldd	r25, Y+9	; 0x09
    1a34:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    1a38:	18 16       	cp	r1, r24
    1a3a:	4c f5       	brge	.+82     	; 0x1a8e <LCD_Void_Write_Blinking_String+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a3c:	20 e0       	ldi	r18, 0x00	; 0
    1a3e:	30 e0       	ldi	r19, 0x00	; 0
    1a40:	40 e2       	ldi	r20, 0x20	; 32
    1a42:	51 e4       	ldi	r21, 0x41	; 65
    1a44:	6a 81       	ldd	r22, Y+2	; 0x02
    1a46:	7b 81       	ldd	r23, Y+3	; 0x03
    1a48:	8c 81       	ldd	r24, Y+4	; 0x04
    1a4a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a4c:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1a50:	dc 01       	movw	r26, r24
    1a52:	cb 01       	movw	r24, r22
    1a54:	bc 01       	movw	r22, r24
    1a56:	cd 01       	movw	r24, r26
    1a58:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    1a5c:	dc 01       	movw	r26, r24
    1a5e:	cb 01       	movw	r24, r22
    1a60:	9b 87       	std	Y+11, r25	; 0x0b
    1a62:	8a 87       	std	Y+10, r24	; 0x0a
    1a64:	0f c0       	rjmp	.+30     	; 0x1a84 <LCD_Void_Write_Blinking_String+0xe4>
    1a66:	88 ec       	ldi	r24, 0xC8	; 200
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	9d 87       	std	Y+13, r25	; 0x0d
    1a6c:	8c 87       	std	Y+12, r24	; 0x0c
    1a6e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a70:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a72:	01 97       	sbiw	r24, 0x01	; 1
    1a74:	f1 f7       	brne	.-4      	; 0x1a72 <LCD_Void_Write_Blinking_String+0xd2>
    1a76:	9d 87       	std	Y+13, r25	; 0x0d
    1a78:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a7a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a7c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a7e:	01 97       	sbiw	r24, 0x01	; 1
    1a80:	9b 87       	std	Y+11, r25	; 0x0b
    1a82:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a84:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a86:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a88:	89 2b       	or	r24, r25
    1a8a:	69 f7       	brne	.-38     	; 0x1a66 <LCD_Void_Write_Blinking_String+0xc6>
    1a8c:	14 c0       	rjmp	.+40     	; 0x1ab6 <LCD_Void_Write_Blinking_String+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a8e:	6e 81       	ldd	r22, Y+6	; 0x06
    1a90:	7f 81       	ldd	r23, Y+7	; 0x07
    1a92:	88 85       	ldd	r24, Y+8	; 0x08
    1a94:	99 85       	ldd	r25, Y+9	; 0x09
    1a96:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    1a9a:	dc 01       	movw	r26, r24
    1a9c:	cb 01       	movw	r24, r22
    1a9e:	9b 87       	std	Y+11, r25	; 0x0b
    1aa0:	8a 87       	std	Y+10, r24	; 0x0a
    1aa2:	8a 85       	ldd	r24, Y+10	; 0x0a
    1aa4:	9b 85       	ldd	r25, Y+11	; 0x0b
    1aa6:	9f 87       	std	Y+15, r25	; 0x0f
    1aa8:	8e 87       	std	Y+14, r24	; 0x0e
    1aaa:	8e 85       	ldd	r24, Y+14	; 0x0e
    1aac:	9f 85       	ldd	r25, Y+15	; 0x0f
    1aae:	01 97       	sbiw	r24, 0x01	; 1
    1ab0:	f1 f7       	brne	.-4      	; 0x1aae <LCD_Void_Write_Blinking_String+0x10e>
    1ab2:	9f 87       	std	Y+15, r25	; 0x0f
    1ab4:	8e 87       	std	Y+14, r24	; 0x0e
		_delay_ms(500);
		i++;
    1ab6:	89 81       	ldd	r24, Y+1	; 0x01
    1ab8:	8f 5f       	subi	r24, 0xFF	; 255
    1aba:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1abc:	89 81       	ldd	r24, Y+1	; 0x01
    1abe:	88 2f       	mov	r24, r24
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	28 89       	ldd	r18, Y+16	; 0x10
    1ac4:	39 89       	ldd	r19, Y+17	; 0x11
    1ac6:	82 0f       	add	r24, r18
    1ac8:	93 1f       	adc	r25, r19
    1aca:	fc 01       	movw	r30, r24
    1acc:	80 81       	ld	r24, Z
    1ace:	88 23       	and	r24, r24
    1ad0:	09 f0       	breq	.+2      	; 0x1ad4 <LCD_Void_Write_Blinking_String+0x134>
    1ad2:	74 cf       	rjmp	.-280    	; 0x19bc <LCD_Void_Write_Blinking_String+0x1c>
	{
		LCD_Void_Write_Data(copy_string[i]);
		_delay_ms(500);
		i++;
	}
}
    1ad4:	00 00       	nop
    1ad6:	61 96       	adiw	r28, 0x11	; 17
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	de bf       	out	0x3e, r29	; 62
    1ade:	0f be       	out	0x3f, r0	; 63
    1ae0:	cd bf       	out	0x3d, r28	; 61
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <LCD_Set_Block>:

void LCD_Set_Block(u8 copy_block_nb) // sets the ddram address to the block you want to write
{
    1ae8:	cf 93       	push	r28
    1aea:	df 93       	push	r29
    1aec:	1f 92       	push	r1
    1aee:	cd b7       	in	r28, 0x3d	; 61
    1af0:	de b7       	in	r29, 0x3e	; 62
    1af2:	89 83       	std	Y+1, r24	; 0x01
	if(copy_block_nb<16)
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	80 31       	cpi	r24, 0x10	; 16
    1af8:	28 f4       	brcc	.+10     	; 0x1b04 <LCD_Set_Block+0x1c>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
    1afa:	89 81       	ldd	r24, Y+1	; 0x01
    1afc:	80 58       	subi	r24, 0x80	; 128
    1afe:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
	}
}
    1b02:	04 c0       	rjmp	.+8      	; 0x1b0c <LCD_Set_Block+0x24>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
    1b04:	89 81       	ldd	r24, Y+1	; 0x01
    1b06:	80 55       	subi	r24, 0x50	; 80
    1b08:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
	}
}
    1b0c:	00 00       	nop
    1b0e:	0f 90       	pop	r0
    1b10:	df 91       	pop	r29
    1b12:	cf 91       	pop	r28
    1b14:	08 95       	ret

00001b16 <LCD_Void_Write_Moving_String>:

void LCD_Void_Write_Moving_String(u8* copy_string)
{
    1b16:	cf 93       	push	r28
    1b18:	df 93       	push	r29
    1b1a:	cd b7       	in	r28, 0x3d	; 61
    1b1c:	de b7       	in	r29, 0x3e	; 62
    1b1e:	63 97       	sbiw	r28, 0x13	; 19
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	de bf       	out	0x3e, r29	; 62
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	cd bf       	out	0x3d, r28	; 61
    1b2a:	9b 8b       	std	Y+19, r25	; 0x13
    1b2c:	8a 8b       	std	Y+18, r24	; 0x12
	u8 i;
	for (int j = 0; j<5 ;j++)
    1b2e:	1b 82       	std	Y+3, r1	; 0x03
    1b30:	1a 82       	std	Y+2, r1	; 0x02
    1b32:	97 c0       	rjmp	.+302    	; 0x1c62 <LCD_Void_Write_Moving_String+0x14c>
	{
		LCD_Set_Block(j);
    1b34:	8a 81       	ldd	r24, Y+2	; 0x02
    1b36:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_Set_Block>
		i = 0;
    1b3a:	19 82       	std	Y+1, r1	; 0x01
		while(copy_string[i] != '\0')
    1b3c:	0e c0       	rjmp	.+28     	; 0x1b5a <LCD_Void_Write_Moving_String+0x44>
		{

			LCD_Void_Write_Data(copy_string[i]);
    1b3e:	89 81       	ldd	r24, Y+1	; 0x01
    1b40:	88 2f       	mov	r24, r24
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	2a 89       	ldd	r18, Y+18	; 0x12
    1b46:	3b 89       	ldd	r19, Y+19	; 0x13
    1b48:	82 0f       	add	r24, r18
    1b4a:	93 1f       	adc	r25, r19
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	80 81       	ld	r24, Z
    1b50:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
			i++;
    1b54:	89 81       	ldd	r24, Y+1	; 0x01
    1b56:	8f 5f       	subi	r24, 0xFF	; 255
    1b58:	89 83       	std	Y+1, r24	; 0x01
	u8 i;
	for (int j = 0; j<5 ;j++)
	{
		LCD_Set_Block(j);
		i = 0;
		while(copy_string[i] != '\0')
    1b5a:	89 81       	ldd	r24, Y+1	; 0x01
    1b5c:	88 2f       	mov	r24, r24
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	2a 89       	ldd	r18, Y+18	; 0x12
    1b62:	3b 89       	ldd	r19, Y+19	; 0x13
    1b64:	82 0f       	add	r24, r18
    1b66:	93 1f       	adc	r25, r19
    1b68:	fc 01       	movw	r30, r24
    1b6a:	80 81       	ld	r24, Z
    1b6c:	88 23       	and	r24, r24
    1b6e:	39 f7       	brne	.-50     	; 0x1b3e <LCD_Void_Write_Moving_String+0x28>
    1b70:	80 e0       	ldi	r24, 0x00	; 0
    1b72:	90 e0       	ldi	r25, 0x00	; 0
    1b74:	aa e7       	ldi	r26, 0x7A	; 122
    1b76:	b4 e4       	ldi	r27, 0x44	; 68
    1b78:	8c 83       	std	Y+4, r24	; 0x04
    1b7a:	9d 83       	std	Y+5, r25	; 0x05
    1b7c:	ae 83       	std	Y+6, r26	; 0x06
    1b7e:	bf 83       	std	Y+7, r27	; 0x07

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	4a ef       	ldi	r20, 0xFA	; 250
    1b86:	54 e4       	ldi	r21, 0x44	; 68
    1b88:	6c 81       	ldd	r22, Y+4	; 0x04
    1b8a:	7d 81       	ldd	r23, Y+5	; 0x05
    1b8c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b8e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b90:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1b94:	dc 01       	movw	r26, r24
    1b96:	cb 01       	movw	r24, r22
    1b98:	88 87       	std	Y+8, r24	; 0x08
    1b9a:	99 87       	std	Y+9, r25	; 0x09
    1b9c:	aa 87       	std	Y+10, r26	; 0x0a
    1b9e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	40 e8       	ldi	r20, 0x80	; 128
    1ba6:	5f e3       	ldi	r21, 0x3F	; 63
    1ba8:	68 85       	ldd	r22, Y+8	; 0x08
    1baa:	79 85       	ldd	r23, Y+9	; 0x09
    1bac:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bae:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bb0:	0e 94 8c 30 	call	0x6118	; 0x6118 <__cmpsf2>
    1bb4:	88 23       	and	r24, r24
    1bb6:	2c f4       	brge	.+10     	; 0x1bc2 <LCD_Void_Write_Moving_String+0xac>
		__ticks = 1;
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	90 e0       	ldi	r25, 0x00	; 0
    1bbc:	9d 87       	std	Y+13, r25	; 0x0d
    1bbe:	8c 87       	std	Y+12, r24	; 0x0c
    1bc0:	3f c0       	rjmp	.+126    	; 0x1c40 <LCD_Void_Write_Moving_String+0x12a>
	else if (__tmp > 65535)
    1bc2:	20 e0       	ldi	r18, 0x00	; 0
    1bc4:	3f ef       	ldi	r19, 0xFF	; 255
    1bc6:	4f e7       	ldi	r20, 0x7F	; 127
    1bc8:	57 e4       	ldi	r21, 0x47	; 71
    1bca:	68 85       	ldd	r22, Y+8	; 0x08
    1bcc:	79 85       	ldd	r23, Y+9	; 0x09
    1bce:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bd0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bd2:	0e 94 a7 31 	call	0x634e	; 0x634e <__gesf2>
    1bd6:	18 16       	cp	r1, r24
    1bd8:	4c f5       	brge	.+82     	; 0x1c2c <LCD_Void_Write_Moving_String+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bda:	20 e0       	ldi	r18, 0x00	; 0
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	40 e2       	ldi	r20, 0x20	; 32
    1be0:	51 e4       	ldi	r21, 0x41	; 65
    1be2:	6c 81       	ldd	r22, Y+4	; 0x04
    1be4:	7d 81       	ldd	r23, Y+5	; 0x05
    1be6:	8e 81       	ldd	r24, Y+6	; 0x06
    1be8:	9f 81       	ldd	r25, Y+7	; 0x07
    1bea:	0e 94 ac 31 	call	0x6358	; 0x6358 <__mulsf3>
    1bee:	dc 01       	movw	r26, r24
    1bf0:	cb 01       	movw	r24, r22
    1bf2:	bc 01       	movw	r22, r24
    1bf4:	cd 01       	movw	r24, r26
    1bf6:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    1bfa:	dc 01       	movw	r26, r24
    1bfc:	cb 01       	movw	r24, r22
    1bfe:	9d 87       	std	Y+13, r25	; 0x0d
    1c00:	8c 87       	std	Y+12, r24	; 0x0c
    1c02:	0f c0       	rjmp	.+30     	; 0x1c22 <LCD_Void_Write_Moving_String+0x10c>
    1c04:	88 ec       	ldi	r24, 0xC8	; 200
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	9f 87       	std	Y+15, r25	; 0x0f
    1c0a:	8e 87       	std	Y+14, r24	; 0x0e
    1c0c:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c0e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c10:	01 97       	sbiw	r24, 0x01	; 1
    1c12:	f1 f7       	brne	.-4      	; 0x1c10 <LCD_Void_Write_Moving_String+0xfa>
    1c14:	9f 87       	std	Y+15, r25	; 0x0f
    1c16:	8e 87       	std	Y+14, r24	; 0x0e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c18:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c1a:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c1c:	01 97       	sbiw	r24, 0x01	; 1
    1c1e:	9d 87       	std	Y+13, r25	; 0x0d
    1c20:	8c 87       	std	Y+12, r24	; 0x0c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c22:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c24:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c26:	89 2b       	or	r24, r25
    1c28:	69 f7       	brne	.-38     	; 0x1c04 <LCD_Void_Write_Moving_String+0xee>
    1c2a:	14 c0       	rjmp	.+40     	; 0x1c54 <LCD_Void_Write_Moving_String+0x13e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c2c:	68 85       	ldd	r22, Y+8	; 0x08
    1c2e:	79 85       	ldd	r23, Y+9	; 0x09
    1c30:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c32:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c34:	0e 94 03 31 	call	0x6206	; 0x6206 <__fixunssfsi>
    1c38:	dc 01       	movw	r26, r24
    1c3a:	cb 01       	movw	r24, r22
    1c3c:	9d 87       	std	Y+13, r25	; 0x0d
    1c3e:	8c 87       	std	Y+12, r24	; 0x0c
    1c40:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c42:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c44:	99 8b       	std	Y+17, r25	; 0x11
    1c46:	88 8b       	std	Y+16, r24	; 0x10
    1c48:	88 89       	ldd	r24, Y+16	; 0x10
    1c4a:	99 89       	ldd	r25, Y+17	; 0x11
    1c4c:	01 97       	sbiw	r24, 0x01	; 1
    1c4e:	f1 f7       	brne	.-4      	; 0x1c4c <LCD_Void_Write_Moving_String+0x136>
    1c50:	99 8b       	std	Y+17, r25	; 0x11
    1c52:	88 8b       	std	Y+16, r24	; 0x10

			LCD_Void_Write_Data(copy_string[i]);
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
    1c54:	0e 94 c5 0c 	call	0x198a	; 0x198a <LCD_Void_Clear>
}

void LCD_Void_Write_Moving_String(u8* copy_string)
{
	u8 i;
	for (int j = 0; j<5 ;j++)
    1c58:	8a 81       	ldd	r24, Y+2	; 0x02
    1c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c5c:	01 96       	adiw	r24, 0x01	; 1
    1c5e:	9b 83       	std	Y+3, r25	; 0x03
    1c60:	8a 83       	std	Y+2, r24	; 0x02
    1c62:	8a 81       	ldd	r24, Y+2	; 0x02
    1c64:	9b 81       	ldd	r25, Y+3	; 0x03
    1c66:	05 97       	sbiw	r24, 0x05	; 5
    1c68:	0c f4       	brge	.+2      	; 0x1c6c <LCD_Void_Write_Moving_String+0x156>
    1c6a:	64 cf       	rjmp	.-312    	; 0x1b34 <LCD_Void_Write_Moving_String+0x1e>
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
	}
}
    1c6c:	00 00       	nop
    1c6e:	63 96       	adiw	r28, 0x13	; 19
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	de bf       	out	0x3e, r29	; 62
    1c76:	0f be       	out	0x3f, r0	; 63
    1c78:	cd bf       	out	0x3d, r28	; 61
    1c7a:	df 91       	pop	r29
    1c7c:	cf 91       	pop	r28
    1c7e:	08 95       	ret

00001c80 <LCD_Void_Write_CGRAM>:

void LCD_Void_Write_CGRAM(u8 copy_row_0,u8 copy_row_1,u8 copy_row_2,u8 copy_row_3,u8 copy_row_4,u8 copy_row_5,u8 copy_row_6,u8 copy_row_7,u8 copy_CGRAM_address)
{
    1c80:	8f 92       	push	r8
    1c82:	af 92       	push	r10
    1c84:	cf 92       	push	r12
    1c86:	ef 92       	push	r14
    1c88:	0f 93       	push	r16
    1c8a:	cf 93       	push	r28
    1c8c:	df 93       	push	r29
    1c8e:	cd b7       	in	r28, 0x3d	; 61
    1c90:	de b7       	in	r29, 0x3e	; 62
    1c92:	29 97       	sbiw	r28, 0x09	; 9
    1c94:	0f b6       	in	r0, 0x3f	; 63
    1c96:	f8 94       	cli
    1c98:	de bf       	out	0x3e, r29	; 62
    1c9a:	0f be       	out	0x3f, r0	; 63
    1c9c:	cd bf       	out	0x3d, r28	; 61
    1c9e:	89 83       	std	Y+1, r24	; 0x01
    1ca0:	6a 83       	std	Y+2, r22	; 0x02
    1ca2:	4b 83       	std	Y+3, r20	; 0x03
    1ca4:	2c 83       	std	Y+4, r18	; 0x04
    1ca6:	0d 83       	std	Y+5, r16	; 0x05
    1ca8:	ee 82       	std	Y+6, r14	; 0x06
    1caa:	cf 82       	std	Y+7, r12	; 0x07
    1cac:	a8 86       	std	Y+8, r10	; 0x08
    1cae:	89 86       	std	Y+9, r8	; 0x09
	LCD_Void_Write_Cmd(copy_CGRAM_address);
    1cb0:	89 85       	ldd	r24, Y+9	; 0x09
    1cb2:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
	LCD_Void_Write_Data(copy_row_0);
    1cb6:	89 81       	ldd	r24, Y+1	; 0x01
    1cb8:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_1);
    1cbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cbe:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_2);
    1cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc4:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_3);
    1cc8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cca:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_4);
    1cce:	8d 81       	ldd	r24, Y+5	; 0x05
    1cd0:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_5);
    1cd4:	8e 81       	ldd	r24, Y+6	; 0x06
    1cd6:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_6);
    1cda:	8f 81       	ldd	r24, Y+7	; 0x07
    1cdc:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_7);
    1ce0:	88 85       	ldd	r24, Y+8	; 0x08
    1ce2:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Cmd(0b10000000);
    1ce6:	80 e8       	ldi	r24, 0x80	; 128
    1ce8:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <LCD_Void_Write_Cmd>
}
    1cec:	00 00       	nop
    1cee:	29 96       	adiw	r28, 0x09	; 9
    1cf0:	0f b6       	in	r0, 0x3f	; 63
    1cf2:	f8 94       	cli
    1cf4:	de bf       	out	0x3e, r29	; 62
    1cf6:	0f be       	out	0x3f, r0	; 63
    1cf8:	cd bf       	out	0x3d, r28	; 61
    1cfa:	df 91       	pop	r29
    1cfc:	cf 91       	pop	r28
    1cfe:	0f 91       	pop	r16
    1d00:	ef 90       	pop	r14
    1d02:	cf 90       	pop	r12
    1d04:	af 90       	pop	r10
    1d06:	8f 90       	pop	r8
    1d08:	08 95       	ret

00001d0a <LCD_Void_Write_Number>:

void LCD_Void_Write_Number(u32 Number)
{
    1d0a:	cf 93       	push	r28
    1d0c:	df 93       	push	r29
    1d0e:	00 d0       	rcall	.+0      	; 0x1d10 <LCD_Void_Write_Number+0x6>
    1d10:	00 d0       	rcall	.+0      	; 0x1d12 <LCD_Void_Write_Number+0x8>
    1d12:	1f 92       	push	r1
    1d14:	cd b7       	in	r28, 0x3d	; 61
    1d16:	de b7       	in	r29, 0x3e	; 62
    1d18:	9d 83       	std	Y+5, r25	; 0x05
    1d1a:	8c 83       	std	Y+4, r24	; 0x04
	u32 Reversed_Num = 0;
    1d1c:	1a 82       	std	Y+2, r1	; 0x02
    1d1e:	19 82       	std	Y+1, r1	; 0x01
	u8 count = 0;
    1d20:	1b 82       	std	Y+3, r1	; 0x03
	while(Number > 0)
    1d22:	3c c0       	rjmp	.+120    	; 0x1d9c <LCD_Void_Write_Number+0x92>
	{
		Reversed_Num = (Number%10) + (Reversed_Num*10);
    1d24:	4c 81       	ldd	r20, Y+4	; 0x04
    1d26:	5d 81       	ldd	r21, Y+5	; 0x05
    1d28:	9a 01       	movw	r18, r20
    1d2a:	ad ec       	ldi	r26, 0xCD	; 205
    1d2c:	bc ec       	ldi	r27, 0xCC	; 204
    1d2e:	0e 94 10 30 	call	0x6020	; 0x6020 <__umulhisi3>
    1d32:	9c 01       	movw	r18, r24
    1d34:	36 95       	lsr	r19
    1d36:	27 95       	ror	r18
    1d38:	36 95       	lsr	r19
    1d3a:	27 95       	ror	r18
    1d3c:	36 95       	lsr	r19
    1d3e:	27 95       	ror	r18
    1d40:	c9 01       	movw	r24, r18
    1d42:	88 0f       	add	r24, r24
    1d44:	99 1f       	adc	r25, r25
    1d46:	9c 01       	movw	r18, r24
    1d48:	22 0f       	add	r18, r18
    1d4a:	33 1f       	adc	r19, r19
    1d4c:	22 0f       	add	r18, r18
    1d4e:	33 1f       	adc	r19, r19
    1d50:	82 0f       	add	r24, r18
    1d52:	93 1f       	adc	r25, r19
    1d54:	9a 01       	movw	r18, r20
    1d56:	28 1b       	sub	r18, r24
    1d58:	39 0b       	sbc	r19, r25
    1d5a:	89 81       	ldd	r24, Y+1	; 0x01
    1d5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d5e:	88 0f       	add	r24, r24
    1d60:	99 1f       	adc	r25, r25
    1d62:	ac 01       	movw	r20, r24
    1d64:	44 0f       	add	r20, r20
    1d66:	55 1f       	adc	r21, r21
    1d68:	44 0f       	add	r20, r20
    1d6a:	55 1f       	adc	r21, r21
    1d6c:	84 0f       	add	r24, r20
    1d6e:	95 1f       	adc	r25, r21
    1d70:	82 0f       	add	r24, r18
    1d72:	93 1f       	adc	r25, r19
    1d74:	9a 83       	std	Y+2, r25	; 0x02
    1d76:	89 83       	std	Y+1, r24	; 0x01
		Number /= 10;
    1d78:	8c 81       	ldd	r24, Y+4	; 0x04
    1d7a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d7c:	9c 01       	movw	r18, r24
    1d7e:	ad ec       	ldi	r26, 0xCD	; 205
    1d80:	bc ec       	ldi	r27, 0xCC	; 204
    1d82:	0e 94 10 30 	call	0x6020	; 0x6020 <__umulhisi3>
    1d86:	96 95       	lsr	r25
    1d88:	87 95       	ror	r24
    1d8a:	96 95       	lsr	r25
    1d8c:	87 95       	ror	r24
    1d8e:	96 95       	lsr	r25
    1d90:	87 95       	ror	r24
    1d92:	9d 83       	std	Y+5, r25	; 0x05
    1d94:	8c 83       	std	Y+4, r24	; 0x04
		count ++;
    1d96:	8b 81       	ldd	r24, Y+3	; 0x03
    1d98:	8f 5f       	subi	r24, 0xFF	; 255
    1d9a:	8b 83       	std	Y+3, r24	; 0x03

void LCD_Void_Write_Number(u32 Number)
{
	u32 Reversed_Num = 0;
	u8 count = 0;
	while(Number > 0)
    1d9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d9e:	9d 81       	ldd	r25, Y+5	; 0x05
    1da0:	89 2b       	or	r24, r25
    1da2:	09 f0       	breq	.+2      	; 0x1da6 <LCD_Void_Write_Number+0x9c>
    1da4:	bf cf       	rjmp	.-130    	; 0x1d24 <LCD_Void_Write_Number+0x1a>
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1da6:	1d 82       	std	Y+5, r1	; 0x05
    1da8:	1c 82       	std	Y+4, r1	; 0x04
    1daa:	31 c0       	rjmp	.+98     	; 0x1e0e <LCD_Void_Write_Number+0x104>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
    1dac:	49 81       	ldd	r20, Y+1	; 0x01
    1dae:	5a 81       	ldd	r21, Y+2	; 0x02
    1db0:	9a 01       	movw	r18, r20
    1db2:	ad ec       	ldi	r26, 0xCD	; 205
    1db4:	bc ec       	ldi	r27, 0xCC	; 204
    1db6:	0e 94 10 30 	call	0x6020	; 0x6020 <__umulhisi3>
    1dba:	96 95       	lsr	r25
    1dbc:	87 95       	ror	r24
    1dbe:	96 95       	lsr	r25
    1dc0:	87 95       	ror	r24
    1dc2:	96 95       	lsr	r25
    1dc4:	87 95       	ror	r24
    1dc6:	88 0f       	add	r24, r24
    1dc8:	99 1f       	adc	r25, r25
    1dca:	9c 01       	movw	r18, r24
    1dcc:	22 0f       	add	r18, r18
    1dce:	33 1f       	adc	r19, r19
    1dd0:	22 0f       	add	r18, r18
    1dd2:	33 1f       	adc	r19, r19
    1dd4:	82 0f       	add	r24, r18
    1dd6:	93 1f       	adc	r25, r19
    1dd8:	9a 01       	movw	r18, r20
    1dda:	28 1b       	sub	r18, r24
    1ddc:	39 0b       	sbc	r19, r25
    1dde:	c9 01       	movw	r24, r18
    1de0:	80 5d       	subi	r24, 0xD0	; 208
    1de2:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
		Reversed_Num /= 10;
    1de6:	89 81       	ldd	r24, Y+1	; 0x01
    1de8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dea:	9c 01       	movw	r18, r24
    1dec:	ad ec       	ldi	r26, 0xCD	; 205
    1dee:	bc ec       	ldi	r27, 0xCC	; 204
    1df0:	0e 94 10 30 	call	0x6020	; 0x6020 <__umulhisi3>
    1df4:	96 95       	lsr	r25
    1df6:	87 95       	ror	r24
    1df8:	96 95       	lsr	r25
    1dfa:	87 95       	ror	r24
    1dfc:	96 95       	lsr	r25
    1dfe:	87 95       	ror	r24
    1e00:	9a 83       	std	Y+2, r25	; 0x02
    1e02:	89 83       	std	Y+1, r24	; 0x01
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1e04:	8c 81       	ldd	r24, Y+4	; 0x04
    1e06:	9d 81       	ldd	r25, Y+5	; 0x05
    1e08:	01 96       	adiw	r24, 0x01	; 1
    1e0a:	9d 83       	std	Y+5, r25	; 0x05
    1e0c:	8c 83       	std	Y+4, r24	; 0x04
    1e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e10:	28 2f       	mov	r18, r24
    1e12:	30 e0       	ldi	r19, 0x00	; 0
    1e14:	8c 81       	ldd	r24, Y+4	; 0x04
    1e16:	9d 81       	ldd	r25, Y+5	; 0x05
    1e18:	82 17       	cp	r24, r18
    1e1a:	93 07       	cpc	r25, r19
    1e1c:	38 f2       	brcs	.-114    	; 0x1dac <LCD_Void_Write_Number+0xa2>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
		Reversed_Num /= 10;
	}

}
    1e1e:	00 00       	nop
    1e20:	0f 90       	pop	r0
    1e22:	0f 90       	pop	r0
    1e24:	0f 90       	pop	r0
    1e26:	0f 90       	pop	r0
    1e28:	0f 90       	pop	r0
    1e2a:	df 91       	pop	r29
    1e2c:	cf 91       	pop	r28
    1e2e:	08 95       	ret

00001e30 <LCD_Void_Write_Number_2>:


void LCD_Void_Write_Number_2(u8 Number)
{
    1e30:	cf 93       	push	r28
    1e32:	df 93       	push	r29
    1e34:	1f 92       	push	r1
    1e36:	cd b7       	in	r28, 0x3d	; 61
    1e38:	de b7       	in	r29, 0x3e	; 62
    1e3a:	89 83       	std	Y+1, r24	; 0x01

	LCD_Void_Write_Data((Number/10)+'0');
    1e3c:	99 81       	ldd	r25, Y+1	; 0x01
    1e3e:	8d ec       	ldi	r24, 0xCD	; 205
    1e40:	98 9f       	mul	r25, r24
    1e42:	81 2d       	mov	r24, r1
    1e44:	11 24       	eor	r1, r1
    1e46:	86 95       	lsr	r24
    1e48:	86 95       	lsr	r24
    1e4a:	86 95       	lsr	r24
    1e4c:	80 5d       	subi	r24, 0xD0	; 208
    1e4e:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>
	LCD_Void_Write_Data((Number%10)+'0');
    1e52:	99 81       	ldd	r25, Y+1	; 0x01
    1e54:	8d ec       	ldi	r24, 0xCD	; 205
    1e56:	98 9f       	mul	r25, r24
    1e58:	81 2d       	mov	r24, r1
    1e5a:	11 24       	eor	r1, r1
    1e5c:	86 95       	lsr	r24
    1e5e:	86 95       	lsr	r24
    1e60:	86 95       	lsr	r24
    1e62:	88 0f       	add	r24, r24
    1e64:	28 2f       	mov	r18, r24
    1e66:	22 0f       	add	r18, r18
    1e68:	22 0f       	add	r18, r18
    1e6a:	82 0f       	add	r24, r18
    1e6c:	29 2f       	mov	r18, r25
    1e6e:	28 1b       	sub	r18, r24
    1e70:	82 2f       	mov	r24, r18
    1e72:	80 5d       	subi	r24, 0xD0	; 208
    1e74:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_Void_Write_Data>

}
    1e78:	00 00       	nop
    1e7a:	0f 90       	pop	r0
    1e7c:	df 91       	pop	r29
    1e7e:	cf 91       	pop	r28
    1e80:	08 95       	ret

00001e82 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1e82:	cf 93       	push	r28
    1e84:	df 93       	push	r29
    1e86:	00 d0       	rcall	.+0      	; 0x1e88 <xEventGroupCreate+0x6>
    1e88:	cd b7       	in	r28, 0x3d	; 61
    1e8a:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1e8c:	8b e0       	ldi	r24, 0x0B	; 11
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	0e 94 a2 12 	call	0x2544	; 0x2544 <pvPortMalloc>
    1e94:	9a 83       	std	Y+2, r25	; 0x02
    1e96:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9c:	89 2b       	or	r24, r25
    1e9e:	51 f0       	breq	.+20     	; 0x1eb4 <xEventGroupCreate+0x32>
		{
			pxEventBits->uxEventBits = 0;
    1ea0:	89 81       	ldd	r24, Y+1	; 0x01
    1ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea4:	fc 01       	movw	r30, r24
    1ea6:	11 82       	std	Z+1, r1	; 0x01
    1ea8:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1eaa:	89 81       	ldd	r24, Y+1	; 0x01
    1eac:	9a 81       	ldd	r25, Y+2	; 0x02
    1eae:	02 96       	adiw	r24, 0x02	; 2
    1eb0:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    1eb4:	89 81       	ldd	r24, Y+1	; 0x01
    1eb6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1eb8:	0f 90       	pop	r0
    1eba:	0f 90       	pop	r0
    1ebc:	df 91       	pop	r29
    1ebe:	cf 91       	pop	r28
    1ec0:	08 95       	ret

00001ec2 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1ec2:	cf 93       	push	r28
    1ec4:	df 93       	push	r29
    1ec6:	cd b7       	in	r28, 0x3d	; 61
    1ec8:	de b7       	in	r29, 0x3e	; 62
    1eca:	60 97       	sbiw	r28, 0x10	; 16
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	de bf       	out	0x3e, r29	; 62
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	cd bf       	out	0x3d, r28	; 61
    1ed6:	9a 87       	std	Y+10, r25	; 0x0a
    1ed8:	89 87       	std	Y+9, r24	; 0x09
    1eda:	7c 87       	std	Y+12, r23	; 0x0c
    1edc:	6b 87       	std	Y+11, r22	; 0x0b
    1ede:	5e 87       	std	Y+14, r21	; 0x0e
    1ee0:	4d 87       	std	Y+13, r20	; 0x0d
    1ee2:	38 8b       	std	Y+16, r19	; 0x10
    1ee4:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    1ee6:	89 85       	ldd	r24, Y+9	; 0x09
    1ee8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1eea:	9c 83       	std	Y+4, r25	; 0x04
    1eec:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1eee:	1d 82       	std	Y+5, r1	; 0x05
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1ef0:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef8:	fc 01       	movw	r30, r24
    1efa:	80 81       	ld	r24, Z
    1efc:	91 81       	ldd	r25, Z+1	; 0x01
    1efe:	9f 83       	std	Y+7, r25	; 0x07
    1f00:	8e 83       	std	Y+6, r24	; 0x06

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1f02:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f04:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f06:	89 85       	ldd	r24, Y+9	; 0x09
    1f08:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f0a:	b9 01       	movw	r22, r18
    1f0c:	0e 94 43 11 	call	0x2286	; 0x2286 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f10:	2e 81       	ldd	r18, Y+6	; 0x06
    1f12:	3f 81       	ldd	r19, Y+7	; 0x07
    1f14:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f16:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f18:	28 2b       	or	r18, r24
    1f1a:	39 2b       	or	r19, r25
    1f1c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f1e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f20:	28 23       	and	r18, r24
    1f22:	39 23       	and	r19, r25
    1f24:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f26:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f28:	28 17       	cp	r18, r24
    1f2a:	39 07       	cpc	r19, r25
    1f2c:	d9 f4       	brne	.+54     	; 0x1f64 <xEventGroupSync+0xa2>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1f2e:	2e 81       	ldd	r18, Y+6	; 0x06
    1f30:	3f 81       	ldd	r19, Y+7	; 0x07
    1f32:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f34:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f36:	82 2b       	or	r24, r18
    1f38:	93 2b       	or	r25, r19
    1f3a:	9a 83       	std	Y+2, r25	; 0x02
    1f3c:	89 83       	std	Y+1, r24	; 0x01

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f40:	9c 81       	ldd	r25, Y+4	; 0x04
    1f42:	fc 01       	movw	r30, r24
    1f44:	20 81       	ld	r18, Z
    1f46:	31 81       	ldd	r19, Z+1	; 0x01
    1f48:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f4c:	80 95       	com	r24
    1f4e:	90 95       	com	r25
    1f50:	28 23       	and	r18, r24
    1f52:	39 23       	and	r19, r25
    1f54:	8b 81       	ldd	r24, Y+3	; 0x03
    1f56:	9c 81       	ldd	r25, Y+4	; 0x04
    1f58:	fc 01       	movw	r30, r24
    1f5a:	31 83       	std	Z+1, r19	; 0x01
    1f5c:	20 83       	st	Z, r18

			xTicksToWait = 0;
    1f5e:	18 8a       	std	Y+16, r1	; 0x10
    1f60:	1f 86       	std	Y+15, r1	; 0x0f
    1f62:	1c c0       	rjmp	.+56     	; 0x1f9c <xEventGroupSync+0xda>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1f64:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f66:	98 89       	ldd	r25, Y+16	; 0x10
    1f68:	89 2b       	or	r24, r25
    1f6a:	79 f0       	breq	.+30     	; 0x1f8a <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1f6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f6e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f70:	9c 01       	movw	r18, r24
    1f72:	35 60       	ori	r19, 0x05	; 5
    1f74:	8b 81       	ldd	r24, Y+3	; 0x03
    1f76:	9c 81       	ldd	r25, Y+4	; 0x04
    1f78:	02 96       	adiw	r24, 0x02	; 2
    1f7a:	4f 85       	ldd	r20, Y+15	; 0x0f
    1f7c:	58 89       	ldd	r21, Y+16	; 0x10
    1f7e:	b9 01       	movw	r22, r18
    1f80:	0e 94 31 27 	call	0x4e62	; 0x4e62 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1f84:	1a 82       	std	Y+2, r1	; 0x02
    1f86:	19 82       	std	Y+1, r1	; 0x01
    1f88:	09 c0       	rjmp	.+18     	; 0x1f9c <xEventGroupSync+0xda>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8e:	fc 01       	movw	r30, r24
    1f90:	80 81       	ld	r24, Z
    1f92:	91 81       	ldd	r25, Z+1	; 0x01
    1f94:	9a 83       	std	Y+2, r25	; 0x02
    1f96:	89 83       	std	Y+1, r24	; 0x01
				xTimeoutOccurred = pdTRUE;
    1f98:	81 e0       	ldi	r24, 0x01	; 1
    1f9a:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1f9c:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    1fa0:	88 87       	std	Y+8, r24	; 0x08

	if( xTicksToWait != ( TickType_t ) 0 )
    1fa2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fa4:	98 89       	ldd	r25, Y+16	; 0x10
    1fa6:	89 2b       	or	r24, r25
    1fa8:	09 f4       	brne	.+2      	; 0x1fac <xEventGroupSync+0xea>
    1faa:	3d c0       	rjmp	.+122    	; 0x2026 <xEventGroupSync+0x164>
	{
		if( xAlreadyYielded == pdFALSE )
    1fac:	88 85       	ldd	r24, Y+8	; 0x08
    1fae:	88 23       	and	r24, r24
    1fb0:	11 f4       	brne	.+4      	; 0x1fb6 <xEventGroupSync+0xf4>
		{
			portYIELD_WITHIN_API();
    1fb2:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1fb6:	0e 94 94 2b 	call	0x5728	; 0x5728 <uxTaskResetEventItemValue>
    1fba:	9a 83       	std	Y+2, r25	; 0x02
    1fbc:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1fbe:	89 81       	ldd	r24, Y+1	; 0x01
    1fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    1fc2:	88 27       	eor	r24, r24
    1fc4:	92 70       	andi	r25, 0x02	; 2
    1fc6:	89 2b       	or	r24, r25
    1fc8:	49 f5       	brne	.+82     	; 0x201c <xEventGroupSync+0x15a>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1fca:	0f b6       	in	r0, 0x3f	; 63
    1fcc:	f8 94       	cli
    1fce:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	80 81       	ld	r24, Z
    1fd8:	91 81       	ldd	r25, Z+1	; 0x01
    1fda:	9a 83       	std	Y+2, r25	; 0x02
    1fdc:	89 83       	std	Y+1, r24	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1fde:	29 81       	ldd	r18, Y+1	; 0x01
    1fe0:	3a 81       	ldd	r19, Y+2	; 0x02
    1fe2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fe4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fe6:	28 23       	and	r18, r24
    1fe8:	39 23       	and	r19, r25
    1fea:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fec:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fee:	28 17       	cp	r18, r24
    1ff0:	39 07       	cpc	r19, r25
    1ff2:	81 f4       	brne	.+32     	; 0x2014 <xEventGroupSync+0x152>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff8:	fc 01       	movw	r30, r24
    1ffa:	20 81       	ld	r18, Z
    1ffc:	31 81       	ldd	r19, Z+1	; 0x01
    1ffe:	8d 85       	ldd	r24, Y+13	; 0x0d
    2000:	9e 85       	ldd	r25, Y+14	; 0x0e
    2002:	80 95       	com	r24
    2004:	90 95       	com	r25
    2006:	28 23       	and	r18, r24
    2008:	39 23       	and	r19, r25
    200a:	8b 81       	ldd	r24, Y+3	; 0x03
    200c:	9c 81       	ldd	r25, Y+4	; 0x04
    200e:	fc 01       	movw	r30, r24
    2010:	31 83       	std	Z+1, r19	; 0x01
    2012:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2014:	0f 90       	pop	r0
    2016:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2018:	81 e0       	ldi	r24, 0x01	; 1
    201a:	8d 83       	std	Y+5, r24	; 0x05
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    201c:	89 81       	ldd	r24, Y+1	; 0x01
    201e:	9a 81       	ldd	r25, Y+2	; 0x02
    2020:	99 27       	eor	r25, r25
    2022:	9a 83       	std	Y+2, r25	; 0x02
    2024:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2026:	89 81       	ldd	r24, Y+1	; 0x01
    2028:	9a 81       	ldd	r25, Y+2	; 0x02
}
    202a:	60 96       	adiw	r28, 0x10	; 16
    202c:	0f b6       	in	r0, 0x3f	; 63
    202e:	f8 94       	cli
    2030:	de bf       	out	0x3e, r29	; 62
    2032:	0f be       	out	0x3f, r0	; 63
    2034:	cd bf       	out	0x3d, r28	; 61
    2036:	df 91       	pop	r29
    2038:	cf 91       	pop	r28
    203a:	08 95       	ret

0000203c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    203c:	0f 93       	push	r16
    203e:	1f 93       	push	r17
    2040:	cf 93       	push	r28
    2042:	df 93       	push	r29
    2044:	cd b7       	in	r28, 0x3d	; 61
    2046:	de b7       	in	r29, 0x3e	; 62
    2048:	63 97       	sbiw	r28, 0x13	; 19
    204a:	0f b6       	in	r0, 0x3f	; 63
    204c:	f8 94       	cli
    204e:	de bf       	out	0x3e, r29	; 62
    2050:	0f be       	out	0x3f, r0	; 63
    2052:	cd bf       	out	0x3d, r28	; 61
    2054:	9d 87       	std	Y+13, r25	; 0x0d
    2056:	8c 87       	std	Y+12, r24	; 0x0c
    2058:	7f 87       	std	Y+15, r23	; 0x0f
    205a:	6e 87       	std	Y+14, r22	; 0x0e
    205c:	48 8b       	std	Y+16, r20	; 0x10
    205e:	29 8b       	std	Y+17, r18	; 0x11
    2060:	1b 8b       	std	Y+19, r17	; 0x13
    2062:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    2064:	8c 85       	ldd	r24, Y+12	; 0x0c
    2066:	9d 85       	ldd	r25, Y+13	; 0x0d
    2068:	9e 83       	std	Y+6, r25	; 0x06
    206a:	8d 83       	std	Y+5, r24	; 0x05
EventBits_t uxReturn, uxControlBits = 0;
    206c:	1c 82       	std	Y+4, r1	; 0x04
    206e:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2070:	1f 82       	std	Y+7, r1	; 0x07
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2072:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2076:	8d 81       	ldd	r24, Y+5	; 0x05
    2078:	9e 81       	ldd	r25, Y+6	; 0x06
    207a:	fc 01       	movw	r30, r24
    207c:	80 81       	ld	r24, Z
    207e:	91 81       	ldd	r25, Z+1	; 0x01
    2080:	99 87       	std	Y+9, r25	; 0x09
    2082:	88 87       	std	Y+8, r24	; 0x08

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2084:	2e 85       	ldd	r18, Y+14	; 0x0e
    2086:	3f 85       	ldd	r19, Y+15	; 0x0f
    2088:	88 85       	ldd	r24, Y+8	; 0x08
    208a:	99 85       	ldd	r25, Y+9	; 0x09
    208c:	49 89       	ldd	r20, Y+17	; 0x11
    208e:	b9 01       	movw	r22, r18
    2090:	0e 94 70 12 	call	0x24e0	; 0x24e0 <prvTestWaitCondition>
    2094:	8a 87       	std	Y+10, r24	; 0x0a

		if( xWaitConditionMet != pdFALSE )
    2096:	8a 85       	ldd	r24, Y+10	; 0x0a
    2098:	88 23       	and	r24, r24
    209a:	d1 f0       	breq	.+52     	; 0x20d0 <xEventGroupWaitBits+0x94>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    209c:	88 85       	ldd	r24, Y+8	; 0x08
    209e:	99 85       	ldd	r25, Y+9	; 0x09
    20a0:	9a 83       	std	Y+2, r25	; 0x02
    20a2:	89 83       	std	Y+1, r24	; 0x01
			xTicksToWait = ( TickType_t ) 0;
    20a4:	1b 8a       	std	Y+19, r1	; 0x13
    20a6:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    20a8:	88 89       	ldd	r24, Y+16	; 0x10
    20aa:	88 23       	and	r24, r24
    20ac:	e1 f1       	breq	.+120    	; 0x2126 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    20ae:	8d 81       	ldd	r24, Y+5	; 0x05
    20b0:	9e 81       	ldd	r25, Y+6	; 0x06
    20b2:	fc 01       	movw	r30, r24
    20b4:	20 81       	ld	r18, Z
    20b6:	31 81       	ldd	r19, Z+1	; 0x01
    20b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    20ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    20bc:	80 95       	com	r24
    20be:	90 95       	com	r25
    20c0:	28 23       	and	r18, r24
    20c2:	39 23       	and	r19, r25
    20c4:	8d 81       	ldd	r24, Y+5	; 0x05
    20c6:	9e 81       	ldd	r25, Y+6	; 0x06
    20c8:	fc 01       	movw	r30, r24
    20ca:	31 83       	std	Z+1, r19	; 0x01
    20cc:	20 83       	st	Z, r18
    20ce:	2b c0       	rjmp	.+86     	; 0x2126 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    20d0:	8a 89       	ldd	r24, Y+18	; 0x12
    20d2:	9b 89       	ldd	r25, Y+19	; 0x13
    20d4:	89 2b       	or	r24, r25
    20d6:	39 f4       	brne	.+14     	; 0x20e6 <xEventGroupWaitBits+0xaa>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    20d8:	88 85       	ldd	r24, Y+8	; 0x08
    20da:	99 85       	ldd	r25, Y+9	; 0x09
    20dc:	9a 83       	std	Y+2, r25	; 0x02
    20de:	89 83       	std	Y+1, r24	; 0x01
			xTimeoutOccurred = pdTRUE;
    20e0:	81 e0       	ldi	r24, 0x01	; 1
    20e2:	8f 83       	std	Y+7, r24	; 0x07
    20e4:	20 c0       	rjmp	.+64     	; 0x2126 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    20e6:	88 89       	ldd	r24, Y+16	; 0x10
    20e8:	88 23       	and	r24, r24
    20ea:	29 f0       	breq	.+10     	; 0x20f6 <xEventGroupWaitBits+0xba>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    20ec:	8b 81       	ldd	r24, Y+3	; 0x03
    20ee:	9c 81       	ldd	r25, Y+4	; 0x04
    20f0:	91 60       	ori	r25, 0x01	; 1
    20f2:	9c 83       	std	Y+4, r25	; 0x04
    20f4:	8b 83       	std	Y+3, r24	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    20f6:	89 89       	ldd	r24, Y+17	; 0x11
    20f8:	88 23       	and	r24, r24
    20fa:	29 f0       	breq	.+10     	; 0x2106 <xEventGroupWaitBits+0xca>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    20fc:	8b 81       	ldd	r24, Y+3	; 0x03
    20fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2100:	94 60       	ori	r25, 0x04	; 4
    2102:	9c 83       	std	Y+4, r25	; 0x04
    2104:	8b 83       	std	Y+3, r24	; 0x03
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2106:	2e 85       	ldd	r18, Y+14	; 0x0e
    2108:	3f 85       	ldd	r19, Y+15	; 0x0f
    210a:	8b 81       	ldd	r24, Y+3	; 0x03
    210c:	9c 81       	ldd	r25, Y+4	; 0x04
    210e:	28 2b       	or	r18, r24
    2110:	39 2b       	or	r19, r25
    2112:	8d 81       	ldd	r24, Y+5	; 0x05
    2114:	9e 81       	ldd	r25, Y+6	; 0x06
    2116:	02 96       	adiw	r24, 0x02	; 2
    2118:	4a 89       	ldd	r20, Y+18	; 0x12
    211a:	5b 89       	ldd	r21, Y+19	; 0x13
    211c:	b9 01       	movw	r22, r18
    211e:	0e 94 31 27 	call	0x4e62	; 0x4e62 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2122:	1a 82       	std	Y+2, r1	; 0x02
    2124:	19 82       	std	Y+1, r1	; 0x01

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2126:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    212a:	8b 87       	std	Y+11, r24	; 0x0b

	if( xTicksToWait != ( TickType_t ) 0 )
    212c:	8a 89       	ldd	r24, Y+18	; 0x12
    212e:	9b 89       	ldd	r25, Y+19	; 0x13
    2130:	89 2b       	or	r24, r25
    2132:	09 f4       	brne	.+2      	; 0x2136 <xEventGroupWaitBits+0xfa>
    2134:	3f c0       	rjmp	.+126    	; 0x21b4 <xEventGroupWaitBits+0x178>
	{
		if( xAlreadyYielded == pdFALSE )
    2136:	8b 85       	ldd	r24, Y+11	; 0x0b
    2138:	88 23       	and	r24, r24
    213a:	11 f4       	brne	.+4      	; 0x2140 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    213c:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2140:	0e 94 94 2b 	call	0x5728	; 0x5728 <uxTaskResetEventItemValue>
    2144:	9a 83       	std	Y+2, r25	; 0x02
    2146:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2148:	89 81       	ldd	r24, Y+1	; 0x01
    214a:	9a 81       	ldd	r25, Y+2	; 0x02
    214c:	88 27       	eor	r24, r24
    214e:	92 70       	andi	r25, 0x02	; 2
    2150:	89 2b       	or	r24, r25
    2152:	59 f5       	brne	.+86     	; 0x21aa <xEventGroupWaitBits+0x16e>
		{
			taskENTER_CRITICAL();
    2154:	0f b6       	in	r0, 0x3f	; 63
    2156:	f8 94       	cli
    2158:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    215a:	8d 81       	ldd	r24, Y+5	; 0x05
    215c:	9e 81       	ldd	r25, Y+6	; 0x06
    215e:	fc 01       	movw	r30, r24
    2160:	80 81       	ld	r24, Z
    2162:	91 81       	ldd	r25, Z+1	; 0x01
    2164:	9a 83       	std	Y+2, r25	; 0x02
    2166:	89 83       	std	Y+1, r24	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2168:	2e 85       	ldd	r18, Y+14	; 0x0e
    216a:	3f 85       	ldd	r19, Y+15	; 0x0f
    216c:	89 81       	ldd	r24, Y+1	; 0x01
    216e:	9a 81       	ldd	r25, Y+2	; 0x02
    2170:	49 89       	ldd	r20, Y+17	; 0x11
    2172:	b9 01       	movw	r22, r18
    2174:	0e 94 70 12 	call	0x24e0	; 0x24e0 <prvTestWaitCondition>
    2178:	88 23       	and	r24, r24
    217a:	99 f0       	breq	.+38     	; 0x21a2 <xEventGroupWaitBits+0x166>
				{
					if( xClearOnExit != pdFALSE )
    217c:	88 89       	ldd	r24, Y+16	; 0x10
    217e:	88 23       	and	r24, r24
    2180:	81 f0       	breq	.+32     	; 0x21a2 <xEventGroupWaitBits+0x166>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2182:	8d 81       	ldd	r24, Y+5	; 0x05
    2184:	9e 81       	ldd	r25, Y+6	; 0x06
    2186:	fc 01       	movw	r30, r24
    2188:	20 81       	ld	r18, Z
    218a:	31 81       	ldd	r19, Z+1	; 0x01
    218c:	8e 85       	ldd	r24, Y+14	; 0x0e
    218e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2190:	80 95       	com	r24
    2192:	90 95       	com	r25
    2194:	28 23       	and	r18, r24
    2196:	39 23       	and	r19, r25
    2198:	8d 81       	ldd	r24, Y+5	; 0x05
    219a:	9e 81       	ldd	r25, Y+6	; 0x06
    219c:	fc 01       	movw	r30, r24
    219e:	31 83       	std	Z+1, r19	; 0x01
    21a0:	20 83       	st	Z, r18
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    21a2:	81 e0       	ldi	r24, 0x01	; 1
    21a4:	8f 83       	std	Y+7, r24	; 0x07
			}
			taskEXIT_CRITICAL();
    21a6:	0f 90       	pop	r0
    21a8:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    21aa:	89 81       	ldd	r24, Y+1	; 0x01
    21ac:	9a 81       	ldd	r25, Y+2	; 0x02
    21ae:	99 27       	eor	r25, r25
    21b0:	9a 83       	std	Y+2, r25	; 0x02
    21b2:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    21b4:	89 81       	ldd	r24, Y+1	; 0x01
    21b6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    21b8:	63 96       	adiw	r28, 0x13	; 19
    21ba:	0f b6       	in	r0, 0x3f	; 63
    21bc:	f8 94       	cli
    21be:	de bf       	out	0x3e, r29	; 62
    21c0:	0f be       	out	0x3f, r0	; 63
    21c2:	cd bf       	out	0x3d, r28	; 61
    21c4:	df 91       	pop	r29
    21c6:	cf 91       	pop	r28
    21c8:	1f 91       	pop	r17
    21ca:	0f 91       	pop	r16
    21cc:	08 95       	ret

000021ce <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    21ce:	cf 93       	push	r28
    21d0:	df 93       	push	r29
    21d2:	cd b7       	in	r28, 0x3d	; 61
    21d4:	de b7       	in	r29, 0x3e	; 62
    21d6:	28 97       	sbiw	r28, 0x08	; 8
    21d8:	0f b6       	in	r0, 0x3f	; 63
    21da:	f8 94       	cli
    21dc:	de bf       	out	0x3e, r29	; 62
    21de:	0f be       	out	0x3f, r0	; 63
    21e0:	cd bf       	out	0x3d, r28	; 61
    21e2:	9e 83       	std	Y+6, r25	; 0x06
    21e4:	8d 83       	std	Y+5, r24	; 0x05
    21e6:	78 87       	std	Y+8, r23	; 0x08
    21e8:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    21ea:	8d 81       	ldd	r24, Y+5	; 0x05
    21ec:	9e 81       	ldd	r25, Y+6	; 0x06
    21ee:	9a 83       	std	Y+2, r25	; 0x02
    21f0:	89 83       	std	Y+1, r24	; 0x01
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    21f2:	0f b6       	in	r0, 0x3f	; 63
    21f4:	f8 94       	cli
    21f6:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    21f8:	89 81       	ldd	r24, Y+1	; 0x01
    21fa:	9a 81       	ldd	r25, Y+2	; 0x02
    21fc:	fc 01       	movw	r30, r24
    21fe:	80 81       	ld	r24, Z
    2200:	91 81       	ldd	r25, Z+1	; 0x01
    2202:	9c 83       	std	Y+4, r25	; 0x04
    2204:	8b 83       	std	Y+3, r24	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2206:	89 81       	ldd	r24, Y+1	; 0x01
    2208:	9a 81       	ldd	r25, Y+2	; 0x02
    220a:	fc 01       	movw	r30, r24
    220c:	20 81       	ld	r18, Z
    220e:	31 81       	ldd	r19, Z+1	; 0x01
    2210:	8f 81       	ldd	r24, Y+7	; 0x07
    2212:	98 85       	ldd	r25, Y+8	; 0x08
    2214:	80 95       	com	r24
    2216:	90 95       	com	r25
    2218:	28 23       	and	r18, r24
    221a:	39 23       	and	r19, r25
    221c:	89 81       	ldd	r24, Y+1	; 0x01
    221e:	9a 81       	ldd	r25, Y+2	; 0x02
    2220:	fc 01       	movw	r30, r24
    2222:	31 83       	std	Z+1, r19	; 0x01
    2224:	20 83       	st	Z, r18
	}
	taskEXIT_CRITICAL();
    2226:	0f 90       	pop	r0
    2228:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    222a:	8b 81       	ldd	r24, Y+3	; 0x03
    222c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    222e:	28 96       	adiw	r28, 0x08	; 8
    2230:	0f b6       	in	r0, 0x3f	; 63
    2232:	f8 94       	cli
    2234:	de bf       	out	0x3e, r29	; 62
    2236:	0f be       	out	0x3f, r0	; 63
    2238:	cd bf       	out	0x3d, r28	; 61
    223a:	df 91       	pop	r29
    223c:	cf 91       	pop	r28
    223e:	08 95       	ret

00002240 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2240:	cf 93       	push	r28
    2242:	df 93       	push	r29
    2244:	cd b7       	in	r28, 0x3d	; 61
    2246:	de b7       	in	r29, 0x3e	; 62
    2248:	27 97       	sbiw	r28, 0x07	; 7
    224a:	0f b6       	in	r0, 0x3f	; 63
    224c:	f8 94       	cli
    224e:	de bf       	out	0x3e, r29	; 62
    2250:	0f be       	out	0x3f, r0	; 63
    2252:	cd bf       	out	0x3d, r28	; 61
    2254:	9f 83       	std	Y+7, r25	; 0x07
    2256:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    2258:	8e 81       	ldd	r24, Y+6	; 0x06
    225a:	9f 81       	ldd	r25, Y+7	; 0x07
    225c:	9a 83       	std	Y+2, r25	; 0x02
    225e:	89 83       	std	Y+1, r24	; 0x01
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2260:	1b 82       	std	Y+3, r1	; 0x03
	{
		uxReturn = pxEventBits->uxEventBits;
    2262:	89 81       	ldd	r24, Y+1	; 0x01
    2264:	9a 81       	ldd	r25, Y+2	; 0x02
    2266:	fc 01       	movw	r30, r24
    2268:	80 81       	ld	r24, Z
    226a:	91 81       	ldd	r25, Z+1	; 0x01
    226c:	9d 83       	std	Y+5, r25	; 0x05
    226e:	8c 83       	std	Y+4, r24	; 0x04
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2270:	8c 81       	ldd	r24, Y+4	; 0x04
    2272:	9d 81       	ldd	r25, Y+5	; 0x05
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2274:	27 96       	adiw	r28, 0x07	; 7
    2276:	0f b6       	in	r0, 0x3f	; 63
    2278:	f8 94       	cli
    227a:	de bf       	out	0x3e, r29	; 62
    227c:	0f be       	out	0x3f, r0	; 63
    227e:	cd bf       	out	0x3d, r28	; 61
    2280:	df 91       	pop	r29
    2282:	cf 91       	pop	r28
    2284:	08 95       	ret

00002286 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2286:	cf 93       	push	r28
    2288:	df 93       	push	r29
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
    228e:	65 97       	sbiw	r28, 0x15	; 21
    2290:	0f b6       	in	r0, 0x3f	; 63
    2292:	f8 94       	cli
    2294:	de bf       	out	0x3e, r29	; 62
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	cd bf       	out	0x3d, r28	; 61
    229a:	9b 8b       	std	Y+19, r25	; 0x13
    229c:	8a 8b       	std	Y+18, r24	; 0x12
    229e:	7d 8b       	std	Y+21, r23	; 0x15
    22a0:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    22a2:	1c 82       	std	Y+4, r1	; 0x04
    22a4:	1b 82       	std	Y+3, r1	; 0x03
EventGroup_t *pxEventBits = xEventGroup;
    22a6:	8a 89       	ldd	r24, Y+18	; 0x12
    22a8:	9b 89       	ldd	r25, Y+19	; 0x13
    22aa:	9f 83       	std	Y+7, r25	; 0x07
    22ac:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xMatchFound = pdFALSE;
    22ae:	1d 82       	std	Y+5, r1	; 0x05
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    22b0:	8e 81       	ldd	r24, Y+6	; 0x06
    22b2:	9f 81       	ldd	r25, Y+7	; 0x07
    22b4:	02 96       	adiw	r24, 0x02	; 2
    22b6:	99 87       	std	Y+9, r25	; 0x09
    22b8:	88 87       	std	Y+8, r24	; 0x08
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    22ba:	88 85       	ldd	r24, Y+8	; 0x08
    22bc:	99 85       	ldd	r25, Y+9	; 0x09
    22be:	03 96       	adiw	r24, 0x03	; 3
    22c0:	9b 87       	std	Y+11, r25	; 0x0b
    22c2:	8a 87       	std	Y+10, r24	; 0x0a
	vTaskSuspendAll();
    22c4:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    22c8:	88 85       	ldd	r24, Y+8	; 0x08
    22ca:	99 85       	ldd	r25, Y+9	; 0x09
    22cc:	fc 01       	movw	r30, r24
    22ce:	85 81       	ldd	r24, Z+5	; 0x05
    22d0:	96 81       	ldd	r25, Z+6	; 0x06
    22d2:	9a 83       	std	Y+2, r25	; 0x02
    22d4:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    22d6:	8e 81       	ldd	r24, Y+6	; 0x06
    22d8:	9f 81       	ldd	r25, Y+7	; 0x07
    22da:	fc 01       	movw	r30, r24
    22dc:	20 81       	ld	r18, Z
    22de:	31 81       	ldd	r19, Z+1	; 0x01
    22e0:	8c 89       	ldd	r24, Y+20	; 0x14
    22e2:	9d 89       	ldd	r25, Y+21	; 0x15
    22e4:	28 2b       	or	r18, r24
    22e6:	39 2b       	or	r19, r25
    22e8:	8e 81       	ldd	r24, Y+6	; 0x06
    22ea:	9f 81       	ldd	r25, Y+7	; 0x07
    22ec:	fc 01       	movw	r30, r24
    22ee:	31 83       	std	Z+1, r19	; 0x01
    22f0:	20 83       	st	Z, r18

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    22f2:	5e c0       	rjmp	.+188    	; 0x23b0 <xEventGroupSetBits+0x12a>
		{
			pxNext = listGET_NEXT( pxListItem );
    22f4:	89 81       	ldd	r24, Y+1	; 0x01
    22f6:	9a 81       	ldd	r25, Y+2	; 0x02
    22f8:	fc 01       	movw	r30, r24
    22fa:	82 81       	ldd	r24, Z+2	; 0x02
    22fc:	93 81       	ldd	r25, Z+3	; 0x03
    22fe:	9d 87       	std	Y+13, r25	; 0x0d
    2300:	8c 87       	std	Y+12, r24	; 0x0c
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	9a 81       	ldd	r25, Y+2	; 0x02
    2306:	fc 01       	movw	r30, r24
    2308:	80 81       	ld	r24, Z
    230a:	91 81       	ldd	r25, Z+1	; 0x01
    230c:	9f 87       	std	Y+15, r25	; 0x0f
    230e:	8e 87       	std	Y+14, r24	; 0x0e
			xMatchFound = pdFALSE;
    2310:	1d 82       	std	Y+5, r1	; 0x05

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2312:	8e 85       	ldd	r24, Y+14	; 0x0e
    2314:	9f 85       	ldd	r25, Y+15	; 0x0f
    2316:	88 27       	eor	r24, r24
    2318:	99 8b       	std	Y+17, r25	; 0x11
    231a:	88 8b       	std	Y+16, r24	; 0x10
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    231c:	8e 85       	ldd	r24, Y+14	; 0x0e
    231e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2320:	99 27       	eor	r25, r25
    2322:	9f 87       	std	Y+15, r25	; 0x0f
    2324:	8e 87       	std	Y+14, r24	; 0x0e

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2326:	88 89       	ldd	r24, Y+16	; 0x10
    2328:	99 89       	ldd	r25, Y+17	; 0x11
    232a:	88 27       	eor	r24, r24
    232c:	94 70       	andi	r25, 0x04	; 4
    232e:	89 2b       	or	r24, r25
    2330:	71 f4       	brne	.+28     	; 0x234e <xEventGroupSetBits+0xc8>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2332:	8e 81       	ldd	r24, Y+6	; 0x06
    2334:	9f 81       	ldd	r25, Y+7	; 0x07
    2336:	fc 01       	movw	r30, r24
    2338:	20 81       	ld	r18, Z
    233a:	31 81       	ldd	r19, Z+1	; 0x01
    233c:	8e 85       	ldd	r24, Y+14	; 0x0e
    233e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2340:	82 23       	and	r24, r18
    2342:	93 23       	and	r25, r19
    2344:	89 2b       	or	r24, r25
    2346:	99 f0       	breq	.+38     	; 0x236e <xEventGroupSetBits+0xe8>
				{
					xMatchFound = pdTRUE;
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	8d 83       	std	Y+5, r24	; 0x05
    234c:	10 c0       	rjmp	.+32     	; 0x236e <xEventGroupSetBits+0xe8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    234e:	8e 81       	ldd	r24, Y+6	; 0x06
    2350:	9f 81       	ldd	r25, Y+7	; 0x07
    2352:	fc 01       	movw	r30, r24
    2354:	20 81       	ld	r18, Z
    2356:	31 81       	ldd	r19, Z+1	; 0x01
    2358:	8e 85       	ldd	r24, Y+14	; 0x0e
    235a:	9f 85       	ldd	r25, Y+15	; 0x0f
    235c:	28 23       	and	r18, r24
    235e:	39 23       	and	r19, r25
    2360:	8e 85       	ldd	r24, Y+14	; 0x0e
    2362:	9f 85       	ldd	r25, Y+15	; 0x0f
    2364:	28 17       	cp	r18, r24
    2366:	39 07       	cpc	r19, r25
    2368:	11 f4       	brne	.+4      	; 0x236e <xEventGroupSetBits+0xe8>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    236a:	81 e0       	ldi	r24, 0x01	; 1
    236c:	8d 83       	std	Y+5, r24	; 0x05
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    236e:	8d 81       	ldd	r24, Y+5	; 0x05
    2370:	88 23       	and	r24, r24
    2372:	d1 f0       	breq	.+52     	; 0x23a8 <xEventGroupSetBits+0x122>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2374:	88 89       	ldd	r24, Y+16	; 0x10
    2376:	99 89       	ldd	r25, Y+17	; 0x11
    2378:	88 27       	eor	r24, r24
    237a:	91 70       	andi	r25, 0x01	; 1
    237c:	89 2b       	or	r24, r25
    237e:	41 f0       	breq	.+16     	; 0x2390 <xEventGroupSetBits+0x10a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    2380:	2b 81       	ldd	r18, Y+3	; 0x03
    2382:	3c 81       	ldd	r19, Y+4	; 0x04
    2384:	8e 85       	ldd	r24, Y+14	; 0x0e
    2386:	9f 85       	ldd	r25, Y+15	; 0x0f
    2388:	82 2b       	or	r24, r18
    238a:	93 2b       	or	r25, r19
    238c:	9c 83       	std	Y+4, r25	; 0x04
    238e:	8b 83       	std	Y+3, r24	; 0x03
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2390:	8e 81       	ldd	r24, Y+6	; 0x06
    2392:	9f 81       	ldd	r25, Y+7	; 0x07
    2394:	fc 01       	movw	r30, r24
    2396:	80 81       	ld	r24, Z
    2398:	91 81       	ldd	r25, Z+1	; 0x01
    239a:	9c 01       	movw	r18, r24
    239c:	32 60       	ori	r19, 0x02	; 2
    239e:	89 81       	ldd	r24, Y+1	; 0x01
    23a0:	9a 81       	ldd	r25, Y+2	; 0x02
    23a2:	b9 01       	movw	r22, r18
    23a4:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    23a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    23aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    23ac:	9a 83       	std	Y+2, r25	; 0x02
    23ae:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    23b0:	29 81       	ldd	r18, Y+1	; 0x01
    23b2:	3a 81       	ldd	r19, Y+2	; 0x02
    23b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    23b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    23b8:	28 17       	cp	r18, r24
    23ba:	39 07       	cpc	r19, r25
    23bc:	09 f0       	breq	.+2      	; 0x23c0 <xEventGroupSetBits+0x13a>
    23be:	9a cf       	rjmp	.-204    	; 0x22f4 <xEventGroupSetBits+0x6e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    23c0:	8e 81       	ldd	r24, Y+6	; 0x06
    23c2:	9f 81       	ldd	r25, Y+7	; 0x07
    23c4:	fc 01       	movw	r30, r24
    23c6:	20 81       	ld	r18, Z
    23c8:	31 81       	ldd	r19, Z+1	; 0x01
    23ca:	8b 81       	ldd	r24, Y+3	; 0x03
    23cc:	9c 81       	ldd	r25, Y+4	; 0x04
    23ce:	80 95       	com	r24
    23d0:	90 95       	com	r25
    23d2:	28 23       	and	r18, r24
    23d4:	39 23       	and	r19, r25
    23d6:	8e 81       	ldd	r24, Y+6	; 0x06
    23d8:	9f 81       	ldd	r25, Y+7	; 0x07
    23da:	fc 01       	movw	r30, r24
    23dc:	31 83       	std	Z+1, r19	; 0x01
    23de:	20 83       	st	Z, r18
	}
	( void ) xTaskResumeAll();
    23e0:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    23e4:	8e 81       	ldd	r24, Y+6	; 0x06
    23e6:	9f 81       	ldd	r25, Y+7	; 0x07
    23e8:	fc 01       	movw	r30, r24
    23ea:	80 81       	ld	r24, Z
    23ec:	91 81       	ldd	r25, Z+1	; 0x01
}
    23ee:	65 96       	adiw	r28, 0x15	; 21
    23f0:	0f b6       	in	r0, 0x3f	; 63
    23f2:	f8 94       	cli
    23f4:	de bf       	out	0x3e, r29	; 62
    23f6:	0f be       	out	0x3f, r0	; 63
    23f8:	cd bf       	out	0x3d, r28	; 61
    23fa:	df 91       	pop	r29
    23fc:	cf 91       	pop	r28
    23fe:	08 95       	ret

00002400 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2400:	cf 93       	push	r28
    2402:	df 93       	push	r29
    2404:	00 d0       	rcall	.+0      	; 0x2406 <vEventGroupDelete+0x6>
    2406:	00 d0       	rcall	.+0      	; 0x2408 <vEventGroupDelete+0x8>
    2408:	00 d0       	rcall	.+0      	; 0x240a <vEventGroupDelete+0xa>
    240a:	cd b7       	in	r28, 0x3d	; 61
    240c:	de b7       	in	r29, 0x3e	; 62
    240e:	9e 83       	std	Y+6, r25	; 0x06
    2410:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    2412:	8d 81       	ldd	r24, Y+5	; 0x05
    2414:	9e 81       	ldd	r25, Y+6	; 0x06
    2416:	9a 83       	std	Y+2, r25	; 0x02
    2418:	89 83       	std	Y+1, r24	; 0x01
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    241a:	89 81       	ldd	r24, Y+1	; 0x01
    241c:	9a 81       	ldd	r25, Y+2	; 0x02
    241e:	02 96       	adiw	r24, 0x02	; 2
    2420:	9c 83       	std	Y+4, r25	; 0x04
    2422:	8b 83       	std	Y+3, r24	; 0x03

	vTaskSuspendAll();
    2424:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2428:	09 c0       	rjmp	.+18     	; 0x243c <vEventGroupDelete+0x3c>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    242a:	8b 81       	ldd	r24, Y+3	; 0x03
    242c:	9c 81       	ldd	r25, Y+4	; 0x04
    242e:	fc 01       	movw	r30, r24
    2430:	85 81       	ldd	r24, Z+5	; 0x05
    2432:	96 81       	ldd	r25, Z+6	; 0x06
    2434:	60 e0       	ldi	r22, 0x00	; 0
    2436:	72 e0       	ldi	r23, 0x02	; 2
    2438:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    243c:	8b 81       	ldd	r24, Y+3	; 0x03
    243e:	9c 81       	ldd	r25, Y+4	; 0x04
    2440:	fc 01       	movw	r30, r24
    2442:	80 81       	ld	r24, Z
    2444:	88 23       	and	r24, r24
    2446:	89 f7       	brne	.-30     	; 0x242a <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	9a 81       	ldd	r25, Y+2	; 0x02
    244c:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    2450:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
}
    2454:	00 00       	nop
    2456:	26 96       	adiw	r28, 0x06	; 6
    2458:	0f b6       	in	r0, 0x3f	; 63
    245a:	f8 94       	cli
    245c:	de bf       	out	0x3e, r29	; 62
    245e:	0f be       	out	0x3f, r0	; 63
    2460:	cd bf       	out	0x3d, r28	; 61
    2462:	df 91       	pop	r29
    2464:	cf 91       	pop	r28
    2466:	08 95       	ret

00002468 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    2468:	cf 93       	push	r28
    246a:	df 93       	push	r29
    246c:	00 d0       	rcall	.+0      	; 0x246e <vEventGroupSetBitsCallback+0x6>
    246e:	00 d0       	rcall	.+0      	; 0x2470 <vEventGroupSetBitsCallback+0x8>
    2470:	00 d0       	rcall	.+0      	; 0x2472 <vEventGroupSetBitsCallback+0xa>
    2472:	cd b7       	in	r28, 0x3d	; 61
    2474:	de b7       	in	r29, 0x3e	; 62
    2476:	9a 83       	std	Y+2, r25	; 0x02
    2478:	89 83       	std	Y+1, r24	; 0x01
    247a:	4b 83       	std	Y+3, r20	; 0x03
    247c:	5c 83       	std	Y+4, r21	; 0x04
    247e:	6d 83       	std	Y+5, r22	; 0x05
    2480:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2482:	2b 81       	ldd	r18, Y+3	; 0x03
    2484:	3c 81       	ldd	r19, Y+4	; 0x04
    2486:	89 81       	ldd	r24, Y+1	; 0x01
    2488:	9a 81       	ldd	r25, Y+2	; 0x02
    248a:	b9 01       	movw	r22, r18
    248c:	0e 94 43 11 	call	0x2286	; 0x2286 <xEventGroupSetBits>
}
    2490:	00 00       	nop
    2492:	26 96       	adiw	r28, 0x06	; 6
    2494:	0f b6       	in	r0, 0x3f	; 63
    2496:	f8 94       	cli
    2498:	de bf       	out	0x3e, r29	; 62
    249a:	0f be       	out	0x3f, r0	; 63
    249c:	cd bf       	out	0x3d, r28	; 61
    249e:	df 91       	pop	r29
    24a0:	cf 91       	pop	r28
    24a2:	08 95       	ret

000024a4 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    24a4:	cf 93       	push	r28
    24a6:	df 93       	push	r29
    24a8:	00 d0       	rcall	.+0      	; 0x24aa <vEventGroupClearBitsCallback+0x6>
    24aa:	00 d0       	rcall	.+0      	; 0x24ac <vEventGroupClearBitsCallback+0x8>
    24ac:	00 d0       	rcall	.+0      	; 0x24ae <vEventGroupClearBitsCallback+0xa>
    24ae:	cd b7       	in	r28, 0x3d	; 61
    24b0:	de b7       	in	r29, 0x3e	; 62
    24b2:	9a 83       	std	Y+2, r25	; 0x02
    24b4:	89 83       	std	Y+1, r24	; 0x01
    24b6:	4b 83       	std	Y+3, r20	; 0x03
    24b8:	5c 83       	std	Y+4, r21	; 0x04
    24ba:	6d 83       	std	Y+5, r22	; 0x05
    24bc:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    24be:	2b 81       	ldd	r18, Y+3	; 0x03
    24c0:	3c 81       	ldd	r19, Y+4	; 0x04
    24c2:	89 81       	ldd	r24, Y+1	; 0x01
    24c4:	9a 81       	ldd	r25, Y+2	; 0x02
    24c6:	b9 01       	movw	r22, r18
    24c8:	0e 94 e7 10 	call	0x21ce	; 0x21ce <xEventGroupClearBits>
}
    24cc:	00 00       	nop
    24ce:	26 96       	adiw	r28, 0x06	; 6
    24d0:	0f b6       	in	r0, 0x3f	; 63
    24d2:	f8 94       	cli
    24d4:	de bf       	out	0x3e, r29	; 62
    24d6:	0f be       	out	0x3f, r0	; 63
    24d8:	cd bf       	out	0x3d, r28	; 61
    24da:	df 91       	pop	r29
    24dc:	cf 91       	pop	r28
    24de:	08 95       	ret

000024e0 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    24e0:	cf 93       	push	r28
    24e2:	df 93       	push	r29
    24e4:	00 d0       	rcall	.+0      	; 0x24e6 <prvTestWaitCondition+0x6>
    24e6:	00 d0       	rcall	.+0      	; 0x24e8 <prvTestWaitCondition+0x8>
    24e8:	00 d0       	rcall	.+0      	; 0x24ea <prvTestWaitCondition+0xa>
    24ea:	cd b7       	in	r28, 0x3d	; 61
    24ec:	de b7       	in	r29, 0x3e	; 62
    24ee:	9b 83       	std	Y+3, r25	; 0x03
    24f0:	8a 83       	std	Y+2, r24	; 0x02
    24f2:	7d 83       	std	Y+5, r23	; 0x05
    24f4:	6c 83       	std	Y+4, r22	; 0x04
    24f6:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    24f8:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    24fa:	8e 81       	ldd	r24, Y+6	; 0x06
    24fc:	88 23       	and	r24, r24
    24fe:	59 f4       	brne	.+22     	; 0x2516 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2500:	2a 81       	ldd	r18, Y+2	; 0x02
    2502:	3b 81       	ldd	r19, Y+3	; 0x03
    2504:	8c 81       	ldd	r24, Y+4	; 0x04
    2506:	9d 81       	ldd	r25, Y+5	; 0x05
    2508:	82 23       	and	r24, r18
    250a:	93 23       	and	r25, r19
    250c:	89 2b       	or	r24, r25
    250e:	81 f0       	breq	.+32     	; 0x2530 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    2510:	81 e0       	ldi	r24, 0x01	; 1
    2512:	89 83       	std	Y+1, r24	; 0x01
    2514:	0d c0       	rjmp	.+26     	; 0x2530 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2516:	2a 81       	ldd	r18, Y+2	; 0x02
    2518:	3b 81       	ldd	r19, Y+3	; 0x03
    251a:	8c 81       	ldd	r24, Y+4	; 0x04
    251c:	9d 81       	ldd	r25, Y+5	; 0x05
    251e:	28 23       	and	r18, r24
    2520:	39 23       	and	r19, r25
    2522:	8c 81       	ldd	r24, Y+4	; 0x04
    2524:	9d 81       	ldd	r25, Y+5	; 0x05
    2526:	28 17       	cp	r18, r24
    2528:	39 07       	cpc	r19, r25
    252a:	11 f4       	brne	.+4      	; 0x2530 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    252c:	81 e0       	ldi	r24, 0x01	; 1
    252e:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    2530:	89 81       	ldd	r24, Y+1	; 0x01
}
    2532:	26 96       	adiw	r28, 0x06	; 6
    2534:	0f b6       	in	r0, 0x3f	; 63
    2536:	f8 94       	cli
    2538:	de bf       	out	0x3e, r29	; 62
    253a:	0f be       	out	0x3f, r0	; 63
    253c:	cd bf       	out	0x3d, r28	; 61
    253e:	df 91       	pop	r29
    2540:	cf 91       	pop	r28
    2542:	08 95       	ret

00002544 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2544:	cf 93       	push	r28
    2546:	df 93       	push	r29
    2548:	00 d0       	rcall	.+0      	; 0x254a <pvPortMalloc+0x6>
    254a:	00 d0       	rcall	.+0      	; 0x254c <pvPortMalloc+0x8>
    254c:	cd b7       	in	r28, 0x3d	; 61
    254e:	de b7       	in	r29, 0x3e	; 62
    2550:	9c 83       	std	Y+4, r25	; 0x04
    2552:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2554:	1a 82       	std	Y+2, r1	; 0x02
    2556:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2558:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    255c:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pucAlignedHeap.2085>
    2560:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pucAlignedHeap.2085+0x1>
    2564:	89 2b       	or	r24, r25
    2566:	31 f4       	brne	.+12     	; 0x2574 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2568:	80 ec       	ldi	r24, 0xC0	; 192
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <pucAlignedHeap.2085+0x1>
    2570:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2574:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <xNextFreeByte>
    2578:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    257c:	8b 81       	ldd	r24, Y+3	; 0x03
    257e:	9c 81       	ldd	r25, Y+4	; 0x04
    2580:	82 0f       	add	r24, r18
    2582:	93 1f       	adc	r25, r19
    2584:	8b 3d       	cpi	r24, 0xDB	; 219
    2586:	95 40       	sbci	r25, 0x05	; 5
    2588:	38 f5       	brcc	.+78     	; 0x25d8 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    258a:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <xNextFreeByte>
    258e:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    2592:	8b 81       	ldd	r24, Y+3	; 0x03
    2594:	9c 81       	ldd	r25, Y+4	; 0x04
    2596:	28 0f       	add	r18, r24
    2598:	39 1f       	adc	r19, r25
    259a:	80 91 9b 06 	lds	r24, 0x069B	; 0x80069b <xNextFreeByte>
    259e:	90 91 9c 06 	lds	r25, 0x069C	; 0x80069c <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    25a2:	82 17       	cp	r24, r18
    25a4:	93 07       	cpc	r25, r19
    25a6:	c0 f4       	brcc	.+48     	; 0x25d8 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    25a8:	20 91 9d 06 	lds	r18, 0x069D	; 0x80069d <pucAlignedHeap.2085>
    25ac:	30 91 9e 06 	lds	r19, 0x069E	; 0x80069e <pucAlignedHeap.2085+0x1>
    25b0:	80 91 9b 06 	lds	r24, 0x069B	; 0x80069b <xNextFreeByte>
    25b4:	90 91 9c 06 	lds	r25, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    25b8:	82 0f       	add	r24, r18
    25ba:	93 1f       	adc	r25, r19
    25bc:	9a 83       	std	Y+2, r25	; 0x02
    25be:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    25c0:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <xNextFreeByte>
    25c4:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    25c8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ca:	9c 81       	ldd	r25, Y+4	; 0x04
    25cc:	82 0f       	add	r24, r18
    25ce:	93 1f       	adc	r25, r19
    25d0:	90 93 9c 06 	sts	0x069C, r25	; 0x80069c <xNextFreeByte+0x1>
    25d4:	80 93 9b 06 	sts	0x069B, r24	; 0x80069b <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    25d8:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    25dc:	89 81       	ldd	r24, Y+1	; 0x01
    25de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    25e0:	0f 90       	pop	r0
    25e2:	0f 90       	pop	r0
    25e4:	0f 90       	pop	r0
    25e6:	0f 90       	pop	r0
    25e8:	df 91       	pop	r29
    25ea:	cf 91       	pop	r28
    25ec:	08 95       	ret

000025ee <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    25ee:	cf 93       	push	r28
    25f0:	df 93       	push	r29
    25f2:	00 d0       	rcall	.+0      	; 0x25f4 <vPortFree+0x6>
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	9a 83       	std	Y+2, r25	; 0x02
    25fa:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    25fc:	00 00       	nop
    25fe:	0f 90       	pop	r0
    2600:	0f 90       	pop	r0
    2602:	df 91       	pop	r29
    2604:	cf 91       	pop	r28
    2606:	08 95       	ret

00002608 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2608:	cf 93       	push	r28
    260a:	df 93       	push	r29
    260c:	cd b7       	in	r28, 0x3d	; 61
    260e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2610:	10 92 9c 06 	sts	0x069C, r1	; 0x80069c <xNextFreeByte+0x1>
    2614:	10 92 9b 06 	sts	0x069B, r1	; 0x80069b <xNextFreeByte>
}
    2618:	00 00       	nop
    261a:	df 91       	pop	r29
    261c:	cf 91       	pop	r28
    261e:	08 95       	ret

00002620 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2620:	cf 93       	push	r28
    2622:	df 93       	push	r29
    2624:	cd b7       	in	r28, 0x3d	; 61
    2626:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2628:	80 91 9b 06 	lds	r24, 0x069B	; 0x80069b <xNextFreeByte>
    262c:	90 91 9c 06 	lds	r25, 0x069C	; 0x80069c <xNextFreeByte+0x1>
    2630:	2b ed       	ldi	r18, 0xDB	; 219
    2632:	35 e0       	ldi	r19, 0x05	; 5
    2634:	a9 01       	movw	r20, r18
    2636:	48 1b       	sub	r20, r24
    2638:	59 0b       	sbc	r21, r25
    263a:	ca 01       	movw	r24, r20
}
    263c:	df 91       	pop	r29
    263e:	cf 91       	pop	r28
    2640:	08 95       	ret

00002642 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2642:	cf 93       	push	r28
    2644:	df 93       	push	r29
    2646:	00 d0       	rcall	.+0      	; 0x2648 <vListInitialise+0x6>
    2648:	cd b7       	in	r28, 0x3d	; 61
    264a:	de b7       	in	r29, 0x3e	; 62
    264c:	9a 83       	std	Y+2, r25	; 0x02
    264e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2650:	89 81       	ldd	r24, Y+1	; 0x01
    2652:	9a 81       	ldd	r25, Y+2	; 0x02
    2654:	9c 01       	movw	r18, r24
    2656:	2d 5f       	subi	r18, 0xFD	; 253
    2658:	3f 4f       	sbci	r19, 0xFF	; 255
    265a:	89 81       	ldd	r24, Y+1	; 0x01
    265c:	9a 81       	ldd	r25, Y+2	; 0x02
    265e:	fc 01       	movw	r30, r24
    2660:	32 83       	std	Z+2, r19	; 0x02
    2662:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2664:	89 81       	ldd	r24, Y+1	; 0x01
    2666:	9a 81       	ldd	r25, Y+2	; 0x02
    2668:	2f ef       	ldi	r18, 0xFF	; 255
    266a:	3f ef       	ldi	r19, 0xFF	; 255
    266c:	fc 01       	movw	r30, r24
    266e:	34 83       	std	Z+4, r19	; 0x04
    2670:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2672:	89 81       	ldd	r24, Y+1	; 0x01
    2674:	9a 81       	ldd	r25, Y+2	; 0x02
    2676:	9c 01       	movw	r18, r24
    2678:	2d 5f       	subi	r18, 0xFD	; 253
    267a:	3f 4f       	sbci	r19, 0xFF	; 255
    267c:	89 81       	ldd	r24, Y+1	; 0x01
    267e:	9a 81       	ldd	r25, Y+2	; 0x02
    2680:	fc 01       	movw	r30, r24
    2682:	36 83       	std	Z+6, r19	; 0x06
    2684:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	9a 81       	ldd	r25, Y+2	; 0x02
    268a:	9c 01       	movw	r18, r24
    268c:	2d 5f       	subi	r18, 0xFD	; 253
    268e:	3f 4f       	sbci	r19, 0xFF	; 255
    2690:	89 81       	ldd	r24, Y+1	; 0x01
    2692:	9a 81       	ldd	r25, Y+2	; 0x02
    2694:	fc 01       	movw	r30, r24
    2696:	30 87       	std	Z+8, r19	; 0x08
    2698:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    269a:	89 81       	ldd	r24, Y+1	; 0x01
    269c:	9a 81       	ldd	r25, Y+2	; 0x02
    269e:	fc 01       	movw	r30, r24
    26a0:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    26a2:	00 00       	nop
    26a4:	0f 90       	pop	r0
    26a6:	0f 90       	pop	r0
    26a8:	df 91       	pop	r29
    26aa:	cf 91       	pop	r28
    26ac:	08 95       	ret

000026ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    26ae:	cf 93       	push	r28
    26b0:	df 93       	push	r29
    26b2:	00 d0       	rcall	.+0      	; 0x26b4 <vListInitialiseItem+0x6>
    26b4:	cd b7       	in	r28, 0x3d	; 61
    26b6:	de b7       	in	r29, 0x3e	; 62
    26b8:	9a 83       	std	Y+2, r25	; 0x02
    26ba:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	9a 81       	ldd	r25, Y+2	; 0x02
    26c0:	fc 01       	movw	r30, r24
    26c2:	11 86       	std	Z+9, r1	; 0x09
    26c4:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    26c6:	00 00       	nop
    26c8:	0f 90       	pop	r0
    26ca:	0f 90       	pop	r0
    26cc:	df 91       	pop	r29
    26ce:	cf 91       	pop	r28
    26d0:	08 95       	ret

000026d2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    26d2:	cf 93       	push	r28
    26d4:	df 93       	push	r29
    26d6:	00 d0       	rcall	.+0      	; 0x26d8 <vListInsertEnd+0x6>
    26d8:	00 d0       	rcall	.+0      	; 0x26da <vListInsertEnd+0x8>
    26da:	00 d0       	rcall	.+0      	; 0x26dc <vListInsertEnd+0xa>
    26dc:	cd b7       	in	r28, 0x3d	; 61
    26de:	de b7       	in	r29, 0x3e	; 62
    26e0:	9c 83       	std	Y+4, r25	; 0x04
    26e2:	8b 83       	std	Y+3, r24	; 0x03
    26e4:	7e 83       	std	Y+6, r23	; 0x06
    26e6:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    26e8:	8b 81       	ldd	r24, Y+3	; 0x03
    26ea:	9c 81       	ldd	r25, Y+4	; 0x04
    26ec:	fc 01       	movw	r30, r24
    26ee:	81 81       	ldd	r24, Z+1	; 0x01
    26f0:	92 81       	ldd	r25, Z+2	; 0x02
    26f2:	9a 83       	std	Y+2, r25	; 0x02
    26f4:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    26f6:	8d 81       	ldd	r24, Y+5	; 0x05
    26f8:	9e 81       	ldd	r25, Y+6	; 0x06
    26fa:	29 81       	ldd	r18, Y+1	; 0x01
    26fc:	3a 81       	ldd	r19, Y+2	; 0x02
    26fe:	fc 01       	movw	r30, r24
    2700:	33 83       	std	Z+3, r19	; 0x03
    2702:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2704:	89 81       	ldd	r24, Y+1	; 0x01
    2706:	9a 81       	ldd	r25, Y+2	; 0x02
    2708:	fc 01       	movw	r30, r24
    270a:	24 81       	ldd	r18, Z+4	; 0x04
    270c:	35 81       	ldd	r19, Z+5	; 0x05
    270e:	8d 81       	ldd	r24, Y+5	; 0x05
    2710:	9e 81       	ldd	r25, Y+6	; 0x06
    2712:	fc 01       	movw	r30, r24
    2714:	35 83       	std	Z+5, r19	; 0x05
    2716:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2718:	89 81       	ldd	r24, Y+1	; 0x01
    271a:	9a 81       	ldd	r25, Y+2	; 0x02
    271c:	fc 01       	movw	r30, r24
    271e:	84 81       	ldd	r24, Z+4	; 0x04
    2720:	95 81       	ldd	r25, Z+5	; 0x05
    2722:	2d 81       	ldd	r18, Y+5	; 0x05
    2724:	3e 81       	ldd	r19, Y+6	; 0x06
    2726:	fc 01       	movw	r30, r24
    2728:	33 83       	std	Z+3, r19	; 0x03
    272a:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    272c:	89 81       	ldd	r24, Y+1	; 0x01
    272e:	9a 81       	ldd	r25, Y+2	; 0x02
    2730:	2d 81       	ldd	r18, Y+5	; 0x05
    2732:	3e 81       	ldd	r19, Y+6	; 0x06
    2734:	fc 01       	movw	r30, r24
    2736:	35 83       	std	Z+5, r19	; 0x05
    2738:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    273a:	8d 81       	ldd	r24, Y+5	; 0x05
    273c:	9e 81       	ldd	r25, Y+6	; 0x06
    273e:	2b 81       	ldd	r18, Y+3	; 0x03
    2740:	3c 81       	ldd	r19, Y+4	; 0x04
    2742:	fc 01       	movw	r30, r24
    2744:	31 87       	std	Z+9, r19	; 0x09
    2746:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2748:	8b 81       	ldd	r24, Y+3	; 0x03
    274a:	9c 81       	ldd	r25, Y+4	; 0x04
    274c:	fc 01       	movw	r30, r24
    274e:	80 81       	ld	r24, Z
    2750:	21 e0       	ldi	r18, 0x01	; 1
    2752:	28 0f       	add	r18, r24
    2754:	8b 81       	ldd	r24, Y+3	; 0x03
    2756:	9c 81       	ldd	r25, Y+4	; 0x04
    2758:	fc 01       	movw	r30, r24
    275a:	20 83       	st	Z, r18
}
    275c:	00 00       	nop
    275e:	26 96       	adiw	r28, 0x06	; 6
    2760:	0f b6       	in	r0, 0x3f	; 63
    2762:	f8 94       	cli
    2764:	de bf       	out	0x3e, r29	; 62
    2766:	0f be       	out	0x3f, r0	; 63
    2768:	cd bf       	out	0x3d, r28	; 61
    276a:	df 91       	pop	r29
    276c:	cf 91       	pop	r28
    276e:	08 95       	ret

00002770 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2770:	cf 93       	push	r28
    2772:	df 93       	push	r29
    2774:	cd b7       	in	r28, 0x3d	; 61
    2776:	de b7       	in	r29, 0x3e	; 62
    2778:	28 97       	sbiw	r28, 0x08	; 8
    277a:	0f b6       	in	r0, 0x3f	; 63
    277c:	f8 94       	cli
    277e:	de bf       	out	0x3e, r29	; 62
    2780:	0f be       	out	0x3f, r0	; 63
    2782:	cd bf       	out	0x3d, r28	; 61
    2784:	9e 83       	std	Y+6, r25	; 0x06
    2786:	8d 83       	std	Y+5, r24	; 0x05
    2788:	78 87       	std	Y+8, r23	; 0x08
    278a:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    278c:	8f 81       	ldd	r24, Y+7	; 0x07
    278e:	98 85       	ldd	r25, Y+8	; 0x08
    2790:	fc 01       	movw	r30, r24
    2792:	80 81       	ld	r24, Z
    2794:	91 81       	ldd	r25, Z+1	; 0x01
    2796:	9c 83       	std	Y+4, r25	; 0x04
    2798:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	01 96       	adiw	r24, 0x01	; 1
    27a0:	41 f4       	brne	.+16     	; 0x27b2 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    27a2:	8d 81       	ldd	r24, Y+5	; 0x05
    27a4:	9e 81       	ldd	r25, Y+6	; 0x06
    27a6:	fc 01       	movw	r30, r24
    27a8:	87 81       	ldd	r24, Z+7	; 0x07
    27aa:	90 85       	ldd	r25, Z+8	; 0x08
    27ac:	9a 83       	std	Y+2, r25	; 0x02
    27ae:	89 83       	std	Y+1, r24	; 0x01
    27b0:	1a c0       	rjmp	.+52     	; 0x27e6 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    27b2:	8d 81       	ldd	r24, Y+5	; 0x05
    27b4:	9e 81       	ldd	r25, Y+6	; 0x06
    27b6:	03 96       	adiw	r24, 0x03	; 3
    27b8:	9a 83       	std	Y+2, r25	; 0x02
    27ba:	89 83       	std	Y+1, r24	; 0x01
    27bc:	07 c0       	rjmp	.+14     	; 0x27cc <vListInsert+0x5c>
    27be:	89 81       	ldd	r24, Y+1	; 0x01
    27c0:	9a 81       	ldd	r25, Y+2	; 0x02
    27c2:	fc 01       	movw	r30, r24
    27c4:	82 81       	ldd	r24, Z+2	; 0x02
    27c6:	93 81       	ldd	r25, Z+3	; 0x03
    27c8:	9a 83       	std	Y+2, r25	; 0x02
    27ca:	89 83       	std	Y+1, r24	; 0x01
    27cc:	89 81       	ldd	r24, Y+1	; 0x01
    27ce:	9a 81       	ldd	r25, Y+2	; 0x02
    27d0:	fc 01       	movw	r30, r24
    27d2:	82 81       	ldd	r24, Z+2	; 0x02
    27d4:	93 81       	ldd	r25, Z+3	; 0x03
    27d6:	fc 01       	movw	r30, r24
    27d8:	20 81       	ld	r18, Z
    27da:	31 81       	ldd	r19, Z+1	; 0x01
    27dc:	8b 81       	ldd	r24, Y+3	; 0x03
    27de:	9c 81       	ldd	r25, Y+4	; 0x04
    27e0:	82 17       	cp	r24, r18
    27e2:	93 07       	cpc	r25, r19
    27e4:	60 f7       	brcc	.-40     	; 0x27be <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    27e6:	89 81       	ldd	r24, Y+1	; 0x01
    27e8:	9a 81       	ldd	r25, Y+2	; 0x02
    27ea:	fc 01       	movw	r30, r24
    27ec:	22 81       	ldd	r18, Z+2	; 0x02
    27ee:	33 81       	ldd	r19, Z+3	; 0x03
    27f0:	8f 81       	ldd	r24, Y+7	; 0x07
    27f2:	98 85       	ldd	r25, Y+8	; 0x08
    27f4:	fc 01       	movw	r30, r24
    27f6:	33 83       	std	Z+3, r19	; 0x03
    27f8:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    27fa:	8f 81       	ldd	r24, Y+7	; 0x07
    27fc:	98 85       	ldd	r25, Y+8	; 0x08
    27fe:	fc 01       	movw	r30, r24
    2800:	82 81       	ldd	r24, Z+2	; 0x02
    2802:	93 81       	ldd	r25, Z+3	; 0x03
    2804:	2f 81       	ldd	r18, Y+7	; 0x07
    2806:	38 85       	ldd	r19, Y+8	; 0x08
    2808:	fc 01       	movw	r30, r24
    280a:	35 83       	std	Z+5, r19	; 0x05
    280c:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    280e:	8f 81       	ldd	r24, Y+7	; 0x07
    2810:	98 85       	ldd	r25, Y+8	; 0x08
    2812:	29 81       	ldd	r18, Y+1	; 0x01
    2814:	3a 81       	ldd	r19, Y+2	; 0x02
    2816:	fc 01       	movw	r30, r24
    2818:	35 83       	std	Z+5, r19	; 0x05
    281a:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    281c:	89 81       	ldd	r24, Y+1	; 0x01
    281e:	9a 81       	ldd	r25, Y+2	; 0x02
    2820:	2f 81       	ldd	r18, Y+7	; 0x07
    2822:	38 85       	ldd	r19, Y+8	; 0x08
    2824:	fc 01       	movw	r30, r24
    2826:	33 83       	std	Z+3, r19	; 0x03
    2828:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    282a:	8f 81       	ldd	r24, Y+7	; 0x07
    282c:	98 85       	ldd	r25, Y+8	; 0x08
    282e:	2d 81       	ldd	r18, Y+5	; 0x05
    2830:	3e 81       	ldd	r19, Y+6	; 0x06
    2832:	fc 01       	movw	r30, r24
    2834:	31 87       	std	Z+9, r19	; 0x09
    2836:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2838:	8d 81       	ldd	r24, Y+5	; 0x05
    283a:	9e 81       	ldd	r25, Y+6	; 0x06
    283c:	fc 01       	movw	r30, r24
    283e:	80 81       	ld	r24, Z
    2840:	21 e0       	ldi	r18, 0x01	; 1
    2842:	28 0f       	add	r18, r24
    2844:	8d 81       	ldd	r24, Y+5	; 0x05
    2846:	9e 81       	ldd	r25, Y+6	; 0x06
    2848:	fc 01       	movw	r30, r24
    284a:	20 83       	st	Z, r18
}
    284c:	00 00       	nop
    284e:	28 96       	adiw	r28, 0x08	; 8
    2850:	0f b6       	in	r0, 0x3f	; 63
    2852:	f8 94       	cli
    2854:	de bf       	out	0x3e, r29	; 62
    2856:	0f be       	out	0x3f, r0	; 63
    2858:	cd bf       	out	0x3d, r28	; 61
    285a:	df 91       	pop	r29
    285c:	cf 91       	pop	r28
    285e:	08 95       	ret

00002860 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2860:	cf 93       	push	r28
    2862:	df 93       	push	r29
    2864:	00 d0       	rcall	.+0      	; 0x2866 <uxListRemove+0x6>
    2866:	00 d0       	rcall	.+0      	; 0x2868 <uxListRemove+0x8>
    2868:	cd b7       	in	r28, 0x3d	; 61
    286a:	de b7       	in	r29, 0x3e	; 62
    286c:	9c 83       	std	Y+4, r25	; 0x04
    286e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2870:	8b 81       	ldd	r24, Y+3	; 0x03
    2872:	9c 81       	ldd	r25, Y+4	; 0x04
    2874:	fc 01       	movw	r30, r24
    2876:	80 85       	ldd	r24, Z+8	; 0x08
    2878:	91 85       	ldd	r25, Z+9	; 0x09
    287a:	9a 83       	std	Y+2, r25	; 0x02
    287c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    287e:	8b 81       	ldd	r24, Y+3	; 0x03
    2880:	9c 81       	ldd	r25, Y+4	; 0x04
    2882:	fc 01       	movw	r30, r24
    2884:	82 81       	ldd	r24, Z+2	; 0x02
    2886:	93 81       	ldd	r25, Z+3	; 0x03
    2888:	2b 81       	ldd	r18, Y+3	; 0x03
    288a:	3c 81       	ldd	r19, Y+4	; 0x04
    288c:	f9 01       	movw	r30, r18
    288e:	24 81       	ldd	r18, Z+4	; 0x04
    2890:	35 81       	ldd	r19, Z+5	; 0x05
    2892:	fc 01       	movw	r30, r24
    2894:	35 83       	std	Z+5, r19	; 0x05
    2896:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2898:	8b 81       	ldd	r24, Y+3	; 0x03
    289a:	9c 81       	ldd	r25, Y+4	; 0x04
    289c:	fc 01       	movw	r30, r24
    289e:	84 81       	ldd	r24, Z+4	; 0x04
    28a0:	95 81       	ldd	r25, Z+5	; 0x05
    28a2:	2b 81       	ldd	r18, Y+3	; 0x03
    28a4:	3c 81       	ldd	r19, Y+4	; 0x04
    28a6:	f9 01       	movw	r30, r18
    28a8:	22 81       	ldd	r18, Z+2	; 0x02
    28aa:	33 81       	ldd	r19, Z+3	; 0x03
    28ac:	fc 01       	movw	r30, r24
    28ae:	33 83       	std	Z+3, r19	; 0x03
    28b0:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    28b2:	89 81       	ldd	r24, Y+1	; 0x01
    28b4:	9a 81       	ldd	r25, Y+2	; 0x02
    28b6:	fc 01       	movw	r30, r24
    28b8:	21 81       	ldd	r18, Z+1	; 0x01
    28ba:	32 81       	ldd	r19, Z+2	; 0x02
    28bc:	8b 81       	ldd	r24, Y+3	; 0x03
    28be:	9c 81       	ldd	r25, Y+4	; 0x04
    28c0:	28 17       	cp	r18, r24
    28c2:	39 07       	cpc	r19, r25
    28c4:	51 f4       	brne	.+20     	; 0x28da <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	fc 01       	movw	r30, r24
    28cc:	24 81       	ldd	r18, Z+4	; 0x04
    28ce:	35 81       	ldd	r19, Z+5	; 0x05
    28d0:	89 81       	ldd	r24, Y+1	; 0x01
    28d2:	9a 81       	ldd	r25, Y+2	; 0x02
    28d4:	fc 01       	movw	r30, r24
    28d6:	32 83       	std	Z+2, r19	; 0x02
    28d8:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    28da:	8b 81       	ldd	r24, Y+3	; 0x03
    28dc:	9c 81       	ldd	r25, Y+4	; 0x04
    28de:	fc 01       	movw	r30, r24
    28e0:	11 86       	std	Z+9, r1	; 0x09
    28e2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    28e4:	89 81       	ldd	r24, Y+1	; 0x01
    28e6:	9a 81       	ldd	r25, Y+2	; 0x02
    28e8:	fc 01       	movw	r30, r24
    28ea:	80 81       	ld	r24, Z
    28ec:	2f ef       	ldi	r18, 0xFF	; 255
    28ee:	28 0f       	add	r18, r24
    28f0:	89 81       	ldd	r24, Y+1	; 0x01
    28f2:	9a 81       	ldd	r25, Y+2	; 0x02
    28f4:	fc 01       	movw	r30, r24
    28f6:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    28f8:	89 81       	ldd	r24, Y+1	; 0x01
    28fa:	9a 81       	ldd	r25, Y+2	; 0x02
    28fc:	fc 01       	movw	r30, r24
    28fe:	80 81       	ld	r24, Z
}
    2900:	0f 90       	pop	r0
    2902:	0f 90       	pop	r0
    2904:	0f 90       	pop	r0
    2906:	0f 90       	pop	r0
    2908:	df 91       	pop	r29
    290a:	cf 91       	pop	r28
    290c:	08 95       	ret

0000290e <main>:
#include "avr/sleep.h"
#include "KBD_interface.h"


int main(void)
{
    290e:	ef 92       	push	r14
    2910:	ff 92       	push	r15
    2912:	0f 93       	push	r16
    2914:	cf 93       	push	r28
    2916:	df 93       	push	r29
    2918:	cd b7       	in	r28, 0x3d	; 61
    291a:	de b7       	in	r29, 0x3e	; 62
	LCD_initialize();
    291c:	0e 94 fd 07 	call	0xffa	; 0xffa <LCD_initialize>
	LCD_Void_Clear();
    2920:	0e 94 c5 0c 	call	0x198a	; 0x198a <LCD_Void_Clear>
	Clock_Print_Default_Interface();
    2924:	0e 94 49 00 	call	0x92	; 0x92 <Clock_Print_Default_Interface>
	KBD_u8Initialize(GROUP_B);
    2928:	81 e0       	ldi	r24, 0x01	; 1
    292a:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <KBD_u8Initialize>
	xTaskCreate(Clock_Second,"seconds",150,NULL,1,NULL);
    292e:	e1 2c       	mov	r14, r1
    2930:	f1 2c       	mov	r15, r1
    2932:	01 e0       	ldi	r16, 0x01	; 1
    2934:	20 e0       	ldi	r18, 0x00	; 0
    2936:	30 e0       	ldi	r19, 0x00	; 0
    2938:	46 e9       	ldi	r20, 0x96	; 150
    293a:	50 e0       	ldi	r21, 0x00	; 0
    293c:	62 e8       	ldi	r22, 0x82	; 130
    293e:	70 e0       	ldi	r23, 0x00	; 0
    2940:	8c e6       	ldi	r24, 0x6C	; 108
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	0e 94 32 20 	call	0x4064	; 0x4064 <xTaskCreate>
	xTaskCreate(Clock_Minute,"minutes",150,NULL,1,NULL);
    2948:	e1 2c       	mov	r14, r1
    294a:	f1 2c       	mov	r15, r1
    294c:	01 e0       	ldi	r16, 0x01	; 1
    294e:	20 e0       	ldi	r18, 0x00	; 0
    2950:	30 e0       	ldi	r19, 0x00	; 0
    2952:	46 e9       	ldi	r20, 0x96	; 150
    2954:	50 e0       	ldi	r21, 0x00	; 0
    2956:	6a e8       	ldi	r22, 0x8A	; 138
    2958:	70 e0       	ldi	r23, 0x00	; 0
    295a:	8f eb       	ldi	r24, 0xBF	; 191
    295c:	90 e0       	ldi	r25, 0x00	; 0
    295e:	0e 94 32 20 	call	0x4064	; 0x4064 <xTaskCreate>
	xTaskCreate(Clock_Hours,"hours",150,NULL,1,NULL);
    2962:	e1 2c       	mov	r14, r1
    2964:	f1 2c       	mov	r15, r1
    2966:	01 e0       	ldi	r16, 0x01	; 1
    2968:	20 e0       	ldi	r18, 0x00	; 0
    296a:	30 e0       	ldi	r19, 0x00	; 0
    296c:	46 e9       	ldi	r20, 0x96	; 150
    296e:	50 e0       	ldi	r21, 0x00	; 0
    2970:	62 e9       	ldi	r22, 0x92	; 146
    2972:	70 e0       	ldi	r23, 0x00	; 0
    2974:	8b e0       	ldi	r24, 0x0B	; 11
    2976:	91 e0       	ldi	r25, 0x01	; 1
    2978:	0e 94 32 20 	call	0x4064	; 0x4064 <xTaskCreate>
	xTaskCreate(Clock_Check_KPD,"KPD_check",150,NULL,2,NULL);
    297c:	e1 2c       	mov	r14, r1
    297e:	f1 2c       	mov	r15, r1
    2980:	02 e0       	ldi	r16, 0x02	; 2
    2982:	20 e0       	ldi	r18, 0x00	; 0
    2984:	30 e0       	ldi	r19, 0x00	; 0
    2986:	46 e9       	ldi	r20, 0x96	; 150
    2988:	50 e0       	ldi	r21, 0x00	; 0
    298a:	68 e9       	ldi	r22, 0x98	; 152
    298c:	70 e0       	ldi	r23, 0x00	; 0
    298e:	87 e6       	ldi	r24, 0x67	; 103
    2990:	91 e0       	ldi	r25, 0x01	; 1
    2992:	0e 94 32 20 	call	0x4064	; 0x4064 <xTaskCreate>
	xTaskCreate(Clock_Enter_Typing_Mode,"Enter typing mode",300,NULL,2,NULL);
    2996:	e1 2c       	mov	r14, r1
    2998:	f1 2c       	mov	r15, r1
    299a:	02 e0       	ldi	r16, 0x02	; 2
    299c:	20 e0       	ldi	r18, 0x00	; 0
    299e:	30 e0       	ldi	r19, 0x00	; 0
    29a0:	4c e2       	ldi	r20, 0x2C	; 44
    29a2:	51 e0       	ldi	r21, 0x01	; 1
    29a4:	62 ea       	ldi	r22, 0xA2	; 162
    29a6:	70 e0       	ldi	r23, 0x00	; 0
    29a8:	8e e9       	ldi	r24, 0x9E	; 158
    29aa:	91 e0       	ldi	r25, 0x01	; 1
    29ac:	0e 94 32 20 	call	0x4064	; 0x4064 <xTaskCreate>
	vTaskStartScheduler();
    29b0:	0e 94 73 24 	call	0x48e6	; 0x48e6 <vTaskStartScheduler>

	while(1)
	{

	}
    29b4:	ff cf       	rjmp	.-2      	; 0x29b4 <main+0xa6>

000029b6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    29b6:	cf 93       	push	r28
    29b8:	df 93       	push	r29
    29ba:	cd b7       	in	r28, 0x3d	; 61
    29bc:	de b7       	in	r29, 0x3e	; 62
    29be:	28 97       	sbiw	r28, 0x08	; 8
    29c0:	0f b6       	in	r0, 0x3f	; 63
    29c2:	f8 94       	cli
    29c4:	de bf       	out	0x3e, r29	; 62
    29c6:	0f be       	out	0x3f, r0	; 63
    29c8:	cd bf       	out	0x3d, r28	; 61
    29ca:	9c 83       	std	Y+4, r25	; 0x04
    29cc:	8b 83       	std	Y+3, r24	; 0x03
    29ce:	7e 83       	std	Y+6, r23	; 0x06
    29d0:	6d 83       	std	Y+5, r22	; 0x05
    29d2:	58 87       	std	Y+8, r21	; 0x08
    29d4:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    29d6:	8b 81       	ldd	r24, Y+3	; 0x03
    29d8:	9c 81       	ldd	r25, Y+4	; 0x04
    29da:	21 e1       	ldi	r18, 0x11	; 17
    29dc:	fc 01       	movw	r30, r24
    29de:	20 83       	st	Z, r18
	pxTopOfStack--;
    29e0:	8b 81       	ldd	r24, Y+3	; 0x03
    29e2:	9c 81       	ldd	r25, Y+4	; 0x04
    29e4:	01 97       	sbiw	r24, 0x01	; 1
    29e6:	9c 83       	std	Y+4, r25	; 0x04
    29e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    29ea:	8b 81       	ldd	r24, Y+3	; 0x03
    29ec:	9c 81       	ldd	r25, Y+4	; 0x04
    29ee:	22 e2       	ldi	r18, 0x22	; 34
    29f0:	fc 01       	movw	r30, r24
    29f2:	20 83       	st	Z, r18
	pxTopOfStack--;
    29f4:	8b 81       	ldd	r24, Y+3	; 0x03
    29f6:	9c 81       	ldd	r25, Y+4	; 0x04
    29f8:	01 97       	sbiw	r24, 0x01	; 1
    29fa:	9c 83       	std	Y+4, r25	; 0x04
    29fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    29fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2a00:	9c 81       	ldd	r25, Y+4	; 0x04
    2a02:	23 e3       	ldi	r18, 0x33	; 51
    2a04:	fc 01       	movw	r30, r24
    2a06:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a08:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a0c:	01 97       	sbiw	r24, 0x01	; 1
    2a0e:	9c 83       	std	Y+4, r25	; 0x04
    2a10:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2a12:	8d 81       	ldd	r24, Y+5	; 0x05
    2a14:	9e 81       	ldd	r25, Y+6	; 0x06
    2a16:	9a 83       	std	Y+2, r25	; 0x02
    2a18:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2a1a:	29 81       	ldd	r18, Y+1	; 0x01
    2a1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a20:	fc 01       	movw	r30, r24
    2a22:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a24:	8b 81       	ldd	r24, Y+3	; 0x03
    2a26:	9c 81       	ldd	r25, Y+4	; 0x04
    2a28:	01 97       	sbiw	r24, 0x01	; 1
    2a2a:	9c 83       	std	Y+4, r25	; 0x04
    2a2c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2a2e:	89 81       	ldd	r24, Y+1	; 0x01
    2a30:	9a 81       	ldd	r25, Y+2	; 0x02
    2a32:	89 2f       	mov	r24, r25
    2a34:	99 27       	eor	r25, r25
    2a36:	9a 83       	std	Y+2, r25	; 0x02
    2a38:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2a3a:	29 81       	ldd	r18, Y+1	; 0x01
    2a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a40:	fc 01       	movw	r30, r24
    2a42:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a44:	8b 81       	ldd	r24, Y+3	; 0x03
    2a46:	9c 81       	ldd	r25, Y+4	; 0x04
    2a48:	01 97       	sbiw	r24, 0x01	; 1
    2a4a:	9c 83       	std	Y+4, r25	; 0x04
    2a4c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a50:	9c 81       	ldd	r25, Y+4	; 0x04
    2a52:	fc 01       	movw	r30, r24
    2a54:	10 82       	st	Z, r1
	pxTopOfStack--;
    2a56:	8b 81       	ldd	r24, Y+3	; 0x03
    2a58:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5a:	01 97       	sbiw	r24, 0x01	; 1
    2a5c:	9c 83       	std	Y+4, r25	; 0x04
    2a5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2a60:	8b 81       	ldd	r24, Y+3	; 0x03
    2a62:	9c 81       	ldd	r25, Y+4	; 0x04
    2a64:	20 e8       	ldi	r18, 0x80	; 128
    2a66:	fc 01       	movw	r30, r24
    2a68:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	01 97       	sbiw	r24, 0x01	; 1
    2a70:	9c 83       	std	Y+4, r25	; 0x04
    2a72:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2a74:	8b 81       	ldd	r24, Y+3	; 0x03
    2a76:	9c 81       	ldd	r25, Y+4	; 0x04
    2a78:	fc 01       	movw	r30, r24
    2a7a:	10 82       	st	Z, r1
	pxTopOfStack--;
    2a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a80:	01 97       	sbiw	r24, 0x01	; 1
    2a82:	9c 83       	std	Y+4, r25	; 0x04
    2a84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2a86:	8b 81       	ldd	r24, Y+3	; 0x03
    2a88:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8a:	22 e0       	ldi	r18, 0x02	; 2
    2a8c:	fc 01       	movw	r30, r24
    2a8e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a90:	8b 81       	ldd	r24, Y+3	; 0x03
    2a92:	9c 81       	ldd	r25, Y+4	; 0x04
    2a94:	01 97       	sbiw	r24, 0x01	; 1
    2a96:	9c 83       	std	Y+4, r25	; 0x04
    2a98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2a9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a9e:	23 e0       	ldi	r18, 0x03	; 3
    2aa0:	fc 01       	movw	r30, r24
    2aa2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa6:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa8:	01 97       	sbiw	r24, 0x01	; 1
    2aaa:	9c 83       	std	Y+4, r25	; 0x04
    2aac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2aae:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab2:	24 e0       	ldi	r18, 0x04	; 4
    2ab4:	fc 01       	movw	r30, r24
    2ab6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aba:	9c 81       	ldd	r25, Y+4	; 0x04
    2abc:	01 97       	sbiw	r24, 0x01	; 1
    2abe:	9c 83       	std	Y+4, r25	; 0x04
    2ac0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac6:	25 e0       	ldi	r18, 0x05	; 5
    2ac8:	fc 01       	movw	r30, r24
    2aca:	20 83       	st	Z, r18
	pxTopOfStack--;
    2acc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ace:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad0:	01 97       	sbiw	r24, 0x01	; 1
    2ad2:	9c 83       	std	Y+4, r25	; 0x04
    2ad4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad8:	9c 81       	ldd	r25, Y+4	; 0x04
    2ada:	26 e0       	ldi	r18, 0x06	; 6
    2adc:	fc 01       	movw	r30, r24
    2ade:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae4:	01 97       	sbiw	r24, 0x01	; 1
    2ae6:	9c 83       	std	Y+4, r25	; 0x04
    2ae8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2aea:	8b 81       	ldd	r24, Y+3	; 0x03
    2aec:	9c 81       	ldd	r25, Y+4	; 0x04
    2aee:	27 e0       	ldi	r18, 0x07	; 7
    2af0:	fc 01       	movw	r30, r24
    2af2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2af4:	8b 81       	ldd	r24, Y+3	; 0x03
    2af6:	9c 81       	ldd	r25, Y+4	; 0x04
    2af8:	01 97       	sbiw	r24, 0x01	; 1
    2afa:	9c 83       	std	Y+4, r25	; 0x04
    2afc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2afe:	8b 81       	ldd	r24, Y+3	; 0x03
    2b00:	9c 81       	ldd	r25, Y+4	; 0x04
    2b02:	28 e0       	ldi	r18, 0x08	; 8
    2b04:	fc 01       	movw	r30, r24
    2b06:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b08:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0c:	01 97       	sbiw	r24, 0x01	; 1
    2b0e:	9c 83       	std	Y+4, r25	; 0x04
    2b10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2b12:	8b 81       	ldd	r24, Y+3	; 0x03
    2b14:	9c 81       	ldd	r25, Y+4	; 0x04
    2b16:	29 e0       	ldi	r18, 0x09	; 9
    2b18:	fc 01       	movw	r30, r24
    2b1a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b20:	01 97       	sbiw	r24, 0x01	; 1
    2b22:	9c 83       	std	Y+4, r25	; 0x04
    2b24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2b26:	8b 81       	ldd	r24, Y+3	; 0x03
    2b28:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2a:	20 e1       	ldi	r18, 0x10	; 16
    2b2c:	fc 01       	movw	r30, r24
    2b2e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b30:	8b 81       	ldd	r24, Y+3	; 0x03
    2b32:	9c 81       	ldd	r25, Y+4	; 0x04
    2b34:	01 97       	sbiw	r24, 0x01	; 1
    2b36:	9c 83       	std	Y+4, r25	; 0x04
    2b38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b3e:	21 e1       	ldi	r18, 0x11	; 17
    2b40:	fc 01       	movw	r30, r24
    2b42:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b44:	8b 81       	ldd	r24, Y+3	; 0x03
    2b46:	9c 81       	ldd	r25, Y+4	; 0x04
    2b48:	01 97       	sbiw	r24, 0x01	; 1
    2b4a:	9c 83       	std	Y+4, r25	; 0x04
    2b4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b50:	9c 81       	ldd	r25, Y+4	; 0x04
    2b52:	22 e1       	ldi	r18, 0x12	; 18
    2b54:	fc 01       	movw	r30, r24
    2b56:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b58:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5c:	01 97       	sbiw	r24, 0x01	; 1
    2b5e:	9c 83       	std	Y+4, r25	; 0x04
    2b60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2b62:	8b 81       	ldd	r24, Y+3	; 0x03
    2b64:	9c 81       	ldd	r25, Y+4	; 0x04
    2b66:	23 e1       	ldi	r18, 0x13	; 19
    2b68:	fc 01       	movw	r30, r24
    2b6a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b70:	01 97       	sbiw	r24, 0x01	; 1
    2b72:	9c 83       	std	Y+4, r25	; 0x04
    2b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2b76:	8b 81       	ldd	r24, Y+3	; 0x03
    2b78:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7a:	24 e1       	ldi	r18, 0x14	; 20
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b80:	8b 81       	ldd	r24, Y+3	; 0x03
    2b82:	9c 81       	ldd	r25, Y+4	; 0x04
    2b84:	01 97       	sbiw	r24, 0x01	; 1
    2b86:	9c 83       	std	Y+4, r25	; 0x04
    2b88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8e:	25 e1       	ldi	r18, 0x15	; 21
    2b90:	fc 01       	movw	r30, r24
    2b92:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b94:	8b 81       	ldd	r24, Y+3	; 0x03
    2b96:	9c 81       	ldd	r25, Y+4	; 0x04
    2b98:	01 97       	sbiw	r24, 0x01	; 1
    2b9a:	9c 83       	std	Y+4, r25	; 0x04
    2b9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2b9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba2:	26 e1       	ldi	r18, 0x16	; 22
    2ba4:	fc 01       	movw	r30, r24
    2ba6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ba8:	8b 81       	ldd	r24, Y+3	; 0x03
    2baa:	9c 81       	ldd	r25, Y+4	; 0x04
    2bac:	01 97       	sbiw	r24, 0x01	; 1
    2bae:	9c 83       	std	Y+4, r25	; 0x04
    2bb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb6:	27 e1       	ldi	r18, 0x17	; 23
    2bb8:	fc 01       	movw	r30, r24
    2bba:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc0:	01 97       	sbiw	r24, 0x01	; 1
    2bc2:	9c 83       	std	Y+4, r25	; 0x04
    2bc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2bc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bca:	28 e1       	ldi	r18, 0x18	; 24
    2bcc:	fc 01       	movw	r30, r24
    2bce:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    2bd4:	01 97       	sbiw	r24, 0x01	; 1
    2bd6:	9c 83       	std	Y+4, r25	; 0x04
    2bd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2bda:	8b 81       	ldd	r24, Y+3	; 0x03
    2bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bde:	29 e1       	ldi	r18, 0x19	; 25
    2be0:	fc 01       	movw	r30, r24
    2be2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2be4:	8b 81       	ldd	r24, Y+3	; 0x03
    2be6:	9c 81       	ldd	r25, Y+4	; 0x04
    2be8:	01 97       	sbiw	r24, 0x01	; 1
    2bea:	9c 83       	std	Y+4, r25	; 0x04
    2bec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2bee:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf2:	20 e2       	ldi	r18, 0x20	; 32
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfc:	01 97       	sbiw	r24, 0x01	; 1
    2bfe:	9c 83       	std	Y+4, r25	; 0x04
    2c00:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2c02:	8b 81       	ldd	r24, Y+3	; 0x03
    2c04:	9c 81       	ldd	r25, Y+4	; 0x04
    2c06:	21 e2       	ldi	r18, 0x21	; 33
    2c08:	fc 01       	movw	r30, r24
    2c0a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c10:	01 97       	sbiw	r24, 0x01	; 1
    2c12:	9c 83       	std	Y+4, r25	; 0x04
    2c14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2c16:	8b 81       	ldd	r24, Y+3	; 0x03
    2c18:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1a:	22 e2       	ldi	r18, 0x22	; 34
    2c1c:	fc 01       	movw	r30, r24
    2c1e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c20:	8b 81       	ldd	r24, Y+3	; 0x03
    2c22:	9c 81       	ldd	r25, Y+4	; 0x04
    2c24:	01 97       	sbiw	r24, 0x01	; 1
    2c26:	9c 83       	std	Y+4, r25	; 0x04
    2c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2e:	23 e2       	ldi	r18, 0x23	; 35
    2c30:	fc 01       	movw	r30, r24
    2c32:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c34:	8b 81       	ldd	r24, Y+3	; 0x03
    2c36:	9c 81       	ldd	r25, Y+4	; 0x04
    2c38:	01 97       	sbiw	r24, 0x01	; 1
    2c3a:	9c 83       	std	Y+4, r25	; 0x04
    2c3c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2c3e:	8f 81       	ldd	r24, Y+7	; 0x07
    2c40:	98 85       	ldd	r25, Y+8	; 0x08
    2c42:	9a 83       	std	Y+2, r25	; 0x02
    2c44:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c46:	29 81       	ldd	r18, Y+1	; 0x01
    2c48:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4c:	fc 01       	movw	r30, r24
    2c4e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c50:	8b 81       	ldd	r24, Y+3	; 0x03
    2c52:	9c 81       	ldd	r25, Y+4	; 0x04
    2c54:	01 97       	sbiw	r24, 0x01	; 1
    2c56:	9c 83       	std	Y+4, r25	; 0x04
    2c58:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2c5a:	89 81       	ldd	r24, Y+1	; 0x01
    2c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5e:	89 2f       	mov	r24, r25
    2c60:	99 27       	eor	r25, r25
    2c62:	9a 83       	std	Y+2, r25	; 0x02
    2c64:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c66:	29 81       	ldd	r18, Y+1	; 0x01
    2c68:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c6c:	fc 01       	movw	r30, r24
    2c6e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c70:	8b 81       	ldd	r24, Y+3	; 0x03
    2c72:	9c 81       	ldd	r25, Y+4	; 0x04
    2c74:	01 97       	sbiw	r24, 0x01	; 1
    2c76:	9c 83       	std	Y+4, r25	; 0x04
    2c78:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c7e:	26 e2       	ldi	r18, 0x26	; 38
    2c80:	fc 01       	movw	r30, r24
    2c82:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c84:	8b 81       	ldd	r24, Y+3	; 0x03
    2c86:	9c 81       	ldd	r25, Y+4	; 0x04
    2c88:	01 97       	sbiw	r24, 0x01	; 1
    2c8a:	9c 83       	std	Y+4, r25	; 0x04
    2c8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c90:	9c 81       	ldd	r25, Y+4	; 0x04
    2c92:	27 e2       	ldi	r18, 0x27	; 39
    2c94:	fc 01       	movw	r30, r24
    2c96:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c98:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9c:	01 97       	sbiw	r24, 0x01	; 1
    2c9e:	9c 83       	std	Y+4, r25	; 0x04
    2ca0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca6:	28 e2       	ldi	r18, 0x28	; 40
    2ca8:	fc 01       	movw	r30, r24
    2caa:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cac:	8b 81       	ldd	r24, Y+3	; 0x03
    2cae:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb0:	01 97       	sbiw	r24, 0x01	; 1
    2cb2:	9c 83       	std	Y+4, r25	; 0x04
    2cb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cba:	29 e2       	ldi	r18, 0x29	; 41
    2cbc:	fc 01       	movw	r30, r24
    2cbe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc4:	01 97       	sbiw	r24, 0x01	; 1
    2cc6:	9c 83       	std	Y+4, r25	; 0x04
    2cc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2cca:	8b 81       	ldd	r24, Y+3	; 0x03
    2ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    2cce:	20 e3       	ldi	r18, 0x30	; 48
    2cd0:	fc 01       	movw	r30, r24
    2cd2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd8:	01 97       	sbiw	r24, 0x01	; 1
    2cda:	9c 83       	std	Y+4, r25	; 0x04
    2cdc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2cde:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce2:	21 e3       	ldi	r18, 0x31	; 49
    2ce4:	fc 01       	movw	r30, r24
    2ce6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cea:	9c 81       	ldd	r25, Y+4	; 0x04
    2cec:	01 97       	sbiw	r24, 0x01	; 1
    2cee:	9c 83       	std	Y+4, r25	; 0x04
    2cf0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2cf6:	28 96       	adiw	r28, 0x08	; 8
    2cf8:	0f b6       	in	r0, 0x3f	; 63
    2cfa:	f8 94       	cli
    2cfc:	de bf       	out	0x3e, r29	; 62
    2cfe:	0f be       	out	0x3f, r0	; 63
    2d00:	cd bf       	out	0x3d, r28	; 61
    2d02:	df 91       	pop	r29
    2d04:	cf 91       	pop	r28
    2d06:	08 95       	ret

00002d08 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2d08:	cf 93       	push	r28
    2d0a:	df 93       	push	r29
    2d0c:	cd b7       	in	r28, 0x3d	; 61
    2d0e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2d10:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2d14:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2d18:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2d1c:	cd 91       	ld	r28, X+
    2d1e:	cd bf       	out	0x3d, r28	; 61
    2d20:	dd 91       	ld	r29, X+
    2d22:	de bf       	out	0x3e, r29	; 62
    2d24:	ff 91       	pop	r31
    2d26:	ef 91       	pop	r30
    2d28:	df 91       	pop	r29
    2d2a:	cf 91       	pop	r28
    2d2c:	bf 91       	pop	r27
    2d2e:	af 91       	pop	r26
    2d30:	9f 91       	pop	r25
    2d32:	8f 91       	pop	r24
    2d34:	7f 91       	pop	r23
    2d36:	6f 91       	pop	r22
    2d38:	5f 91       	pop	r21
    2d3a:	4f 91       	pop	r20
    2d3c:	3f 91       	pop	r19
    2d3e:	2f 91       	pop	r18
    2d40:	1f 91       	pop	r17
    2d42:	0f 91       	pop	r16
    2d44:	ff 90       	pop	r15
    2d46:	ef 90       	pop	r14
    2d48:	df 90       	pop	r13
    2d4a:	cf 90       	pop	r12
    2d4c:	bf 90       	pop	r11
    2d4e:	af 90       	pop	r10
    2d50:	9f 90       	pop	r9
    2d52:	8f 90       	pop	r8
    2d54:	7f 90       	pop	r7
    2d56:	6f 90       	pop	r6
    2d58:	5f 90       	pop	r5
    2d5a:	4f 90       	pop	r4
    2d5c:	3f 90       	pop	r3
    2d5e:	2f 90       	pop	r2
    2d60:	1f 90       	pop	r1
    2d62:	0f 90       	pop	r0
    2d64:	0f be       	out	0x3f, r0	; 63
    2d66:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2d68:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
}
    2d6c:	df 91       	pop	r29
    2d6e:	cf 91       	pop	r28
    2d70:	08 95       	ret

00002d72 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2d72:	cf 93       	push	r28
    2d74:	df 93       	push	r29
    2d76:	cd b7       	in	r28, 0x3d	; 61
    2d78:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2d7a:	00 00       	nop
    2d7c:	df 91       	pop	r29
    2d7e:	cf 91       	pop	r28
    2d80:	08 95       	ret

00002d82 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2d82:	0f 92       	push	r0
    2d84:	0f b6       	in	r0, 0x3f	; 63
    2d86:	f8 94       	cli
    2d88:	0f 92       	push	r0
    2d8a:	1f 92       	push	r1
    2d8c:	11 24       	eor	r1, r1
    2d8e:	2f 92       	push	r2
    2d90:	3f 92       	push	r3
    2d92:	4f 92       	push	r4
    2d94:	5f 92       	push	r5
    2d96:	6f 92       	push	r6
    2d98:	7f 92       	push	r7
    2d9a:	8f 92       	push	r8
    2d9c:	9f 92       	push	r9
    2d9e:	af 92       	push	r10
    2da0:	bf 92       	push	r11
    2da2:	cf 92       	push	r12
    2da4:	df 92       	push	r13
    2da6:	ef 92       	push	r14
    2da8:	ff 92       	push	r15
    2daa:	0f 93       	push	r16
    2dac:	1f 93       	push	r17
    2dae:	2f 93       	push	r18
    2db0:	3f 93       	push	r19
    2db2:	4f 93       	push	r20
    2db4:	5f 93       	push	r21
    2db6:	6f 93       	push	r22
    2db8:	7f 93       	push	r23
    2dba:	8f 93       	push	r24
    2dbc:	9f 93       	push	r25
    2dbe:	af 93       	push	r26
    2dc0:	bf 93       	push	r27
    2dc2:	cf 93       	push	r28
    2dc4:	df 93       	push	r29
    2dc6:	ef 93       	push	r30
    2dc8:	ff 93       	push	r31
    2dca:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2dce:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2dd2:	0d b6       	in	r0, 0x3d	; 61
    2dd4:	0d 92       	st	X+, r0
    2dd6:	0e b6       	in	r0, 0x3e	; 62
    2dd8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2dda:	0e 94 9a 26 	call	0x4d34	; 0x4d34 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2dde:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2de2:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2de6:	cd 91       	ld	r28, X+
    2de8:	cd bf       	out	0x3d, r28	; 61
    2dea:	dd 91       	ld	r29, X+
    2dec:	de bf       	out	0x3e, r29	; 62
    2dee:	ff 91       	pop	r31
    2df0:	ef 91       	pop	r30
    2df2:	df 91       	pop	r29
    2df4:	cf 91       	pop	r28
    2df6:	bf 91       	pop	r27
    2df8:	af 91       	pop	r26
    2dfa:	9f 91       	pop	r25
    2dfc:	8f 91       	pop	r24
    2dfe:	7f 91       	pop	r23
    2e00:	6f 91       	pop	r22
    2e02:	5f 91       	pop	r21
    2e04:	4f 91       	pop	r20
    2e06:	3f 91       	pop	r19
    2e08:	2f 91       	pop	r18
    2e0a:	1f 91       	pop	r17
    2e0c:	0f 91       	pop	r16
    2e0e:	ff 90       	pop	r15
    2e10:	ef 90       	pop	r14
    2e12:	df 90       	pop	r13
    2e14:	cf 90       	pop	r12
    2e16:	bf 90       	pop	r11
    2e18:	af 90       	pop	r10
    2e1a:	9f 90       	pop	r9
    2e1c:	8f 90       	pop	r8
    2e1e:	7f 90       	pop	r7
    2e20:	6f 90       	pop	r6
    2e22:	5f 90       	pop	r5
    2e24:	4f 90       	pop	r4
    2e26:	3f 90       	pop	r3
    2e28:	2f 90       	pop	r2
    2e2a:	1f 90       	pop	r1
    2e2c:	0f 90       	pop	r0
    2e2e:	0f be       	out	0x3f, r0	; 63
    2e30:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e32:	08 95       	ret
	...

00002e36 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2e36:	0f 92       	push	r0
    2e38:	0f b6       	in	r0, 0x3f	; 63
    2e3a:	f8 94       	cli
    2e3c:	0f 92       	push	r0
    2e3e:	1f 92       	push	r1
    2e40:	11 24       	eor	r1, r1
    2e42:	2f 92       	push	r2
    2e44:	3f 92       	push	r3
    2e46:	4f 92       	push	r4
    2e48:	5f 92       	push	r5
    2e4a:	6f 92       	push	r6
    2e4c:	7f 92       	push	r7
    2e4e:	8f 92       	push	r8
    2e50:	9f 92       	push	r9
    2e52:	af 92       	push	r10
    2e54:	bf 92       	push	r11
    2e56:	cf 92       	push	r12
    2e58:	df 92       	push	r13
    2e5a:	ef 92       	push	r14
    2e5c:	ff 92       	push	r15
    2e5e:	0f 93       	push	r16
    2e60:	1f 93       	push	r17
    2e62:	2f 93       	push	r18
    2e64:	3f 93       	push	r19
    2e66:	4f 93       	push	r20
    2e68:	5f 93       	push	r21
    2e6a:	6f 93       	push	r22
    2e6c:	7f 93       	push	r23
    2e6e:	8f 93       	push	r24
    2e70:	9f 93       	push	r25
    2e72:	af 93       	push	r26
    2e74:	bf 93       	push	r27
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	ef 93       	push	r30
    2e7c:	ff 93       	push	r31
    2e7e:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2e82:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2e86:	0d b6       	in	r0, 0x3d	; 61
    2e88:	0d 92       	st	X+, r0
    2e8a:	0e b6       	in	r0, 0x3e	; 62
    2e8c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2e8e:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <xTaskIncrementTick>
    2e92:	88 23       	and	r24, r24
    2e94:	11 f0       	breq	.+4      	; 0x2e9a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2e96:	0e 94 9a 26 	call	0x4d34	; 0x4d34 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2e9a:	a0 91 9f 06 	lds	r26, 0x069F	; 0x80069f <pxCurrentTCB>
    2e9e:	b0 91 a0 06 	lds	r27, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    2ea2:	cd 91       	ld	r28, X+
    2ea4:	cd bf       	out	0x3d, r28	; 61
    2ea6:	dd 91       	ld	r29, X+
    2ea8:	de bf       	out	0x3e, r29	; 62
    2eaa:	ff 91       	pop	r31
    2eac:	ef 91       	pop	r30
    2eae:	df 91       	pop	r29
    2eb0:	cf 91       	pop	r28
    2eb2:	bf 91       	pop	r27
    2eb4:	af 91       	pop	r26
    2eb6:	9f 91       	pop	r25
    2eb8:	8f 91       	pop	r24
    2eba:	7f 91       	pop	r23
    2ebc:	6f 91       	pop	r22
    2ebe:	5f 91       	pop	r21
    2ec0:	4f 91       	pop	r20
    2ec2:	3f 91       	pop	r19
    2ec4:	2f 91       	pop	r18
    2ec6:	1f 91       	pop	r17
    2ec8:	0f 91       	pop	r16
    2eca:	ff 90       	pop	r15
    2ecc:	ef 90       	pop	r14
    2ece:	df 90       	pop	r13
    2ed0:	cf 90       	pop	r12
    2ed2:	bf 90       	pop	r11
    2ed4:	af 90       	pop	r10
    2ed6:	9f 90       	pop	r9
    2ed8:	8f 90       	pop	r8
    2eda:	7f 90       	pop	r7
    2edc:	6f 90       	pop	r6
    2ede:	5f 90       	pop	r5
    2ee0:	4f 90       	pop	r4
    2ee2:	3f 90       	pop	r3
    2ee4:	2f 90       	pop	r2
    2ee6:	1f 90       	pop	r1
    2ee8:	0f 90       	pop	r0
    2eea:	0f be       	out	0x3f, r0	; 63
    2eec:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2eee:	08 95       	ret
	...

00002ef2 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2ef2:	cf 93       	push	r28
    2ef4:	df 93       	push	r29
    2ef6:	00 d0       	rcall	.+0      	; 0x2ef8 <prvSetupTimerInterrupt+0x6>
    2ef8:	00 d0       	rcall	.+0      	; 0x2efa <prvSetupTimerInterrupt+0x8>
    2efa:	00 d0       	rcall	.+0      	; 0x2efc <prvSetupTimerInterrupt+0xa>
    2efc:	cd b7       	in	r28, 0x3d	; 61
    2efe:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2f00:	80 e0       	ldi	r24, 0x00	; 0
    2f02:	9a e6       	ldi	r25, 0x6A	; 106
    2f04:	a8 e1       	ldi	r26, 0x18	; 24
    2f06:	b0 e0       	ldi	r27, 0x00	; 0
    2f08:	89 83       	std	Y+1, r24	; 0x01
    2f0a:	9a 83       	std	Y+2, r25	; 0x02
    2f0c:	ab 83       	std	Y+3, r26	; 0x03
    2f0e:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2f10:	89 81       	ldd	r24, Y+1	; 0x01
    2f12:	9a 81       	ldd	r25, Y+2	; 0x02
    2f14:	ab 81       	ldd	r26, Y+3	; 0x03
    2f16:	bc 81       	ldd	r27, Y+4	; 0x04
    2f18:	68 94       	set
    2f1a:	15 f8       	bld	r1, 5
    2f1c:	b6 95       	lsr	r27
    2f1e:	a7 95       	ror	r26
    2f20:	97 95       	ror	r25
    2f22:	87 95       	ror	r24
    2f24:	16 94       	lsr	r1
    2f26:	d1 f7       	brne	.-12     	; 0x2f1c <prvSetupTimerInterrupt+0x2a>
    2f28:	89 83       	std	Y+1, r24	; 0x01
    2f2a:	9a 83       	std	Y+2, r25	; 0x02
    2f2c:	ab 83       	std	Y+3, r26	; 0x03
    2f2e:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2f30:	89 81       	ldd	r24, Y+1	; 0x01
    2f32:	9a 81       	ldd	r25, Y+2	; 0x02
    2f34:	ab 81       	ldd	r26, Y+3	; 0x03
    2f36:	bc 81       	ldd	r27, Y+4	; 0x04
    2f38:	01 97       	sbiw	r24, 0x01	; 1
    2f3a:	a1 09       	sbc	r26, r1
    2f3c:	b1 09       	sbc	r27, r1
    2f3e:	89 83       	std	Y+1, r24	; 0x01
    2f40:	9a 83       	std	Y+2, r25	; 0x02
    2f42:	ab 83       	std	Y+3, r26	; 0x03
    2f44:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2f46:	89 81       	ldd	r24, Y+1	; 0x01
    2f48:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    2f4a:	89 81       	ldd	r24, Y+1	; 0x01
    2f4c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f4e:	ab 81       	ldd	r26, Y+3	; 0x03
    2f50:	bc 81       	ldd	r27, Y+4	; 0x04
    2f52:	89 2f       	mov	r24, r25
    2f54:	9a 2f       	mov	r25, r26
    2f56:	ab 2f       	mov	r26, r27
    2f58:	bb 27       	eor	r27, r27
    2f5a:	89 83       	std	Y+1, r24	; 0x01
    2f5c:	9a 83       	std	Y+2, r25	; 0x02
    2f5e:	ab 83       	std	Y+3, r26	; 0x03
    2f60:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2f62:	89 81       	ldd	r24, Y+1	; 0x01
    2f64:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    2f66:	8b e4       	ldi	r24, 0x4B	; 75
    2f68:	90 e0       	ldi	r25, 0x00	; 0
    2f6a:	2e 81       	ldd	r18, Y+6	; 0x06
    2f6c:	fc 01       	movw	r30, r24
    2f6e:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    2f70:	8a e4       	ldi	r24, 0x4A	; 74
    2f72:	90 e0       	ldi	r25, 0x00	; 0
    2f74:	2d 81       	ldd	r18, Y+5	; 0x05
    2f76:	fc 01       	movw	r30, r24
    2f78:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2f7a:	8b e0       	ldi	r24, 0x0B	; 11
    2f7c:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    2f7e:	8e e4       	ldi	r24, 0x4E	; 78
    2f80:	90 e0       	ldi	r25, 0x00	; 0
    2f82:	2d 81       	ldd	r18, Y+5	; 0x05
    2f84:	fc 01       	movw	r30, r24
    2f86:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2f88:	89 e5       	ldi	r24, 0x59	; 89
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	80 81       	ld	r24, Z
    2f90:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2f92:	8d 81       	ldd	r24, Y+5	; 0x05
    2f94:	80 61       	ori	r24, 0x10	; 16
    2f96:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK = ucLowByte;
    2f98:	89 e5       	ldi	r24, 0x59	; 89
    2f9a:	90 e0       	ldi	r25, 0x00	; 0
    2f9c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f9e:	fc 01       	movw	r30, r24
    2fa0:	20 83       	st	Z, r18
}
    2fa2:	00 00       	nop
    2fa4:	26 96       	adiw	r28, 0x06	; 6
    2fa6:	0f b6       	in	r0, 0x3f	; 63
    2fa8:	f8 94       	cli
    2faa:	de bf       	out	0x3e, r29	; 62
    2fac:	0f be       	out	0x3f, r0	; 63
    2fae:	cd bf       	out	0x3d, r28	; 61
    2fb0:	df 91       	pop	r29
    2fb2:	cf 91       	pop	r28
    2fb4:	08 95       	ret

00002fb6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void _VECTOR(7)( void ) __attribute__ ( ( signal, naked ) );
	void _VECTOR(7)( void )
	{
		vPortYieldFromTick();
    2fb6:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2fba:	18 95       	reti
	...

00002fbe <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2fbe:	cf 93       	push	r28
    2fc0:	df 93       	push	r29
    2fc2:	00 d0       	rcall	.+0      	; 0x2fc4 <xQueueGenericReset+0x6>
    2fc4:	00 d0       	rcall	.+0      	; 0x2fc6 <xQueueGenericReset+0x8>
    2fc6:	1f 92       	push	r1
    2fc8:	cd b7       	in	r28, 0x3d	; 61
    2fca:	de b7       	in	r29, 0x3e	; 62
    2fcc:	9c 83       	std	Y+4, r25	; 0x04
    2fce:	8b 83       	std	Y+3, r24	; 0x03
    2fd0:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd6:	9a 83       	std	Y+2, r25	; 0x02
    2fd8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2fda:	0f b6       	in	r0, 0x3f	; 63
    2fdc:	f8 94       	cli
    2fde:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2fe0:	89 81       	ldd	r24, Y+1	; 0x01
    2fe2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	80 81       	ld	r24, Z
    2fe8:	91 81       	ldd	r25, Z+1	; 0x01
    2fea:	29 81       	ldd	r18, Y+1	; 0x01
    2fec:	3a 81       	ldd	r19, Y+2	; 0x02
    2fee:	f9 01       	movw	r30, r18
    2ff0:	23 8d       	ldd	r18, Z+27	; 0x1b
    2ff2:	42 2f       	mov	r20, r18
    2ff4:	50 e0       	ldi	r21, 0x00	; 0
    2ff6:	29 81       	ldd	r18, Y+1	; 0x01
    2ff8:	3a 81       	ldd	r19, Y+2	; 0x02
    2ffa:	f9 01       	movw	r30, r18
    2ffc:	24 8d       	ldd	r18, Z+28	; 0x1c
    2ffe:	22 2f       	mov	r18, r18
    3000:	30 e0       	ldi	r19, 0x00	; 0
    3002:	42 9f       	mul	r20, r18
    3004:	b0 01       	movw	r22, r0
    3006:	43 9f       	mul	r20, r19
    3008:	70 0d       	add	r23, r0
    300a:	52 9f       	mul	r21, r18
    300c:	70 0d       	add	r23, r0
    300e:	11 24       	eor	r1, r1
    3010:	9b 01       	movw	r18, r22
    3012:	28 0f       	add	r18, r24
    3014:	39 1f       	adc	r19, r25
    3016:	89 81       	ldd	r24, Y+1	; 0x01
    3018:	9a 81       	ldd	r25, Y+2	; 0x02
    301a:	fc 01       	movw	r30, r24
    301c:	35 83       	std	Z+5, r19	; 0x05
    301e:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3020:	89 81       	ldd	r24, Y+1	; 0x01
    3022:	9a 81       	ldd	r25, Y+2	; 0x02
    3024:	fc 01       	movw	r30, r24
    3026:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3028:	89 81       	ldd	r24, Y+1	; 0x01
    302a:	9a 81       	ldd	r25, Y+2	; 0x02
    302c:	fc 01       	movw	r30, r24
    302e:	20 81       	ld	r18, Z
    3030:	31 81       	ldd	r19, Z+1	; 0x01
    3032:	89 81       	ldd	r24, Y+1	; 0x01
    3034:	9a 81       	ldd	r25, Y+2	; 0x02
    3036:	fc 01       	movw	r30, r24
    3038:	33 83       	std	Z+3, r19	; 0x03
    303a:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    303c:	89 81       	ldd	r24, Y+1	; 0x01
    303e:	9a 81       	ldd	r25, Y+2	; 0x02
    3040:	fc 01       	movw	r30, r24
    3042:	20 81       	ld	r18, Z
    3044:	31 81       	ldd	r19, Z+1	; 0x01
    3046:	89 81       	ldd	r24, Y+1	; 0x01
    3048:	9a 81       	ldd	r25, Y+2	; 0x02
    304a:	fc 01       	movw	r30, r24
    304c:	83 8d       	ldd	r24, Z+27	; 0x1b
    304e:	88 2f       	mov	r24, r24
    3050:	90 e0       	ldi	r25, 0x00	; 0
    3052:	bc 01       	movw	r22, r24
    3054:	61 50       	subi	r22, 0x01	; 1
    3056:	71 09       	sbc	r23, r1
    3058:	89 81       	ldd	r24, Y+1	; 0x01
    305a:	9a 81       	ldd	r25, Y+2	; 0x02
    305c:	fc 01       	movw	r30, r24
    305e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3060:	48 2f       	mov	r20, r24
    3062:	50 e0       	ldi	r21, 0x00	; 0
    3064:	64 9f       	mul	r22, r20
    3066:	c0 01       	movw	r24, r0
    3068:	65 9f       	mul	r22, r21
    306a:	90 0d       	add	r25, r0
    306c:	74 9f       	mul	r23, r20
    306e:	90 0d       	add	r25, r0
    3070:	11 24       	eor	r1, r1
    3072:	28 0f       	add	r18, r24
    3074:	39 1f       	adc	r19, r25
    3076:	89 81       	ldd	r24, Y+1	; 0x01
    3078:	9a 81       	ldd	r25, Y+2	; 0x02
    307a:	fc 01       	movw	r30, r24
    307c:	37 83       	std	Z+7, r19	; 0x07
    307e:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    3080:	89 81       	ldd	r24, Y+1	; 0x01
    3082:	9a 81       	ldd	r25, Y+2	; 0x02
    3084:	2f ef       	ldi	r18, 0xFF	; 255
    3086:	fc 01       	movw	r30, r24
    3088:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    308a:	89 81       	ldd	r24, Y+1	; 0x01
    308c:	9a 81       	ldd	r25, Y+2	; 0x02
    308e:	2f ef       	ldi	r18, 0xFF	; 255
    3090:	fc 01       	movw	r30, r24
    3092:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    3094:	8d 81       	ldd	r24, Y+5	; 0x05
    3096:	88 23       	and	r24, r24
    3098:	81 f4       	brne	.+32     	; 0x30ba <xQueueGenericReset+0xfc>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    309a:	89 81       	ldd	r24, Y+1	; 0x01
    309c:	9a 81       	ldd	r25, Y+2	; 0x02
    309e:	fc 01       	movw	r30, r24
    30a0:	80 85       	ldd	r24, Z+8	; 0x08
    30a2:	88 23       	and	r24, r24
    30a4:	a1 f0       	breq	.+40     	; 0x30ce <xQueueGenericReset+0x110>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30a6:	89 81       	ldd	r24, Y+1	; 0x01
    30a8:	9a 81       	ldd	r25, Y+2	; 0x02
    30aa:	08 96       	adiw	r24, 0x08	; 8
    30ac:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    30b0:	88 23       	and	r24, r24
    30b2:	69 f0       	breq	.+26     	; 0x30ce <xQueueGenericReset+0x110>
				{
					queueYIELD_IF_USING_PREEMPTION();
    30b4:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
    30b8:	0a c0       	rjmp	.+20     	; 0x30ce <xQueueGenericReset+0x110>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    30ba:	89 81       	ldd	r24, Y+1	; 0x01
    30bc:	9a 81       	ldd	r25, Y+2	; 0x02
    30be:	08 96       	adiw	r24, 0x08	; 8
    30c0:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    30c4:	89 81       	ldd	r24, Y+1	; 0x01
    30c6:	9a 81       	ldd	r25, Y+2	; 0x02
    30c8:	41 96       	adiw	r24, 0x11	; 17
    30ca:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    30ce:	0f 90       	pop	r0
    30d0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    30d2:	81 e0       	ldi	r24, 0x01	; 1
}
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	0f 90       	pop	r0
    30dc:	0f 90       	pop	r0
    30de:	df 91       	pop	r29
    30e0:	cf 91       	pop	r28
    30e2:	08 95       	ret

000030e4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    30e4:	0f 93       	push	r16
    30e6:	1f 93       	push	r17
    30e8:	cf 93       	push	r28
    30ea:	df 93       	push	r29
    30ec:	cd b7       	in	r28, 0x3d	; 61
    30ee:	de b7       	in	r29, 0x3e	; 62
    30f0:	29 97       	sbiw	r28, 0x09	; 9
    30f2:	0f b6       	in	r0, 0x3f	; 63
    30f4:	f8 94       	cli
    30f6:	de bf       	out	0x3e, r29	; 62
    30f8:	0f be       	out	0x3f, r0	; 63
    30fa:	cd bf       	out	0x3d, r28	; 61
    30fc:	8f 83       	std	Y+7, r24	; 0x07
    30fe:	68 87       	std	Y+8, r22	; 0x08
    3100:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    3102:	88 85       	ldd	r24, Y+8	; 0x08
    3104:	88 23       	and	r24, r24
    3106:	19 f4       	brne	.+6      	; 0x310e <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    3108:	1a 82       	std	Y+2, r1	; 0x02
    310a:	19 82       	std	Y+1, r1	; 0x01
    310c:	0f c0       	rjmp	.+30     	; 0x312c <xQueueGenericCreate+0x48>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    310e:	8f 81       	ldd	r24, Y+7	; 0x07
    3110:	48 2f       	mov	r20, r24
    3112:	50 e0       	ldi	r21, 0x00	; 0
    3114:	88 85       	ldd	r24, Y+8	; 0x08
    3116:	28 2f       	mov	r18, r24
    3118:	30 e0       	ldi	r19, 0x00	; 0
    311a:	42 9f       	mul	r20, r18
    311c:	c0 01       	movw	r24, r0
    311e:	43 9f       	mul	r20, r19
    3120:	90 0d       	add	r25, r0
    3122:	52 9f       	mul	r21, r18
    3124:	90 0d       	add	r25, r0
    3126:	11 24       	eor	r1, r1
    3128:	9a 83       	std	Y+2, r25	; 0x02
    312a:	89 83       	std	Y+1, r24	; 0x01
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    312c:	89 81       	ldd	r24, Y+1	; 0x01
    312e:	9a 81       	ldd	r25, Y+2	; 0x02
    3130:	4f 96       	adiw	r24, 0x1f	; 31
    3132:	0e 94 a2 12 	call	0x2544	; 0x2544 <pvPortMalloc>
    3136:	9c 83       	std	Y+4, r25	; 0x04
    3138:	8b 83       	std	Y+3, r24	; 0x03

		if( pxNewQueue != NULL )
    313a:	8b 81       	ldd	r24, Y+3	; 0x03
    313c:	9c 81       	ldd	r25, Y+4	; 0x04
    313e:	89 2b       	or	r24, r25
    3140:	a1 f0       	breq	.+40     	; 0x316a <xQueueGenericCreate+0x86>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    3142:	8b 81       	ldd	r24, Y+3	; 0x03
    3144:	9c 81       	ldd	r25, Y+4	; 0x04
    3146:	9e 83       	std	Y+6, r25	; 0x06
    3148:	8d 83       	std	Y+5, r24	; 0x05
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    314a:	8d 81       	ldd	r24, Y+5	; 0x05
    314c:	9e 81       	ldd	r25, Y+6	; 0x06
    314e:	4f 96       	adiw	r24, 0x1f	; 31
    3150:	9e 83       	std	Y+6, r25	; 0x06
    3152:	8d 83       	std	Y+5, r24	; 0x05
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    3154:	2b 81       	ldd	r18, Y+3	; 0x03
    3156:	3c 81       	ldd	r19, Y+4	; 0x04
    3158:	8d 81       	ldd	r24, Y+5	; 0x05
    315a:	9e 81       	ldd	r25, Y+6	; 0x06
    315c:	89 01       	movw	r16, r18
    315e:	29 85       	ldd	r18, Y+9	; 0x09
    3160:	ac 01       	movw	r20, r24
    3162:	68 85       	ldd	r22, Y+8	; 0x08
    3164:	8f 81       	ldd	r24, Y+7	; 0x07
    3166:	0e 94 c2 18 	call	0x3184	; 0x3184 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    316a:	8b 81       	ldd	r24, Y+3	; 0x03
    316c:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    316e:	29 96       	adiw	r28, 0x09	; 9
    3170:	0f b6       	in	r0, 0x3f	; 63
    3172:	f8 94       	cli
    3174:	de bf       	out	0x3e, r29	; 62
    3176:	0f be       	out	0x3f, r0	; 63
    3178:	cd bf       	out	0x3d, r28	; 61
    317a:	df 91       	pop	r29
    317c:	cf 91       	pop	r28
    317e:	1f 91       	pop	r17
    3180:	0f 91       	pop	r16
    3182:	08 95       	ret

00003184 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    3184:	0f 93       	push	r16
    3186:	1f 93       	push	r17
    3188:	cf 93       	push	r28
    318a:	df 93       	push	r29
    318c:	cd b7       	in	r28, 0x3d	; 61
    318e:	de b7       	in	r29, 0x3e	; 62
    3190:	27 97       	sbiw	r28, 0x07	; 7
    3192:	0f b6       	in	r0, 0x3f	; 63
    3194:	f8 94       	cli
    3196:	de bf       	out	0x3e, r29	; 62
    3198:	0f be       	out	0x3f, r0	; 63
    319a:	cd bf       	out	0x3d, r28	; 61
    319c:	89 83       	std	Y+1, r24	; 0x01
    319e:	6a 83       	std	Y+2, r22	; 0x02
    31a0:	5c 83       	std	Y+4, r21	; 0x04
    31a2:	4b 83       	std	Y+3, r20	; 0x03
    31a4:	2d 83       	std	Y+5, r18	; 0x05
    31a6:	1f 83       	std	Y+7, r17	; 0x07
    31a8:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    31aa:	8a 81       	ldd	r24, Y+2	; 0x02
    31ac:	88 23       	and	r24, r24
    31ae:	41 f4       	brne	.+16     	; 0x31c0 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    31b0:	8e 81       	ldd	r24, Y+6	; 0x06
    31b2:	9f 81       	ldd	r25, Y+7	; 0x07
    31b4:	2e 81       	ldd	r18, Y+6	; 0x06
    31b6:	3f 81       	ldd	r19, Y+7	; 0x07
    31b8:	fc 01       	movw	r30, r24
    31ba:	31 83       	std	Z+1, r19	; 0x01
    31bc:	20 83       	st	Z, r18
    31be:	07 c0       	rjmp	.+14     	; 0x31ce <prvInitialiseNewQueue+0x4a>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    31c0:	8e 81       	ldd	r24, Y+6	; 0x06
    31c2:	9f 81       	ldd	r25, Y+7	; 0x07
    31c4:	2b 81       	ldd	r18, Y+3	; 0x03
    31c6:	3c 81       	ldd	r19, Y+4	; 0x04
    31c8:	fc 01       	movw	r30, r24
    31ca:	31 83       	std	Z+1, r19	; 0x01
    31cc:	20 83       	st	Z, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    31ce:	8e 81       	ldd	r24, Y+6	; 0x06
    31d0:	9f 81       	ldd	r25, Y+7	; 0x07
    31d2:	29 81       	ldd	r18, Y+1	; 0x01
    31d4:	fc 01       	movw	r30, r24
    31d6:	23 8f       	std	Z+27, r18	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    31d8:	8e 81       	ldd	r24, Y+6	; 0x06
    31da:	9f 81       	ldd	r25, Y+7	; 0x07
    31dc:	2a 81       	ldd	r18, Y+2	; 0x02
    31de:	fc 01       	movw	r30, r24
    31e0:	24 8f       	std	Z+28, r18	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    31e2:	8e 81       	ldd	r24, Y+6	; 0x06
    31e4:	9f 81       	ldd	r25, Y+7	; 0x07
    31e6:	61 e0       	ldi	r22, 0x01	; 1
    31e8:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    31ec:	00 00       	nop
    31ee:	27 96       	adiw	r28, 0x07	; 7
    31f0:	0f b6       	in	r0, 0x3f	; 63
    31f2:	f8 94       	cli
    31f4:	de bf       	out	0x3e, r29	; 62
    31f6:	0f be       	out	0x3f, r0	; 63
    31f8:	cd bf       	out	0x3d, r28	; 61
    31fa:	df 91       	pop	r29
    31fc:	cf 91       	pop	r28
    31fe:	1f 91       	pop	r17
    3200:	0f 91       	pop	r16
    3202:	08 95       	ret

00003204 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    3204:	cf 93       	push	r28
    3206:	df 93       	push	r29
    3208:	00 d0       	rcall	.+0      	; 0x320a <prvInitialiseMutex+0x6>
    320a:	cd b7       	in	r28, 0x3d	; 61
    320c:	de b7       	in	r29, 0x3e	; 62
    320e:	9a 83       	std	Y+2, r25	; 0x02
    3210:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    3212:	89 81       	ldd	r24, Y+1	; 0x01
    3214:	9a 81       	ldd	r25, Y+2	; 0x02
    3216:	89 2b       	or	r24, r25
    3218:	b9 f0       	breq	.+46     	; 0x3248 <prvInitialiseMutex+0x44>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    321a:	89 81       	ldd	r24, Y+1	; 0x01
    321c:	9a 81       	ldd	r25, Y+2	; 0x02
    321e:	fc 01       	movw	r30, r24
    3220:	15 82       	std	Z+5, r1	; 0x05
    3222:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    3224:	89 81       	ldd	r24, Y+1	; 0x01
    3226:	9a 81       	ldd	r25, Y+2	; 0x02
    3228:	fc 01       	movw	r30, r24
    322a:	11 82       	std	Z+1, r1	; 0x01
    322c:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    322e:	89 81       	ldd	r24, Y+1	; 0x01
    3230:	9a 81       	ldd	r25, Y+2	; 0x02
    3232:	fc 01       	movw	r30, r24
    3234:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    3236:	89 81       	ldd	r24, Y+1	; 0x01
    3238:	9a 81       	ldd	r25, Y+2	; 0x02
    323a:	20 e0       	ldi	r18, 0x00	; 0
    323c:	40 e0       	ldi	r20, 0x00	; 0
    323e:	50 e0       	ldi	r21, 0x00	; 0
    3240:	60 e0       	ldi	r22, 0x00	; 0
    3242:	70 e0       	ldi	r23, 0x00	; 0
    3244:	0e 94 4a 19 	call	0x3294	; 0x3294 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    3248:	00 00       	nop
    324a:	0f 90       	pop	r0
    324c:	0f 90       	pop	r0
    324e:	df 91       	pop	r29
    3250:	cf 91       	pop	r28
    3252:	08 95       	ret

00003254 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    3254:	cf 93       	push	r28
    3256:	df 93       	push	r29
    3258:	00 d0       	rcall	.+0      	; 0x325a <xQueueCreateMutex+0x6>
    325a:	00 d0       	rcall	.+0      	; 0x325c <xQueueCreateMutex+0x8>
    325c:	1f 92       	push	r1
    325e:	cd b7       	in	r28, 0x3d	; 61
    3260:	de b7       	in	r29, 0x3e	; 62
    3262:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    3264:	81 e0       	ldi	r24, 0x01	; 1
    3266:	89 83       	std	Y+1, r24	; 0x01
    3268:	1a 82       	std	Y+2, r1	; 0x02

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    326a:	4d 81       	ldd	r20, Y+5	; 0x05
    326c:	6a 81       	ldd	r22, Y+2	; 0x02
    326e:	89 81       	ldd	r24, Y+1	; 0x01
    3270:	0e 94 72 18 	call	0x30e4	; 0x30e4 <xQueueGenericCreate>
    3274:	9c 83       	std	Y+4, r25	; 0x04
    3276:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    3278:	8b 81       	ldd	r24, Y+3	; 0x03
    327a:	9c 81       	ldd	r25, Y+4	; 0x04
    327c:	0e 94 02 19 	call	0x3204	; 0x3204 <prvInitialiseMutex>

		return xNewQueue;
    3280:	8b 81       	ldd	r24, Y+3	; 0x03
    3282:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    3284:	0f 90       	pop	r0
    3286:	0f 90       	pop	r0
    3288:	0f 90       	pop	r0
    328a:	0f 90       	pop	r0
    328c:	0f 90       	pop	r0
    328e:	df 91       	pop	r29
    3290:	cf 91       	pop	r28
    3292:	08 95       	ret

00003294 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3294:	cf 93       	push	r28
    3296:	df 93       	push	r29
    3298:	cd b7       	in	r28, 0x3d	; 61
    329a:	de b7       	in	r29, 0x3e	; 62
    329c:	2e 97       	sbiw	r28, 0x0e	; 14
    329e:	0f b6       	in	r0, 0x3f	; 63
    32a0:	f8 94       	cli
    32a2:	de bf       	out	0x3e, r29	; 62
    32a4:	0f be       	out	0x3f, r0	; 63
    32a6:	cd bf       	out	0x3d, r28	; 61
    32a8:	99 87       	std	Y+9, r25	; 0x09
    32aa:	88 87       	std	Y+8, r24	; 0x08
    32ac:	7b 87       	std	Y+11, r23	; 0x0b
    32ae:	6a 87       	std	Y+10, r22	; 0x0a
    32b0:	5d 87       	std	Y+13, r21	; 0x0d
    32b2:	4c 87       	std	Y+12, r20	; 0x0c
    32b4:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    32b6:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    32b8:	88 85       	ldd	r24, Y+8	; 0x08
    32ba:	99 85       	ldd	r25, Y+9	; 0x09
    32bc:	9b 83       	std	Y+3, r25	; 0x03
    32be:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    32c0:	0f b6       	in	r0, 0x3f	; 63
    32c2:	f8 94       	cli
    32c4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    32c6:	8a 81       	ldd	r24, Y+2	; 0x02
    32c8:	9b 81       	ldd	r25, Y+3	; 0x03
    32ca:	fc 01       	movw	r30, r24
    32cc:	22 8d       	ldd	r18, Z+26	; 0x1a
    32ce:	8a 81       	ldd	r24, Y+2	; 0x02
    32d0:	9b 81       	ldd	r25, Y+3	; 0x03
    32d2:	fc 01       	movw	r30, r24
    32d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    32d6:	28 17       	cp	r18, r24
    32d8:	18 f0       	brcs	.+6      	; 0x32e0 <xQueueGenericSend+0x4c>
    32da:	8e 85       	ldd	r24, Y+14	; 0x0e
    32dc:	82 30       	cpi	r24, 0x02	; 2
    32de:	11 f5       	brne	.+68     	; 0x3324 <xQueueGenericSend+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    32e0:	2a 85       	ldd	r18, Y+10	; 0x0a
    32e2:	3b 85       	ldd	r19, Y+11	; 0x0b
    32e4:	8a 81       	ldd	r24, Y+2	; 0x02
    32e6:	9b 81       	ldd	r25, Y+3	; 0x03
    32e8:	4e 85       	ldd	r20, Y+14	; 0x0e
    32ea:	b9 01       	movw	r22, r18
    32ec:	0e 94 2f 1e 	call	0x3c5e	; 0x3c5e <prvCopyDataToQueue>
    32f0:	8c 83       	std	Y+4, r24	; 0x04

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    32f2:	8a 81       	ldd	r24, Y+2	; 0x02
    32f4:	9b 81       	ldd	r25, Y+3	; 0x03
    32f6:	fc 01       	movw	r30, r24
    32f8:	81 89       	ldd	r24, Z+17	; 0x11
    32fa:	88 23       	and	r24, r24
    32fc:	51 f0       	breq	.+20     	; 0x3312 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3300:	9b 81       	ldd	r25, Y+3	; 0x03
    3302:	41 96       	adiw	r24, 0x11	; 17
    3304:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    3308:	88 23       	and	r24, r24
    330a:	41 f0       	breq	.+16     	; 0x331c <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    330c:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
    3310:	05 c0       	rjmp	.+10     	; 0x331c <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3312:	8c 81       	ldd	r24, Y+4	; 0x04
    3314:	88 23       	and	r24, r24
    3316:	11 f0       	breq	.+4      	; 0x331c <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3318:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    331c:	0f 90       	pop	r0
    331e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3320:	81 e0       	ldi	r24, 0x01	; 1
    3322:	60 c0       	rjmp	.+192    	; 0x33e4 <xQueueGenericSend+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3324:	8c 85       	ldd	r24, Y+12	; 0x0c
    3326:	9d 85       	ldd	r25, Y+13	; 0x0d
    3328:	89 2b       	or	r24, r25
    332a:	21 f4       	brne	.+8      	; 0x3334 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    332c:	0f 90       	pop	r0
    332e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3330:	80 e0       	ldi	r24, 0x00	; 0
    3332:	58 c0       	rjmp	.+176    	; 0x33e4 <xQueueGenericSend+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    3334:	89 81       	ldd	r24, Y+1	; 0x01
    3336:	88 23       	and	r24, r24
    3338:	31 f4       	brne	.+12     	; 0x3346 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    333a:	ce 01       	movw	r24, r28
    333c:	05 96       	adiw	r24, 0x05	; 5
    333e:	0e 94 55 28 	call	0x50aa	; 0x50aa <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3342:	81 e0       	ldi	r24, 0x01	; 1
    3344:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3346:	0f 90       	pop	r0
    3348:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    334a:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    334e:	0f b6       	in	r0, 0x3f	; 63
    3350:	f8 94       	cli
    3352:	0f 92       	push	r0
    3354:	8a 81       	ldd	r24, Y+2	; 0x02
    3356:	9b 81       	ldd	r25, Y+3	; 0x03
    3358:	fc 01       	movw	r30, r24
    335a:	85 8d       	ldd	r24, Z+29	; 0x1d
    335c:	8f 3f       	cpi	r24, 0xFF	; 255
    335e:	21 f4       	brne	.+8      	; 0x3368 <xQueueGenericSend+0xd4>
    3360:	8a 81       	ldd	r24, Y+2	; 0x02
    3362:	9b 81       	ldd	r25, Y+3	; 0x03
    3364:	fc 01       	movw	r30, r24
    3366:	15 8e       	std	Z+29, r1	; 0x1d
    3368:	8a 81       	ldd	r24, Y+2	; 0x02
    336a:	9b 81       	ldd	r25, Y+3	; 0x03
    336c:	fc 01       	movw	r30, r24
    336e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3370:	8f 3f       	cpi	r24, 0xFF	; 255
    3372:	21 f4       	brne	.+8      	; 0x337c <xQueueGenericSend+0xe8>
    3374:	8a 81       	ldd	r24, Y+2	; 0x02
    3376:	9b 81       	ldd	r25, Y+3	; 0x03
    3378:	fc 01       	movw	r30, r24
    337a:	16 8e       	std	Z+30, r1	; 0x1e
    337c:	0f 90       	pop	r0
    337e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3380:	9e 01       	movw	r18, r28
    3382:	24 5f       	subi	r18, 0xF4	; 244
    3384:	3f 4f       	sbci	r19, 0xFF	; 255
    3386:	ce 01       	movw	r24, r28
    3388:	05 96       	adiw	r24, 0x05	; 5
    338a:	b9 01       	movw	r22, r18
    338c:	0e 94 71 28 	call	0x50e2	; 0x50e2 <xTaskCheckForTimeOut>
    3390:	88 23       	and	r24, r24
    3392:	09 f5       	brne	.+66     	; 0x33d6 <xQueueGenericSend+0x142>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3394:	8a 81       	ldd	r24, Y+2	; 0x02
    3396:	9b 81       	ldd	r25, Y+3	; 0x03
    3398:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <prvIsQueueFull>
    339c:	88 23       	and	r24, r24
    339e:	a1 f0       	breq	.+40     	; 0x33c8 <xQueueGenericSend+0x134>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    33a0:	2c 85       	ldd	r18, Y+12	; 0x0c
    33a2:	3d 85       	ldd	r19, Y+13	; 0x0d
    33a4:	8a 81       	ldd	r24, Y+2	; 0x02
    33a6:	9b 81       	ldd	r25, Y+3	; 0x03
    33a8:	08 96       	adiw	r24, 0x08	; 8
    33aa:	b9 01       	movw	r22, r18
    33ac:	0e 94 0e 27 	call	0x4e1c	; 0x4e1c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    33b0:	8a 81       	ldd	r24, Y+2	; 0x02
    33b2:	9b 81       	ldd	r25, Y+3	; 0x03
    33b4:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    33b8:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    33bc:	88 23       	and	r24, r24
    33be:	09 f0       	breq	.+2      	; 0x33c2 <xQueueGenericSend+0x12e>
    33c0:	7f cf       	rjmp	.-258    	; 0x32c0 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    33c2:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
    33c6:	7c cf       	rjmp	.-264    	; 0x32c0 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    33c8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ca:	9b 81       	ldd	r25, Y+3	; 0x03
    33cc:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    33d0:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    33d4:	75 cf       	rjmp	.-278    	; 0x32c0 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    33d6:	8a 81       	ldd	r24, Y+2	; 0x02
    33d8:	9b 81       	ldd	r25, Y+3	; 0x03
    33da:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    33de:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    33e2:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    33e4:	2e 96       	adiw	r28, 0x0e	; 14
    33e6:	0f b6       	in	r0, 0x3f	; 63
    33e8:	f8 94       	cli
    33ea:	de bf       	out	0x3e, r29	; 62
    33ec:	0f be       	out	0x3f, r0	; 63
    33ee:	cd bf       	out	0x3d, r28	; 61
    33f0:	df 91       	pop	r29
    33f2:	cf 91       	pop	r28
    33f4:	08 95       	ret

000033f6 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    33f6:	cf 93       	push	r28
    33f8:	df 93       	push	r29
    33fa:	cd b7       	in	r28, 0x3d	; 61
    33fc:	de b7       	in	r29, 0x3e	; 62
    33fe:	2c 97       	sbiw	r28, 0x0c	; 12
    3400:	0f b6       	in	r0, 0x3f	; 63
    3402:	f8 94       	cli
    3404:	de bf       	out	0x3e, r29	; 62
    3406:	0f be       	out	0x3f, r0	; 63
    3408:	cd bf       	out	0x3d, r28	; 61
    340a:	9f 83       	std	Y+7, r25	; 0x07
    340c:	8e 83       	std	Y+6, r24	; 0x06
    340e:	79 87       	std	Y+9, r23	; 0x09
    3410:	68 87       	std	Y+8, r22	; 0x08
    3412:	5b 87       	std	Y+11, r21	; 0x0b
    3414:	4a 87       	std	Y+10, r20	; 0x0a
    3416:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3418:	8e 81       	ldd	r24, Y+6	; 0x06
    341a:	9f 81       	ldd	r25, Y+7	; 0x07
    341c:	9b 83       	std	Y+3, r25	; 0x03
    341e:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3420:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3422:	8a 81       	ldd	r24, Y+2	; 0x02
    3424:	9b 81       	ldd	r25, Y+3	; 0x03
    3426:	fc 01       	movw	r30, r24
    3428:	22 8d       	ldd	r18, Z+26	; 0x1a
    342a:	8a 81       	ldd	r24, Y+2	; 0x02
    342c:	9b 81       	ldd	r25, Y+3	; 0x03
    342e:	fc 01       	movw	r30, r24
    3430:	83 8d       	ldd	r24, Z+27	; 0x1b
    3432:	28 17       	cp	r18, r24
    3434:	18 f0       	brcs	.+6      	; 0x343c <xQueueGenericSendFromISR+0x46>
    3436:	8c 85       	ldd	r24, Y+12	; 0x0c
    3438:	82 30       	cpi	r24, 0x02	; 2
    343a:	89 f5       	brne	.+98     	; 0x349e <xQueueGenericSendFromISR+0xa8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    343c:	8a 81       	ldd	r24, Y+2	; 0x02
    343e:	9b 81       	ldd	r25, Y+3	; 0x03
    3440:	fc 01       	movw	r30, r24
    3442:	86 8d       	ldd	r24, Z+30	; 0x1e
    3444:	8d 83       	std	Y+5, r24	; 0x05
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3446:	28 85       	ldd	r18, Y+8	; 0x08
    3448:	39 85       	ldd	r19, Y+9	; 0x09
    344a:	8a 81       	ldd	r24, Y+2	; 0x02
    344c:	9b 81       	ldd	r25, Y+3	; 0x03
    344e:	4c 85       	ldd	r20, Y+12	; 0x0c
    3450:	b9 01       	movw	r22, r18
    3452:	0e 94 2f 1e 	call	0x3c5e	; 0x3c5e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3456:	8d 81       	ldd	r24, Y+5	; 0x05
    3458:	8f 3f       	cpi	r24, 0xFF	; 255
    345a:	b9 f4       	brne	.+46     	; 0x348a <xQueueGenericSendFromISR+0x94>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    345c:	8a 81       	ldd	r24, Y+2	; 0x02
    345e:	9b 81       	ldd	r25, Y+3	; 0x03
    3460:	fc 01       	movw	r30, r24
    3462:	81 89       	ldd	r24, Z+17	; 0x11
    3464:	88 23       	and	r24, r24
    3466:	c1 f0       	breq	.+48     	; 0x3498 <xQueueGenericSendFromISR+0xa2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3468:	8a 81       	ldd	r24, Y+2	; 0x02
    346a:	9b 81       	ldd	r25, Y+3	; 0x03
    346c:	41 96       	adiw	r24, 0x11	; 17
    346e:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    3472:	88 23       	and	r24, r24
    3474:	89 f0       	breq	.+34     	; 0x3498 <xQueueGenericSendFromISR+0xa2>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3476:	8a 85       	ldd	r24, Y+10	; 0x0a
    3478:	9b 85       	ldd	r25, Y+11	; 0x0b
    347a:	89 2b       	or	r24, r25
    347c:	69 f0       	breq	.+26     	; 0x3498 <xQueueGenericSendFromISR+0xa2>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    347e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3480:	9b 85       	ldd	r25, Y+11	; 0x0b
    3482:	21 e0       	ldi	r18, 0x01	; 1
    3484:	fc 01       	movw	r30, r24
    3486:	20 83       	st	Z, r18
    3488:	07 c0       	rjmp	.+14     	; 0x3498 <xQueueGenericSendFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    348a:	8d 81       	ldd	r24, Y+5	; 0x05
    348c:	8f 5f       	subi	r24, 0xFF	; 255
    348e:	28 2f       	mov	r18, r24
    3490:	8a 81       	ldd	r24, Y+2	; 0x02
    3492:	9b 81       	ldd	r25, Y+3	; 0x03
    3494:	fc 01       	movw	r30, r24
    3496:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    3498:	81 e0       	ldi	r24, 0x01	; 1
    349a:	89 83       	std	Y+1, r24	; 0x01
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
    349c:	01 c0       	rjmp	.+2      	; 0x34a0 <xQueueGenericSendFromISR+0xaa>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    349e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    34a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    34a2:	2c 96       	adiw	r28, 0x0c	; 12
    34a4:	0f b6       	in	r0, 0x3f	; 63
    34a6:	f8 94       	cli
    34a8:	de bf       	out	0x3e, r29	; 62
    34aa:	0f be       	out	0x3f, r0	; 63
    34ac:	cd bf       	out	0x3d, r28	; 61
    34ae:	df 91       	pop	r29
    34b0:	cf 91       	pop	r28
    34b2:	08 95       	ret

000034b4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    34b4:	cf 93       	push	r28
    34b6:	df 93       	push	r29
    34b8:	cd b7       	in	r28, 0x3d	; 61
    34ba:	de b7       	in	r29, 0x3e	; 62
    34bc:	2a 97       	sbiw	r28, 0x0a	; 10
    34be:	0f b6       	in	r0, 0x3f	; 63
    34c0:	f8 94       	cli
    34c2:	de bf       	out	0x3e, r29	; 62
    34c4:	0f be       	out	0x3f, r0	; 63
    34c6:	cd bf       	out	0x3d, r28	; 61
    34c8:	98 87       	std	Y+8, r25	; 0x08
    34ca:	8f 83       	std	Y+7, r24	; 0x07
    34cc:	7a 87       	std	Y+10, r23	; 0x0a
    34ce:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    34d0:	8f 81       	ldd	r24, Y+7	; 0x07
    34d2:	98 85       	ldd	r25, Y+8	; 0x08
    34d4:	9b 83       	std	Y+3, r25	; 0x03
    34d6:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    34d8:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    34da:	8a 81       	ldd	r24, Y+2	; 0x02
    34dc:	9b 81       	ldd	r25, Y+3	; 0x03
    34de:	fc 01       	movw	r30, r24
    34e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    34e2:	8d 83       	std	Y+5, r24	; 0x05

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    34e4:	8a 81       	ldd	r24, Y+2	; 0x02
    34e6:	9b 81       	ldd	r25, Y+3	; 0x03
    34e8:	fc 01       	movw	r30, r24
    34ea:	93 8d       	ldd	r25, Z+27	; 0x1b
    34ec:	8d 81       	ldd	r24, Y+5	; 0x05
    34ee:	89 17       	cp	r24, r25
    34f0:	80 f5       	brcc	.+96     	; 0x3552 <xQueueGiveFromISR+0x9e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    34f2:	8a 81       	ldd	r24, Y+2	; 0x02
    34f4:	9b 81       	ldd	r25, Y+3	; 0x03
    34f6:	fc 01       	movw	r30, r24
    34f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    34fa:	8e 83       	std	Y+6, r24	; 0x06
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    34fc:	8d 81       	ldd	r24, Y+5	; 0x05
    34fe:	21 e0       	ldi	r18, 0x01	; 1
    3500:	28 0f       	add	r18, r24
    3502:	8a 81       	ldd	r24, Y+2	; 0x02
    3504:	9b 81       	ldd	r25, Y+3	; 0x03
    3506:	fc 01       	movw	r30, r24
    3508:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    350a:	8e 81       	ldd	r24, Y+6	; 0x06
    350c:	8f 3f       	cpi	r24, 0xFF	; 255
    350e:	b9 f4       	brne	.+46     	; 0x353e <xQueueGiveFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3510:	8a 81       	ldd	r24, Y+2	; 0x02
    3512:	9b 81       	ldd	r25, Y+3	; 0x03
    3514:	fc 01       	movw	r30, r24
    3516:	81 89       	ldd	r24, Z+17	; 0x11
    3518:	88 23       	and	r24, r24
    351a:	c1 f0       	breq	.+48     	; 0x354c <xQueueGiveFromISR+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    351c:	8a 81       	ldd	r24, Y+2	; 0x02
    351e:	9b 81       	ldd	r25, Y+3	; 0x03
    3520:	41 96       	adiw	r24, 0x11	; 17
    3522:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    3526:	88 23       	and	r24, r24
    3528:	89 f0       	breq	.+34     	; 0x354c <xQueueGiveFromISR+0x98>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    352a:	89 85       	ldd	r24, Y+9	; 0x09
    352c:	9a 85       	ldd	r25, Y+10	; 0x0a
    352e:	89 2b       	or	r24, r25
    3530:	69 f0       	breq	.+26     	; 0x354c <xQueueGiveFromISR+0x98>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3532:	89 85       	ldd	r24, Y+9	; 0x09
    3534:	9a 85       	ldd	r25, Y+10	; 0x0a
    3536:	21 e0       	ldi	r18, 0x01	; 1
    3538:	fc 01       	movw	r30, r24
    353a:	20 83       	st	Z, r18
    353c:	07 c0       	rjmp	.+14     	; 0x354c <xQueueGiveFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    353e:	8e 81       	ldd	r24, Y+6	; 0x06
    3540:	8f 5f       	subi	r24, 0xFF	; 255
    3542:	28 2f       	mov	r18, r24
    3544:	8a 81       	ldd	r24, Y+2	; 0x02
    3546:	9b 81       	ldd	r25, Y+3	; 0x03
    3548:	fc 01       	movw	r30, r24
    354a:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    354c:	81 e0       	ldi	r24, 0x01	; 1
    354e:	89 83       	std	Y+1, r24	; 0x01
    3550:	01 c0       	rjmp	.+2      	; 0x3554 <xQueueGiveFromISR+0xa0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3552:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3554:	89 81       	ldd	r24, Y+1	; 0x01
}
    3556:	2a 96       	adiw	r28, 0x0a	; 10
    3558:	0f b6       	in	r0, 0x3f	; 63
    355a:	f8 94       	cli
    355c:	de bf       	out	0x3e, r29	; 62
    355e:	0f be       	out	0x3f, r0	; 63
    3560:	cd bf       	out	0x3d, r28	; 61
    3562:	df 91       	pop	r29
    3564:	cf 91       	pop	r28
    3566:	08 95       	ret

00003568 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3568:	cf 93       	push	r28
    356a:	df 93       	push	r29
    356c:	cd b7       	in	r28, 0x3d	; 61
    356e:	de b7       	in	r29, 0x3e	; 62
    3570:	2d 97       	sbiw	r28, 0x0d	; 13
    3572:	0f b6       	in	r0, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	de bf       	out	0x3e, r29	; 62
    3578:	0f be       	out	0x3f, r0	; 63
    357a:	cd bf       	out	0x3d, r28	; 61
    357c:	99 87       	std	Y+9, r25	; 0x09
    357e:	88 87       	std	Y+8, r24	; 0x08
    3580:	7b 87       	std	Y+11, r23	; 0x0b
    3582:	6a 87       	std	Y+10, r22	; 0x0a
    3584:	5d 87       	std	Y+13, r21	; 0x0d
    3586:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3588:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    358a:	88 85       	ldd	r24, Y+8	; 0x08
    358c:	99 85       	ldd	r25, Y+9	; 0x09
    358e:	9b 83       	std	Y+3, r25	; 0x03
    3590:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3592:	0f b6       	in	r0, 0x3f	; 63
    3594:	f8 94       	cli
    3596:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3598:	8a 81       	ldd	r24, Y+2	; 0x02
    359a:	9b 81       	ldd	r25, Y+3	; 0x03
    359c:	fc 01       	movw	r30, r24
    359e:	82 8d       	ldd	r24, Z+26	; 0x1a
    35a0:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    35a2:	8c 81       	ldd	r24, Y+4	; 0x04
    35a4:	88 23       	and	r24, r24
    35a6:	09 f1       	breq	.+66     	; 0x35ea <xQueueReceive+0x82>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    35a8:	2a 85       	ldd	r18, Y+10	; 0x0a
    35aa:	3b 85       	ldd	r19, Y+11	; 0x0b
    35ac:	8a 81       	ldd	r24, Y+2	; 0x02
    35ae:	9b 81       	ldd	r25, Y+3	; 0x03
    35b0:	b9 01       	movw	r22, r18
    35b2:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    35b6:	8c 81       	ldd	r24, Y+4	; 0x04
    35b8:	2f ef       	ldi	r18, 0xFF	; 255
    35ba:	28 0f       	add	r18, r24
    35bc:	8a 81       	ldd	r24, Y+2	; 0x02
    35be:	9b 81       	ldd	r25, Y+3	; 0x03
    35c0:	fc 01       	movw	r30, r24
    35c2:	22 8f       	std	Z+26, r18	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35c4:	8a 81       	ldd	r24, Y+2	; 0x02
    35c6:	9b 81       	ldd	r25, Y+3	; 0x03
    35c8:	fc 01       	movw	r30, r24
    35ca:	80 85       	ldd	r24, Z+8	; 0x08
    35cc:	88 23       	and	r24, r24
    35ce:	49 f0       	breq	.+18     	; 0x35e2 <xQueueReceive+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    35d0:	8a 81       	ldd	r24, Y+2	; 0x02
    35d2:	9b 81       	ldd	r25, Y+3	; 0x03
    35d4:	08 96       	adiw	r24, 0x08	; 8
    35d6:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    35da:	88 23       	and	r24, r24
    35dc:	11 f0       	breq	.+4      	; 0x35e2 <xQueueReceive+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    35de:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    35e2:	0f 90       	pop	r0
    35e4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    35e6:	81 e0       	ldi	r24, 0x01	; 1
    35e8:	67 c0       	rjmp	.+206    	; 0x36b8 <xQueueReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    35ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    35ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    35ee:	89 2b       	or	r24, r25
    35f0:	21 f4       	brne	.+8      	; 0x35fa <xQueueReceive+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    35f2:	0f 90       	pop	r0
    35f4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    35f6:	80 e0       	ldi	r24, 0x00	; 0
    35f8:	5f c0       	rjmp	.+190    	; 0x36b8 <xQueueReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    35fa:	89 81       	ldd	r24, Y+1	; 0x01
    35fc:	88 23       	and	r24, r24
    35fe:	31 f4       	brne	.+12     	; 0x360c <xQueueReceive+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3600:	ce 01       	movw	r24, r28
    3602:	05 96       	adiw	r24, 0x05	; 5
    3604:	0e 94 55 28 	call	0x50aa	; 0x50aa <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3608:	81 e0       	ldi	r24, 0x01	; 1
    360a:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    360c:	0f 90       	pop	r0
    360e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3610:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3614:	0f b6       	in	r0, 0x3f	; 63
    3616:	f8 94       	cli
    3618:	0f 92       	push	r0
    361a:	8a 81       	ldd	r24, Y+2	; 0x02
    361c:	9b 81       	ldd	r25, Y+3	; 0x03
    361e:	fc 01       	movw	r30, r24
    3620:	85 8d       	ldd	r24, Z+29	; 0x1d
    3622:	8f 3f       	cpi	r24, 0xFF	; 255
    3624:	21 f4       	brne	.+8      	; 0x362e <xQueueReceive+0xc6>
    3626:	8a 81       	ldd	r24, Y+2	; 0x02
    3628:	9b 81       	ldd	r25, Y+3	; 0x03
    362a:	fc 01       	movw	r30, r24
    362c:	15 8e       	std	Z+29, r1	; 0x1d
    362e:	8a 81       	ldd	r24, Y+2	; 0x02
    3630:	9b 81       	ldd	r25, Y+3	; 0x03
    3632:	fc 01       	movw	r30, r24
    3634:	86 8d       	ldd	r24, Z+30	; 0x1e
    3636:	8f 3f       	cpi	r24, 0xFF	; 255
    3638:	21 f4       	brne	.+8      	; 0x3642 <xQueueReceive+0xda>
    363a:	8a 81       	ldd	r24, Y+2	; 0x02
    363c:	9b 81       	ldd	r25, Y+3	; 0x03
    363e:	fc 01       	movw	r30, r24
    3640:	16 8e       	std	Z+30, r1	; 0x1e
    3642:	0f 90       	pop	r0
    3644:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3646:	9e 01       	movw	r18, r28
    3648:	24 5f       	subi	r18, 0xF4	; 244
    364a:	3f 4f       	sbci	r19, 0xFF	; 255
    364c:	ce 01       	movw	r24, r28
    364e:	05 96       	adiw	r24, 0x05	; 5
    3650:	b9 01       	movw	r22, r18
    3652:	0e 94 71 28 	call	0x50e2	; 0x50e2 <xTaskCheckForTimeOut>
    3656:	88 23       	and	r24, r24
    3658:	09 f5       	brne	.+66     	; 0x369c <xQueueReceive+0x134>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    365a:	8a 81       	ldd	r24, Y+2	; 0x02
    365c:	9b 81       	ldd	r25, Y+3	; 0x03
    365e:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <prvIsQueueEmpty>
    3662:	88 23       	and	r24, r24
    3664:	a1 f0       	breq	.+40     	; 0x368e <xQueueReceive+0x126>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3666:	2c 85       	ldd	r18, Y+12	; 0x0c
    3668:	3d 85       	ldd	r19, Y+13	; 0x0d
    366a:	8a 81       	ldd	r24, Y+2	; 0x02
    366c:	9b 81       	ldd	r25, Y+3	; 0x03
    366e:	41 96       	adiw	r24, 0x11	; 17
    3670:	b9 01       	movw	r22, r18
    3672:	0e 94 0e 27 	call	0x4e1c	; 0x4e1c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3676:	8a 81       	ldd	r24, Y+2	; 0x02
    3678:	9b 81       	ldd	r25, Y+3	; 0x03
    367a:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    367e:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    3682:	88 23       	and	r24, r24
    3684:	09 f0       	breq	.+2      	; 0x3688 <xQueueReceive+0x120>
    3686:	85 cf       	rjmp	.-246    	; 0x3592 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    3688:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
    368c:	82 cf       	rjmp	.-252    	; 0x3592 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    368e:	8a 81       	ldd	r24, Y+2	; 0x02
    3690:	9b 81       	ldd	r25, Y+3	; 0x03
    3692:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3696:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    369a:	7b cf       	rjmp	.-266    	; 0x3592 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    369c:	8a 81       	ldd	r24, Y+2	; 0x02
    369e:	9b 81       	ldd	r25, Y+3	; 0x03
    36a0:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    36a4:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    36a8:	8a 81       	ldd	r24, Y+2	; 0x02
    36aa:	9b 81       	ldd	r25, Y+3	; 0x03
    36ac:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <prvIsQueueEmpty>
    36b0:	88 23       	and	r24, r24
    36b2:	09 f4       	brne	.+2      	; 0x36b6 <xQueueReceive+0x14e>
    36b4:	6e cf       	rjmp	.-292    	; 0x3592 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    36b6:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    36b8:	2d 96       	adiw	r28, 0x0d	; 13
    36ba:	0f b6       	in	r0, 0x3f	; 63
    36bc:	f8 94       	cli
    36be:	de bf       	out	0x3e, r29	; 62
    36c0:	0f be       	out	0x3f, r0	; 63
    36c2:	cd bf       	out	0x3d, r28	; 61
    36c4:	df 91       	pop	r29
    36c6:	cf 91       	pop	r28
    36c8:	08 95       	ret

000036ca <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    36ca:	cf 93       	push	r28
    36cc:	df 93       	push	r29
    36ce:	cd b7       	in	r28, 0x3d	; 61
    36d0:	de b7       	in	r29, 0x3e	; 62
    36d2:	2d 97       	sbiw	r28, 0x0d	; 13
    36d4:	0f b6       	in	r0, 0x3f	; 63
    36d6:	f8 94       	cli
    36d8:	de bf       	out	0x3e, r29	; 62
    36da:	0f be       	out	0x3f, r0	; 63
    36dc:	cd bf       	out	0x3d, r28	; 61
    36de:	9b 87       	std	Y+11, r25	; 0x0b
    36e0:	8a 87       	std	Y+10, r24	; 0x0a
    36e2:	7d 87       	std	Y+13, r23	; 0x0d
    36e4:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    36e6:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    36e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    36ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    36ec:	9c 83       	std	Y+4, r25	; 0x04
    36ee:	8b 83       	std	Y+3, r24	; 0x03

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    36f0:	1a 82       	std	Y+2, r1	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    36f2:	0f b6       	in	r0, 0x3f	; 63
    36f4:	f8 94       	cli
    36f6:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    36f8:	8b 81       	ldd	r24, Y+3	; 0x03
    36fa:	9c 81       	ldd	r25, Y+4	; 0x04
    36fc:	fc 01       	movw	r30, r24
    36fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3700:	8d 83       	std	Y+5, r24	; 0x05

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3702:	8d 81       	ldd	r24, Y+5	; 0x05
    3704:	88 23       	and	r24, r24
    3706:	49 f1       	breq	.+82     	; 0x375a <xQueueSemaphoreTake+0x90>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3708:	8d 81       	ldd	r24, Y+5	; 0x05
    370a:	2f ef       	ldi	r18, 0xFF	; 255
    370c:	28 0f       	add	r18, r24
    370e:	8b 81       	ldd	r24, Y+3	; 0x03
    3710:	9c 81       	ldd	r25, Y+4	; 0x04
    3712:	fc 01       	movw	r30, r24
    3714:	22 8f       	std	Z+26, r18	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3716:	8b 81       	ldd	r24, Y+3	; 0x03
    3718:	9c 81       	ldd	r25, Y+4	; 0x04
    371a:	fc 01       	movw	r30, r24
    371c:	80 81       	ld	r24, Z
    371e:	91 81       	ldd	r25, Z+1	; 0x01
    3720:	89 2b       	or	r24, r25
    3722:	41 f4       	brne	.+16     	; 0x3734 <xQueueSemaphoreTake+0x6a>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    3724:	0e 94 be 2b 	call	0x577c	; 0x577c <pvTaskIncrementMutexHeldCount>
    3728:	9c 01       	movw	r18, r24
    372a:	8b 81       	ldd	r24, Y+3	; 0x03
    372c:	9c 81       	ldd	r25, Y+4	; 0x04
    372e:	fc 01       	movw	r30, r24
    3730:	35 83       	std	Z+5, r19	; 0x05
    3732:	24 83       	std	Z+4, r18	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3734:	8b 81       	ldd	r24, Y+3	; 0x03
    3736:	9c 81       	ldd	r25, Y+4	; 0x04
    3738:	fc 01       	movw	r30, r24
    373a:	80 85       	ldd	r24, Z+8	; 0x08
    373c:	88 23       	and	r24, r24
    373e:	49 f0       	breq	.+18     	; 0x3752 <xQueueSemaphoreTake+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3740:	8b 81       	ldd	r24, Y+3	; 0x03
    3742:	9c 81       	ldd	r25, Y+4	; 0x04
    3744:	08 96       	adiw	r24, 0x08	; 8
    3746:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    374a:	88 23       	and	r24, r24
    374c:	11 f0       	breq	.+4      	; 0x3752 <xQueueSemaphoreTake+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
    374e:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3752:	0f 90       	pop	r0
    3754:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3756:	81 e0       	ldi	r24, 0x01	; 1
    3758:	90 c0       	rjmp	.+288    	; 0x387a <xQueueSemaphoreTake+0x1b0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    375a:	8c 85       	ldd	r24, Y+12	; 0x0c
    375c:	9d 85       	ldd	r25, Y+13	; 0x0d
    375e:	89 2b       	or	r24, r25
    3760:	21 f4       	brne	.+8      	; 0x376a <xQueueSemaphoreTake+0xa0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    3762:	0f 90       	pop	r0
    3764:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3766:	80 e0       	ldi	r24, 0x00	; 0
    3768:	88 c0       	rjmp	.+272    	; 0x387a <xQueueSemaphoreTake+0x1b0>
				}
				else if( xEntryTimeSet == pdFALSE )
    376a:	89 81       	ldd	r24, Y+1	; 0x01
    376c:	88 23       	and	r24, r24
    376e:	31 f4       	brne	.+12     	; 0x377c <xQueueSemaphoreTake+0xb2>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3770:	ce 01       	movw	r24, r28
    3772:	07 96       	adiw	r24, 0x07	; 7
    3774:	0e 94 55 28 	call	0x50aa	; 0x50aa <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3778:	81 e0       	ldi	r24, 0x01	; 1
    377a:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    377c:	0f 90       	pop	r0
    377e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    3780:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3784:	0f b6       	in	r0, 0x3f	; 63
    3786:	f8 94       	cli
    3788:	0f 92       	push	r0
    378a:	8b 81       	ldd	r24, Y+3	; 0x03
    378c:	9c 81       	ldd	r25, Y+4	; 0x04
    378e:	fc 01       	movw	r30, r24
    3790:	85 8d       	ldd	r24, Z+29	; 0x1d
    3792:	8f 3f       	cpi	r24, 0xFF	; 255
    3794:	21 f4       	brne	.+8      	; 0x379e <xQueueSemaphoreTake+0xd4>
    3796:	8b 81       	ldd	r24, Y+3	; 0x03
    3798:	9c 81       	ldd	r25, Y+4	; 0x04
    379a:	fc 01       	movw	r30, r24
    379c:	15 8e       	std	Z+29, r1	; 0x1d
    379e:	8b 81       	ldd	r24, Y+3	; 0x03
    37a0:	9c 81       	ldd	r25, Y+4	; 0x04
    37a2:	fc 01       	movw	r30, r24
    37a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    37a6:	8f 3f       	cpi	r24, 0xFF	; 255
    37a8:	21 f4       	brne	.+8      	; 0x37b2 <xQueueSemaphoreTake+0xe8>
    37aa:	8b 81       	ldd	r24, Y+3	; 0x03
    37ac:	9c 81       	ldd	r25, Y+4	; 0x04
    37ae:	fc 01       	movw	r30, r24
    37b0:	16 8e       	std	Z+30, r1	; 0x1e
    37b2:	0f 90       	pop	r0
    37b4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    37b6:	9e 01       	movw	r18, r28
    37b8:	24 5f       	subi	r18, 0xF4	; 244
    37ba:	3f 4f       	sbci	r19, 0xFF	; 255
    37bc:	ce 01       	movw	r24, r28
    37be:	07 96       	adiw	r24, 0x07	; 7
    37c0:	b9 01       	movw	r22, r18
    37c2:	0e 94 71 28 	call	0x50e2	; 0x50e2 <xTaskCheckForTimeOut>
    37c6:	88 23       	and	r24, r24
    37c8:	a9 f5       	brne	.+106    	; 0x3834 <xQueueSemaphoreTake+0x16a>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37ca:	8b 81       	ldd	r24, Y+3	; 0x03
    37cc:	9c 81       	ldd	r25, Y+4	; 0x04
    37ce:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <prvIsQueueEmpty>
    37d2:	88 23       	and	r24, r24
    37d4:	41 f1       	breq	.+80     	; 0x3826 <xQueueSemaphoreTake+0x15c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    37d6:	8b 81       	ldd	r24, Y+3	; 0x03
    37d8:	9c 81       	ldd	r25, Y+4	; 0x04
    37da:	fc 01       	movw	r30, r24
    37dc:	80 81       	ld	r24, Z
    37de:	91 81       	ldd	r25, Z+1	; 0x01
    37e0:	89 2b       	or	r24, r25
    37e2:	69 f4       	brne	.+26     	; 0x37fe <xQueueSemaphoreTake+0x134>
					{
						taskENTER_CRITICAL();
    37e4:	0f b6       	in	r0, 0x3f	; 63
    37e6:	f8 94       	cli
    37e8:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    37ea:	8b 81       	ldd	r24, Y+3	; 0x03
    37ec:	9c 81       	ldd	r25, Y+4	; 0x04
    37ee:	fc 01       	movw	r30, r24
    37f0:	84 81       	ldd	r24, Z+4	; 0x04
    37f2:	95 81       	ldd	r25, Z+5	; 0x05
    37f4:	0e 94 cb 29 	call	0x5396	; 0x5396 <xTaskPriorityInherit>
    37f8:	8a 83       	std	Y+2, r24	; 0x02
						}
						taskEXIT_CRITICAL();
    37fa:	0f 90       	pop	r0
    37fc:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    37fe:	2c 85       	ldd	r18, Y+12	; 0x0c
    3800:	3d 85       	ldd	r19, Y+13	; 0x0d
    3802:	8b 81       	ldd	r24, Y+3	; 0x03
    3804:	9c 81       	ldd	r25, Y+4	; 0x04
    3806:	41 96       	adiw	r24, 0x11	; 17
    3808:	b9 01       	movw	r22, r18
    380a:	0e 94 0e 27 	call	0x4e1c	; 0x4e1c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    380e:	8b 81       	ldd	r24, Y+3	; 0x03
    3810:	9c 81       	ldd	r25, Y+4	; 0x04
    3812:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3816:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    381a:	88 23       	and	r24, r24
    381c:	09 f0       	breq	.+2      	; 0x3820 <xQueueSemaphoreTake+0x156>
    381e:	69 cf       	rjmp	.-302    	; 0x36f2 <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    3820:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
    3824:	66 cf       	rjmp	.-308    	; 0x36f2 <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    3826:	8b 81       	ldd	r24, Y+3	; 0x03
    3828:	9c 81       	ldd	r25, Y+4	; 0x04
    382a:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    382e:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    3832:	5f cf       	rjmp	.-322    	; 0x36f2 <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    3834:	8b 81       	ldd	r24, Y+3	; 0x03
    3836:	9c 81       	ldd	r25, Y+4	; 0x04
    3838:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    383c:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3840:	8b 81       	ldd	r24, Y+3	; 0x03
    3842:	9c 81       	ldd	r25, Y+4	; 0x04
    3844:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <prvIsQueueEmpty>
    3848:	88 23       	and	r24, r24
    384a:	09 f4       	brne	.+2      	; 0x384e <xQueueSemaphoreTake+0x184>
    384c:	52 cf       	rjmp	.-348    	; 0x36f2 <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    384e:	8a 81       	ldd	r24, Y+2	; 0x02
    3850:	88 23       	and	r24, r24
    3852:	91 f0       	breq	.+36     	; 0x3878 <xQueueSemaphoreTake+0x1ae>
					{
						taskENTER_CRITICAL();
    3854:	0f b6       	in	r0, 0x3f	; 63
    3856:	f8 94       	cli
    3858:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    385a:	8b 81       	ldd	r24, Y+3	; 0x03
    385c:	9c 81       	ldd	r25, Y+4	; 0x04
    385e:	0e 94 0c 1e 	call	0x3c18	; 0x3c18 <prvGetDisinheritPriorityAfterTimeout>
    3862:	8e 83       	std	Y+6, r24	; 0x06
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    3864:	8b 81       	ldd	r24, Y+3	; 0x03
    3866:	9c 81       	ldd	r25, Y+4	; 0x04
    3868:	fc 01       	movw	r30, r24
    386a:	84 81       	ldd	r24, Z+4	; 0x04
    386c:	95 81       	ldd	r25, Z+5	; 0x05
    386e:	6e 81       	ldd	r22, Y+6	; 0x06
    3870:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    3874:	0f 90       	pop	r0
    3876:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3878:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    387a:	2d 96       	adiw	r28, 0x0d	; 13
    387c:	0f b6       	in	r0, 0x3f	; 63
    387e:	f8 94       	cli
    3880:	de bf       	out	0x3e, r29	; 62
    3882:	0f be       	out	0x3f, r0	; 63
    3884:	cd bf       	out	0x3d, r28	; 61
    3886:	df 91       	pop	r29
    3888:	cf 91       	pop	r28
    388a:	08 95       	ret

0000388c <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    388c:	cf 93       	push	r28
    388e:	df 93       	push	r29
    3890:	cd b7       	in	r28, 0x3d	; 61
    3892:	de b7       	in	r29, 0x3e	; 62
    3894:	2f 97       	sbiw	r28, 0x0f	; 15
    3896:	0f b6       	in	r0, 0x3f	; 63
    3898:	f8 94       	cli
    389a:	de bf       	out	0x3e, r29	; 62
    389c:	0f be       	out	0x3f, r0	; 63
    389e:	cd bf       	out	0x3d, r28	; 61
    38a0:	9b 87       	std	Y+11, r25	; 0x0b
    38a2:	8a 87       	std	Y+10, r24	; 0x0a
    38a4:	7d 87       	std	Y+13, r23	; 0x0d
    38a6:	6c 87       	std	Y+12, r22	; 0x0c
    38a8:	5f 87       	std	Y+15, r21	; 0x0f
    38aa:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    38ac:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    38ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    38b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    38b2:	9b 83       	std	Y+3, r25	; 0x03
    38b4:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    38b6:	0f b6       	in	r0, 0x3f	; 63
    38b8:	f8 94       	cli
    38ba:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    38bc:	8a 81       	ldd	r24, Y+2	; 0x02
    38be:	9b 81       	ldd	r25, Y+3	; 0x03
    38c0:	fc 01       	movw	r30, r24
    38c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    38c4:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    38c6:	8c 81       	ldd	r24, Y+4	; 0x04
    38c8:	88 23       	and	r24, r24
    38ca:	41 f1       	breq	.+80     	; 0x391c <xQueuePeek+0x90>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    38cc:	8a 81       	ldd	r24, Y+2	; 0x02
    38ce:	9b 81       	ldd	r25, Y+3	; 0x03
    38d0:	fc 01       	movw	r30, r24
    38d2:	86 81       	ldd	r24, Z+6	; 0x06
    38d4:	97 81       	ldd	r25, Z+7	; 0x07
    38d6:	9e 83       	std	Y+6, r25	; 0x06
    38d8:	8d 83       	std	Y+5, r24	; 0x05

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    38da:	2c 85       	ldd	r18, Y+12	; 0x0c
    38dc:	3d 85       	ldd	r19, Y+13	; 0x0d
    38de:	8a 81       	ldd	r24, Y+2	; 0x02
    38e0:	9b 81       	ldd	r25, Y+3	; 0x03
    38e2:	b9 01       	movw	r22, r18
    38e4:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    38e8:	8a 81       	ldd	r24, Y+2	; 0x02
    38ea:	9b 81       	ldd	r25, Y+3	; 0x03
    38ec:	2d 81       	ldd	r18, Y+5	; 0x05
    38ee:	3e 81       	ldd	r19, Y+6	; 0x06
    38f0:	fc 01       	movw	r30, r24
    38f2:	37 83       	std	Z+7, r19	; 0x07
    38f4:	26 83       	std	Z+6, r18	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    38f6:	8a 81       	ldd	r24, Y+2	; 0x02
    38f8:	9b 81       	ldd	r25, Y+3	; 0x03
    38fa:	fc 01       	movw	r30, r24
    38fc:	81 89       	ldd	r24, Z+17	; 0x11
    38fe:	88 23       	and	r24, r24
    3900:	49 f0       	breq	.+18     	; 0x3914 <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3902:	8a 81       	ldd	r24, Y+2	; 0x02
    3904:	9b 81       	ldd	r25, Y+3	; 0x03
    3906:	41 96       	adiw	r24, 0x11	; 17
    3908:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    390c:	88 23       	and	r24, r24
    390e:	11 f0       	breq	.+4      	; 0x3914 <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    3910:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3914:	0f 90       	pop	r0
    3916:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3918:	81 e0       	ldi	r24, 0x01	; 1
    391a:	67 c0       	rjmp	.+206    	; 0x39ea <xQueuePeek+0x15e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    391c:	8e 85       	ldd	r24, Y+14	; 0x0e
    391e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3920:	89 2b       	or	r24, r25
    3922:	21 f4       	brne	.+8      	; 0x392c <xQueuePeek+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3924:	0f 90       	pop	r0
    3926:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3928:	80 e0       	ldi	r24, 0x00	; 0
    392a:	5f c0       	rjmp	.+190    	; 0x39ea <xQueuePeek+0x15e>
				}
				else if( xEntryTimeSet == pdFALSE )
    392c:	89 81       	ldd	r24, Y+1	; 0x01
    392e:	88 23       	and	r24, r24
    3930:	31 f4       	brne	.+12     	; 0x393e <xQueuePeek+0xb2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3932:	ce 01       	movw	r24, r28
    3934:	07 96       	adiw	r24, 0x07	; 7
    3936:	0e 94 55 28 	call	0x50aa	; 0x50aa <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    393a:	81 e0       	ldi	r24, 0x01	; 1
    393c:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    393e:	0f 90       	pop	r0
    3940:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3942:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3946:	0f b6       	in	r0, 0x3f	; 63
    3948:	f8 94       	cli
    394a:	0f 92       	push	r0
    394c:	8a 81       	ldd	r24, Y+2	; 0x02
    394e:	9b 81       	ldd	r25, Y+3	; 0x03
    3950:	fc 01       	movw	r30, r24
    3952:	85 8d       	ldd	r24, Z+29	; 0x1d
    3954:	8f 3f       	cpi	r24, 0xFF	; 255
    3956:	21 f4       	brne	.+8      	; 0x3960 <xQueuePeek+0xd4>
    3958:	8a 81       	ldd	r24, Y+2	; 0x02
    395a:	9b 81       	ldd	r25, Y+3	; 0x03
    395c:	fc 01       	movw	r30, r24
    395e:	15 8e       	std	Z+29, r1	; 0x1d
    3960:	8a 81       	ldd	r24, Y+2	; 0x02
    3962:	9b 81       	ldd	r25, Y+3	; 0x03
    3964:	fc 01       	movw	r30, r24
    3966:	86 8d       	ldd	r24, Z+30	; 0x1e
    3968:	8f 3f       	cpi	r24, 0xFF	; 255
    396a:	21 f4       	brne	.+8      	; 0x3974 <xQueuePeek+0xe8>
    396c:	8a 81       	ldd	r24, Y+2	; 0x02
    396e:	9b 81       	ldd	r25, Y+3	; 0x03
    3970:	fc 01       	movw	r30, r24
    3972:	16 8e       	std	Z+30, r1	; 0x1e
    3974:	0f 90       	pop	r0
    3976:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3978:	9e 01       	movw	r18, r28
    397a:	22 5f       	subi	r18, 0xF2	; 242
    397c:	3f 4f       	sbci	r19, 0xFF	; 255
    397e:	ce 01       	movw	r24, r28
    3980:	07 96       	adiw	r24, 0x07	; 7
    3982:	b9 01       	movw	r22, r18
    3984:	0e 94 71 28 	call	0x50e2	; 0x50e2 <xTaskCheckForTimeOut>
    3988:	88 23       	and	r24, r24
    398a:	09 f5       	brne	.+66     	; 0x39ce <xQueuePeek+0x142>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    398c:	8a 81       	ldd	r24, Y+2	; 0x02
    398e:	9b 81       	ldd	r25, Y+3	; 0x03
    3990:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <prvIsQueueEmpty>
    3994:	88 23       	and	r24, r24
    3996:	a1 f0       	breq	.+40     	; 0x39c0 <xQueuePeek+0x134>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3998:	2e 85       	ldd	r18, Y+14	; 0x0e
    399a:	3f 85       	ldd	r19, Y+15	; 0x0f
    399c:	8a 81       	ldd	r24, Y+2	; 0x02
    399e:	9b 81       	ldd	r25, Y+3	; 0x03
    39a0:	41 96       	adiw	r24, 0x11	; 17
    39a2:	b9 01       	movw	r22, r18
    39a4:	0e 94 0e 27 	call	0x4e1c	; 0x4e1c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    39a8:	8a 81       	ldd	r24, Y+2	; 0x02
    39aa:	9b 81       	ldd	r25, Y+3	; 0x03
    39ac:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    39b0:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    39b4:	88 23       	and	r24, r24
    39b6:	09 f0       	breq	.+2      	; 0x39ba <xQueuePeek+0x12e>
    39b8:	7e cf       	rjmp	.-260    	; 0x38b6 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    39ba:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
    39be:	7b cf       	rjmp	.-266    	; 0x38b6 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    39c0:	8a 81       	ldd	r24, Y+2	; 0x02
    39c2:	9b 81       	ldd	r25, Y+3	; 0x03
    39c4:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    39c8:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    39cc:	74 cf       	rjmp	.-280    	; 0x38b6 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    39ce:	8a 81       	ldd	r24, Y+2	; 0x02
    39d0:	9b 81       	ldd	r25, Y+3	; 0x03
    39d2:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    39d6:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    39da:	8a 81       	ldd	r24, Y+2	; 0x02
    39dc:	9b 81       	ldd	r25, Y+3	; 0x03
    39de:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <prvIsQueueEmpty>
    39e2:	88 23       	and	r24, r24
    39e4:	09 f4       	brne	.+2      	; 0x39e8 <xQueuePeek+0x15c>
    39e6:	67 cf       	rjmp	.-306    	; 0x38b6 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    39e8:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    39ea:	2f 96       	adiw	r28, 0x0f	; 15
    39ec:	0f b6       	in	r0, 0x3f	; 63
    39ee:	f8 94       	cli
    39f0:	de bf       	out	0x3e, r29	; 62
    39f2:	0f be       	out	0x3f, r0	; 63
    39f4:	cd bf       	out	0x3d, r28	; 61
    39f6:	df 91       	pop	r29
    39f8:	cf 91       	pop	r28
    39fa:	08 95       	ret

000039fc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    39fc:	cf 93       	push	r28
    39fe:	df 93       	push	r29
    3a00:	cd b7       	in	r28, 0x3d	; 61
    3a02:	de b7       	in	r29, 0x3e	; 62
    3a04:	2c 97       	sbiw	r28, 0x0c	; 12
    3a06:	0f b6       	in	r0, 0x3f	; 63
    3a08:	f8 94       	cli
    3a0a:	de bf       	out	0x3e, r29	; 62
    3a0c:	0f be       	out	0x3f, r0	; 63
    3a0e:	cd bf       	out	0x3d, r28	; 61
    3a10:	98 87       	std	Y+8, r25	; 0x08
    3a12:	8f 83       	std	Y+7, r24	; 0x07
    3a14:	7a 87       	std	Y+10, r23	; 0x0a
    3a16:	69 87       	std	Y+9, r22	; 0x09
    3a18:	5c 87       	std	Y+12, r21	; 0x0c
    3a1a:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3a1c:	8f 81       	ldd	r24, Y+7	; 0x07
    3a1e:	98 85       	ldd	r25, Y+8	; 0x08
    3a20:	9b 83       	std	Y+3, r25	; 0x03
    3a22:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3a24:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3a26:	8a 81       	ldd	r24, Y+2	; 0x02
    3a28:	9b 81       	ldd	r25, Y+3	; 0x03
    3a2a:	fc 01       	movw	r30, r24
    3a2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a2e:	8d 83       	std	Y+5, r24	; 0x05

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a30:	8d 81       	ldd	r24, Y+5	; 0x05
    3a32:	88 23       	and	r24, r24
    3a34:	b9 f1       	breq	.+110    	; 0x3aa4 <xQueueReceiveFromISR+0xa8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    3a36:	8a 81       	ldd	r24, Y+2	; 0x02
    3a38:	9b 81       	ldd	r25, Y+3	; 0x03
    3a3a:	fc 01       	movw	r30, r24
    3a3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a3e:	8e 83       	std	Y+6, r24	; 0x06

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a40:	29 85       	ldd	r18, Y+9	; 0x09
    3a42:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a44:	8a 81       	ldd	r24, Y+2	; 0x02
    3a46:	9b 81       	ldd	r25, Y+3	; 0x03
    3a48:	b9 01       	movw	r22, r18
    3a4a:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3a4e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a50:	2f ef       	ldi	r18, 0xFF	; 255
    3a52:	28 0f       	add	r18, r24
    3a54:	8a 81       	ldd	r24, Y+2	; 0x02
    3a56:	9b 81       	ldd	r25, Y+3	; 0x03
    3a58:	fc 01       	movw	r30, r24
    3a5a:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    3a5c:	8e 81       	ldd	r24, Y+6	; 0x06
    3a5e:	8f 3f       	cpi	r24, 0xFF	; 255
    3a60:	b9 f4       	brne	.+46     	; 0x3a90 <xQueueReceiveFromISR+0x94>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3a62:	8a 81       	ldd	r24, Y+2	; 0x02
    3a64:	9b 81       	ldd	r25, Y+3	; 0x03
    3a66:	fc 01       	movw	r30, r24
    3a68:	80 85       	ldd	r24, Z+8	; 0x08
    3a6a:	88 23       	and	r24, r24
    3a6c:	c1 f0       	breq	.+48     	; 0x3a9e <xQueueReceiveFromISR+0xa2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a70:	9b 81       	ldd	r25, Y+3	; 0x03
    3a72:	08 96       	adiw	r24, 0x08	; 8
    3a74:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    3a78:	88 23       	and	r24, r24
    3a7a:	89 f0       	breq	.+34     	; 0x3a9e <xQueueReceiveFromISR+0xa2>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3a7c:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a7e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a80:	89 2b       	or	r24, r25
    3a82:	69 f0       	breq	.+26     	; 0x3a9e <xQueueReceiveFromISR+0xa2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3a84:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a86:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a88:	21 e0       	ldi	r18, 0x01	; 1
    3a8a:	fc 01       	movw	r30, r24
    3a8c:	20 83       	st	Z, r18
    3a8e:	07 c0       	rjmp	.+14     	; 0x3a9e <xQueueReceiveFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3a90:	8e 81       	ldd	r24, Y+6	; 0x06
    3a92:	8f 5f       	subi	r24, 0xFF	; 255
    3a94:	28 2f       	mov	r18, r24
    3a96:	8a 81       	ldd	r24, Y+2	; 0x02
    3a98:	9b 81       	ldd	r25, Y+3	; 0x03
    3a9a:	fc 01       	movw	r30, r24
    3a9c:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3a9e:	81 e0       	ldi	r24, 0x01	; 1
    3aa0:	89 83       	std	Y+1, r24	; 0x01
    3aa2:	01 c0       	rjmp	.+2      	; 0x3aa6 <xQueueReceiveFromISR+0xaa>
		}
		else
		{
			xReturn = pdFAIL;
    3aa4:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3aa6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3aa8:	2c 96       	adiw	r28, 0x0c	; 12
    3aaa:	0f b6       	in	r0, 0x3f	; 63
    3aac:	f8 94       	cli
    3aae:	de bf       	out	0x3e, r29	; 62
    3ab0:	0f be       	out	0x3f, r0	; 63
    3ab2:	cd bf       	out	0x3d, r28	; 61
    3ab4:	df 91       	pop	r29
    3ab6:	cf 91       	pop	r28
    3ab8:	08 95       	ret

00003aba <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3aba:	cf 93       	push	r28
    3abc:	df 93       	push	r29
    3abe:	cd b7       	in	r28, 0x3d	; 61
    3ac0:	de b7       	in	r29, 0x3e	; 62
    3ac2:	2a 97       	sbiw	r28, 0x0a	; 10
    3ac4:	0f b6       	in	r0, 0x3f	; 63
    3ac6:	f8 94       	cli
    3ac8:	de bf       	out	0x3e, r29	; 62
    3aca:	0f be       	out	0x3f, r0	; 63
    3acc:	cd bf       	out	0x3d, r28	; 61
    3ace:	98 87       	std	Y+8, r25	; 0x08
    3ad0:	8f 83       	std	Y+7, r24	; 0x07
    3ad2:	7a 87       	std	Y+10, r23	; 0x0a
    3ad4:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3ad6:	8f 81       	ldd	r24, Y+7	; 0x07
    3ad8:	98 85       	ldd	r25, Y+8	; 0x08
    3ada:	9b 83       	std	Y+3, r25	; 0x03
    3adc:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3ade:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ae2:	9b 81       	ldd	r25, Y+3	; 0x03
    3ae4:	fc 01       	movw	r30, r24
    3ae6:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ae8:	88 23       	and	r24, r24
    3aea:	c1 f0       	breq	.+48     	; 0x3b1c <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3aec:	8a 81       	ldd	r24, Y+2	; 0x02
    3aee:	9b 81       	ldd	r25, Y+3	; 0x03
    3af0:	fc 01       	movw	r30, r24
    3af2:	86 81       	ldd	r24, Z+6	; 0x06
    3af4:	97 81       	ldd	r25, Z+7	; 0x07
    3af6:	9e 83       	std	Y+6, r25	; 0x06
    3af8:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3afa:	29 85       	ldd	r18, Y+9	; 0x09
    3afc:	3a 85       	ldd	r19, Y+10	; 0x0a
    3afe:	8a 81       	ldd	r24, Y+2	; 0x02
    3b00:	9b 81       	ldd	r25, Y+3	; 0x03
    3b02:	b9 01       	movw	r22, r18
    3b04:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3b08:	8a 81       	ldd	r24, Y+2	; 0x02
    3b0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b0c:	2d 81       	ldd	r18, Y+5	; 0x05
    3b0e:	3e 81       	ldd	r19, Y+6	; 0x06
    3b10:	fc 01       	movw	r30, r24
    3b12:	37 83       	std	Z+7, r19	; 0x07
    3b14:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3b16:	81 e0       	ldi	r24, 0x01	; 1
    3b18:	89 83       	std	Y+1, r24	; 0x01
    3b1a:	01 c0       	rjmp	.+2      	; 0x3b1e <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    3b1c:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b1e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b20:	2a 96       	adiw	r28, 0x0a	; 10
    3b22:	0f b6       	in	r0, 0x3f	; 63
    3b24:	f8 94       	cli
    3b26:	de bf       	out	0x3e, r29	; 62
    3b28:	0f be       	out	0x3f, r0	; 63
    3b2a:	cd bf       	out	0x3d, r28	; 61
    3b2c:	df 91       	pop	r29
    3b2e:	cf 91       	pop	r28
    3b30:	08 95       	ret

00003b32 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3b32:	cf 93       	push	r28
    3b34:	df 93       	push	r29
    3b36:	00 d0       	rcall	.+0      	; 0x3b38 <uxQueueMessagesWaiting+0x6>
    3b38:	1f 92       	push	r1
    3b3a:	cd b7       	in	r28, 0x3d	; 61
    3b3c:	de b7       	in	r29, 0x3e	; 62
    3b3e:	9b 83       	std	Y+3, r25	; 0x03
    3b40:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3b42:	0f b6       	in	r0, 0x3f	; 63
    3b44:	f8 94       	cli
    3b46:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3b48:	8a 81       	ldd	r24, Y+2	; 0x02
    3b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b4c:	fc 01       	movw	r30, r24
    3b4e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b50:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3b52:	0f 90       	pop	r0
    3b54:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3b56:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b58:	0f 90       	pop	r0
    3b5a:	0f 90       	pop	r0
    3b5c:	0f 90       	pop	r0
    3b5e:	df 91       	pop	r29
    3b60:	cf 91       	pop	r28
    3b62:	08 95       	ret

00003b64 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3b64:	cf 93       	push	r28
    3b66:	df 93       	push	r29
    3b68:	00 d0       	rcall	.+0      	; 0x3b6a <uxQueueSpacesAvailable+0x6>
    3b6a:	00 d0       	rcall	.+0      	; 0x3b6c <uxQueueSpacesAvailable+0x8>
    3b6c:	1f 92       	push	r1
    3b6e:	cd b7       	in	r28, 0x3d	; 61
    3b70:	de b7       	in	r29, 0x3e	; 62
    3b72:	9d 83       	std	Y+5, r25	; 0x05
    3b74:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3b76:	8c 81       	ldd	r24, Y+4	; 0x04
    3b78:	9d 81       	ldd	r25, Y+5	; 0x05
    3b7a:	9a 83       	std	Y+2, r25	; 0x02
    3b7c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3b7e:	0f b6       	in	r0, 0x3f	; 63
    3b80:	f8 94       	cli
    3b82:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3b84:	89 81       	ldd	r24, Y+1	; 0x01
    3b86:	9a 81       	ldd	r25, Y+2	; 0x02
    3b88:	fc 01       	movw	r30, r24
    3b8a:	23 8d       	ldd	r18, Z+27	; 0x1b
    3b8c:	89 81       	ldd	r24, Y+1	; 0x01
    3b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b90:	fc 01       	movw	r30, r24
    3b92:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b94:	f2 2f       	mov	r31, r18
    3b96:	f8 1b       	sub	r31, r24
    3b98:	8f 2f       	mov	r24, r31
    3b9a:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3b9c:	0f 90       	pop	r0
    3b9e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3ba0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3ba2:	0f 90       	pop	r0
    3ba4:	0f 90       	pop	r0
    3ba6:	0f 90       	pop	r0
    3ba8:	0f 90       	pop	r0
    3baa:	0f 90       	pop	r0
    3bac:	df 91       	pop	r29
    3bae:	cf 91       	pop	r28
    3bb0:	08 95       	ret

00003bb2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3bb2:	cf 93       	push	r28
    3bb4:	df 93       	push	r29
    3bb6:	00 d0       	rcall	.+0      	; 0x3bb8 <uxQueueMessagesWaitingFromISR+0x6>
    3bb8:	00 d0       	rcall	.+0      	; 0x3bba <uxQueueMessagesWaitingFromISR+0x8>
    3bba:	1f 92       	push	r1
    3bbc:	cd b7       	in	r28, 0x3d	; 61
    3bbe:	de b7       	in	r29, 0x3e	; 62
    3bc0:	9d 83       	std	Y+5, r25	; 0x05
    3bc2:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3bc4:	8c 81       	ldd	r24, Y+4	; 0x04
    3bc6:	9d 81       	ldd	r25, Y+5	; 0x05
    3bc8:	9a 83       	std	Y+2, r25	; 0x02
    3bca:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3bcc:	89 81       	ldd	r24, Y+1	; 0x01
    3bce:	9a 81       	ldd	r25, Y+2	; 0x02
    3bd0:	fc 01       	movw	r30, r24
    3bd2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bd4:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3bd6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3bd8:	0f 90       	pop	r0
    3bda:	0f 90       	pop	r0
    3bdc:	0f 90       	pop	r0
    3bde:	0f 90       	pop	r0
    3be0:	0f 90       	pop	r0
    3be2:	df 91       	pop	r29
    3be4:	cf 91       	pop	r28
    3be6:	08 95       	ret

00003be8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3be8:	cf 93       	push	r28
    3bea:	df 93       	push	r29
    3bec:	00 d0       	rcall	.+0      	; 0x3bee <vQueueDelete+0x6>
    3bee:	00 d0       	rcall	.+0      	; 0x3bf0 <vQueueDelete+0x8>
    3bf0:	cd b7       	in	r28, 0x3d	; 61
    3bf2:	de b7       	in	r29, 0x3e	; 62
    3bf4:	9c 83       	std	Y+4, r25	; 0x04
    3bf6:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    3bfc:	9a 83       	std	Y+2, r25	; 0x02
    3bfe:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3c00:	89 81       	ldd	r24, Y+1	; 0x01
    3c02:	9a 81       	ldd	r25, Y+2	; 0x02
    3c04:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3c08:	00 00       	nop
    3c0a:	0f 90       	pop	r0
    3c0c:	0f 90       	pop	r0
    3c0e:	0f 90       	pop	r0
    3c10:	0f 90       	pop	r0
    3c12:	df 91       	pop	r29
    3c14:	cf 91       	pop	r28
    3c16:	08 95       	ret

00003c18 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    3c18:	cf 93       	push	r28
    3c1a:	df 93       	push	r29
    3c1c:	00 d0       	rcall	.+0      	; 0x3c1e <prvGetDisinheritPriorityAfterTimeout+0x6>
    3c1e:	1f 92       	push	r1
    3c20:	cd b7       	in	r28, 0x3d	; 61
    3c22:	de b7       	in	r29, 0x3e	; 62
    3c24:	9b 83       	std	Y+3, r25	; 0x03
    3c26:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    3c28:	8a 81       	ldd	r24, Y+2	; 0x02
    3c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c2c:	fc 01       	movw	r30, r24
    3c2e:	81 89       	ldd	r24, Z+17	; 0x11
    3c30:	88 23       	and	r24, r24
    3c32:	69 f0       	breq	.+26     	; 0x3c4e <prvGetDisinheritPriorityAfterTimeout+0x36>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    3c34:	8a 81       	ldd	r24, Y+2	; 0x02
    3c36:	9b 81       	ldd	r25, Y+3	; 0x03
    3c38:	fc 01       	movw	r30, r24
    3c3a:	86 89       	ldd	r24, Z+22	; 0x16
    3c3c:	97 89       	ldd	r25, Z+23	; 0x17
    3c3e:	fc 01       	movw	r30, r24
    3c40:	80 81       	ld	r24, Z
    3c42:	91 81       	ldd	r25, Z+1	; 0x01
    3c44:	98 2f       	mov	r25, r24
    3c46:	85 e0       	ldi	r24, 0x05	; 5
    3c48:	89 1b       	sub	r24, r25
    3c4a:	89 83       	std	Y+1, r24	; 0x01
    3c4c:	01 c0       	rjmp	.+2      	; 0x3c50 <prvGetDisinheritPriorityAfterTimeout+0x38>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    3c4e:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    3c50:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3c52:	0f 90       	pop	r0
    3c54:	0f 90       	pop	r0
    3c56:	0f 90       	pop	r0
    3c58:	df 91       	pop	r29
    3c5a:	cf 91       	pop	r28
    3c5c:	08 95       	ret

00003c5e <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3c5e:	cf 93       	push	r28
    3c60:	df 93       	push	r29
    3c62:	cd b7       	in	r28, 0x3d	; 61
    3c64:	de b7       	in	r29, 0x3e	; 62
    3c66:	27 97       	sbiw	r28, 0x07	; 7
    3c68:	0f b6       	in	r0, 0x3f	; 63
    3c6a:	f8 94       	cli
    3c6c:	de bf       	out	0x3e, r29	; 62
    3c6e:	0f be       	out	0x3f, r0	; 63
    3c70:	cd bf       	out	0x3d, r28	; 61
    3c72:	9c 83       	std	Y+4, r25	; 0x04
    3c74:	8b 83       	std	Y+3, r24	; 0x03
    3c76:	7e 83       	std	Y+6, r23	; 0x06
    3c78:	6d 83       	std	Y+5, r22	; 0x05
    3c7a:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3c7c:	19 82       	std	Y+1, r1	; 0x01
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c80:	9c 81       	ldd	r25, Y+4	; 0x04
    3c82:	fc 01       	movw	r30, r24
    3c84:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c86:	8a 83       	std	Y+2, r24	; 0x02

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3c88:	8b 81       	ldd	r24, Y+3	; 0x03
    3c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c8c:	fc 01       	movw	r30, r24
    3c8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c90:	88 23       	and	r24, r24
    3c92:	b1 f4       	brne	.+44     	; 0x3cc0 <prvCopyDataToQueue+0x62>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3c94:	8b 81       	ldd	r24, Y+3	; 0x03
    3c96:	9c 81       	ldd	r25, Y+4	; 0x04
    3c98:	fc 01       	movw	r30, r24
    3c9a:	80 81       	ld	r24, Z
    3c9c:	91 81       	ldd	r25, Z+1	; 0x01
    3c9e:	89 2b       	or	r24, r25
    3ca0:	09 f0       	breq	.+2      	; 0x3ca4 <prvCopyDataToQueue+0x46>
    3ca2:	9c c0       	rjmp	.+312    	; 0x3ddc <prvCopyDataToQueue+0x17e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    3ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ca8:	fc 01       	movw	r30, r24
    3caa:	84 81       	ldd	r24, Z+4	; 0x04
    3cac:	95 81       	ldd	r25, Z+5	; 0x05
    3cae:	0e 94 77 2a 	call	0x54ee	; 0x54ee <xTaskPriorityDisinherit>
    3cb2:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    3cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb8:	fc 01       	movw	r30, r24
    3cba:	15 82       	std	Z+5, r1	; 0x05
    3cbc:	14 82       	std	Z+4, r1	; 0x04
    3cbe:	8e c0       	rjmp	.+284    	; 0x3ddc <prvCopyDataToQueue+0x17e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    3cc2:	88 23       	and	r24, r24
    3cc4:	d9 f5       	brne	.+118    	; 0x3d3c <prvCopyDataToQueue+0xde>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cca:	fc 01       	movw	r30, r24
    3ccc:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cce:	48 2f       	mov	r20, r24
    3cd0:	50 e0       	ldi	r21, 0x00	; 0
    3cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd6:	fc 01       	movw	r30, r24
    3cd8:	82 81       	ldd	r24, Z+2	; 0x02
    3cda:	93 81       	ldd	r25, Z+3	; 0x03
    3cdc:	2d 81       	ldd	r18, Y+5	; 0x05
    3cde:	3e 81       	ldd	r19, Y+6	; 0x06
    3ce0:	b9 01       	movw	r22, r18
    3ce2:	0e 94 19 32 	call	0x6432	; 0x6432 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cea:	fc 01       	movw	r30, r24
    3cec:	22 81       	ldd	r18, Z+2	; 0x02
    3cee:	33 81       	ldd	r19, Z+3	; 0x03
    3cf0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf2:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf4:	fc 01       	movw	r30, r24
    3cf6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cf8:	88 2f       	mov	r24, r24
    3cfa:	90 e0       	ldi	r25, 0x00	; 0
    3cfc:	28 0f       	add	r18, r24
    3cfe:	39 1f       	adc	r19, r25
    3d00:	8b 81       	ldd	r24, Y+3	; 0x03
    3d02:	9c 81       	ldd	r25, Y+4	; 0x04
    3d04:	fc 01       	movw	r30, r24
    3d06:	33 83       	std	Z+3, r19	; 0x03
    3d08:	22 83       	std	Z+2, r18	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d0e:	fc 01       	movw	r30, r24
    3d10:	22 81       	ldd	r18, Z+2	; 0x02
    3d12:	33 81       	ldd	r19, Z+3	; 0x03
    3d14:	8b 81       	ldd	r24, Y+3	; 0x03
    3d16:	9c 81       	ldd	r25, Y+4	; 0x04
    3d18:	fc 01       	movw	r30, r24
    3d1a:	84 81       	ldd	r24, Z+4	; 0x04
    3d1c:	95 81       	ldd	r25, Z+5	; 0x05
    3d1e:	28 17       	cp	r18, r24
    3d20:	39 07       	cpc	r19, r25
    3d22:	08 f4       	brcc	.+2      	; 0x3d26 <prvCopyDataToQueue+0xc8>
    3d24:	5b c0       	rjmp	.+182    	; 0x3ddc <prvCopyDataToQueue+0x17e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3d26:	8b 81       	ldd	r24, Y+3	; 0x03
    3d28:	9c 81       	ldd	r25, Y+4	; 0x04
    3d2a:	fc 01       	movw	r30, r24
    3d2c:	20 81       	ld	r18, Z
    3d2e:	31 81       	ldd	r19, Z+1	; 0x01
    3d30:	8b 81       	ldd	r24, Y+3	; 0x03
    3d32:	9c 81       	ldd	r25, Y+4	; 0x04
    3d34:	fc 01       	movw	r30, r24
    3d36:	33 83       	std	Z+3, r19	; 0x03
    3d38:	22 83       	std	Z+2, r18	; 0x02
    3d3a:	50 c0       	rjmp	.+160    	; 0x3ddc <prvCopyDataToQueue+0x17e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d40:	fc 01       	movw	r30, r24
    3d42:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d44:	48 2f       	mov	r20, r24
    3d46:	50 e0       	ldi	r21, 0x00	; 0
    3d48:	8b 81       	ldd	r24, Y+3	; 0x03
    3d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d4c:	fc 01       	movw	r30, r24
    3d4e:	86 81       	ldd	r24, Z+6	; 0x06
    3d50:	97 81       	ldd	r25, Z+7	; 0x07
    3d52:	2d 81       	ldd	r18, Y+5	; 0x05
    3d54:	3e 81       	ldd	r19, Y+6	; 0x06
    3d56:	b9 01       	movw	r22, r18
    3d58:	0e 94 19 32 	call	0x6432	; 0x6432 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d60:	fc 01       	movw	r30, r24
    3d62:	26 81       	ldd	r18, Z+6	; 0x06
    3d64:	37 81       	ldd	r19, Z+7	; 0x07
    3d66:	8b 81       	ldd	r24, Y+3	; 0x03
    3d68:	9c 81       	ldd	r25, Y+4	; 0x04
    3d6a:	fc 01       	movw	r30, r24
    3d6c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d6e:	88 2f       	mov	r24, r24
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	91 95       	neg	r25
    3d74:	81 95       	neg	r24
    3d76:	91 09       	sbc	r25, r1
    3d78:	28 0f       	add	r18, r24
    3d7a:	39 1f       	adc	r19, r25
    3d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d80:	fc 01       	movw	r30, r24
    3d82:	37 83       	std	Z+7, r19	; 0x07
    3d84:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d86:	8b 81       	ldd	r24, Y+3	; 0x03
    3d88:	9c 81       	ldd	r25, Y+4	; 0x04
    3d8a:	fc 01       	movw	r30, r24
    3d8c:	26 81       	ldd	r18, Z+6	; 0x06
    3d8e:	37 81       	ldd	r19, Z+7	; 0x07
    3d90:	8b 81       	ldd	r24, Y+3	; 0x03
    3d92:	9c 81       	ldd	r25, Y+4	; 0x04
    3d94:	fc 01       	movw	r30, r24
    3d96:	80 81       	ld	r24, Z
    3d98:	91 81       	ldd	r25, Z+1	; 0x01
    3d9a:	28 17       	cp	r18, r24
    3d9c:	39 07       	cpc	r19, r25
    3d9e:	a8 f4       	brcc	.+42     	; 0x3dca <prvCopyDataToQueue+0x16c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3da0:	8b 81       	ldd	r24, Y+3	; 0x03
    3da2:	9c 81       	ldd	r25, Y+4	; 0x04
    3da4:	fc 01       	movw	r30, r24
    3da6:	24 81       	ldd	r18, Z+4	; 0x04
    3da8:	35 81       	ldd	r19, Z+5	; 0x05
    3daa:	8b 81       	ldd	r24, Y+3	; 0x03
    3dac:	9c 81       	ldd	r25, Y+4	; 0x04
    3dae:	fc 01       	movw	r30, r24
    3db0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3db2:	88 2f       	mov	r24, r24
    3db4:	90 e0       	ldi	r25, 0x00	; 0
    3db6:	91 95       	neg	r25
    3db8:	81 95       	neg	r24
    3dba:	91 09       	sbc	r25, r1
    3dbc:	28 0f       	add	r18, r24
    3dbe:	39 1f       	adc	r19, r25
    3dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3dc4:	fc 01       	movw	r30, r24
    3dc6:	37 83       	std	Z+7, r19	; 0x07
    3dc8:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3dca:	8f 81       	ldd	r24, Y+7	; 0x07
    3dcc:	82 30       	cpi	r24, 0x02	; 2
    3dce:	31 f4       	brne	.+12     	; 0x3ddc <prvCopyDataToQueue+0x17e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd2:	88 23       	and	r24, r24
    3dd4:	19 f0       	breq	.+6      	; 0x3ddc <prvCopyDataToQueue+0x17e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd8:	81 50       	subi	r24, 0x01	; 1
    3dda:	8a 83       	std	Y+2, r24	; 0x02
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3ddc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dde:	21 e0       	ldi	r18, 0x01	; 1
    3de0:	28 0f       	add	r18, r24
    3de2:	8b 81       	ldd	r24, Y+3	; 0x03
    3de4:	9c 81       	ldd	r25, Y+4	; 0x04
    3de6:	fc 01       	movw	r30, r24
    3de8:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3dea:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dec:	27 96       	adiw	r28, 0x07	; 7
    3dee:	0f b6       	in	r0, 0x3f	; 63
    3df0:	f8 94       	cli
    3df2:	de bf       	out	0x3e, r29	; 62
    3df4:	0f be       	out	0x3f, r0	; 63
    3df6:	cd bf       	out	0x3d, r28	; 61
    3df8:	df 91       	pop	r29
    3dfa:	cf 91       	pop	r28
    3dfc:	08 95       	ret

00003dfe <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3dfe:	cf 93       	push	r28
    3e00:	df 93       	push	r29
    3e02:	00 d0       	rcall	.+0      	; 0x3e04 <prvCopyDataFromQueue+0x6>
    3e04:	00 d0       	rcall	.+0      	; 0x3e06 <prvCopyDataFromQueue+0x8>
    3e06:	cd b7       	in	r28, 0x3d	; 61
    3e08:	de b7       	in	r29, 0x3e	; 62
    3e0a:	9a 83       	std	Y+2, r25	; 0x02
    3e0c:	89 83       	std	Y+1, r24	; 0x01
    3e0e:	7c 83       	std	Y+4, r23	; 0x04
    3e10:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3e12:	89 81       	ldd	r24, Y+1	; 0x01
    3e14:	9a 81       	ldd	r25, Y+2	; 0x02
    3e16:	fc 01       	movw	r30, r24
    3e18:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e1a:	88 23       	and	r24, r24
    3e1c:	c9 f1       	breq	.+114    	; 0x3e90 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3e1e:	89 81       	ldd	r24, Y+1	; 0x01
    3e20:	9a 81       	ldd	r25, Y+2	; 0x02
    3e22:	fc 01       	movw	r30, r24
    3e24:	26 81       	ldd	r18, Z+6	; 0x06
    3e26:	37 81       	ldd	r19, Z+7	; 0x07
    3e28:	89 81       	ldd	r24, Y+1	; 0x01
    3e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e2c:	fc 01       	movw	r30, r24
    3e2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e30:	88 2f       	mov	r24, r24
    3e32:	90 e0       	ldi	r25, 0x00	; 0
    3e34:	28 0f       	add	r18, r24
    3e36:	39 1f       	adc	r19, r25
    3e38:	89 81       	ldd	r24, Y+1	; 0x01
    3e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e3c:	fc 01       	movw	r30, r24
    3e3e:	37 83       	std	Z+7, r19	; 0x07
    3e40:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3e42:	89 81       	ldd	r24, Y+1	; 0x01
    3e44:	9a 81       	ldd	r25, Y+2	; 0x02
    3e46:	fc 01       	movw	r30, r24
    3e48:	26 81       	ldd	r18, Z+6	; 0x06
    3e4a:	37 81       	ldd	r19, Z+7	; 0x07
    3e4c:	89 81       	ldd	r24, Y+1	; 0x01
    3e4e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e50:	fc 01       	movw	r30, r24
    3e52:	84 81       	ldd	r24, Z+4	; 0x04
    3e54:	95 81       	ldd	r25, Z+5	; 0x05
    3e56:	28 17       	cp	r18, r24
    3e58:	39 07       	cpc	r19, r25
    3e5a:	50 f0       	brcs	.+20     	; 0x3e70 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
    3e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e60:	fc 01       	movw	r30, r24
    3e62:	20 81       	ld	r18, Z
    3e64:	31 81       	ldd	r19, Z+1	; 0x01
    3e66:	89 81       	ldd	r24, Y+1	; 0x01
    3e68:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6a:	fc 01       	movw	r30, r24
    3e6c:	37 83       	std	Z+7, r19	; 0x07
    3e6e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	9a 81       	ldd	r25, Y+2	; 0x02
    3e74:	fc 01       	movw	r30, r24
    3e76:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e78:	48 2f       	mov	r20, r24
    3e7a:	50 e0       	ldi	r21, 0x00	; 0
    3e7c:	89 81       	ldd	r24, Y+1	; 0x01
    3e7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e80:	fc 01       	movw	r30, r24
    3e82:	26 81       	ldd	r18, Z+6	; 0x06
    3e84:	37 81       	ldd	r19, Z+7	; 0x07
    3e86:	8b 81       	ldd	r24, Y+3	; 0x03
    3e88:	9c 81       	ldd	r25, Y+4	; 0x04
    3e8a:	b9 01       	movw	r22, r18
    3e8c:	0e 94 19 32 	call	0x6432	; 0x6432 <memcpy>
	}
}
    3e90:	00 00       	nop
    3e92:	0f 90       	pop	r0
    3e94:	0f 90       	pop	r0
    3e96:	0f 90       	pop	r0
    3e98:	0f 90       	pop	r0
    3e9a:	df 91       	pop	r29
    3e9c:	cf 91       	pop	r28
    3e9e:	08 95       	ret

00003ea0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3ea0:	cf 93       	push	r28
    3ea2:	df 93       	push	r29
    3ea4:	00 d0       	rcall	.+0      	; 0x3ea6 <prvUnlockQueue+0x6>
    3ea6:	00 d0       	rcall	.+0      	; 0x3ea8 <prvUnlockQueue+0x8>
    3ea8:	cd b7       	in	r28, 0x3d	; 61
    3eaa:	de b7       	in	r29, 0x3e	; 62
    3eac:	9c 83       	std	Y+4, r25	; 0x04
    3eae:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3eb0:	0f b6       	in	r0, 0x3f	; 63
    3eb2:	f8 94       	cli
    3eb4:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3eb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3eba:	fc 01       	movw	r30, r24
    3ebc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ebe:	89 83       	std	Y+1, r24	; 0x01

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3ec0:	12 c0       	rjmp	.+36     	; 0x3ee6 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ec6:	fc 01       	movw	r30, r24
    3ec8:	81 89       	ldd	r24, Z+17	; 0x11
    3eca:	88 23       	and	r24, r24
    3ecc:	81 f0       	breq	.+32     	; 0x3eee <prvUnlockQueue+0x4e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ece:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ed2:	41 96       	adiw	r24, 0x11	; 17
    3ed4:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    3ed8:	88 23       	and	r24, r24
    3eda:	11 f0       	breq	.+4      	; 0x3ee0 <prvUnlockQueue+0x40>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3edc:	0e 94 e4 28 	call	0x51c8	; 0x51c8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3ee0:	89 81       	ldd	r24, Y+1	; 0x01
    3ee2:	81 50       	subi	r24, 0x01	; 1
    3ee4:	89 83       	std	Y+1, r24	; 0x01
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3ee6:	89 81       	ldd	r24, Y+1	; 0x01
    3ee8:	18 16       	cp	r1, r24
    3eea:	5c f3       	brlt	.-42     	; 0x3ec2 <prvUnlockQueue+0x22>
    3eec:	01 c0       	rjmp	.+2      	; 0x3ef0 <prvUnlockQueue+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3eee:	00 00       	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef4:	2f ef       	ldi	r18, 0xFF	; 255
    3ef6:	fc 01       	movw	r30, r24
    3ef8:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3efa:	0f 90       	pop	r0
    3efc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3efe:	0f b6       	in	r0, 0x3f	; 63
    3f00:	f8 94       	cli
    3f02:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3f04:	8b 81       	ldd	r24, Y+3	; 0x03
    3f06:	9c 81       	ldd	r25, Y+4	; 0x04
    3f08:	fc 01       	movw	r30, r24
    3f0a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f0c:	8a 83       	std	Y+2, r24	; 0x02

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3f0e:	12 c0       	rjmp	.+36     	; 0x3f34 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f10:	8b 81       	ldd	r24, Y+3	; 0x03
    3f12:	9c 81       	ldd	r25, Y+4	; 0x04
    3f14:	fc 01       	movw	r30, r24
    3f16:	80 85       	ldd	r24, Z+8	; 0x08
    3f18:	88 23       	and	r24, r24
    3f1a:	81 f0       	breq	.+32     	; 0x3f3c <prvUnlockQueue+0x9c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3f1c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f1e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f20:	08 96       	adiw	r24, 0x08	; 8
    3f22:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskRemoveFromEventList>
    3f26:	88 23       	and	r24, r24
    3f28:	11 f0       	breq	.+4      	; 0x3f2e <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    3f2a:	0e 94 e4 28 	call	0x51c8	; 0x51c8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f30:	81 50       	subi	r24, 0x01	; 1
    3f32:	8a 83       	std	Y+2, r24	; 0x02
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3f34:	8a 81       	ldd	r24, Y+2	; 0x02
    3f36:	18 16       	cp	r1, r24
    3f38:	5c f3       	brlt	.-42     	; 0x3f10 <prvUnlockQueue+0x70>
    3f3a:	01 c0       	rjmp	.+2      	; 0x3f3e <prvUnlockQueue+0x9e>

				--cRxLock;
			}
			else
			{
				break;
    3f3c:	00 00       	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f40:	9c 81       	ldd	r25, Y+4	; 0x04
    3f42:	2f ef       	ldi	r18, 0xFF	; 255
    3f44:	fc 01       	movw	r30, r24
    3f46:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    3f48:	0f 90       	pop	r0
    3f4a:	0f be       	out	0x3f, r0	; 63
}
    3f4c:	00 00       	nop
    3f4e:	0f 90       	pop	r0
    3f50:	0f 90       	pop	r0
    3f52:	0f 90       	pop	r0
    3f54:	0f 90       	pop	r0
    3f56:	df 91       	pop	r29
    3f58:	cf 91       	pop	r28
    3f5a:	08 95       	ret

00003f5c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3f5c:	cf 93       	push	r28
    3f5e:	df 93       	push	r29
    3f60:	00 d0       	rcall	.+0      	; 0x3f62 <prvIsQueueEmpty+0x6>
    3f62:	1f 92       	push	r1
    3f64:	cd b7       	in	r28, 0x3d	; 61
    3f66:	de b7       	in	r29, 0x3e	; 62
    3f68:	9b 83       	std	Y+3, r25	; 0x03
    3f6a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3f6c:	0f b6       	in	r0, 0x3f	; 63
    3f6e:	f8 94       	cli
    3f70:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3f72:	8a 81       	ldd	r24, Y+2	; 0x02
    3f74:	9b 81       	ldd	r25, Y+3	; 0x03
    3f76:	fc 01       	movw	r30, r24
    3f78:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f7a:	88 23       	and	r24, r24
    3f7c:	19 f4       	brne	.+6      	; 0x3f84 <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    3f7e:	81 e0       	ldi	r24, 0x01	; 1
    3f80:	89 83       	std	Y+1, r24	; 0x01
    3f82:	01 c0       	rjmp	.+2      	; 0x3f86 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    3f84:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3f86:	0f 90       	pop	r0
    3f88:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f8a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f8c:	0f 90       	pop	r0
    3f8e:	0f 90       	pop	r0
    3f90:	0f 90       	pop	r0
    3f92:	df 91       	pop	r29
    3f94:	cf 91       	pop	r28
    3f96:	08 95       	ret

00003f98 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3f98:	cf 93       	push	r28
    3f9a:	df 93       	push	r29
    3f9c:	00 d0       	rcall	.+0      	; 0x3f9e <xQueueIsQueueEmptyFromISR+0x6>
    3f9e:	00 d0       	rcall	.+0      	; 0x3fa0 <xQueueIsQueueEmptyFromISR+0x8>
    3fa0:	1f 92       	push	r1
    3fa2:	cd b7       	in	r28, 0x3d	; 61
    3fa4:	de b7       	in	r29, 0x3e	; 62
    3fa6:	9d 83       	std	Y+5, r25	; 0x05
    3fa8:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3faa:	8c 81       	ldd	r24, Y+4	; 0x04
    3fac:	9d 81       	ldd	r25, Y+5	; 0x05
    3fae:	9b 83       	std	Y+3, r25	; 0x03
    3fb0:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3fb2:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb4:	9b 81       	ldd	r25, Y+3	; 0x03
    3fb6:	fc 01       	movw	r30, r24
    3fb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3fba:	88 23       	and	r24, r24
    3fbc:	19 f4       	brne	.+6      	; 0x3fc4 <xQueueIsQueueEmptyFromISR+0x2c>
	{
		xReturn = pdTRUE;
    3fbe:	81 e0       	ldi	r24, 0x01	; 1
    3fc0:	89 83       	std	Y+1, r24	; 0x01
    3fc2:	01 c0       	rjmp	.+2      	; 0x3fc6 <xQueueIsQueueEmptyFromISR+0x2e>
	}
	else
	{
		xReturn = pdFALSE;
    3fc4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3fc6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3fc8:	0f 90       	pop	r0
    3fca:	0f 90       	pop	r0
    3fcc:	0f 90       	pop	r0
    3fce:	0f 90       	pop	r0
    3fd0:	0f 90       	pop	r0
    3fd2:	df 91       	pop	r29
    3fd4:	cf 91       	pop	r28
    3fd6:	08 95       	ret

00003fd8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3fd8:	cf 93       	push	r28
    3fda:	df 93       	push	r29
    3fdc:	00 d0       	rcall	.+0      	; 0x3fde <prvIsQueueFull+0x6>
    3fde:	1f 92       	push	r1
    3fe0:	cd b7       	in	r28, 0x3d	; 61
    3fe2:	de b7       	in	r29, 0x3e	; 62
    3fe4:	9b 83       	std	Y+3, r25	; 0x03
    3fe6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3fe8:	0f b6       	in	r0, 0x3f	; 63
    3fea:	f8 94       	cli
    3fec:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3fee:	8a 81       	ldd	r24, Y+2	; 0x02
    3ff0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ff2:	fc 01       	movw	r30, r24
    3ff4:	22 8d       	ldd	r18, Z+26	; 0x1a
    3ff6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ff8:	9b 81       	ldd	r25, Y+3	; 0x03
    3ffa:	fc 01       	movw	r30, r24
    3ffc:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ffe:	28 17       	cp	r18, r24
    4000:	19 f4       	brne	.+6      	; 0x4008 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    4002:	81 e0       	ldi	r24, 0x01	; 1
    4004:	89 83       	std	Y+1, r24	; 0x01
    4006:	01 c0       	rjmp	.+2      	; 0x400a <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    4008:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    400a:	0f 90       	pop	r0
    400c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    400e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4010:	0f 90       	pop	r0
    4012:	0f 90       	pop	r0
    4014:	0f 90       	pop	r0
    4016:	df 91       	pop	r29
    4018:	cf 91       	pop	r28
    401a:	08 95       	ret

0000401c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    401c:	cf 93       	push	r28
    401e:	df 93       	push	r29
    4020:	00 d0       	rcall	.+0      	; 0x4022 <xQueueIsQueueFullFromISR+0x6>
    4022:	00 d0       	rcall	.+0      	; 0x4024 <xQueueIsQueueFullFromISR+0x8>
    4024:	1f 92       	push	r1
    4026:	cd b7       	in	r28, 0x3d	; 61
    4028:	de b7       	in	r29, 0x3e	; 62
    402a:	9d 83       	std	Y+5, r25	; 0x05
    402c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    402e:	8c 81       	ldd	r24, Y+4	; 0x04
    4030:	9d 81       	ldd	r25, Y+5	; 0x05
    4032:	9b 83       	std	Y+3, r25	; 0x03
    4034:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4036:	8a 81       	ldd	r24, Y+2	; 0x02
    4038:	9b 81       	ldd	r25, Y+3	; 0x03
    403a:	fc 01       	movw	r30, r24
    403c:	22 8d       	ldd	r18, Z+26	; 0x1a
    403e:	8a 81       	ldd	r24, Y+2	; 0x02
    4040:	9b 81       	ldd	r25, Y+3	; 0x03
    4042:	fc 01       	movw	r30, r24
    4044:	83 8d       	ldd	r24, Z+27	; 0x1b
    4046:	28 17       	cp	r18, r24
    4048:	19 f4       	brne	.+6      	; 0x4050 <xQueueIsQueueFullFromISR+0x34>
	{
		xReturn = pdTRUE;
    404a:	81 e0       	ldi	r24, 0x01	; 1
    404c:	89 83       	std	Y+1, r24	; 0x01
    404e:	01 c0       	rjmp	.+2      	; 0x4052 <xQueueIsQueueFullFromISR+0x36>
	}
	else
	{
		xReturn = pdFALSE;
    4050:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4052:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4054:	0f 90       	pop	r0
    4056:	0f 90       	pop	r0
    4058:	0f 90       	pop	r0
    405a:	0f 90       	pop	r0
    405c:	0f 90       	pop	r0
    405e:	df 91       	pop	r29
    4060:	cf 91       	pop	r28
    4062:	08 95       	ret

00004064 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4064:	8f 92       	push	r8
    4066:	9f 92       	push	r9
    4068:	af 92       	push	r10
    406a:	bf 92       	push	r11
    406c:	cf 92       	push	r12
    406e:	df 92       	push	r13
    4070:	ef 92       	push	r14
    4072:	ff 92       	push	r15
    4074:	0f 93       	push	r16
    4076:	1f 93       	push	r17
    4078:	cf 93       	push	r28
    407a:	df 93       	push	r29
    407c:	cd b7       	in	r28, 0x3d	; 61
    407e:	de b7       	in	r29, 0x3e	; 62
    4080:	60 97       	sbiw	r28, 0x10	; 16
    4082:	0f b6       	in	r0, 0x3f	; 63
    4084:	f8 94       	cli
    4086:	de bf       	out	0x3e, r29	; 62
    4088:	0f be       	out	0x3f, r0	; 63
    408a:	cd bf       	out	0x3d, r28	; 61
    408c:	9f 83       	std	Y+7, r25	; 0x07
    408e:	8e 83       	std	Y+6, r24	; 0x06
    4090:	79 87       	std	Y+9, r23	; 0x09
    4092:	68 87       	std	Y+8, r22	; 0x08
    4094:	5b 87       	std	Y+11, r21	; 0x0b
    4096:	4a 87       	std	Y+10, r20	; 0x0a
    4098:	3d 87       	std	Y+13, r19	; 0x0d
    409a:	2c 87       	std	Y+12, r18	; 0x0c
    409c:	0e 87       	std	Y+14, r16	; 0x0e
    409e:	f8 8a       	std	Y+16, r15	; 0x10
    40a0:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    40a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    40a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    40a6:	0e 94 a2 12 	call	0x2544	; 0x2544 <pvPortMalloc>
    40aa:	9d 83       	std	Y+5, r25	; 0x05
    40ac:	8c 83       	std	Y+4, r24	; 0x04

			if( pxStack != NULL )
    40ae:	8c 81       	ldd	r24, Y+4	; 0x04
    40b0:	9d 81       	ldd	r25, Y+5	; 0x05
    40b2:	89 2b       	or	r24, r25
    40b4:	b9 f0       	breq	.+46     	; 0x40e4 <xTaskCreate+0x80>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    40b6:	88 e2       	ldi	r24, 0x28	; 40
    40b8:	90 e0       	ldi	r25, 0x00	; 0
    40ba:	0e 94 a2 12 	call	0x2544	; 0x2544 <pvPortMalloc>
    40be:	9a 83       	std	Y+2, r25	; 0x02
    40c0:	89 83       	std	Y+1, r24	; 0x01

				if( pxNewTCB != NULL )
    40c2:	89 81       	ldd	r24, Y+1	; 0x01
    40c4:	9a 81       	ldd	r25, Y+2	; 0x02
    40c6:	89 2b       	or	r24, r25
    40c8:	41 f0       	breq	.+16     	; 0x40da <xTaskCreate+0x76>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    40ca:	89 81       	ldd	r24, Y+1	; 0x01
    40cc:	9a 81       	ldd	r25, Y+2	; 0x02
    40ce:	2c 81       	ldd	r18, Y+4	; 0x04
    40d0:	3d 81       	ldd	r19, Y+5	; 0x05
    40d2:	fc 01       	movw	r30, r24
    40d4:	30 8f       	std	Z+24, r19	; 0x18
    40d6:	27 8b       	std	Z+23, r18	; 0x17
    40d8:	07 c0       	rjmp	.+14     	; 0x40e8 <xTaskCreate+0x84>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    40da:	8c 81       	ldd	r24, Y+4	; 0x04
    40dc:	9d 81       	ldd	r25, Y+5	; 0x05
    40de:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vPortFree>
    40e2:	02 c0       	rjmp	.+4      	; 0x40e8 <xTaskCreate+0x84>
				}
			}
			else
			{
				pxNewTCB = NULL;
    40e4:	1a 82       	std	Y+2, r1	; 0x02
    40e6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    40e8:	89 81       	ldd	r24, Y+1	; 0x01
    40ea:	9a 81       	ldd	r25, Y+2	; 0x02
    40ec:	89 2b       	or	r24, r25
    40ee:	09 f1       	breq	.+66     	; 0x4132 <xTaskCreate+0xce>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    40f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    40f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    40f4:	cc 01       	movw	r24, r24
    40f6:	a0 e0       	ldi	r26, 0x00	; 0
    40f8:	b0 e0       	ldi	r27, 0x00	; 0
    40fa:	09 81       	ldd	r16, Y+1	; 0x01
    40fc:	1a 81       	ldd	r17, Y+2	; 0x02
    40fe:	4f 85       	ldd	r20, Y+15	; 0x0f
    4100:	58 89       	ldd	r21, Y+16	; 0x10
    4102:	2c 85       	ldd	r18, Y+12	; 0x0c
    4104:	3d 85       	ldd	r19, Y+13	; 0x0d
    4106:	68 85       	ldd	r22, Y+8	; 0x08
    4108:	79 85       	ldd	r23, Y+9	; 0x09
    410a:	ee 81       	ldd	r30, Y+6	; 0x06
    410c:	ff 81       	ldd	r31, Y+7	; 0x07
    410e:	81 2c       	mov	r8, r1
    4110:	91 2c       	mov	r9, r1
    4112:	58 01       	movw	r10, r16
    4114:	6a 01       	movw	r12, r20
    4116:	ee 84       	ldd	r14, Y+14	; 0x0e
    4118:	89 01       	movw	r16, r18
    411a:	9c 01       	movw	r18, r24
    411c:	ad 01       	movw	r20, r26
    411e:	cf 01       	movw	r24, r30
    4120:	0e 94 af 20 	call	0x415e	; 0x415e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4124:	89 81       	ldd	r24, Y+1	; 0x01
    4126:	9a 81       	ldd	r25, Y+2	; 0x02
    4128:	0e 94 83 21 	call	0x4306	; 0x4306 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    412c:	81 e0       	ldi	r24, 0x01	; 1
    412e:	8b 83       	std	Y+3, r24	; 0x03
    4130:	02 c0       	rjmp	.+4      	; 0x4136 <xTaskCreate+0xd2>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4132:	8f ef       	ldi	r24, 0xFF	; 255
    4134:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4136:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4138:	60 96       	adiw	r28, 0x10	; 16
    413a:	0f b6       	in	r0, 0x3f	; 63
    413c:	f8 94       	cli
    413e:	de bf       	out	0x3e, r29	; 62
    4140:	0f be       	out	0x3f, r0	; 63
    4142:	cd bf       	out	0x3d, r28	; 61
    4144:	df 91       	pop	r29
    4146:	cf 91       	pop	r28
    4148:	1f 91       	pop	r17
    414a:	0f 91       	pop	r16
    414c:	ff 90       	pop	r15
    414e:	ef 90       	pop	r14
    4150:	df 90       	pop	r13
    4152:	cf 90       	pop	r12
    4154:	bf 90       	pop	r11
    4156:	af 90       	pop	r10
    4158:	9f 90       	pop	r9
    415a:	8f 90       	pop	r8
    415c:	08 95       	ret

0000415e <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    415e:	8f 92       	push	r8
    4160:	9f 92       	push	r9
    4162:	af 92       	push	r10
    4164:	bf 92       	push	r11
    4166:	cf 92       	push	r12
    4168:	df 92       	push	r13
    416a:	ef 92       	push	r14
    416c:	0f 93       	push	r16
    416e:	1f 93       	push	r17
    4170:	cf 93       	push	r28
    4172:	df 93       	push	r29
    4174:	cd b7       	in	r28, 0x3d	; 61
    4176:	de b7       	in	r29, 0x3e	; 62
    4178:	64 97       	sbiw	r28, 0x14	; 20
    417a:	0f b6       	in	r0, 0x3f	; 63
    417c:	f8 94       	cli
    417e:	de bf       	out	0x3e, r29	; 62
    4180:	0f be       	out	0x3f, r0	; 63
    4182:	cd bf       	out	0x3d, r28	; 61
    4184:	9d 83       	std	Y+5, r25	; 0x05
    4186:	8c 83       	std	Y+4, r24	; 0x04
    4188:	7f 83       	std	Y+7, r23	; 0x07
    418a:	6e 83       	std	Y+6, r22	; 0x06
    418c:	28 87       	std	Y+8, r18	; 0x08
    418e:	39 87       	std	Y+9, r19	; 0x09
    4190:	4a 87       	std	Y+10, r20	; 0x0a
    4192:	5b 87       	std	Y+11, r21	; 0x0b
    4194:	1d 87       	std	Y+13, r17	; 0x0d
    4196:	0c 87       	std	Y+12, r16	; 0x0c
    4198:	ee 86       	std	Y+14, r14	; 0x0e
    419a:	d8 8a       	std	Y+16, r13	; 0x10
    419c:	cf 86       	std	Y+15, r12	; 0x0f
    419e:	ba 8a       	std	Y+18, r11	; 0x12
    41a0:	a9 8a       	std	Y+17, r10	; 0x11
    41a2:	9c 8a       	std	Y+20, r9	; 0x14
    41a4:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    41a6:	89 89       	ldd	r24, Y+17	; 0x11
    41a8:	9a 89       	ldd	r25, Y+18	; 0x12
    41aa:	fc 01       	movw	r30, r24
    41ac:	27 89       	ldd	r18, Z+23	; 0x17
    41ae:	30 8d       	ldd	r19, Z+24	; 0x18
    41b0:	88 85       	ldd	r24, Y+8	; 0x08
    41b2:	99 85       	ldd	r25, Y+9	; 0x09
    41b4:	01 97       	sbiw	r24, 0x01	; 1
    41b6:	82 0f       	add	r24, r18
    41b8:	93 1f       	adc	r25, r19
    41ba:	9b 83       	std	Y+3, r25	; 0x03
    41bc:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    41be:	8e 81       	ldd	r24, Y+6	; 0x06
    41c0:	9f 81       	ldd	r25, Y+7	; 0x07
    41c2:	89 2b       	or	r24, r25
    41c4:	69 f1       	breq	.+90     	; 0x4220 <prvInitialiseNewTask+0xc2>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    41c6:	19 82       	std	Y+1, r1	; 0x01
    41c8:	21 c0       	rjmp	.+66     	; 0x420c <prvInitialiseNewTask+0xae>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    41ca:	89 81       	ldd	r24, Y+1	; 0x01
    41cc:	88 2f       	mov	r24, r24
    41ce:	90 e0       	ldi	r25, 0x00	; 0
    41d0:	29 81       	ldd	r18, Y+1	; 0x01
    41d2:	22 2f       	mov	r18, r18
    41d4:	30 e0       	ldi	r19, 0x00	; 0
    41d6:	4e 81       	ldd	r20, Y+6	; 0x06
    41d8:	5f 81       	ldd	r21, Y+7	; 0x07
    41da:	24 0f       	add	r18, r20
    41dc:	35 1f       	adc	r19, r21
    41de:	f9 01       	movw	r30, r18
    41e0:	40 81       	ld	r20, Z
    41e2:	29 89       	ldd	r18, Y+17	; 0x11
    41e4:	3a 89       	ldd	r19, Y+18	; 0x12
    41e6:	82 0f       	add	r24, r18
    41e8:	93 1f       	adc	r25, r19
    41ea:	49 96       	adiw	r24, 0x19	; 25
    41ec:	fc 01       	movw	r30, r24
    41ee:	40 83       	st	Z, r20

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    41f0:	89 81       	ldd	r24, Y+1	; 0x01
    41f2:	88 2f       	mov	r24, r24
    41f4:	90 e0       	ldi	r25, 0x00	; 0
    41f6:	2e 81       	ldd	r18, Y+6	; 0x06
    41f8:	3f 81       	ldd	r19, Y+7	; 0x07
    41fa:	82 0f       	add	r24, r18
    41fc:	93 1f       	adc	r25, r19
    41fe:	fc 01       	movw	r30, r24
    4200:	80 81       	ld	r24, Z
    4202:	88 23       	and	r24, r24
    4204:	39 f0       	breq	.+14     	; 0x4214 <prvInitialiseNewTask+0xb6>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4206:	89 81       	ldd	r24, Y+1	; 0x01
    4208:	8f 5f       	subi	r24, 0xFF	; 255
    420a:	89 83       	std	Y+1, r24	; 0x01
    420c:	89 81       	ldd	r24, Y+1	; 0x01
    420e:	88 30       	cpi	r24, 0x08	; 8
    4210:	e0 f2       	brcs	.-72     	; 0x41ca <prvInitialiseNewTask+0x6c>
    4212:	01 c0       	rjmp	.+2      	; 0x4216 <prvInitialiseNewTask+0xb8>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
    4214:	00 00       	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4216:	89 89       	ldd	r24, Y+17	; 0x11
    4218:	9a 89       	ldd	r25, Y+18	; 0x12
    421a:	fc 01       	movw	r30, r24
    421c:	10 a2       	std	Z+32, r1	; 0x20
    421e:	04 c0       	rjmp	.+8      	; 0x4228 <prvInitialiseNewTask+0xca>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4220:	89 89       	ldd	r24, Y+17	; 0x11
    4222:	9a 89       	ldd	r25, Y+18	; 0x12
    4224:	fc 01       	movw	r30, r24
    4226:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4228:	8e 85       	ldd	r24, Y+14	; 0x0e
    422a:	85 30       	cpi	r24, 0x05	; 5
    422c:	10 f0       	brcs	.+4      	; 0x4232 <prvInitialiseNewTask+0xd4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    422e:	84 e0       	ldi	r24, 0x04	; 4
    4230:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4232:	89 89       	ldd	r24, Y+17	; 0x11
    4234:	9a 89       	ldd	r25, Y+18	; 0x12
    4236:	2e 85       	ldd	r18, Y+14	; 0x0e
    4238:	fc 01       	movw	r30, r24
    423a:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    423c:	89 89       	ldd	r24, Y+17	; 0x11
    423e:	9a 89       	ldd	r25, Y+18	; 0x12
    4240:	2e 85       	ldd	r18, Y+14	; 0x0e
    4242:	fc 01       	movw	r30, r24
    4244:	21 a3       	std	Z+33, r18	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    4246:	89 89       	ldd	r24, Y+17	; 0x11
    4248:	9a 89       	ldd	r25, Y+18	; 0x12
    424a:	fc 01       	movw	r30, r24
    424c:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    424e:	89 89       	ldd	r24, Y+17	; 0x11
    4250:	9a 89       	ldd	r25, Y+18	; 0x12
    4252:	02 96       	adiw	r24, 0x02	; 2
    4254:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4258:	89 89       	ldd	r24, Y+17	; 0x11
    425a:	9a 89       	ldd	r25, Y+18	; 0x12
    425c:	0c 96       	adiw	r24, 0x0c	; 12
    425e:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4262:	89 89       	ldd	r24, Y+17	; 0x11
    4264:	9a 89       	ldd	r25, Y+18	; 0x12
    4266:	29 89       	ldd	r18, Y+17	; 0x11
    4268:	3a 89       	ldd	r19, Y+18	; 0x12
    426a:	fc 01       	movw	r30, r24
    426c:	31 87       	std	Z+9, r19	; 0x09
    426e:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4270:	8e 85       	ldd	r24, Y+14	; 0x0e
    4272:	88 2f       	mov	r24, r24
    4274:	90 e0       	ldi	r25, 0x00	; 0
    4276:	25 e0       	ldi	r18, 0x05	; 5
    4278:	30 e0       	ldi	r19, 0x00	; 0
    427a:	28 1b       	sub	r18, r24
    427c:	39 0b       	sbc	r19, r25
    427e:	89 89       	ldd	r24, Y+17	; 0x11
    4280:	9a 89       	ldd	r25, Y+18	; 0x12
    4282:	fc 01       	movw	r30, r24
    4284:	35 87       	std	Z+13, r19	; 0x0d
    4286:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4288:	89 89       	ldd	r24, Y+17	; 0x11
    428a:	9a 89       	ldd	r25, Y+18	; 0x12
    428c:	29 89       	ldd	r18, Y+17	; 0x11
    428e:	3a 89       	ldd	r19, Y+18	; 0x12
    4290:	fc 01       	movw	r30, r24
    4292:	33 8b       	std	Z+19, r19	; 0x13
    4294:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4296:	89 89       	ldd	r24, Y+17	; 0x11
    4298:	9a 89       	ldd	r25, Y+18	; 0x12
    429a:	fc 01       	movw	r30, r24
    429c:	13 a2       	std	Z+35, r1	; 0x23
    429e:	14 a2       	std	Z+36, r1	; 0x24
    42a0:	15 a2       	std	Z+37, r1	; 0x25
    42a2:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    42a4:	89 89       	ldd	r24, Y+17	; 0x11
    42a6:	9a 89       	ldd	r25, Y+18	; 0x12
    42a8:	fc 01       	movw	r30, r24
    42aa:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    42ac:	4c 85       	ldd	r20, Y+12	; 0x0c
    42ae:	5d 85       	ldd	r21, Y+13	; 0x0d
    42b0:	2c 81       	ldd	r18, Y+4	; 0x04
    42b2:	3d 81       	ldd	r19, Y+5	; 0x05
    42b4:	8a 81       	ldd	r24, Y+2	; 0x02
    42b6:	9b 81       	ldd	r25, Y+3	; 0x03
    42b8:	b9 01       	movw	r22, r18
    42ba:	0e 94 db 14 	call	0x29b6	; 0x29b6 <pxPortInitialiseStack>
    42be:	9c 01       	movw	r18, r24
    42c0:	89 89       	ldd	r24, Y+17	; 0x11
    42c2:	9a 89       	ldd	r25, Y+18	; 0x12
    42c4:	fc 01       	movw	r30, r24
    42c6:	31 83       	std	Z+1, r19	; 0x01
    42c8:	20 83       	st	Z, r18
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    42ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    42cc:	98 89       	ldd	r25, Y+16	; 0x10
    42ce:	89 2b       	or	r24, r25
    42d0:	39 f0       	breq	.+14     	; 0x42e0 <prvInitialiseNewTask+0x182>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    42d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    42d4:	98 89       	ldd	r25, Y+16	; 0x10
    42d6:	29 89       	ldd	r18, Y+17	; 0x11
    42d8:	3a 89       	ldd	r19, Y+18	; 0x12
    42da:	fc 01       	movw	r30, r24
    42dc:	31 83       	std	Z+1, r19	; 0x01
    42de:	20 83       	st	Z, r18
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    42e0:	00 00       	nop
    42e2:	64 96       	adiw	r28, 0x14	; 20
    42e4:	0f b6       	in	r0, 0x3f	; 63
    42e6:	f8 94       	cli
    42e8:	de bf       	out	0x3e, r29	; 62
    42ea:	0f be       	out	0x3f, r0	; 63
    42ec:	cd bf       	out	0x3d, r28	; 61
    42ee:	df 91       	pop	r29
    42f0:	cf 91       	pop	r28
    42f2:	1f 91       	pop	r17
    42f4:	0f 91       	pop	r16
    42f6:	ef 90       	pop	r14
    42f8:	df 90       	pop	r13
    42fa:	cf 90       	pop	r12
    42fc:	bf 90       	pop	r11
    42fe:	af 90       	pop	r10
    4300:	9f 90       	pop	r9
    4302:	8f 90       	pop	r8
    4304:	08 95       	ret

00004306 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4306:	cf 93       	push	r28
    4308:	df 93       	push	r29
    430a:	00 d0       	rcall	.+0      	; 0x430c <prvAddNewTaskToReadyList+0x6>
    430c:	cd b7       	in	r28, 0x3d	; 61
    430e:	de b7       	in	r29, 0x3e	; 62
    4310:	9a 83       	std	Y+2, r25	; 0x02
    4312:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4314:	0f b6       	in	r0, 0x3f	; 63
    4316:	f8 94       	cli
    4318:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    431a:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    431e:	8f 5f       	subi	r24, 0xFF	; 255
    4320:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    4324:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4328:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    432c:	89 2b       	or	r24, r25
    432e:	69 f4       	brne	.+26     	; 0x434a <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4330:	89 81       	ldd	r24, Y+1	; 0x01
    4332:	9a 81       	ldd	r25, Y+2	; 0x02
    4334:	90 93 a0 06 	sts	0x06A0, r25	; 0x8006a0 <pxCurrentTCB+0x1>
    4338:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    433c:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    4340:	81 30       	cpi	r24, 0x01	; 1
    4342:	c9 f4       	brne	.+50     	; 0x4376 <prvAddNewTaskToReadyList+0x70>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4344:	0e 94 ff 28 	call	0x51fe	; 0x51fe <prvInitialiseTaskLists>
    4348:	16 c0       	rjmp	.+44     	; 0x4376 <prvAddNewTaskToReadyList+0x70>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    434a:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    434e:	88 23       	and	r24, r24
    4350:	91 f4       	brne	.+36     	; 0x4376 <prvAddNewTaskToReadyList+0x70>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4352:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4356:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    435a:	fc 01       	movw	r30, r24
    435c:	26 89       	ldd	r18, Z+22	; 0x16
    435e:	89 81       	ldd	r24, Y+1	; 0x01
    4360:	9a 81       	ldd	r25, Y+2	; 0x02
    4362:	fc 01       	movw	r30, r24
    4364:	86 89       	ldd	r24, Z+22	; 0x16
    4366:	82 17       	cp	r24, r18
    4368:	30 f0       	brcs	.+12     	; 0x4376 <prvAddNewTaskToReadyList+0x70>
				{
					pxCurrentTCB = pxNewTCB;
    436a:	89 81       	ldd	r24, Y+1	; 0x01
    436c:	9a 81       	ldd	r25, Y+2	; 0x02
    436e:	90 93 a0 06 	sts	0x06A0, r25	; 0x8006a0 <pxCurrentTCB+0x1>
    4372:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4376:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTaskNumber>
    437a:	8f 5f       	subi	r24, 0xFF	; 255
    437c:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4380:	89 81       	ldd	r24, Y+1	; 0x01
    4382:	9a 81       	ldd	r25, Y+2	; 0x02
    4384:	fc 01       	movw	r30, r24
    4386:	96 89       	ldd	r25, Z+22	; 0x16
    4388:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    438c:	89 17       	cp	r24, r25
    438e:	30 f4       	brcc	.+12     	; 0x439c <prvAddNewTaskToReadyList+0x96>
    4390:	89 81       	ldd	r24, Y+1	; 0x01
    4392:	9a 81       	ldd	r25, Y+2	; 0x02
    4394:	fc 01       	movw	r30, r24
    4396:	86 89       	ldd	r24, Z+22	; 0x16
    4398:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    439c:	89 81       	ldd	r24, Y+1	; 0x01
    439e:	9a 81       	ldd	r25, Y+2	; 0x02
    43a0:	ac 01       	movw	r20, r24
    43a2:	4e 5f       	subi	r20, 0xFE	; 254
    43a4:	5f 4f       	sbci	r21, 0xFF	; 255
    43a6:	89 81       	ldd	r24, Y+1	; 0x01
    43a8:	9a 81       	ldd	r25, Y+2	; 0x02
    43aa:	fc 01       	movw	r30, r24
    43ac:	86 89       	ldd	r24, Z+22	; 0x16
    43ae:	28 2f       	mov	r18, r24
    43b0:	30 e0       	ldi	r19, 0x00	; 0
    43b2:	c9 01       	movw	r24, r18
    43b4:	88 0f       	add	r24, r24
    43b6:	99 1f       	adc	r25, r25
    43b8:	88 0f       	add	r24, r24
    43ba:	99 1f       	adc	r25, r25
    43bc:	88 0f       	add	r24, r24
    43be:	99 1f       	adc	r25, r25
    43c0:	82 0f       	add	r24, r18
    43c2:	93 1f       	adc	r25, r19
    43c4:	8f 55       	subi	r24, 0x5F	; 95
    43c6:	99 4f       	sbci	r25, 0xF9	; 249
    43c8:	ba 01       	movw	r22, r20
    43ca:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    43ce:	0f 90       	pop	r0
    43d0:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    43d2:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    43d6:	88 23       	and	r24, r24
    43d8:	71 f0       	breq	.+28     	; 0x43f6 <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    43da:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    43de:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    43e2:	fc 01       	movw	r30, r24
    43e4:	26 89       	ldd	r18, Z+22	; 0x16
    43e6:	89 81       	ldd	r24, Y+1	; 0x01
    43e8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ea:	fc 01       	movw	r30, r24
    43ec:	86 89       	ldd	r24, Z+22	; 0x16
    43ee:	28 17       	cp	r18, r24
    43f0:	10 f4       	brcc	.+4      	; 0x43f6 <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    43f2:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    43f6:	00 00       	nop
    43f8:	0f 90       	pop	r0
    43fa:	0f 90       	pop	r0
    43fc:	df 91       	pop	r29
    43fe:	cf 91       	pop	r28
    4400:	08 95       	ret

00004402 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4402:	cf 93       	push	r28
    4404:	df 93       	push	r29
    4406:	00 d0       	rcall	.+0      	; 0x4408 <vTaskDelete+0x6>
    4408:	00 d0       	rcall	.+0      	; 0x440a <vTaskDelete+0x8>
    440a:	cd b7       	in	r28, 0x3d	; 61
    440c:	de b7       	in	r29, 0x3e	; 62
    440e:	9c 83       	std	Y+4, r25	; 0x04
    4410:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4412:	0f b6       	in	r0, 0x3f	; 63
    4414:	f8 94       	cli
    4416:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4418:	8b 81       	ldd	r24, Y+3	; 0x03
    441a:	9c 81       	ldd	r25, Y+4	; 0x04
    441c:	89 2b       	or	r24, r25
    441e:	29 f4       	brne	.+10     	; 0x442a <vTaskDelete+0x28>
    4420:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4424:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4428:	02 c0       	rjmp	.+4      	; 0x442e <vTaskDelete+0x2c>
    442a:	8b 81       	ldd	r24, Y+3	; 0x03
    442c:	9c 81       	ldd	r25, Y+4	; 0x04
    442e:	9a 83       	std	Y+2, r25	; 0x02
    4430:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4432:	89 81       	ldd	r24, Y+1	; 0x01
    4434:	9a 81       	ldd	r25, Y+2	; 0x02
    4436:	02 96       	adiw	r24, 0x02	; 2
    4438:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    443c:	89 81       	ldd	r24, Y+1	; 0x01
    443e:	9a 81       	ldd	r25, Y+2	; 0x02
    4440:	fc 01       	movw	r30, r24
    4442:	84 89       	ldd	r24, Z+20	; 0x14
    4444:	95 89       	ldd	r25, Z+21	; 0x15
    4446:	89 2b       	or	r24, r25
    4448:	29 f0       	breq	.+10     	; 0x4454 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    444a:	89 81       	ldd	r24, Y+1	; 0x01
    444c:	9a 81       	ldd	r25, Y+2	; 0x02
    444e:	0c 96       	adiw	r24, 0x0c	; 12
    4450:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4454:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTaskNumber>
    4458:	8f 5f       	subi	r24, 0xFF	; 255
    445a:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    445e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4462:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4466:	29 81       	ldd	r18, Y+1	; 0x01
    4468:	3a 81       	ldd	r19, Y+2	; 0x02
    446a:	28 17       	cp	r18, r24
    446c:	39 07       	cpc	r19, r25
    446e:	71 f4       	brne	.+28     	; 0x448c <vTaskDelete+0x8a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4470:	89 81       	ldd	r24, Y+1	; 0x01
    4472:	9a 81       	ldd	r25, Y+2	; 0x02
    4474:	02 96       	adiw	r24, 0x02	; 2
    4476:	bc 01       	movw	r22, r24
    4478:	8d ee       	ldi	r24, 0xED	; 237
    447a:	96 e0       	ldi	r25, 0x06	; 6
    447c:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4480:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    4484:	8f 5f       	subi	r24, 0xFF	; 255
    4486:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    448a:	0b c0       	rjmp	.+22     	; 0x44a2 <vTaskDelete+0xa0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    448c:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    4490:	81 50       	subi	r24, 0x01	; 1
    4492:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxCurrentNumberOfTasks>
				prvDeleteTCB( pxTCB );
    4496:	89 81       	ldd	r24, Y+1	; 0x01
    4498:	9a 81       	ldd	r25, Y+2	; 0x02
    449a:	0e 94 72 29 	call	0x52e4	; 0x52e4 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    449e:	0e 94 8a 29 	call	0x5314	; 0x5314 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    44a2:	0f 90       	pop	r0
    44a4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    44a6:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    44aa:	88 23       	and	r24, r24
    44ac:	59 f0       	breq	.+22     	; 0x44c4 <vTaskDelete+0xc2>
		{
			if( pxTCB == pxCurrentTCB )
    44ae:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    44b2:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    44b6:	29 81       	ldd	r18, Y+1	; 0x01
    44b8:	3a 81       	ldd	r19, Y+2	; 0x02
    44ba:	28 17       	cp	r18, r24
    44bc:	39 07       	cpc	r19, r25
    44be:	11 f4       	brne	.+4      	; 0x44c4 <vTaskDelete+0xc2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    44c0:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    44c4:	00 00       	nop
    44c6:	0f 90       	pop	r0
    44c8:	0f 90       	pop	r0
    44ca:	0f 90       	pop	r0
    44cc:	0f 90       	pop	r0
    44ce:	df 91       	pop	r29
    44d0:	cf 91       	pop	r28
    44d2:	08 95       	ret

000044d4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    44d4:	cf 93       	push	r28
    44d6:	df 93       	push	r29
    44d8:	cd b7       	in	r28, 0x3d	; 61
    44da:	de b7       	in	r29, 0x3e	; 62
    44dc:	2a 97       	sbiw	r28, 0x0a	; 10
    44de:	0f b6       	in	r0, 0x3f	; 63
    44e0:	f8 94       	cli
    44e2:	de bf       	out	0x3e, r29	; 62
    44e4:	0f be       	out	0x3f, r0	; 63
    44e6:	cd bf       	out	0x3d, r28	; 61
    44e8:	98 87       	std	Y+8, r25	; 0x08
    44ea:	8f 83       	std	Y+7, r24	; 0x07
    44ec:	7a 87       	std	Y+10, r23	; 0x0a
    44ee:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    44f0:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    44f2:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    44f6:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    44fa:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    44fe:	9b 83       	std	Y+3, r25	; 0x03
    4500:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4502:	8f 81       	ldd	r24, Y+7	; 0x07
    4504:	98 85       	ldd	r25, Y+8	; 0x08
    4506:	fc 01       	movw	r30, r24
    4508:	20 81       	ld	r18, Z
    450a:	31 81       	ldd	r19, Z+1	; 0x01
    450c:	89 85       	ldd	r24, Y+9	; 0x09
    450e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4510:	82 0f       	add	r24, r18
    4512:	93 1f       	adc	r25, r19
    4514:	9d 83       	std	Y+5, r25	; 0x05
    4516:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    4518:	8f 81       	ldd	r24, Y+7	; 0x07
    451a:	98 85       	ldd	r25, Y+8	; 0x08
    451c:	fc 01       	movw	r30, r24
    451e:	20 81       	ld	r18, Z
    4520:	31 81       	ldd	r19, Z+1	; 0x01
    4522:	8a 81       	ldd	r24, Y+2	; 0x02
    4524:	9b 81       	ldd	r25, Y+3	; 0x03
    4526:	82 17       	cp	r24, r18
    4528:	93 07       	cpc	r25, r19
    452a:	a0 f4       	brcc	.+40     	; 0x4554 <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    452c:	8f 81       	ldd	r24, Y+7	; 0x07
    452e:	98 85       	ldd	r25, Y+8	; 0x08
    4530:	fc 01       	movw	r30, r24
    4532:	20 81       	ld	r18, Z
    4534:	31 81       	ldd	r19, Z+1	; 0x01
    4536:	8c 81       	ldd	r24, Y+4	; 0x04
    4538:	9d 81       	ldd	r25, Y+5	; 0x05
    453a:	82 17       	cp	r24, r18
    453c:	93 07       	cpc	r25, r19
    453e:	e8 f4       	brcc	.+58     	; 0x457a <vTaskDelayUntil+0xa6>
    4540:	2c 81       	ldd	r18, Y+4	; 0x04
    4542:	3d 81       	ldd	r19, Y+5	; 0x05
    4544:	8a 81       	ldd	r24, Y+2	; 0x02
    4546:	9b 81       	ldd	r25, Y+3	; 0x03
    4548:	82 17       	cp	r24, r18
    454a:	93 07       	cpc	r25, r19
    454c:	b0 f4       	brcc	.+44     	; 0x457a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    454e:	81 e0       	ldi	r24, 0x01	; 1
    4550:	89 83       	std	Y+1, r24	; 0x01
    4552:	13 c0       	rjmp	.+38     	; 0x457a <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4554:	8f 81       	ldd	r24, Y+7	; 0x07
    4556:	98 85       	ldd	r25, Y+8	; 0x08
    4558:	fc 01       	movw	r30, r24
    455a:	20 81       	ld	r18, Z
    455c:	31 81       	ldd	r19, Z+1	; 0x01
    455e:	8c 81       	ldd	r24, Y+4	; 0x04
    4560:	9d 81       	ldd	r25, Y+5	; 0x05
    4562:	82 17       	cp	r24, r18
    4564:	93 07       	cpc	r25, r19
    4566:	38 f0       	brcs	.+14     	; 0x4576 <vTaskDelayUntil+0xa2>
    4568:	2c 81       	ldd	r18, Y+4	; 0x04
    456a:	3d 81       	ldd	r19, Y+5	; 0x05
    456c:	8a 81       	ldd	r24, Y+2	; 0x02
    456e:	9b 81       	ldd	r25, Y+3	; 0x03
    4570:	82 17       	cp	r24, r18
    4572:	93 07       	cpc	r25, r19
    4574:	10 f4       	brcc	.+4      	; 0x457a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    4576:	81 e0       	ldi	r24, 0x01	; 1
    4578:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    457a:	8f 81       	ldd	r24, Y+7	; 0x07
    457c:	98 85       	ldd	r25, Y+8	; 0x08
    457e:	2c 81       	ldd	r18, Y+4	; 0x04
    4580:	3d 81       	ldd	r19, Y+5	; 0x05
    4582:	fc 01       	movw	r30, r24
    4584:	31 83       	std	Z+1, r19	; 0x01
    4586:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    4588:	89 81       	ldd	r24, Y+1	; 0x01
    458a:	88 23       	and	r24, r24
    458c:	59 f0       	breq	.+22     	; 0x45a4 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    458e:	2c 81       	ldd	r18, Y+4	; 0x04
    4590:	3d 81       	ldd	r19, Y+5	; 0x05
    4592:	8a 81       	ldd	r24, Y+2	; 0x02
    4594:	9b 81       	ldd	r25, Y+3	; 0x03
    4596:	a9 01       	movw	r20, r18
    4598:	48 1b       	sub	r20, r24
    459a:	59 0b       	sbc	r21, r25
    459c:	ca 01       	movw	r24, r20
    459e:	60 e0       	ldi	r22, 0x00	; 0
    45a0:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    45a4:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    45a8:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    45aa:	8e 81       	ldd	r24, Y+6	; 0x06
    45ac:	88 23       	and	r24, r24
    45ae:	11 f4       	brne	.+4      	; 0x45b4 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    45b0:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    45b4:	00 00       	nop
    45b6:	2a 96       	adiw	r28, 0x0a	; 10
    45b8:	0f b6       	in	r0, 0x3f	; 63
    45ba:	f8 94       	cli
    45bc:	de bf       	out	0x3e, r29	; 62
    45be:	0f be       	out	0x3f, r0	; 63
    45c0:	cd bf       	out	0x3d, r28	; 61
    45c2:	df 91       	pop	r29
    45c4:	cf 91       	pop	r28
    45c6:	08 95       	ret

000045c8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    45c8:	cf 93       	push	r28
    45ca:	df 93       	push	r29
    45cc:	00 d0       	rcall	.+0      	; 0x45ce <vTaskDelay+0x6>
    45ce:	1f 92       	push	r1
    45d0:	cd b7       	in	r28, 0x3d	; 61
    45d2:	de b7       	in	r29, 0x3e	; 62
    45d4:	9b 83       	std	Y+3, r25	; 0x03
    45d6:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    45d8:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    45da:	8a 81       	ldd	r24, Y+2	; 0x02
    45dc:	9b 81       	ldd	r25, Y+3	; 0x03
    45de:	89 2b       	or	r24, r25
    45e0:	51 f0       	breq	.+20     	; 0x45f6 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    45e2:	0e 94 b5 24 	call	0x496a	; 0x496a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    45e6:	8a 81       	ldd	r24, Y+2	; 0x02
    45e8:	9b 81       	ldd	r25, Y+3	; 0x03
    45ea:	60 e0       	ldi	r22, 0x00	; 0
    45ec:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    45f0:	0e 94 c2 24 	call	0x4984	; 0x4984 <xTaskResumeAll>
    45f4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    45f6:	89 81       	ldd	r24, Y+1	; 0x01
    45f8:	88 23       	and	r24, r24
    45fa:	11 f4       	brne	.+4      	; 0x4600 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    45fc:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4600:	00 00       	nop
    4602:	0f 90       	pop	r0
    4604:	0f 90       	pop	r0
    4606:	0f 90       	pop	r0
    4608:	df 91       	pop	r29
    460a:	cf 91       	pop	r28
    460c:	08 95       	ret

0000460e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    460e:	cf 93       	push	r28
    4610:	df 93       	push	r29
    4612:	00 d0       	rcall	.+0      	; 0x4614 <vTaskSuspend+0x6>
    4614:	00 d0       	rcall	.+0      	; 0x4616 <vTaskSuspend+0x8>
    4616:	cd b7       	in	r28, 0x3d	; 61
    4618:	de b7       	in	r29, 0x3e	; 62
    461a:	9c 83       	std	Y+4, r25	; 0x04
    461c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    461e:	0f b6       	in	r0, 0x3f	; 63
    4620:	f8 94       	cli
    4622:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4624:	8b 81       	ldd	r24, Y+3	; 0x03
    4626:	9c 81       	ldd	r25, Y+4	; 0x04
    4628:	89 2b       	or	r24, r25
    462a:	29 f4       	brne	.+10     	; 0x4636 <vTaskSuspend+0x28>
    462c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4630:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4634:	02 c0       	rjmp	.+4      	; 0x463a <vTaskSuspend+0x2c>
    4636:	8b 81       	ldd	r24, Y+3	; 0x03
    4638:	9c 81       	ldd	r25, Y+4	; 0x04
    463a:	9a 83       	std	Y+2, r25	; 0x02
    463c:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    463e:	89 81       	ldd	r24, Y+1	; 0x01
    4640:	9a 81       	ldd	r25, Y+2	; 0x02
    4642:	02 96       	adiw	r24, 0x02	; 2
    4644:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4648:	89 81       	ldd	r24, Y+1	; 0x01
    464a:	9a 81       	ldd	r25, Y+2	; 0x02
    464c:	fc 01       	movw	r30, r24
    464e:	84 89       	ldd	r24, Z+20	; 0x14
    4650:	95 89       	ldd	r25, Z+21	; 0x15
    4652:	89 2b       	or	r24, r25
    4654:	29 f0       	breq	.+10     	; 0x4660 <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4656:	89 81       	ldd	r24, Y+1	; 0x01
    4658:	9a 81       	ldd	r25, Y+2	; 0x02
    465a:	0c 96       	adiw	r24, 0x0c	; 12
    465c:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4660:	89 81       	ldd	r24, Y+1	; 0x01
    4662:	9a 81       	ldd	r25, Y+2	; 0x02
    4664:	02 96       	adiw	r24, 0x02	; 2
    4666:	bc 01       	movw	r22, r24
    4668:	87 ef       	ldi	r24, 0xF7	; 247
    466a:	96 e0       	ldi	r25, 0x06	; 6
    466c:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4670:	89 81       	ldd	r24, Y+1	; 0x01
    4672:	9a 81       	ldd	r25, Y+2	; 0x02
    4674:	fc 01       	movw	r30, r24
    4676:	87 a1       	ldd	r24, Z+39	; 0x27
    4678:	81 30       	cpi	r24, 0x01	; 1
    467a:	21 f4       	brne	.+8      	; 0x4684 <vTaskSuspend+0x76>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    467c:	89 81       	ldd	r24, Y+1	; 0x01
    467e:	9a 81       	ldd	r25, Y+2	; 0x02
    4680:	fc 01       	movw	r30, r24
    4682:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4684:	0f 90       	pop	r0
    4686:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    4688:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    468c:	88 23       	and	r24, r24
    468e:	39 f0       	breq	.+14     	; 0x469e <vTaskSuspend+0x90>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    4690:	0f b6       	in	r0, 0x3f	; 63
    4692:	f8 94       	cli
    4694:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    4696:	0e 94 8a 29 	call	0x5314	; 0x5314 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    469a:	0f 90       	pop	r0
    469c:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    469e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    46a2:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    46a6:	29 81       	ldd	r18, Y+1	; 0x01
    46a8:	3a 81       	ldd	r19, Y+2	; 0x02
    46aa:	28 17       	cp	r18, r24
    46ac:	39 07       	cpc	r19, r25
    46ae:	a1 f4       	brne	.+40     	; 0x46d8 <vTaskSuspend+0xca>
		{
			if( xSchedulerRunning != pdFALSE )
    46b0:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
    46b4:	88 23       	and	r24, r24
    46b6:	19 f0       	breq	.+6      	; 0x46be <vTaskSuspend+0xb0>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    46b8:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46bc:	0d c0       	rjmp	.+26     	; 0x46d8 <vTaskSuspend+0xca>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    46be:	90 91 f7 06 	lds	r25, 0x06F7	; 0x8006f7 <xSuspendedTaskList>
    46c2:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    46c6:	98 17       	cp	r25, r24
    46c8:	29 f4       	brne	.+10     	; 0x46d4 <vTaskSuspend+0xc6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    46ca:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <pxCurrentTCB+0x1>
    46ce:	10 92 9f 06 	sts	0x069F, r1	; 0x80069f <pxCurrentTCB>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46d2:	02 c0       	rjmp	.+4      	; 0x46d8 <vTaskSuspend+0xca>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
    46d4:	0e 94 9a 26 	call	0x4d34	; 0x4d34 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    46d8:	00 00       	nop
    46da:	0f 90       	pop	r0
    46dc:	0f 90       	pop	r0
    46de:	0f 90       	pop	r0
    46e0:	0f 90       	pop	r0
    46e2:	df 91       	pop	r29
    46e4:	cf 91       	pop	r28
    46e6:	08 95       	ret

000046e8 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    46e8:	cf 93       	push	r28
    46ea:	df 93       	push	r29
    46ec:	00 d0       	rcall	.+0      	; 0x46ee <prvTaskIsTaskSuspended+0x6>
    46ee:	00 d0       	rcall	.+0      	; 0x46f0 <prvTaskIsTaskSuspended+0x8>
    46f0:	1f 92       	push	r1
    46f2:	cd b7       	in	r28, 0x3d	; 61
    46f4:	de b7       	in	r29, 0x3e	; 62
    46f6:	9d 83       	std	Y+5, r25	; 0x05
    46f8:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    46fa:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = xTask;
    46fc:	8c 81       	ldd	r24, Y+4	; 0x04
    46fe:	9d 81       	ldd	r25, Y+5	; 0x05
    4700:	9b 83       	std	Y+3, r25	; 0x03
    4702:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    4704:	8a 81       	ldd	r24, Y+2	; 0x02
    4706:	9b 81       	ldd	r25, Y+3	; 0x03
    4708:	fc 01       	movw	r30, r24
    470a:	82 85       	ldd	r24, Z+10	; 0x0a
    470c:	93 85       	ldd	r25, Z+11	; 0x0b
    470e:	87 5f       	subi	r24, 0xF7	; 247
    4710:	96 40       	sbci	r25, 0x06	; 6
    4712:	89 f4       	brne	.+34     	; 0x4736 <prvTaskIsTaskSuspended+0x4e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    4714:	8a 81       	ldd	r24, Y+2	; 0x02
    4716:	9b 81       	ldd	r25, Y+3	; 0x03
    4718:	fc 01       	movw	r30, r24
    471a:	84 89       	ldd	r24, Z+20	; 0x14
    471c:	95 89       	ldd	r25, Z+21	; 0x15
    471e:	84 5e       	subi	r24, 0xE4	; 228
    4720:	96 40       	sbci	r25, 0x06	; 6
    4722:	49 f0       	breq	.+18     	; 0x4736 <prvTaskIsTaskSuspended+0x4e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    4724:	8a 81       	ldd	r24, Y+2	; 0x02
    4726:	9b 81       	ldd	r25, Y+3	; 0x03
    4728:	fc 01       	movw	r30, r24
    472a:	84 89       	ldd	r24, Z+20	; 0x14
    472c:	95 89       	ldd	r25, Z+21	; 0x15
    472e:	89 2b       	or	r24, r25
    4730:	11 f4       	brne	.+4      	; 0x4736 <prvTaskIsTaskSuspended+0x4e>
				{
					xReturn = pdTRUE;
    4732:	81 e0       	ldi	r24, 0x01	; 1
    4734:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4736:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4738:	0f 90       	pop	r0
    473a:	0f 90       	pop	r0
    473c:	0f 90       	pop	r0
    473e:	0f 90       	pop	r0
    4740:	0f 90       	pop	r0
    4742:	df 91       	pop	r29
    4744:	cf 91       	pop	r28
    4746:	08 95       	ret

00004748 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4748:	cf 93       	push	r28
    474a:	df 93       	push	r29
    474c:	00 d0       	rcall	.+0      	; 0x474e <vTaskResume+0x6>
    474e:	00 d0       	rcall	.+0      	; 0x4750 <vTaskResume+0x8>
    4750:	cd b7       	in	r28, 0x3d	; 61
    4752:	de b7       	in	r29, 0x3e	; 62
    4754:	9c 83       	std	Y+4, r25	; 0x04
    4756:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4758:	8b 81       	ldd	r24, Y+3	; 0x03
    475a:	9c 81       	ldd	r25, Y+4	; 0x04
    475c:	9a 83       	std	Y+2, r25	; 0x02
    475e:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4760:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4764:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4768:	29 81       	ldd	r18, Y+1	; 0x01
    476a:	3a 81       	ldd	r19, Y+2	; 0x02
    476c:	28 17       	cp	r18, r24
    476e:	39 07       	cpc	r19, r25
    4770:	09 f4       	brne	.+2      	; 0x4774 <vTaskResume+0x2c>
    4772:	4a c0       	rjmp	.+148    	; 0x4808 <vTaskResume+0xc0>
    4774:	89 81       	ldd	r24, Y+1	; 0x01
    4776:	9a 81       	ldd	r25, Y+2	; 0x02
    4778:	89 2b       	or	r24, r25
    477a:	09 f4       	brne	.+2      	; 0x477e <vTaskResume+0x36>
    477c:	45 c0       	rjmp	.+138    	; 0x4808 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    477e:	0f b6       	in	r0, 0x3f	; 63
    4780:	f8 94       	cli
    4782:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4784:	89 81       	ldd	r24, Y+1	; 0x01
    4786:	9a 81       	ldd	r25, Y+2	; 0x02
    4788:	0e 94 74 23 	call	0x46e8	; 0x46e8 <prvTaskIsTaskSuspended>
    478c:	88 23       	and	r24, r24
    478e:	d1 f1       	breq	.+116    	; 0x4804 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4790:	89 81       	ldd	r24, Y+1	; 0x01
    4792:	9a 81       	ldd	r25, Y+2	; 0x02
    4794:	02 96       	adiw	r24, 0x02	; 2
    4796:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    479a:	89 81       	ldd	r24, Y+1	; 0x01
    479c:	9a 81       	ldd	r25, Y+2	; 0x02
    479e:	fc 01       	movw	r30, r24
    47a0:	96 89       	ldd	r25, Z+22	; 0x16
    47a2:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    47a6:	89 17       	cp	r24, r25
    47a8:	30 f4       	brcc	.+12     	; 0x47b6 <vTaskResume+0x6e>
    47aa:	89 81       	ldd	r24, Y+1	; 0x01
    47ac:	9a 81       	ldd	r25, Y+2	; 0x02
    47ae:	fc 01       	movw	r30, r24
    47b0:	86 89       	ldd	r24, Z+22	; 0x16
    47b2:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    47b6:	89 81       	ldd	r24, Y+1	; 0x01
    47b8:	9a 81       	ldd	r25, Y+2	; 0x02
    47ba:	ac 01       	movw	r20, r24
    47bc:	4e 5f       	subi	r20, 0xFE	; 254
    47be:	5f 4f       	sbci	r21, 0xFF	; 255
    47c0:	89 81       	ldd	r24, Y+1	; 0x01
    47c2:	9a 81       	ldd	r25, Y+2	; 0x02
    47c4:	fc 01       	movw	r30, r24
    47c6:	86 89       	ldd	r24, Z+22	; 0x16
    47c8:	28 2f       	mov	r18, r24
    47ca:	30 e0       	ldi	r19, 0x00	; 0
    47cc:	c9 01       	movw	r24, r18
    47ce:	88 0f       	add	r24, r24
    47d0:	99 1f       	adc	r25, r25
    47d2:	88 0f       	add	r24, r24
    47d4:	99 1f       	adc	r25, r25
    47d6:	88 0f       	add	r24, r24
    47d8:	99 1f       	adc	r25, r25
    47da:	82 0f       	add	r24, r18
    47dc:	93 1f       	adc	r25, r19
    47de:	8f 55       	subi	r24, 0x5F	; 95
    47e0:	99 4f       	sbci	r25, 0xF9	; 249
    47e2:	ba 01       	movw	r22, r20
    47e4:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    47e8:	89 81       	ldd	r24, Y+1	; 0x01
    47ea:	9a 81       	ldd	r25, Y+2	; 0x02
    47ec:	fc 01       	movw	r30, r24
    47ee:	26 89       	ldd	r18, Z+22	; 0x16
    47f0:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    47f4:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    47f8:	fc 01       	movw	r30, r24
    47fa:	86 89       	ldd	r24, Z+22	; 0x16
    47fc:	28 17       	cp	r18, r24
    47fe:	10 f0       	brcs	.+4      	; 0x4804 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4800:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4804:	0f 90       	pop	r0
    4806:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4808:	00 00       	nop
    480a:	0f 90       	pop	r0
    480c:	0f 90       	pop	r0
    480e:	0f 90       	pop	r0
    4810:	0f 90       	pop	r0
    4812:	df 91       	pop	r29
    4814:	cf 91       	pop	r28
    4816:	08 95       	ret

00004818 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4818:	cf 93       	push	r28
    481a:	df 93       	push	r29
    481c:	00 d0       	rcall	.+0      	; 0x481e <xTaskResumeFromISR+0x6>
    481e:	00 d0       	rcall	.+0      	; 0x4820 <xTaskResumeFromISR+0x8>
    4820:	00 d0       	rcall	.+0      	; 0x4822 <xTaskResumeFromISR+0xa>
    4822:	cd b7       	in	r28, 0x3d	; 61
    4824:	de b7       	in	r29, 0x3e	; 62
    4826:	9e 83       	std	Y+6, r25	; 0x06
    4828:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    482a:	19 82       	std	Y+1, r1	; 0x01
	TCB_t * const pxTCB = xTaskToResume;
    482c:	8d 81       	ldd	r24, Y+5	; 0x05
    482e:	9e 81       	ldd	r25, Y+6	; 0x06
    4830:	9b 83       	std	Y+3, r25	; 0x03
    4832:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4834:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4836:	8a 81       	ldd	r24, Y+2	; 0x02
    4838:	9b 81       	ldd	r25, Y+3	; 0x03
    483a:	0e 94 74 23 	call	0x46e8	; 0x46e8 <prvTaskIsTaskSuspended>
    483e:	88 23       	and	r24, r24
    4840:	09 f4       	brne	.+2      	; 0x4844 <xTaskResumeFromISR+0x2c>
    4842:	47 c0       	rjmp	.+142    	; 0x48d2 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4844:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4848:	88 23       	and	r24, r24
    484a:	d9 f5       	brne	.+118    	; 0x48c2 <xTaskResumeFromISR+0xaa>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    484c:	8a 81       	ldd	r24, Y+2	; 0x02
    484e:	9b 81       	ldd	r25, Y+3	; 0x03
    4850:	fc 01       	movw	r30, r24
    4852:	26 89       	ldd	r18, Z+22	; 0x16
    4854:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4858:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    485c:	fc 01       	movw	r30, r24
    485e:	86 89       	ldd	r24, Z+22	; 0x16
    4860:	28 17       	cp	r18, r24
    4862:	10 f0       	brcs	.+4      	; 0x4868 <xTaskResumeFromISR+0x50>
					{
						xYieldRequired = pdTRUE;
    4864:	81 e0       	ldi	r24, 0x01	; 1
    4866:	89 83       	std	Y+1, r24	; 0x01
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4868:	8a 81       	ldd	r24, Y+2	; 0x02
    486a:	9b 81       	ldd	r25, Y+3	; 0x03
    486c:	02 96       	adiw	r24, 0x02	; 2
    486e:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4872:	8a 81       	ldd	r24, Y+2	; 0x02
    4874:	9b 81       	ldd	r25, Y+3	; 0x03
    4876:	fc 01       	movw	r30, r24
    4878:	96 89       	ldd	r25, Z+22	; 0x16
    487a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    487e:	89 17       	cp	r24, r25
    4880:	30 f4       	brcc	.+12     	; 0x488e <xTaskResumeFromISR+0x76>
    4882:	8a 81       	ldd	r24, Y+2	; 0x02
    4884:	9b 81       	ldd	r25, Y+3	; 0x03
    4886:	fc 01       	movw	r30, r24
    4888:	86 89       	ldd	r24, Z+22	; 0x16
    488a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    488e:	8a 81       	ldd	r24, Y+2	; 0x02
    4890:	9b 81       	ldd	r25, Y+3	; 0x03
    4892:	ac 01       	movw	r20, r24
    4894:	4e 5f       	subi	r20, 0xFE	; 254
    4896:	5f 4f       	sbci	r21, 0xFF	; 255
    4898:	8a 81       	ldd	r24, Y+2	; 0x02
    489a:	9b 81       	ldd	r25, Y+3	; 0x03
    489c:	fc 01       	movw	r30, r24
    489e:	86 89       	ldd	r24, Z+22	; 0x16
    48a0:	28 2f       	mov	r18, r24
    48a2:	30 e0       	ldi	r19, 0x00	; 0
    48a4:	c9 01       	movw	r24, r18
    48a6:	88 0f       	add	r24, r24
    48a8:	99 1f       	adc	r25, r25
    48aa:	88 0f       	add	r24, r24
    48ac:	99 1f       	adc	r25, r25
    48ae:	88 0f       	add	r24, r24
    48b0:	99 1f       	adc	r25, r25
    48b2:	82 0f       	add	r24, r18
    48b4:	93 1f       	adc	r25, r19
    48b6:	8f 55       	subi	r24, 0x5F	; 95
    48b8:	99 4f       	sbci	r25, 0xF9	; 249
    48ba:	ba 01       	movw	r22, r20
    48bc:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
    48c0:	08 c0       	rjmp	.+16     	; 0x48d2 <xTaskResumeFromISR+0xba>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    48c2:	8a 81       	ldd	r24, Y+2	; 0x02
    48c4:	9b 81       	ldd	r25, Y+3	; 0x03
    48c6:	0c 96       	adiw	r24, 0x0c	; 12
    48c8:	bc 01       	movw	r22, r24
    48ca:	84 ee       	ldi	r24, 0xE4	; 228
    48cc:	96 e0       	ldi	r25, 0x06	; 6
    48ce:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    48d2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    48d4:	26 96       	adiw	r28, 0x06	; 6
    48d6:	0f b6       	in	r0, 0x3f	; 63
    48d8:	f8 94       	cli
    48da:	de bf       	out	0x3e, r29	; 62
    48dc:	0f be       	out	0x3f, r0	; 63
    48de:	cd bf       	out	0x3d, r28	; 61
    48e0:	df 91       	pop	r29
    48e2:	cf 91       	pop	r28
    48e4:	08 95       	ret

000048e6 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    48e6:	ef 92       	push	r14
    48e8:	ff 92       	push	r15
    48ea:	0f 93       	push	r16
    48ec:	cf 93       	push	r28
    48ee:	df 93       	push	r29
    48f0:	1f 92       	push	r1
    48f2:	cd b7       	in	r28, 0x3d	; 61
    48f4:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    48f6:	0f 2e       	mov	r0, r31
    48f8:	fb e0       	ldi	r31, 0x0B	; 11
    48fa:	ef 2e       	mov	r14, r31
    48fc:	f7 e0       	ldi	r31, 0x07	; 7
    48fe:	ff 2e       	mov	r15, r31
    4900:	f0 2d       	mov	r31, r0
    4902:	00 e0       	ldi	r16, 0x00	; 0
    4904:	20 e0       	ldi	r18, 0x00	; 0
    4906:	30 e0       	ldi	r19, 0x00	; 0
    4908:	45 e5       	ldi	r20, 0x55	; 85
    490a:	50 e0       	ldi	r21, 0x00	; 0
    490c:	64 eb       	ldi	r22, 0xB4	; 180
    490e:	70 e0       	ldi	r23, 0x00	; 0
    4910:	8f ee       	ldi	r24, 0xEF	; 239
    4912:	98 e2       	ldi	r25, 0x28	; 40
    4914:	0e 94 32 20 	call	0x4064	; 0x4064 <xTaskCreate>
    4918:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    491a:	89 81       	ldd	r24, Y+1	; 0x01
    491c:	81 30       	cpi	r24, 0x01	; 1
    491e:	81 f4       	brne	.+32     	; 0x4940 <vTaskStartScheduler+0x5a>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4920:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4922:	8f ef       	ldi	r24, 0xFF	; 255
    4924:	9f ef       	ldi	r25, 0xFF	; 255
    4926:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    492a:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    492e:	81 e0       	ldi	r24, 0x01	; 1
    4930:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4934:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <xTickCount+0x1>
    4938:	10 92 01 07 	sts	0x0701, r1	; 0x800701 <xTickCount>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    493c:	0e 94 84 16 	call	0x2d08	; 0x2d08 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4940:	00 00       	nop
    4942:	0f 90       	pop	r0
    4944:	df 91       	pop	r29
    4946:	cf 91       	pop	r28
    4948:	0f 91       	pop	r16
    494a:	ff 90       	pop	r15
    494c:	ef 90       	pop	r14
    494e:	08 95       	ret

00004950 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4950:	cf 93       	push	r28
    4952:	df 93       	push	r29
    4954:	cd b7       	in	r28, 0x3d	; 61
    4956:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4958:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    495a:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <xSchedulerRunning>
	vPortEndScheduler();
    495e:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <vPortEndScheduler>
}
    4962:	00 00       	nop
    4964:	df 91       	pop	r29
    4966:	cf 91       	pop	r28
    4968:	08 95       	ret

0000496a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    496a:	cf 93       	push	r28
    496c:	df 93       	push	r29
    496e:	cd b7       	in	r28, 0x3d	; 61
    4970:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4972:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4976:	8f 5f       	subi	r24, 0xFF	; 255
    4978:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxSchedulerSuspended>
	portMEMORY_BARRIER();
}
    497c:	00 00       	nop
    497e:	df 91       	pop	r29
    4980:	cf 91       	pop	r28
    4982:	08 95       	ret

00004984 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4984:	cf 93       	push	r28
    4986:	df 93       	push	r29
    4988:	00 d0       	rcall	.+0      	; 0x498a <xTaskResumeAll+0x6>
    498a:	00 d0       	rcall	.+0      	; 0x498c <xTaskResumeAll+0x8>
    498c:	cd b7       	in	r28, 0x3d	; 61
    498e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4990:	1a 82       	std	Y+2, r1	; 0x02
    4992:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xAlreadyYielded = pdFALSE;
    4994:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4996:	0f b6       	in	r0, 0x3f	; 63
    4998:	f8 94       	cli
    499a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    499c:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    49a0:	81 50       	subi	r24, 0x01	; 1
    49a2:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    49a6:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    49aa:	88 23       	and	r24, r24
    49ac:	09 f0       	breq	.+2      	; 0x49b0 <xTaskResumeAll+0x2c>
    49ae:	77 c0       	rjmp	.+238    	; 0x4a9e <xTaskResumeAll+0x11a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    49b0:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    49b4:	88 23       	and	r24, r24
    49b6:	09 f4       	brne	.+2      	; 0x49ba <xTaskResumeAll+0x36>
    49b8:	72 c0       	rjmp	.+228    	; 0x4a9e <xTaskResumeAll+0x11a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    49ba:	49 c0       	rjmp	.+146    	; 0x4a4e <xTaskResumeAll+0xca>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49bc:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <xPendingReadyList+0x5>
    49c0:	90 91 ea 06 	lds	r25, 0x06EA	; 0x8006ea <xPendingReadyList+0x6>
    49c4:	fc 01       	movw	r30, r24
    49c6:	86 81       	ldd	r24, Z+6	; 0x06
    49c8:	97 81       	ldd	r25, Z+7	; 0x07
    49ca:	9a 83       	std	Y+2, r25	; 0x02
    49cc:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    49ce:	89 81       	ldd	r24, Y+1	; 0x01
    49d0:	9a 81       	ldd	r25, Y+2	; 0x02
    49d2:	0c 96       	adiw	r24, 0x0c	; 12
    49d4:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    49d8:	89 81       	ldd	r24, Y+1	; 0x01
    49da:	9a 81       	ldd	r25, Y+2	; 0x02
    49dc:	02 96       	adiw	r24, 0x02	; 2
    49de:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    49e2:	89 81       	ldd	r24, Y+1	; 0x01
    49e4:	9a 81       	ldd	r25, Y+2	; 0x02
    49e6:	fc 01       	movw	r30, r24
    49e8:	96 89       	ldd	r25, Z+22	; 0x16
    49ea:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    49ee:	89 17       	cp	r24, r25
    49f0:	30 f4       	brcc	.+12     	; 0x49fe <xTaskResumeAll+0x7a>
    49f2:	89 81       	ldd	r24, Y+1	; 0x01
    49f4:	9a 81       	ldd	r25, Y+2	; 0x02
    49f6:	fc 01       	movw	r30, r24
    49f8:	86 89       	ldd	r24, Z+22	; 0x16
    49fa:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    49fe:	89 81       	ldd	r24, Y+1	; 0x01
    4a00:	9a 81       	ldd	r25, Y+2	; 0x02
    4a02:	ac 01       	movw	r20, r24
    4a04:	4e 5f       	subi	r20, 0xFE	; 254
    4a06:	5f 4f       	sbci	r21, 0xFF	; 255
    4a08:	89 81       	ldd	r24, Y+1	; 0x01
    4a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a0c:	fc 01       	movw	r30, r24
    4a0e:	86 89       	ldd	r24, Z+22	; 0x16
    4a10:	28 2f       	mov	r18, r24
    4a12:	30 e0       	ldi	r19, 0x00	; 0
    4a14:	c9 01       	movw	r24, r18
    4a16:	88 0f       	add	r24, r24
    4a18:	99 1f       	adc	r25, r25
    4a1a:	88 0f       	add	r24, r24
    4a1c:	99 1f       	adc	r25, r25
    4a1e:	88 0f       	add	r24, r24
    4a20:	99 1f       	adc	r25, r25
    4a22:	82 0f       	add	r24, r18
    4a24:	93 1f       	adc	r25, r19
    4a26:	8f 55       	subi	r24, 0x5F	; 95
    4a28:	99 4f       	sbci	r25, 0xF9	; 249
    4a2a:	ba 01       	movw	r22, r20
    4a2c:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4a30:	89 81       	ldd	r24, Y+1	; 0x01
    4a32:	9a 81       	ldd	r25, Y+2	; 0x02
    4a34:	fc 01       	movw	r30, r24
    4a36:	26 89       	ldd	r18, Z+22	; 0x16
    4a38:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4a3c:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4a40:	fc 01       	movw	r30, r24
    4a42:	86 89       	ldd	r24, Z+22	; 0x16
    4a44:	28 17       	cp	r18, r24
    4a46:	18 f0       	brcs	.+6      	; 0x4a4e <xTaskResumeAll+0xca>
					{
						xYieldPending = pdTRUE;
    4a48:	81 e0       	ldi	r24, 0x01	; 1
    4a4a:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4a4e:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <xPendingReadyList>
    4a52:	88 23       	and	r24, r24
    4a54:	09 f0       	breq	.+2      	; 0x4a58 <xTaskResumeAll+0xd4>
    4a56:	b2 cf       	rjmp	.-156    	; 0x49bc <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4a58:	89 81       	ldd	r24, Y+1	; 0x01
    4a5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a5c:	89 2b       	or	r24, r25
    4a5e:	11 f0       	breq	.+4      	; 0x4a64 <xTaskResumeAll+0xe0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4a60:	0e 94 8a 29 	call	0x5314	; 0x5314 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4a64:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxPendedTicks>
    4a68:	8c 83       	std	Y+4, r24	; 0x04

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4a6a:	8c 81       	ldd	r24, Y+4	; 0x04
    4a6c:	88 23       	and	r24, r24
    4a6e:	79 f0       	breq	.+30     	; 0x4a8e <xTaskResumeAll+0x10a>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4a70:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <xTaskIncrementTick>
    4a74:	88 23       	and	r24, r24
    4a76:	19 f0       	breq	.+6      	; 0x4a7e <xTaskResumeAll+0xfa>
							{
								xYieldPending = pdTRUE;
    4a78:	81 e0       	ldi	r24, 0x01	; 1
    4a7a:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4a7e:	8c 81       	ldd	r24, Y+4	; 0x04
    4a80:	81 50       	subi	r24, 0x01	; 1
    4a82:	8c 83       	std	Y+4, r24	; 0x04
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4a84:	8c 81       	ldd	r24, Y+4	; 0x04
    4a86:	88 23       	and	r24, r24
    4a88:	99 f7       	brne	.-26     	; 0x4a70 <xTaskResumeAll+0xec>

						uxPendedTicks = 0;
    4a8a:	10 92 05 07 	sts	0x0705, r1	; 0x800705 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4a8e:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xYieldPending>
    4a92:	88 23       	and	r24, r24
    4a94:	21 f0       	breq	.+8      	; 0x4a9e <xTaskResumeAll+0x11a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4a96:	81 e0       	ldi	r24, 0x01	; 1
    4a98:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4a9a:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4a9e:	0f 90       	pop	r0
    4aa0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4aa2:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4aa4:	0f 90       	pop	r0
    4aa6:	0f 90       	pop	r0
    4aa8:	0f 90       	pop	r0
    4aaa:	0f 90       	pop	r0
    4aac:	df 91       	pop	r29
    4aae:	cf 91       	pop	r28
    4ab0:	08 95       	ret

00004ab2 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4ab2:	cf 93       	push	r28
    4ab4:	df 93       	push	r29
    4ab6:	00 d0       	rcall	.+0      	; 0x4ab8 <xTaskGetTickCount+0x6>
    4ab8:	cd b7       	in	r28, 0x3d	; 61
    4aba:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4abc:	0f b6       	in	r0, 0x3f	; 63
    4abe:	f8 94       	cli
    4ac0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4ac2:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    4ac6:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    4aca:	9a 83       	std	Y+2, r25	; 0x02
    4acc:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4ace:	0f 90       	pop	r0
    4ad0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4ad2:	89 81       	ldd	r24, Y+1	; 0x01
    4ad4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4ad6:	0f 90       	pop	r0
    4ad8:	0f 90       	pop	r0
    4ada:	df 91       	pop	r29
    4adc:	cf 91       	pop	r28
    4ade:	08 95       	ret

00004ae0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4ae0:	cf 93       	push	r28
    4ae2:	df 93       	push	r29
    4ae4:	00 d0       	rcall	.+0      	; 0x4ae6 <xTaskGetTickCountFromISR+0x6>
    4ae6:	1f 92       	push	r1
    4ae8:	cd b7       	in	r28, 0x3d	; 61
    4aea:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4aec:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4aee:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    4af2:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    4af6:	9b 83       	std	Y+3, r25	; 0x03
    4af8:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4afa:	8a 81       	ldd	r24, Y+2	; 0x02
    4afc:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4afe:	0f 90       	pop	r0
    4b00:	0f 90       	pop	r0
    4b02:	0f 90       	pop	r0
    4b04:	df 91       	pop	r29
    4b06:	cf 91       	pop	r28
    4b08:	08 95       	ret

00004b0a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4b0a:	cf 93       	push	r28
    4b0c:	df 93       	push	r29
    4b0e:	cd b7       	in	r28, 0x3d	; 61
    4b10:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4b12:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
}
    4b16:	df 91       	pop	r29
    4b18:	cf 91       	pop	r28
    4b1a:	08 95       	ret

00004b1c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4b1c:	cf 93       	push	r28
    4b1e:	df 93       	push	r29
    4b20:	00 d0       	rcall	.+0      	; 0x4b22 <pcTaskGetName+0x6>
    4b22:	00 d0       	rcall	.+0      	; 0x4b24 <pcTaskGetName+0x8>
    4b24:	cd b7       	in	r28, 0x3d	; 61
    4b26:	de b7       	in	r29, 0x3e	; 62
    4b28:	9c 83       	std	Y+4, r25	; 0x04
    4b2a:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b30:	89 2b       	or	r24, r25
    4b32:	29 f4       	brne	.+10     	; 0x4b3e <pcTaskGetName+0x22>
    4b34:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4b38:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4b3c:	02 c0       	rjmp	.+4      	; 0x4b42 <pcTaskGetName+0x26>
    4b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b40:	9c 81       	ldd	r25, Y+4	; 0x04
    4b42:	9a 83       	std	Y+2, r25	; 0x02
    4b44:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4b46:	89 81       	ldd	r24, Y+1	; 0x01
    4b48:	9a 81       	ldd	r25, Y+2	; 0x02
    4b4a:	49 96       	adiw	r24, 0x19	; 25
}
    4b4c:	0f 90       	pop	r0
    4b4e:	0f 90       	pop	r0
    4b50:	0f 90       	pop	r0
    4b52:	0f 90       	pop	r0
    4b54:	df 91       	pop	r29
    4b56:	cf 91       	pop	r28
    4b58:	08 95       	ret

00004b5a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4b5a:	cf 93       	push	r28
    4b5c:	df 93       	push	r29
    4b5e:	cd b7       	in	r28, 0x3d	; 61
    4b60:	de b7       	in	r29, 0x3e	; 62
    4b62:	29 97       	sbiw	r28, 0x09	; 9
    4b64:	0f b6       	in	r0, 0x3f	; 63
    4b66:	f8 94       	cli
    4b68:	de bf       	out	0x3e, r29	; 62
    4b6a:	0f be       	out	0x3f, r0	; 63
    4b6c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4b6e:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b70:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4b74:	88 23       	and	r24, r24
    4b76:	09 f0       	breq	.+2      	; 0x4b7a <xTaskIncrementTick+0x20>
    4b78:	c8 c0       	rjmp	.+400    	; 0x4d0a <xTaskIncrementTick+0x1b0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4b7a:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    4b7e:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    4b82:	01 96       	adiw	r24, 0x01	; 1
    4b84:	9b 83       	std	Y+3, r25	; 0x03
    4b86:	8a 83       	std	Y+2, r24	; 0x02

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4b88:	8a 81       	ldd	r24, Y+2	; 0x02
    4b8a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b8c:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <xTickCount+0x1>
    4b90:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4b94:	8a 81       	ldd	r24, Y+2	; 0x02
    4b96:	9b 81       	ldd	r25, Y+3	; 0x03
    4b98:	89 2b       	or	r24, r25
    4b9a:	d9 f4       	brne	.+54     	; 0x4bd2 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4b9c:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    4ba0:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    4ba4:	9d 83       	std	Y+5, r25	; 0x05
    4ba6:	8c 83       	std	Y+4, r24	; 0x04
    4ba8:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <pxOverflowDelayedTaskList>
    4bac:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    4bb0:	90 93 e1 06 	sts	0x06E1, r25	; 0x8006e1 <pxDelayedTaskList+0x1>
    4bb4:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <pxDelayedTaskList>
    4bb8:	8c 81       	ldd	r24, Y+4	; 0x04
    4bba:	9d 81       	ldd	r25, Y+5	; 0x05
    4bbc:	90 93 e3 06 	sts	0x06E3, r25	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    4bc0:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <pxOverflowDelayedTaskList>
    4bc4:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xNumOfOverflows>
    4bc8:	8f 5f       	subi	r24, 0xFF	; 255
    4bca:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNumOfOverflows>
    4bce:	0e 94 8a 29 	call	0x5314	; 0x5314 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4bd2:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xNextTaskUnblockTime>
    4bd6:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xNextTaskUnblockTime+0x1>
    4bda:	2a 81       	ldd	r18, Y+2	; 0x02
    4bdc:	3b 81       	ldd	r19, Y+3	; 0x03
    4bde:	28 17       	cp	r18, r24
    4be0:	39 07       	cpc	r19, r25
    4be2:	08 f4       	brcc	.+2      	; 0x4be6 <xTaskIncrementTick+0x8c>
    4be4:	78 c0       	rjmp	.+240    	; 0x4cd6 <xTaskIncrementTick+0x17c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4be6:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    4bea:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    4bee:	fc 01       	movw	r30, r24
    4bf0:	80 81       	ld	r24, Z
    4bf2:	88 23       	and	r24, r24
    4bf4:	39 f4       	brne	.+14     	; 0x4c04 <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4bf6:	8f ef       	ldi	r24, 0xFF	; 255
    4bf8:	9f ef       	ldi	r25, 0xFF	; 255
    4bfa:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    4bfe:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
					break;
    4c02:	69 c0       	rjmp	.+210    	; 0x4cd6 <xTaskIncrementTick+0x17c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4c04:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    4c08:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    4c0c:	fc 01       	movw	r30, r24
    4c0e:	85 81       	ldd	r24, Z+5	; 0x05
    4c10:	96 81       	ldd	r25, Z+6	; 0x06
    4c12:	fc 01       	movw	r30, r24
    4c14:	86 81       	ldd	r24, Z+6	; 0x06
    4c16:	97 81       	ldd	r25, Z+7	; 0x07
    4c18:	9f 83       	std	Y+7, r25	; 0x07
    4c1a:	8e 83       	std	Y+6, r24	; 0x06
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4c1c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c1e:	9f 81       	ldd	r25, Y+7	; 0x07
    4c20:	fc 01       	movw	r30, r24
    4c22:	82 81       	ldd	r24, Z+2	; 0x02
    4c24:	93 81       	ldd	r25, Z+3	; 0x03
    4c26:	99 87       	std	Y+9, r25	; 0x09
    4c28:	88 87       	std	Y+8, r24	; 0x08

					if( xConstTickCount < xItemValue )
    4c2a:	2a 81       	ldd	r18, Y+2	; 0x02
    4c2c:	3b 81       	ldd	r19, Y+3	; 0x03
    4c2e:	88 85       	ldd	r24, Y+8	; 0x08
    4c30:	99 85       	ldd	r25, Y+9	; 0x09
    4c32:	28 17       	cp	r18, r24
    4c34:	39 07       	cpc	r19, r25
    4c36:	38 f4       	brcc	.+14     	; 0x4c46 <xTaskIncrementTick+0xec>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4c38:	88 85       	ldd	r24, Y+8	; 0x08
    4c3a:	99 85       	ldd	r25, Y+9	; 0x09
    4c3c:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    4c40:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    4c44:	48 c0       	rjmp	.+144    	; 0x4cd6 <xTaskIncrementTick+0x17c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4c46:	8e 81       	ldd	r24, Y+6	; 0x06
    4c48:	9f 81       	ldd	r25, Y+7	; 0x07
    4c4a:	02 96       	adiw	r24, 0x02	; 2
    4c4c:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4c50:	8e 81       	ldd	r24, Y+6	; 0x06
    4c52:	9f 81       	ldd	r25, Y+7	; 0x07
    4c54:	fc 01       	movw	r30, r24
    4c56:	84 89       	ldd	r24, Z+20	; 0x14
    4c58:	95 89       	ldd	r25, Z+21	; 0x15
    4c5a:	89 2b       	or	r24, r25
    4c5c:	29 f0       	breq	.+10     	; 0x4c68 <xTaskIncrementTick+0x10e>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4c5e:	8e 81       	ldd	r24, Y+6	; 0x06
    4c60:	9f 81       	ldd	r25, Y+7	; 0x07
    4c62:	0c 96       	adiw	r24, 0x0c	; 12
    4c64:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4c68:	8e 81       	ldd	r24, Y+6	; 0x06
    4c6a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c6c:	fc 01       	movw	r30, r24
    4c6e:	96 89       	ldd	r25, Z+22	; 0x16
    4c70:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4c74:	89 17       	cp	r24, r25
    4c76:	30 f4       	brcc	.+12     	; 0x4c84 <xTaskIncrementTick+0x12a>
    4c78:	8e 81       	ldd	r24, Y+6	; 0x06
    4c7a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c7c:	fc 01       	movw	r30, r24
    4c7e:	86 89       	ldd	r24, Z+22	; 0x16
    4c80:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    4c84:	8e 81       	ldd	r24, Y+6	; 0x06
    4c86:	9f 81       	ldd	r25, Y+7	; 0x07
    4c88:	ac 01       	movw	r20, r24
    4c8a:	4e 5f       	subi	r20, 0xFE	; 254
    4c8c:	5f 4f       	sbci	r21, 0xFF	; 255
    4c8e:	8e 81       	ldd	r24, Y+6	; 0x06
    4c90:	9f 81       	ldd	r25, Y+7	; 0x07
    4c92:	fc 01       	movw	r30, r24
    4c94:	86 89       	ldd	r24, Z+22	; 0x16
    4c96:	28 2f       	mov	r18, r24
    4c98:	30 e0       	ldi	r19, 0x00	; 0
    4c9a:	c9 01       	movw	r24, r18
    4c9c:	88 0f       	add	r24, r24
    4c9e:	99 1f       	adc	r25, r25
    4ca0:	88 0f       	add	r24, r24
    4ca2:	99 1f       	adc	r25, r25
    4ca4:	88 0f       	add	r24, r24
    4ca6:	99 1f       	adc	r25, r25
    4ca8:	82 0f       	add	r24, r18
    4caa:	93 1f       	adc	r25, r19
    4cac:	8f 55       	subi	r24, 0x5F	; 95
    4cae:	99 4f       	sbci	r25, 0xF9	; 249
    4cb0:	ba 01       	movw	r22, r20
    4cb2:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4cb6:	8e 81       	ldd	r24, Y+6	; 0x06
    4cb8:	9f 81       	ldd	r25, Y+7	; 0x07
    4cba:	fc 01       	movw	r30, r24
    4cbc:	26 89       	ldd	r18, Z+22	; 0x16
    4cbe:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4cc2:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4cc6:	fc 01       	movw	r30, r24
    4cc8:	86 89       	ldd	r24, Z+22	; 0x16
    4cca:	28 17       	cp	r18, r24
    4ccc:	08 f4       	brcc	.+2      	; 0x4cd0 <xTaskIncrementTick+0x176>
    4cce:	8b cf       	rjmp	.-234    	; 0x4be6 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4cd0:	81 e0       	ldi	r24, 0x01	; 1
    4cd2:	89 83       	std	Y+1, r24	; 0x01
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    4cd4:	88 cf       	rjmp	.-240    	; 0x4be6 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4cd6:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4cda:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4cde:	fc 01       	movw	r30, r24
    4ce0:	86 89       	ldd	r24, Z+22	; 0x16
    4ce2:	28 2f       	mov	r18, r24
    4ce4:	30 e0       	ldi	r19, 0x00	; 0
    4ce6:	c9 01       	movw	r24, r18
    4ce8:	88 0f       	add	r24, r24
    4cea:	99 1f       	adc	r25, r25
    4cec:	88 0f       	add	r24, r24
    4cee:	99 1f       	adc	r25, r25
    4cf0:	88 0f       	add	r24, r24
    4cf2:	99 1f       	adc	r25, r25
    4cf4:	82 0f       	add	r24, r18
    4cf6:	93 1f       	adc	r25, r19
    4cf8:	8f 55       	subi	r24, 0x5F	; 95
    4cfa:	99 4f       	sbci	r25, 0xF9	; 249
    4cfc:	fc 01       	movw	r30, r24
    4cfe:	80 81       	ld	r24, Z
    4d00:	82 30       	cpi	r24, 0x02	; 2
    4d02:	40 f0       	brcs	.+16     	; 0x4d14 <xTaskIncrementTick+0x1ba>
			{
				xSwitchRequired = pdTRUE;
    4d04:	81 e0       	ldi	r24, 0x01	; 1
    4d06:	89 83       	std	Y+1, r24	; 0x01
    4d08:	05 c0       	rjmp	.+10     	; 0x4d14 <xTaskIncrementTick+0x1ba>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4d0a:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxPendedTicks>
    4d0e:	8f 5f       	subi	r24, 0xFF	; 255
    4d10:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxPendedTicks>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4d14:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xYieldPending>
    4d18:	88 23       	and	r24, r24
    4d1a:	11 f0       	breq	.+4      	; 0x4d20 <xTaskIncrementTick+0x1c6>
		{
			xSwitchRequired = pdTRUE;
    4d1c:	81 e0       	ldi	r24, 0x01	; 1
    4d1e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4d20:	89 81       	ldd	r24, Y+1	; 0x01
}
    4d22:	29 96       	adiw	r28, 0x09	; 9
    4d24:	0f b6       	in	r0, 0x3f	; 63
    4d26:	f8 94       	cli
    4d28:	de bf       	out	0x3e, r29	; 62
    4d2a:	0f be       	out	0x3f, r0	; 63
    4d2c:	cd bf       	out	0x3d, r28	; 61
    4d2e:	df 91       	pop	r29
    4d30:	cf 91       	pop	r28
    4d32:	08 95       	ret

00004d34 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4d34:	cf 93       	push	r28
    4d36:	df 93       	push	r29
    4d38:	00 d0       	rcall	.+0      	; 0x4d3a <vTaskSwitchContext+0x6>
    4d3a:	1f 92       	push	r1
    4d3c:	cd b7       	in	r28, 0x3d	; 61
    4d3e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4d40:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4d44:	88 23       	and	r24, r24
    4d46:	21 f0       	breq	.+8      	; 0x4d50 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4d48:	81 e0       	ldi	r24, 0x01	; 1
    4d4a:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4d4e:	5f c0       	rjmp	.+190    	; 0x4e0e <vTaskSwitchContext+0xda>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    4d50:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d54:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4d58:	89 83       	std	Y+1, r24	; 0x01
    4d5a:	03 c0       	rjmp	.+6      	; 0x4d62 <vTaskSwitchContext+0x2e>
    4d5c:	89 81       	ldd	r24, Y+1	; 0x01
    4d5e:	81 50       	subi	r24, 0x01	; 1
    4d60:	89 83       	std	Y+1, r24	; 0x01
    4d62:	89 81       	ldd	r24, Y+1	; 0x01
    4d64:	28 2f       	mov	r18, r24
    4d66:	30 e0       	ldi	r19, 0x00	; 0
    4d68:	c9 01       	movw	r24, r18
    4d6a:	88 0f       	add	r24, r24
    4d6c:	99 1f       	adc	r25, r25
    4d6e:	88 0f       	add	r24, r24
    4d70:	99 1f       	adc	r25, r25
    4d72:	88 0f       	add	r24, r24
    4d74:	99 1f       	adc	r25, r25
    4d76:	82 0f       	add	r24, r18
    4d78:	93 1f       	adc	r25, r19
    4d7a:	8f 55       	subi	r24, 0x5F	; 95
    4d7c:	99 4f       	sbci	r25, 0xF9	; 249
    4d7e:	fc 01       	movw	r30, r24
    4d80:	80 81       	ld	r24, Z
    4d82:	88 23       	and	r24, r24
    4d84:	59 f3       	breq	.-42     	; 0x4d5c <vTaskSwitchContext+0x28>
    4d86:	89 81       	ldd	r24, Y+1	; 0x01
    4d88:	28 2f       	mov	r18, r24
    4d8a:	30 e0       	ldi	r19, 0x00	; 0
    4d8c:	c9 01       	movw	r24, r18
    4d8e:	88 0f       	add	r24, r24
    4d90:	99 1f       	adc	r25, r25
    4d92:	88 0f       	add	r24, r24
    4d94:	99 1f       	adc	r25, r25
    4d96:	88 0f       	add	r24, r24
    4d98:	99 1f       	adc	r25, r25
    4d9a:	82 0f       	add	r24, r18
    4d9c:	93 1f       	adc	r25, r19
    4d9e:	8f 55       	subi	r24, 0x5F	; 95
    4da0:	99 4f       	sbci	r25, 0xF9	; 249
    4da2:	9b 83       	std	Y+3, r25	; 0x03
    4da4:	8a 83       	std	Y+2, r24	; 0x02
    4da6:	8a 81       	ldd	r24, Y+2	; 0x02
    4da8:	9b 81       	ldd	r25, Y+3	; 0x03
    4daa:	fc 01       	movw	r30, r24
    4dac:	81 81       	ldd	r24, Z+1	; 0x01
    4dae:	92 81       	ldd	r25, Z+2	; 0x02
    4db0:	fc 01       	movw	r30, r24
    4db2:	22 81       	ldd	r18, Z+2	; 0x02
    4db4:	33 81       	ldd	r19, Z+3	; 0x03
    4db6:	8a 81       	ldd	r24, Y+2	; 0x02
    4db8:	9b 81       	ldd	r25, Y+3	; 0x03
    4dba:	fc 01       	movw	r30, r24
    4dbc:	32 83       	std	Z+2, r19	; 0x02
    4dbe:	21 83       	std	Z+1, r18	; 0x01
    4dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    4dc2:	9b 81       	ldd	r25, Y+3	; 0x03
    4dc4:	fc 01       	movw	r30, r24
    4dc6:	21 81       	ldd	r18, Z+1	; 0x01
    4dc8:	32 81       	ldd	r19, Z+2	; 0x02
    4dca:	8a 81       	ldd	r24, Y+2	; 0x02
    4dcc:	9b 81       	ldd	r25, Y+3	; 0x03
    4dce:	03 96       	adiw	r24, 0x03	; 3
    4dd0:	28 17       	cp	r18, r24
    4dd2:	39 07       	cpc	r19, r25
    4dd4:	69 f4       	brne	.+26     	; 0x4df0 <vTaskSwitchContext+0xbc>
    4dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    4dd8:	9b 81       	ldd	r25, Y+3	; 0x03
    4dda:	fc 01       	movw	r30, r24
    4ddc:	81 81       	ldd	r24, Z+1	; 0x01
    4dde:	92 81       	ldd	r25, Z+2	; 0x02
    4de0:	fc 01       	movw	r30, r24
    4de2:	22 81       	ldd	r18, Z+2	; 0x02
    4de4:	33 81       	ldd	r19, Z+3	; 0x03
    4de6:	8a 81       	ldd	r24, Y+2	; 0x02
    4de8:	9b 81       	ldd	r25, Y+3	; 0x03
    4dea:	fc 01       	movw	r30, r24
    4dec:	32 83       	std	Z+2, r19	; 0x02
    4dee:	21 83       	std	Z+1, r18	; 0x01
    4df0:	8a 81       	ldd	r24, Y+2	; 0x02
    4df2:	9b 81       	ldd	r25, Y+3	; 0x03
    4df4:	fc 01       	movw	r30, r24
    4df6:	81 81       	ldd	r24, Z+1	; 0x01
    4df8:	92 81       	ldd	r25, Z+2	; 0x02
    4dfa:	fc 01       	movw	r30, r24
    4dfc:	86 81       	ldd	r24, Z+6	; 0x06
    4dfe:	97 81       	ldd	r25, Z+7	; 0x07
    4e00:	90 93 a0 06 	sts	0x06A0, r25	; 0x8006a0 <pxCurrentTCB+0x1>
    4e04:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <pxCurrentTCB>
    4e08:	89 81       	ldd	r24, Y+1	; 0x01
    4e0a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4e0e:	00 00       	nop
    4e10:	0f 90       	pop	r0
    4e12:	0f 90       	pop	r0
    4e14:	0f 90       	pop	r0
    4e16:	df 91       	pop	r29
    4e18:	cf 91       	pop	r28
    4e1a:	08 95       	ret

00004e1c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4e1c:	cf 93       	push	r28
    4e1e:	df 93       	push	r29
    4e20:	00 d0       	rcall	.+0      	; 0x4e22 <vTaskPlaceOnEventList+0x6>
    4e22:	00 d0       	rcall	.+0      	; 0x4e24 <vTaskPlaceOnEventList+0x8>
    4e24:	cd b7       	in	r28, 0x3d	; 61
    4e26:	de b7       	in	r29, 0x3e	; 62
    4e28:	9a 83       	std	Y+2, r25	; 0x02
    4e2a:	89 83       	std	Y+1, r24	; 0x01
    4e2c:	7c 83       	std	Y+4, r23	; 0x04
    4e2e:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4e30:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4e34:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4e38:	9c 01       	movw	r18, r24
    4e3a:	24 5f       	subi	r18, 0xF4	; 244
    4e3c:	3f 4f       	sbci	r19, 0xFF	; 255
    4e3e:	89 81       	ldd	r24, Y+1	; 0x01
    4e40:	9a 81       	ldd	r25, Y+2	; 0x02
    4e42:	b9 01       	movw	r22, r18
    4e44:	0e 94 b8 13 	call	0x2770	; 0x2770 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e48:	8b 81       	ldd	r24, Y+3	; 0x03
    4e4a:	9c 81       	ldd	r25, Y+4	; 0x04
    4e4c:	61 e0       	ldi	r22, 0x01	; 1
    4e4e:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <prvAddCurrentTaskToDelayedList>
}
    4e52:	00 00       	nop
    4e54:	0f 90       	pop	r0
    4e56:	0f 90       	pop	r0
    4e58:	0f 90       	pop	r0
    4e5a:	0f 90       	pop	r0
    4e5c:	df 91       	pop	r29
    4e5e:	cf 91       	pop	r28
    4e60:	08 95       	ret

00004e62 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4e62:	cf 93       	push	r28
    4e64:	df 93       	push	r29
    4e66:	00 d0       	rcall	.+0      	; 0x4e68 <vTaskPlaceOnUnorderedEventList+0x6>
    4e68:	00 d0       	rcall	.+0      	; 0x4e6a <vTaskPlaceOnUnorderedEventList+0x8>
    4e6a:	00 d0       	rcall	.+0      	; 0x4e6c <vTaskPlaceOnUnorderedEventList+0xa>
    4e6c:	cd b7       	in	r28, 0x3d	; 61
    4e6e:	de b7       	in	r29, 0x3e	; 62
    4e70:	9a 83       	std	Y+2, r25	; 0x02
    4e72:	89 83       	std	Y+1, r24	; 0x01
    4e74:	7c 83       	std	Y+4, r23	; 0x04
    4e76:	6b 83       	std	Y+3, r22	; 0x03
    4e78:	5e 83       	std	Y+6, r21	; 0x06
    4e7a:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4e7c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4e80:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4e84:	2b 81       	ldd	r18, Y+3	; 0x03
    4e86:	3c 81       	ldd	r19, Y+4	; 0x04
    4e88:	30 68       	ori	r19, 0x80	; 128
    4e8a:	fc 01       	movw	r30, r24
    4e8c:	35 87       	std	Z+13, r19	; 0x0d
    4e8e:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4e90:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4e94:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4e98:	9c 01       	movw	r18, r24
    4e9a:	24 5f       	subi	r18, 0xF4	; 244
    4e9c:	3f 4f       	sbci	r19, 0xFF	; 255
    4e9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ea0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ea2:	b9 01       	movw	r22, r18
    4ea4:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4ea8:	8d 81       	ldd	r24, Y+5	; 0x05
    4eaa:	9e 81       	ldd	r25, Y+6	; 0x06
    4eac:	61 e0       	ldi	r22, 0x01	; 1
    4eae:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <prvAddCurrentTaskToDelayedList>
}
    4eb2:	00 00       	nop
    4eb4:	26 96       	adiw	r28, 0x06	; 6
    4eb6:	0f b6       	in	r0, 0x3f	; 63
    4eb8:	f8 94       	cli
    4eba:	de bf       	out	0x3e, r29	; 62
    4ebc:	0f be       	out	0x3f, r0	; 63
    4ebe:	cd bf       	out	0x3d, r28	; 61
    4ec0:	df 91       	pop	r29
    4ec2:	cf 91       	pop	r28
    4ec4:	08 95       	ret

00004ec6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4ec6:	cf 93       	push	r28
    4ec8:	df 93       	push	r29
    4eca:	00 d0       	rcall	.+0      	; 0x4ecc <xTaskRemoveFromEventList+0x6>
    4ecc:	00 d0       	rcall	.+0      	; 0x4ece <xTaskRemoveFromEventList+0x8>
    4ece:	1f 92       	push	r1
    4ed0:	cd b7       	in	r28, 0x3d	; 61
    4ed2:	de b7       	in	r29, 0x3e	; 62
    4ed4:	9d 83       	std	Y+5, r25	; 0x05
    4ed6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ed8:	8c 81       	ldd	r24, Y+4	; 0x04
    4eda:	9d 81       	ldd	r25, Y+5	; 0x05
    4edc:	fc 01       	movw	r30, r24
    4ede:	85 81       	ldd	r24, Z+5	; 0x05
    4ee0:	96 81       	ldd	r25, Z+6	; 0x06
    4ee2:	fc 01       	movw	r30, r24
    4ee4:	86 81       	ldd	r24, Z+6	; 0x06
    4ee6:	97 81       	ldd	r25, Z+7	; 0x07
    4ee8:	9b 83       	std	Y+3, r25	; 0x03
    4eea:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4eec:	8a 81       	ldd	r24, Y+2	; 0x02
    4eee:	9b 81       	ldd	r25, Y+3	; 0x03
    4ef0:	0c 96       	adiw	r24, 0x0c	; 12
    4ef2:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ef6:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    4efa:	88 23       	and	r24, r24
    4efc:	69 f5       	brne	.+90     	; 0x4f58 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4efe:	8a 81       	ldd	r24, Y+2	; 0x02
    4f00:	9b 81       	ldd	r25, Y+3	; 0x03
    4f02:	02 96       	adiw	r24, 0x02	; 2
    4f04:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4f08:	8a 81       	ldd	r24, Y+2	; 0x02
    4f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f0c:	fc 01       	movw	r30, r24
    4f0e:	96 89       	ldd	r25, Z+22	; 0x16
    4f10:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4f14:	89 17       	cp	r24, r25
    4f16:	30 f4       	brcc	.+12     	; 0x4f24 <xTaskRemoveFromEventList+0x5e>
    4f18:	8a 81       	ldd	r24, Y+2	; 0x02
    4f1a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f1c:	fc 01       	movw	r30, r24
    4f1e:	86 89       	ldd	r24, Z+22	; 0x16
    4f20:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    4f24:	8a 81       	ldd	r24, Y+2	; 0x02
    4f26:	9b 81       	ldd	r25, Y+3	; 0x03
    4f28:	ac 01       	movw	r20, r24
    4f2a:	4e 5f       	subi	r20, 0xFE	; 254
    4f2c:	5f 4f       	sbci	r21, 0xFF	; 255
    4f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4f30:	9b 81       	ldd	r25, Y+3	; 0x03
    4f32:	fc 01       	movw	r30, r24
    4f34:	86 89       	ldd	r24, Z+22	; 0x16
    4f36:	28 2f       	mov	r18, r24
    4f38:	30 e0       	ldi	r19, 0x00	; 0
    4f3a:	c9 01       	movw	r24, r18
    4f3c:	88 0f       	add	r24, r24
    4f3e:	99 1f       	adc	r25, r25
    4f40:	88 0f       	add	r24, r24
    4f42:	99 1f       	adc	r25, r25
    4f44:	88 0f       	add	r24, r24
    4f46:	99 1f       	adc	r25, r25
    4f48:	82 0f       	add	r24, r18
    4f4a:	93 1f       	adc	r25, r19
    4f4c:	8f 55       	subi	r24, 0x5F	; 95
    4f4e:	99 4f       	sbci	r25, 0xF9	; 249
    4f50:	ba 01       	movw	r22, r20
    4f52:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
    4f56:	08 c0       	rjmp	.+16     	; 0x4f68 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4f58:	8a 81       	ldd	r24, Y+2	; 0x02
    4f5a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f5c:	0c 96       	adiw	r24, 0x0c	; 12
    4f5e:	bc 01       	movw	r22, r24
    4f60:	84 ee       	ldi	r24, 0xE4	; 228
    4f62:	96 e0       	ldi	r25, 0x06	; 6
    4f64:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f68:	8a 81       	ldd	r24, Y+2	; 0x02
    4f6a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f6c:	fc 01       	movw	r30, r24
    4f6e:	26 89       	ldd	r18, Z+22	; 0x16
    4f70:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    4f74:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    4f78:	fc 01       	movw	r30, r24
    4f7a:	86 89       	ldd	r24, Z+22	; 0x16
    4f7c:	82 17       	cp	r24, r18
    4f7e:	30 f4       	brcc	.+12     	; 0x4f8c <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4f80:	81 e0       	ldi	r24, 0x01	; 1
    4f82:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4f84:	81 e0       	ldi	r24, 0x01	; 1
    4f86:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
    4f8a:	01 c0       	rjmp	.+2      	; 0x4f8e <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    4f8c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4f8e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f90:	0f 90       	pop	r0
    4f92:	0f 90       	pop	r0
    4f94:	0f 90       	pop	r0
    4f96:	0f 90       	pop	r0
    4f98:	0f 90       	pop	r0
    4f9a:	df 91       	pop	r29
    4f9c:	cf 91       	pop	r28
    4f9e:	08 95       	ret

00004fa0 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4fa0:	cf 93       	push	r28
    4fa2:	df 93       	push	r29
    4fa4:	00 d0       	rcall	.+0      	; 0x4fa6 <vTaskRemoveFromUnorderedEventList+0x6>
    4fa6:	00 d0       	rcall	.+0      	; 0x4fa8 <vTaskRemoveFromUnorderedEventList+0x8>
    4fa8:	00 d0       	rcall	.+0      	; 0x4faa <vTaskRemoveFromUnorderedEventList+0xa>
    4faa:	cd b7       	in	r28, 0x3d	; 61
    4fac:	de b7       	in	r29, 0x3e	; 62
    4fae:	9c 83       	std	Y+4, r25	; 0x04
    4fb0:	8b 83       	std	Y+3, r24	; 0x03
    4fb2:	7e 83       	std	Y+6, r23	; 0x06
    4fb4:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4fb6:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb8:	9e 81       	ldd	r25, Y+6	; 0x06
    4fba:	9c 01       	movw	r18, r24
    4fbc:	30 68       	ori	r19, 0x80	; 128
    4fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    4fc0:	9c 81       	ldd	r25, Y+4	; 0x04
    4fc2:	fc 01       	movw	r30, r24
    4fc4:	31 83       	std	Z+1, r19	; 0x01
    4fc6:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4fc8:	8b 81       	ldd	r24, Y+3	; 0x03
    4fca:	9c 81       	ldd	r25, Y+4	; 0x04
    4fcc:	fc 01       	movw	r30, r24
    4fce:	86 81       	ldd	r24, Z+6	; 0x06
    4fd0:	97 81       	ldd	r25, Z+7	; 0x07
    4fd2:	9a 83       	std	Y+2, r25	; 0x02
    4fd4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    4fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    4fda:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4fde:	89 81       	ldd	r24, Y+1	; 0x01
    4fe0:	9a 81       	ldd	r25, Y+2	; 0x02
    4fe2:	02 96       	adiw	r24, 0x02	; 2
    4fe4:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4fe8:	89 81       	ldd	r24, Y+1	; 0x01
    4fea:	9a 81       	ldd	r25, Y+2	; 0x02
    4fec:	fc 01       	movw	r30, r24
    4fee:	96 89       	ldd	r25, Z+22	; 0x16
    4ff0:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    4ff4:	89 17       	cp	r24, r25
    4ff6:	30 f4       	brcc	.+12     	; 0x5004 <vTaskRemoveFromUnorderedEventList+0x64>
    4ff8:	89 81       	ldd	r24, Y+1	; 0x01
    4ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    4ffc:	fc 01       	movw	r30, r24
    4ffe:	86 89       	ldd	r24, Z+22	; 0x16
    5000:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5004:	89 81       	ldd	r24, Y+1	; 0x01
    5006:	9a 81       	ldd	r25, Y+2	; 0x02
    5008:	ac 01       	movw	r20, r24
    500a:	4e 5f       	subi	r20, 0xFE	; 254
    500c:	5f 4f       	sbci	r21, 0xFF	; 255
    500e:	89 81       	ldd	r24, Y+1	; 0x01
    5010:	9a 81       	ldd	r25, Y+2	; 0x02
    5012:	fc 01       	movw	r30, r24
    5014:	86 89       	ldd	r24, Z+22	; 0x16
    5016:	28 2f       	mov	r18, r24
    5018:	30 e0       	ldi	r19, 0x00	; 0
    501a:	c9 01       	movw	r24, r18
    501c:	88 0f       	add	r24, r24
    501e:	99 1f       	adc	r25, r25
    5020:	88 0f       	add	r24, r24
    5022:	99 1f       	adc	r25, r25
    5024:	88 0f       	add	r24, r24
    5026:	99 1f       	adc	r25, r25
    5028:	82 0f       	add	r24, r18
    502a:	93 1f       	adc	r25, r19
    502c:	8f 55       	subi	r24, 0x5F	; 95
    502e:	99 4f       	sbci	r25, 0xF9	; 249
    5030:	ba 01       	movw	r22, r20
    5032:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5036:	89 81       	ldd	r24, Y+1	; 0x01
    5038:	9a 81       	ldd	r25, Y+2	; 0x02
    503a:	fc 01       	movw	r30, r24
    503c:	26 89       	ldd	r18, Z+22	; 0x16
    503e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5042:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5046:	fc 01       	movw	r30, r24
    5048:	86 89       	ldd	r24, Z+22	; 0x16
    504a:	82 17       	cp	r24, r18
    504c:	18 f4       	brcc	.+6      	; 0x5054 <vTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    504e:	81 e0       	ldi	r24, 0x01	; 1
    5050:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
	}
}
    5054:	00 00       	nop
    5056:	26 96       	adiw	r28, 0x06	; 6
    5058:	0f b6       	in	r0, 0x3f	; 63
    505a:	f8 94       	cli
    505c:	de bf       	out	0x3e, r29	; 62
    505e:	0f be       	out	0x3f, r0	; 63
    5060:	cd bf       	out	0x3d, r28	; 61
    5062:	df 91       	pop	r29
    5064:	cf 91       	pop	r28
    5066:	08 95       	ret

00005068 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5068:	cf 93       	push	r28
    506a:	df 93       	push	r29
    506c:	00 d0       	rcall	.+0      	; 0x506e <vTaskSetTimeOutState+0x6>
    506e:	cd b7       	in	r28, 0x3d	; 61
    5070:	de b7       	in	r29, 0x3e	; 62
    5072:	9a 83       	std	Y+2, r25	; 0x02
    5074:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5076:	0f b6       	in	r0, 0x3f	; 63
    5078:	f8 94       	cli
    507a:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    507c:	20 91 07 07 	lds	r18, 0x0707	; 0x800707 <xNumOfOverflows>
    5080:	89 81       	ldd	r24, Y+1	; 0x01
    5082:	9a 81       	ldd	r25, Y+2	; 0x02
    5084:	fc 01       	movw	r30, r24
    5086:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    5088:	20 91 01 07 	lds	r18, 0x0701	; 0x800701 <xTickCount>
    508c:	30 91 02 07 	lds	r19, 0x0702	; 0x800702 <xTickCount+0x1>
    5090:	89 81       	ldd	r24, Y+1	; 0x01
    5092:	9a 81       	ldd	r25, Y+2	; 0x02
    5094:	fc 01       	movw	r30, r24
    5096:	32 83       	std	Z+2, r19	; 0x02
    5098:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    509a:	0f 90       	pop	r0
    509c:	0f be       	out	0x3f, r0	; 63
}
    509e:	00 00       	nop
    50a0:	0f 90       	pop	r0
    50a2:	0f 90       	pop	r0
    50a4:	df 91       	pop	r29
    50a6:	cf 91       	pop	r28
    50a8:	08 95       	ret

000050aa <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    50aa:	cf 93       	push	r28
    50ac:	df 93       	push	r29
    50ae:	00 d0       	rcall	.+0      	; 0x50b0 <vTaskInternalSetTimeOutState+0x6>
    50b0:	cd b7       	in	r28, 0x3d	; 61
    50b2:	de b7       	in	r29, 0x3e	; 62
    50b4:	9a 83       	std	Y+2, r25	; 0x02
    50b6:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    50b8:	20 91 07 07 	lds	r18, 0x0707	; 0x800707 <xNumOfOverflows>
    50bc:	89 81       	ldd	r24, Y+1	; 0x01
    50be:	9a 81       	ldd	r25, Y+2	; 0x02
    50c0:	fc 01       	movw	r30, r24
    50c2:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    50c4:	20 91 01 07 	lds	r18, 0x0701	; 0x800701 <xTickCount>
    50c8:	30 91 02 07 	lds	r19, 0x0702	; 0x800702 <xTickCount+0x1>
    50cc:	89 81       	ldd	r24, Y+1	; 0x01
    50ce:	9a 81       	ldd	r25, Y+2	; 0x02
    50d0:	fc 01       	movw	r30, r24
    50d2:	32 83       	std	Z+2, r19	; 0x02
    50d4:	21 83       	std	Z+1, r18	; 0x01
}
    50d6:	00 00       	nop
    50d8:	0f 90       	pop	r0
    50da:	0f 90       	pop	r0
    50dc:	df 91       	pop	r29
    50de:	cf 91       	pop	r28
    50e0:	08 95       	ret

000050e2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    50e2:	cf 93       	push	r28
    50e4:	df 93       	push	r29
    50e6:	cd b7       	in	r28, 0x3d	; 61
    50e8:	de b7       	in	r29, 0x3e	; 62
    50ea:	29 97       	sbiw	r28, 0x09	; 9
    50ec:	0f b6       	in	r0, 0x3f	; 63
    50ee:	f8 94       	cli
    50f0:	de bf       	out	0x3e, r29	; 62
    50f2:	0f be       	out	0x3f, r0	; 63
    50f4:	cd bf       	out	0x3d, r28	; 61
    50f6:	9f 83       	std	Y+7, r25	; 0x07
    50f8:	8e 83       	std	Y+6, r24	; 0x06
    50fa:	79 87       	std	Y+9, r23	; 0x09
    50fc:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    50fe:	0f b6       	in	r0, 0x3f	; 63
    5100:	f8 94       	cli
    5102:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5104:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    5108:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    510c:	9b 83       	std	Y+3, r25	; 0x03
    510e:	8a 83       	std	Y+2, r24	; 0x02
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5110:	8e 81       	ldd	r24, Y+6	; 0x06
    5112:	9f 81       	ldd	r25, Y+7	; 0x07
    5114:	fc 01       	movw	r30, r24
    5116:	81 81       	ldd	r24, Z+1	; 0x01
    5118:	92 81       	ldd	r25, Z+2	; 0x02
    511a:	2a 81       	ldd	r18, Y+2	; 0x02
    511c:	3b 81       	ldd	r19, Y+3	; 0x03
    511e:	a9 01       	movw	r20, r18
    5120:	48 1b       	sub	r20, r24
    5122:	59 0b       	sbc	r21, r25
    5124:	ca 01       	movw	r24, r20
    5126:	9d 83       	std	Y+5, r25	; 0x05
    5128:	8c 83       	std	Y+4, r24	; 0x04
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    512a:	88 85       	ldd	r24, Y+8	; 0x08
    512c:	99 85       	ldd	r25, Y+9	; 0x09
    512e:	fc 01       	movw	r30, r24
    5130:	80 81       	ld	r24, Z
    5132:	91 81       	ldd	r25, Z+1	; 0x01
    5134:	01 96       	adiw	r24, 0x01	; 1
    5136:	11 f4       	brne	.+4      	; 0x513c <xTaskCheckForTimeOut+0x5a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5138:	19 82       	std	Y+1, r1	; 0x01
    513a:	3a c0       	rjmp	.+116    	; 0x51b0 <xTaskCheckForTimeOut+0xce>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    513c:	8e 81       	ldd	r24, Y+6	; 0x06
    513e:	9f 81       	ldd	r25, Y+7	; 0x07
    5140:	fc 01       	movw	r30, r24
    5142:	90 81       	ld	r25, Z
    5144:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xNumOfOverflows>
    5148:	98 17       	cp	r25, r24
    514a:	69 f0       	breq	.+26     	; 0x5166 <xTaskCheckForTimeOut+0x84>
    514c:	8e 81       	ldd	r24, Y+6	; 0x06
    514e:	9f 81       	ldd	r25, Y+7	; 0x07
    5150:	fc 01       	movw	r30, r24
    5152:	21 81       	ldd	r18, Z+1	; 0x01
    5154:	32 81       	ldd	r19, Z+2	; 0x02
    5156:	8a 81       	ldd	r24, Y+2	; 0x02
    5158:	9b 81       	ldd	r25, Y+3	; 0x03
    515a:	82 17       	cp	r24, r18
    515c:	93 07       	cpc	r25, r19
    515e:	18 f0       	brcs	.+6      	; 0x5166 <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5160:	81 e0       	ldi	r24, 0x01	; 1
    5162:	89 83       	std	Y+1, r24	; 0x01
    5164:	25 c0       	rjmp	.+74     	; 0x51b0 <xTaskCheckForTimeOut+0xce>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5166:	88 85       	ldd	r24, Y+8	; 0x08
    5168:	99 85       	ldd	r25, Y+9	; 0x09
    516a:	fc 01       	movw	r30, r24
    516c:	20 81       	ld	r18, Z
    516e:	31 81       	ldd	r19, Z+1	; 0x01
    5170:	8c 81       	ldd	r24, Y+4	; 0x04
    5172:	9d 81       	ldd	r25, Y+5	; 0x05
    5174:	82 17       	cp	r24, r18
    5176:	93 07       	cpc	r25, r19
    5178:	a0 f4       	brcc	.+40     	; 0x51a2 <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    517a:	88 85       	ldd	r24, Y+8	; 0x08
    517c:	99 85       	ldd	r25, Y+9	; 0x09
    517e:	fc 01       	movw	r30, r24
    5180:	20 81       	ld	r18, Z
    5182:	31 81       	ldd	r19, Z+1	; 0x01
    5184:	8c 81       	ldd	r24, Y+4	; 0x04
    5186:	9d 81       	ldd	r25, Y+5	; 0x05
    5188:	28 1b       	sub	r18, r24
    518a:	39 0b       	sbc	r19, r25
    518c:	88 85       	ldd	r24, Y+8	; 0x08
    518e:	99 85       	ldd	r25, Y+9	; 0x09
    5190:	fc 01       	movw	r30, r24
    5192:	31 83       	std	Z+1, r19	; 0x01
    5194:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    5196:	8e 81       	ldd	r24, Y+6	; 0x06
    5198:	9f 81       	ldd	r25, Y+7	; 0x07
    519a:	0e 94 55 28 	call	0x50aa	; 0x50aa <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    519e:	19 82       	std	Y+1, r1	; 0x01
    51a0:	07 c0       	rjmp	.+14     	; 0x51b0 <xTaskCheckForTimeOut+0xce>
		}
		else
		{
			*pxTicksToWait = 0;
    51a2:	88 85       	ldd	r24, Y+8	; 0x08
    51a4:	99 85       	ldd	r25, Y+9	; 0x09
    51a6:	fc 01       	movw	r30, r24
    51a8:	11 82       	std	Z+1, r1	; 0x01
    51aa:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    51ac:	81 e0       	ldi	r24, 0x01	; 1
    51ae:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    51b0:	0f 90       	pop	r0
    51b2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    51b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    51b6:	29 96       	adiw	r28, 0x09	; 9
    51b8:	0f b6       	in	r0, 0x3f	; 63
    51ba:	f8 94       	cli
    51bc:	de bf       	out	0x3e, r29	; 62
    51be:	0f be       	out	0x3f, r0	; 63
    51c0:	cd bf       	out	0x3d, r28	; 61
    51c2:	df 91       	pop	r29
    51c4:	cf 91       	pop	r28
    51c6:	08 95       	ret

000051c8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    51c8:	cf 93       	push	r28
    51ca:	df 93       	push	r29
    51cc:	cd b7       	in	r28, 0x3d	; 61
    51ce:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    51d0:	81 e0       	ldi	r24, 0x01	; 1
    51d2:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
}
    51d6:	00 00       	nop
    51d8:	df 91       	pop	r29
    51da:	cf 91       	pop	r28
    51dc:	08 95       	ret

000051de <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    51de:	cf 93       	push	r28
    51e0:	df 93       	push	r29
    51e2:	00 d0       	rcall	.+0      	; 0x51e4 <prvIdleTask+0x6>
    51e4:	cd b7       	in	r28, 0x3d	; 61
    51e6:	de b7       	in	r29, 0x3e	; 62
    51e8:	9a 83       	std	Y+2, r25	; 0x02
    51ea:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    51ec:	0e 94 41 29 	call	0x5282	; 0x5282 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    51f0:	80 91 a1 06 	lds	r24, 0x06A1	; 0x8006a1 <pxReadyTasksLists>
    51f4:	82 30       	cpi	r24, 0x02	; 2
    51f6:	d0 f3       	brcs	.-12     	; 0x51ec <prvIdleTask+0xe>
			{
				taskYIELD();
    51f8:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    51fc:	f7 cf       	rjmp	.-18     	; 0x51ec <prvIdleTask+0xe>

000051fe <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    51fe:	cf 93       	push	r28
    5200:	df 93       	push	r29
    5202:	1f 92       	push	r1
    5204:	cd b7       	in	r28, 0x3d	; 61
    5206:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5208:	19 82       	std	Y+1, r1	; 0x01
    520a:	13 c0       	rjmp	.+38     	; 0x5232 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    520c:	89 81       	ldd	r24, Y+1	; 0x01
    520e:	28 2f       	mov	r18, r24
    5210:	30 e0       	ldi	r19, 0x00	; 0
    5212:	c9 01       	movw	r24, r18
    5214:	88 0f       	add	r24, r24
    5216:	99 1f       	adc	r25, r25
    5218:	88 0f       	add	r24, r24
    521a:	99 1f       	adc	r25, r25
    521c:	88 0f       	add	r24, r24
    521e:	99 1f       	adc	r25, r25
    5220:	82 0f       	add	r24, r18
    5222:	93 1f       	adc	r25, r19
    5224:	8f 55       	subi	r24, 0x5F	; 95
    5226:	99 4f       	sbci	r25, 0xF9	; 249
    5228:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    522c:	89 81       	ldd	r24, Y+1	; 0x01
    522e:	8f 5f       	subi	r24, 0xFF	; 255
    5230:	89 83       	std	Y+1, r24	; 0x01
    5232:	89 81       	ldd	r24, Y+1	; 0x01
    5234:	85 30       	cpi	r24, 0x05	; 5
    5236:	50 f3       	brcs	.-44     	; 0x520c <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5238:	8e ec       	ldi	r24, 0xCE	; 206
    523a:	96 e0       	ldi	r25, 0x06	; 6
    523c:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5240:	87 ed       	ldi	r24, 0xD7	; 215
    5242:	96 e0       	ldi	r25, 0x06	; 6
    5244:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5248:	84 ee       	ldi	r24, 0xE4	; 228
    524a:	96 e0       	ldi	r25, 0x06	; 6
    524c:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5250:	8d ee       	ldi	r24, 0xED	; 237
    5252:	96 e0       	ldi	r25, 0x06	; 6
    5254:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5258:	87 ef       	ldi	r24, 0xF7	; 247
    525a:	96 e0       	ldi	r25, 0x06	; 6
    525c:	0e 94 21 13 	call	0x2642	; 0x2642 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5260:	8e ec       	ldi	r24, 0xCE	; 206
    5262:	96 e0       	ldi	r25, 0x06	; 6
    5264:	90 93 e1 06 	sts	0x06E1, r25	; 0x8006e1 <pxDelayedTaskList+0x1>
    5268:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    526c:	87 ed       	ldi	r24, 0xD7	; 215
    526e:	96 e0       	ldi	r25, 0x06	; 6
    5270:	90 93 e3 06 	sts	0x06E3, r25	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    5274:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <pxOverflowDelayedTaskList>
}
    5278:	00 00       	nop
    527a:	0f 90       	pop	r0
    527c:	df 91       	pop	r29
    527e:	cf 91       	pop	r28
    5280:	08 95       	ret

00005282 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5282:	cf 93       	push	r28
    5284:	df 93       	push	r29
    5286:	00 d0       	rcall	.+0      	; 0x5288 <prvCheckTasksWaitingTermination+0x6>
    5288:	cd b7       	in	r28, 0x3d	; 61
    528a:	de b7       	in	r29, 0x3e	; 62
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    528c:	21 c0       	rjmp	.+66     	; 0x52d0 <prvCheckTasksWaitingTermination+0x4e>
		{
			taskENTER_CRITICAL();
    528e:	0f b6       	in	r0, 0x3f	; 63
    5290:	f8 94       	cli
    5292:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5294:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xTasksWaitingTermination+0x5>
    5298:	90 91 f3 06 	lds	r25, 0x06F3	; 0x8006f3 <xTasksWaitingTermination+0x6>
    529c:	fc 01       	movw	r30, r24
    529e:	86 81       	ldd	r24, Z+6	; 0x06
    52a0:	97 81       	ldd	r25, Z+7	; 0x07
    52a2:	9a 83       	std	Y+2, r25	; 0x02
    52a4:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    52a6:	89 81       	ldd	r24, Y+1	; 0x01
    52a8:	9a 81       	ldd	r25, Y+2	; 0x02
    52aa:	02 96       	adiw	r24, 0x02	; 2
    52ac:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
				--uxCurrentNumberOfTasks;
    52b0:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxCurrentNumberOfTasks>
    52b4:	81 50       	subi	r24, 0x01	; 1
    52b6:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
    52ba:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    52be:	81 50       	subi	r24, 0x01	; 1
    52c0:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
    52c4:	0f 90       	pop	r0
    52c6:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    52c8:	89 81       	ldd	r24, Y+1	; 0x01
    52ca:	9a 81       	ldd	r25, Y+2	; 0x02
    52cc:	0e 94 72 29 	call	0x52e4	; 0x52e4 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    52d0:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxDeletedTasksWaitingCleanUp>
    52d4:	88 23       	and	r24, r24
    52d6:	d9 f6       	brne	.-74     	; 0x528e <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    52d8:	00 00       	nop
    52da:	0f 90       	pop	r0
    52dc:	0f 90       	pop	r0
    52de:	df 91       	pop	r29
    52e0:	cf 91       	pop	r28
    52e2:	08 95       	ret

000052e4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    52e4:	cf 93       	push	r28
    52e6:	df 93       	push	r29
    52e8:	00 d0       	rcall	.+0      	; 0x52ea <prvDeleteTCB+0x6>
    52ea:	cd b7       	in	r28, 0x3d	; 61
    52ec:	de b7       	in	r29, 0x3e	; 62
    52ee:	9a 83       	std	Y+2, r25	; 0x02
    52f0:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    52f2:	89 81       	ldd	r24, Y+1	; 0x01
    52f4:	9a 81       	ldd	r25, Y+2	; 0x02
    52f6:	fc 01       	movw	r30, r24
    52f8:	87 89       	ldd	r24, Z+23	; 0x17
    52fa:	90 8d       	ldd	r25, Z+24	; 0x18
    52fc:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vPortFree>
			vPortFree( pxTCB );
    5300:	89 81       	ldd	r24, Y+1	; 0x01
    5302:	9a 81       	ldd	r25, Y+2	; 0x02
    5304:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5308:	00 00       	nop
    530a:	0f 90       	pop	r0
    530c:	0f 90       	pop	r0
    530e:	df 91       	pop	r29
    5310:	cf 91       	pop	r28
    5312:	08 95       	ret

00005314 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5314:	cf 93       	push	r28
    5316:	df 93       	push	r29
    5318:	00 d0       	rcall	.+0      	; 0x531a <prvResetNextTaskUnblockTime+0x6>
    531a:	cd b7       	in	r28, 0x3d	; 61
    531c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    531e:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    5322:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    5326:	fc 01       	movw	r30, r24
    5328:	80 81       	ld	r24, Z
    532a:	88 23       	and	r24, r24
    532c:	39 f4       	brne	.+14     	; 0x533c <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    532e:	8f ef       	ldi	r24, 0xFF	; 255
    5330:	9f ef       	ldi	r25, 0xFF	; 255
    5332:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    5336:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
    533a:	15 c0       	rjmp	.+42     	; 0x5366 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    533c:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    5340:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    5344:	fc 01       	movw	r30, r24
    5346:	85 81       	ldd	r24, Z+5	; 0x05
    5348:	96 81       	ldd	r25, Z+6	; 0x06
    534a:	fc 01       	movw	r30, r24
    534c:	86 81       	ldd	r24, Z+6	; 0x06
    534e:	97 81       	ldd	r25, Z+7	; 0x07
    5350:	9a 83       	std	Y+2, r25	; 0x02
    5352:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5354:	89 81       	ldd	r24, Y+1	; 0x01
    5356:	9a 81       	ldd	r25, Y+2	; 0x02
    5358:	fc 01       	movw	r30, r24
    535a:	82 81       	ldd	r24, Z+2	; 0x02
    535c:	93 81       	ldd	r25, Z+3	; 0x03
    535e:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    5362:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>
	}
}
    5366:	00 00       	nop
    5368:	0f 90       	pop	r0
    536a:	0f 90       	pop	r0
    536c:	df 91       	pop	r29
    536e:	cf 91       	pop	r28
    5370:	08 95       	ret

00005372 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5372:	cf 93       	push	r28
    5374:	df 93       	push	r29
    5376:	00 d0       	rcall	.+0      	; 0x5378 <xTaskGetCurrentTaskHandle+0x6>
    5378:	cd b7       	in	r28, 0x3d	; 61
    537a:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    537c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5380:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5384:	9a 83       	std	Y+2, r25	; 0x02
    5386:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5388:	89 81       	ldd	r24, Y+1	; 0x01
    538a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    538c:	0f 90       	pop	r0
    538e:	0f 90       	pop	r0
    5390:	df 91       	pop	r29
    5392:	cf 91       	pop	r28
    5394:	08 95       	ret

00005396 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    5396:	cf 93       	push	r28
    5398:	df 93       	push	r29
    539a:	00 d0       	rcall	.+0      	; 0x539c <xTaskPriorityInherit+0x6>
    539c:	00 d0       	rcall	.+0      	; 0x539e <xTaskPriorityInherit+0x8>
    539e:	1f 92       	push	r1
    53a0:	cd b7       	in	r28, 0x3d	; 61
    53a2:	de b7       	in	r29, 0x3e	; 62
    53a4:	9d 83       	std	Y+5, r25	; 0x05
    53a6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    53a8:	8c 81       	ldd	r24, Y+4	; 0x04
    53aa:	9d 81       	ldd	r25, Y+5	; 0x05
    53ac:	9b 83       	std	Y+3, r25	; 0x03
    53ae:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    53b0:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    53b2:	8c 81       	ldd	r24, Y+4	; 0x04
    53b4:	9d 81       	ldd	r25, Y+5	; 0x05
    53b6:	89 2b       	or	r24, r25
    53b8:	09 f4       	brne	.+2      	; 0x53bc <xTaskPriorityInherit+0x26>
    53ba:	90 c0       	rjmp	.+288    	; 0x54dc <xTaskPriorityInherit+0x146>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    53bc:	8a 81       	ldd	r24, Y+2	; 0x02
    53be:	9b 81       	ldd	r25, Y+3	; 0x03
    53c0:	fc 01       	movw	r30, r24
    53c2:	26 89       	ldd	r18, Z+22	; 0x16
    53c4:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    53c8:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    53cc:	fc 01       	movw	r30, r24
    53ce:	86 89       	ldd	r24, Z+22	; 0x16
    53d0:	28 17       	cp	r18, r24
    53d2:	08 f0       	brcs	.+2      	; 0x53d6 <xTaskPriorityInherit+0x40>
    53d4:	75 c0       	rjmp	.+234    	; 0x54c0 <xTaskPriorityInherit+0x12a>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    53d6:	8a 81       	ldd	r24, Y+2	; 0x02
    53d8:	9b 81       	ldd	r25, Y+3	; 0x03
    53da:	fc 01       	movw	r30, r24
    53dc:	84 85       	ldd	r24, Z+12	; 0x0c
    53de:	95 85       	ldd	r25, Z+13	; 0x0d
    53e0:	99 23       	and	r25, r25
    53e2:	8c f0       	brlt	.+34     	; 0x5406 <xTaskPriorityInherit+0x70>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    53e4:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    53e8:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    53ec:	fc 01       	movw	r30, r24
    53ee:	86 89       	ldd	r24, Z+22	; 0x16
    53f0:	88 2f       	mov	r24, r24
    53f2:	90 e0       	ldi	r25, 0x00	; 0
    53f4:	25 e0       	ldi	r18, 0x05	; 5
    53f6:	30 e0       	ldi	r19, 0x00	; 0
    53f8:	28 1b       	sub	r18, r24
    53fa:	39 0b       	sbc	r19, r25
    53fc:	8a 81       	ldd	r24, Y+2	; 0x02
    53fe:	9b 81       	ldd	r25, Y+3	; 0x03
    5400:	fc 01       	movw	r30, r24
    5402:	35 87       	std	Z+13, r19	; 0x0d
    5404:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    5406:	8a 81       	ldd	r24, Y+2	; 0x02
    5408:	9b 81       	ldd	r25, Y+3	; 0x03
    540a:	fc 01       	movw	r30, r24
    540c:	42 85       	ldd	r20, Z+10	; 0x0a
    540e:	53 85       	ldd	r21, Z+11	; 0x0b
    5410:	8a 81       	ldd	r24, Y+2	; 0x02
    5412:	9b 81       	ldd	r25, Y+3	; 0x03
    5414:	fc 01       	movw	r30, r24
    5416:	86 89       	ldd	r24, Z+22	; 0x16
    5418:	28 2f       	mov	r18, r24
    541a:	30 e0       	ldi	r19, 0x00	; 0
    541c:	c9 01       	movw	r24, r18
    541e:	88 0f       	add	r24, r24
    5420:	99 1f       	adc	r25, r25
    5422:	88 0f       	add	r24, r24
    5424:	99 1f       	adc	r25, r25
    5426:	88 0f       	add	r24, r24
    5428:	99 1f       	adc	r25, r25
    542a:	82 0f       	add	r24, r18
    542c:	93 1f       	adc	r25, r19
    542e:	8f 55       	subi	r24, 0x5F	; 95
    5430:	99 4f       	sbci	r25, 0xF9	; 249
    5432:	48 17       	cp	r20, r24
    5434:	59 07       	cpc	r21, r25
    5436:	b9 f5       	brne	.+110    	; 0x54a6 <xTaskPriorityInherit+0x110>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5438:	8a 81       	ldd	r24, Y+2	; 0x02
    543a:	9b 81       	ldd	r25, Y+3	; 0x03
    543c:	02 96       	adiw	r24, 0x02	; 2
    543e:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    5442:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5446:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    544a:	fc 01       	movw	r30, r24
    544c:	26 89       	ldd	r18, Z+22	; 0x16
    544e:	8a 81       	ldd	r24, Y+2	; 0x02
    5450:	9b 81       	ldd	r25, Y+3	; 0x03
    5452:	fc 01       	movw	r30, r24
    5454:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    5456:	8a 81       	ldd	r24, Y+2	; 0x02
    5458:	9b 81       	ldd	r25, Y+3	; 0x03
    545a:	fc 01       	movw	r30, r24
    545c:	96 89       	ldd	r25, Z+22	; 0x16
    545e:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5462:	89 17       	cp	r24, r25
    5464:	30 f4       	brcc	.+12     	; 0x5472 <xTaskPriorityInherit+0xdc>
    5466:	8a 81       	ldd	r24, Y+2	; 0x02
    5468:	9b 81       	ldd	r25, Y+3	; 0x03
    546a:	fc 01       	movw	r30, r24
    546c:	86 89       	ldd	r24, Z+22	; 0x16
    546e:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5472:	8a 81       	ldd	r24, Y+2	; 0x02
    5474:	9b 81       	ldd	r25, Y+3	; 0x03
    5476:	ac 01       	movw	r20, r24
    5478:	4e 5f       	subi	r20, 0xFE	; 254
    547a:	5f 4f       	sbci	r21, 0xFF	; 255
    547c:	8a 81       	ldd	r24, Y+2	; 0x02
    547e:	9b 81       	ldd	r25, Y+3	; 0x03
    5480:	fc 01       	movw	r30, r24
    5482:	86 89       	ldd	r24, Z+22	; 0x16
    5484:	28 2f       	mov	r18, r24
    5486:	30 e0       	ldi	r19, 0x00	; 0
    5488:	c9 01       	movw	r24, r18
    548a:	88 0f       	add	r24, r24
    548c:	99 1f       	adc	r25, r25
    548e:	88 0f       	add	r24, r24
    5490:	99 1f       	adc	r25, r25
    5492:	88 0f       	add	r24, r24
    5494:	99 1f       	adc	r25, r25
    5496:	82 0f       	add	r24, r18
    5498:	93 1f       	adc	r25, r19
    549a:	8f 55       	subi	r24, 0x5F	; 95
    549c:	99 4f       	sbci	r25, 0xF9	; 249
    549e:	ba 01       	movw	r22, r20
    54a0:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
    54a4:	0a c0       	rjmp	.+20     	; 0x54ba <xTaskPriorityInherit+0x124>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    54a6:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    54aa:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    54ae:	fc 01       	movw	r30, r24
    54b0:	26 89       	ldd	r18, Z+22	; 0x16
    54b2:	8a 81       	ldd	r24, Y+2	; 0x02
    54b4:	9b 81       	ldd	r25, Y+3	; 0x03
    54b6:	fc 01       	movw	r30, r24
    54b8:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    54ba:	81 e0       	ldi	r24, 0x01	; 1
    54bc:	89 83       	std	Y+1, r24	; 0x01
    54be:	0e c0       	rjmp	.+28     	; 0x54dc <xTaskPriorityInherit+0x146>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    54c0:	8a 81       	ldd	r24, Y+2	; 0x02
    54c2:	9b 81       	ldd	r25, Y+3	; 0x03
    54c4:	fc 01       	movw	r30, r24
    54c6:	21 a1       	ldd	r18, Z+33	; 0x21
    54c8:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    54cc:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    54d0:	fc 01       	movw	r30, r24
    54d2:	86 89       	ldd	r24, Z+22	; 0x16
    54d4:	28 17       	cp	r18, r24
    54d6:	10 f4       	brcc	.+4      	; 0x54dc <xTaskPriorityInherit+0x146>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    54d8:	81 e0       	ldi	r24, 0x01	; 1
    54da:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    54dc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    54de:	0f 90       	pop	r0
    54e0:	0f 90       	pop	r0
    54e2:	0f 90       	pop	r0
    54e4:	0f 90       	pop	r0
    54e6:	0f 90       	pop	r0
    54e8:	df 91       	pop	r29
    54ea:	cf 91       	pop	r28
    54ec:	08 95       	ret

000054ee <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    54ee:	cf 93       	push	r28
    54f0:	df 93       	push	r29
    54f2:	00 d0       	rcall	.+0      	; 0x54f4 <xTaskPriorityDisinherit+0x6>
    54f4:	00 d0       	rcall	.+0      	; 0x54f6 <xTaskPriorityDisinherit+0x8>
    54f6:	1f 92       	push	r1
    54f8:	cd b7       	in	r28, 0x3d	; 61
    54fa:	de b7       	in	r29, 0x3e	; 62
    54fc:	9d 83       	std	Y+5, r25	; 0x05
    54fe:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    5500:	8c 81       	ldd	r24, Y+4	; 0x04
    5502:	9d 81       	ldd	r25, Y+5	; 0x05
    5504:	9b 83       	std	Y+3, r25	; 0x03
    5506:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    5508:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    550a:	8c 81       	ldd	r24, Y+4	; 0x04
    550c:	9d 81       	ldd	r25, Y+5	; 0x05
    550e:	89 2b       	or	r24, r25
    5510:	09 f4       	brne	.+2      	; 0x5514 <xTaskPriorityDisinherit+0x26>
    5512:	61 c0       	rjmp	.+194    	; 0x55d6 <xTaskPriorityDisinherit+0xe8>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    5514:	8a 81       	ldd	r24, Y+2	; 0x02
    5516:	9b 81       	ldd	r25, Y+3	; 0x03
    5518:	fc 01       	movw	r30, r24
    551a:	82 a1       	ldd	r24, Z+34	; 0x22
    551c:	2f ef       	ldi	r18, 0xFF	; 255
    551e:	28 0f       	add	r18, r24
    5520:	8a 81       	ldd	r24, Y+2	; 0x02
    5522:	9b 81       	ldd	r25, Y+3	; 0x03
    5524:	fc 01       	movw	r30, r24
    5526:	22 a3       	std	Z+34, r18	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    5528:	8a 81       	ldd	r24, Y+2	; 0x02
    552a:	9b 81       	ldd	r25, Y+3	; 0x03
    552c:	fc 01       	movw	r30, r24
    552e:	26 89       	ldd	r18, Z+22	; 0x16
    5530:	8a 81       	ldd	r24, Y+2	; 0x02
    5532:	9b 81       	ldd	r25, Y+3	; 0x03
    5534:	fc 01       	movw	r30, r24
    5536:	81 a1       	ldd	r24, Z+33	; 0x21
    5538:	28 17       	cp	r18, r24
    553a:	09 f4       	brne	.+2      	; 0x553e <xTaskPriorityDisinherit+0x50>
    553c:	4c c0       	rjmp	.+152    	; 0x55d6 <xTaskPriorityDisinherit+0xe8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    553e:	8a 81       	ldd	r24, Y+2	; 0x02
    5540:	9b 81       	ldd	r25, Y+3	; 0x03
    5542:	fc 01       	movw	r30, r24
    5544:	82 a1       	ldd	r24, Z+34	; 0x22
    5546:	88 23       	and	r24, r24
    5548:	09 f0       	breq	.+2      	; 0x554c <xTaskPriorityDisinherit+0x5e>
    554a:	45 c0       	rjmp	.+138    	; 0x55d6 <xTaskPriorityDisinherit+0xe8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    554c:	8a 81       	ldd	r24, Y+2	; 0x02
    554e:	9b 81       	ldd	r25, Y+3	; 0x03
    5550:	02 96       	adiw	r24, 0x02	; 2
    5552:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    5556:	8a 81       	ldd	r24, Y+2	; 0x02
    5558:	9b 81       	ldd	r25, Y+3	; 0x03
    555a:	fc 01       	movw	r30, r24
    555c:	21 a1       	ldd	r18, Z+33	; 0x21
    555e:	8a 81       	ldd	r24, Y+2	; 0x02
    5560:	9b 81       	ldd	r25, Y+3	; 0x03
    5562:	fc 01       	movw	r30, r24
    5564:	26 8b       	std	Z+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5566:	8a 81       	ldd	r24, Y+2	; 0x02
    5568:	9b 81       	ldd	r25, Y+3	; 0x03
    556a:	fc 01       	movw	r30, r24
    556c:	86 89       	ldd	r24, Z+22	; 0x16
    556e:	88 2f       	mov	r24, r24
    5570:	90 e0       	ldi	r25, 0x00	; 0
    5572:	25 e0       	ldi	r18, 0x05	; 5
    5574:	30 e0       	ldi	r19, 0x00	; 0
    5576:	28 1b       	sub	r18, r24
    5578:	39 0b       	sbc	r19, r25
    557a:	8a 81       	ldd	r24, Y+2	; 0x02
    557c:	9b 81       	ldd	r25, Y+3	; 0x03
    557e:	fc 01       	movw	r30, r24
    5580:	35 87       	std	Z+13, r19	; 0x0d
    5582:	24 87       	std	Z+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    5584:	8a 81       	ldd	r24, Y+2	; 0x02
    5586:	9b 81       	ldd	r25, Y+3	; 0x03
    5588:	fc 01       	movw	r30, r24
    558a:	96 89       	ldd	r25, Z+22	; 0x16
    558c:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5590:	89 17       	cp	r24, r25
    5592:	30 f4       	brcc	.+12     	; 0x55a0 <xTaskPriorityDisinherit+0xb2>
    5594:	8a 81       	ldd	r24, Y+2	; 0x02
    5596:	9b 81       	ldd	r25, Y+3	; 0x03
    5598:	fc 01       	movw	r30, r24
    559a:	86 89       	ldd	r24, Z+22	; 0x16
    559c:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    55a0:	8a 81       	ldd	r24, Y+2	; 0x02
    55a2:	9b 81       	ldd	r25, Y+3	; 0x03
    55a4:	ac 01       	movw	r20, r24
    55a6:	4e 5f       	subi	r20, 0xFE	; 254
    55a8:	5f 4f       	sbci	r21, 0xFF	; 255
    55aa:	8a 81       	ldd	r24, Y+2	; 0x02
    55ac:	9b 81       	ldd	r25, Y+3	; 0x03
    55ae:	fc 01       	movw	r30, r24
    55b0:	86 89       	ldd	r24, Z+22	; 0x16
    55b2:	28 2f       	mov	r18, r24
    55b4:	30 e0       	ldi	r19, 0x00	; 0
    55b6:	c9 01       	movw	r24, r18
    55b8:	88 0f       	add	r24, r24
    55ba:	99 1f       	adc	r25, r25
    55bc:	88 0f       	add	r24, r24
    55be:	99 1f       	adc	r25, r25
    55c0:	88 0f       	add	r24, r24
    55c2:	99 1f       	adc	r25, r25
    55c4:	82 0f       	add	r24, r18
    55c6:	93 1f       	adc	r25, r19
    55c8:	8f 55       	subi	r24, 0x5F	; 95
    55ca:	99 4f       	sbci	r25, 0xF9	; 249
    55cc:	ba 01       	movw	r22, r20
    55ce:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    55d2:	81 e0       	ldi	r24, 0x01	; 1
    55d4:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    55d6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    55d8:	0f 90       	pop	r0
    55da:	0f 90       	pop	r0
    55dc:	0f 90       	pop	r0
    55de:	0f 90       	pop	r0
    55e0:	0f 90       	pop	r0
    55e2:	df 91       	pop	r29
    55e4:	cf 91       	pop	r28
    55e6:	08 95       	ret

000055e8 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    55e8:	cf 93       	push	r28
    55ea:	df 93       	push	r29
    55ec:	cd b7       	in	r28, 0x3d	; 61
    55ee:	de b7       	in	r29, 0x3e	; 62
    55f0:	28 97       	sbiw	r28, 0x08	; 8
    55f2:	0f b6       	in	r0, 0x3f	; 63
    55f4:	f8 94       	cli
    55f6:	de bf       	out	0x3e, r29	; 62
    55f8:	0f be       	out	0x3f, r0	; 63
    55fa:	cd bf       	out	0x3d, r28	; 61
    55fc:	9f 83       	std	Y+7, r25	; 0x07
    55fe:	8e 83       	std	Y+6, r24	; 0x06
    5600:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    5602:	8e 81       	ldd	r24, Y+6	; 0x06
    5604:	9f 81       	ldd	r25, Y+7	; 0x07
    5606:	9b 83       	std	Y+3, r25	; 0x03
    5608:	8a 83       	std	Y+2, r24	; 0x02
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    560a:	81 e0       	ldi	r24, 0x01	; 1
    560c:	8c 83       	std	Y+4, r24	; 0x04

		if( pxMutexHolder != NULL )
    560e:	8e 81       	ldd	r24, Y+6	; 0x06
    5610:	9f 81       	ldd	r25, Y+7	; 0x07
    5612:	89 2b       	or	r24, r25
    5614:	09 f4       	brne	.+2      	; 0x5618 <vTaskPriorityDisinheritAfterTimeout+0x30>
    5616:	7e c0       	rjmp	.+252    	; 0x5714 <vTaskPriorityDisinheritAfterTimeout+0x12c>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    5618:	8a 81       	ldd	r24, Y+2	; 0x02
    561a:	9b 81       	ldd	r25, Y+3	; 0x03
    561c:	fc 01       	movw	r30, r24
    561e:	91 a1       	ldd	r25, Z+33	; 0x21
    5620:	88 85       	ldd	r24, Y+8	; 0x08
    5622:	98 17       	cp	r25, r24
    5624:	18 f4       	brcc	.+6      	; 0x562c <vTaskPriorityDisinheritAfterTimeout+0x44>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    5626:	88 85       	ldd	r24, Y+8	; 0x08
    5628:	89 83       	std	Y+1, r24	; 0x01
    562a:	05 c0       	rjmp	.+10     	; 0x5636 <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    562c:	8a 81       	ldd	r24, Y+2	; 0x02
    562e:	9b 81       	ldd	r25, Y+3	; 0x03
    5630:	fc 01       	movw	r30, r24
    5632:	81 a1       	ldd	r24, Z+33	; 0x21
    5634:	89 83       	std	Y+1, r24	; 0x01
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    5636:	8a 81       	ldd	r24, Y+2	; 0x02
    5638:	9b 81       	ldd	r25, Y+3	; 0x03
    563a:	fc 01       	movw	r30, r24
    563c:	96 89       	ldd	r25, Z+22	; 0x16
    563e:	89 81       	ldd	r24, Y+1	; 0x01
    5640:	98 17       	cp	r25, r24
    5642:	09 f4       	brne	.+2      	; 0x5646 <vTaskPriorityDisinheritAfterTimeout+0x5e>
    5644:	67 c0       	rjmp	.+206    	; 0x5714 <vTaskPriorityDisinheritAfterTimeout+0x12c>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    5646:	8a 81       	ldd	r24, Y+2	; 0x02
    5648:	9b 81       	ldd	r25, Y+3	; 0x03
    564a:	fc 01       	movw	r30, r24
    564c:	92 a1       	ldd	r25, Z+34	; 0x22
    564e:	8c 81       	ldd	r24, Y+4	; 0x04
    5650:	98 17       	cp	r25, r24
    5652:	09 f0       	breq	.+2      	; 0x5656 <vTaskPriorityDisinheritAfterTimeout+0x6e>
    5654:	5f c0       	rjmp	.+190    	; 0x5714 <vTaskPriorityDisinheritAfterTimeout+0x12c>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    5656:	8a 81       	ldd	r24, Y+2	; 0x02
    5658:	9b 81       	ldd	r25, Y+3	; 0x03
    565a:	fc 01       	movw	r30, r24
    565c:	86 89       	ldd	r24, Z+22	; 0x16
    565e:	8d 83       	std	Y+5, r24	; 0x05
					pxTCB->uxPriority = uxPriorityToUse;
    5660:	8a 81       	ldd	r24, Y+2	; 0x02
    5662:	9b 81       	ldd	r25, Y+3	; 0x03
    5664:	29 81       	ldd	r18, Y+1	; 0x01
    5666:	fc 01       	movw	r30, r24
    5668:	26 8b       	std	Z+22, r18	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    566a:	8a 81       	ldd	r24, Y+2	; 0x02
    566c:	9b 81       	ldd	r25, Y+3	; 0x03
    566e:	fc 01       	movw	r30, r24
    5670:	84 85       	ldd	r24, Z+12	; 0x0c
    5672:	95 85       	ldd	r25, Z+13	; 0x0d
    5674:	99 23       	and	r25, r25
    5676:	64 f0       	brlt	.+24     	; 0x5690 <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5678:	89 81       	ldd	r24, Y+1	; 0x01
    567a:	88 2f       	mov	r24, r24
    567c:	90 e0       	ldi	r25, 0x00	; 0
    567e:	25 e0       	ldi	r18, 0x05	; 5
    5680:	30 e0       	ldi	r19, 0x00	; 0
    5682:	28 1b       	sub	r18, r24
    5684:	39 0b       	sbc	r19, r25
    5686:	8a 81       	ldd	r24, Y+2	; 0x02
    5688:	9b 81       	ldd	r25, Y+3	; 0x03
    568a:	fc 01       	movw	r30, r24
    568c:	35 87       	std	Z+13, r19	; 0x0d
    568e:	24 87       	std	Z+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    5690:	8a 81       	ldd	r24, Y+2	; 0x02
    5692:	9b 81       	ldd	r25, Y+3	; 0x03
    5694:	fc 01       	movw	r30, r24
    5696:	42 85       	ldd	r20, Z+10	; 0x0a
    5698:	53 85       	ldd	r21, Z+11	; 0x0b
    569a:	8d 81       	ldd	r24, Y+5	; 0x05
    569c:	28 2f       	mov	r18, r24
    569e:	30 e0       	ldi	r19, 0x00	; 0
    56a0:	c9 01       	movw	r24, r18
    56a2:	88 0f       	add	r24, r24
    56a4:	99 1f       	adc	r25, r25
    56a6:	88 0f       	add	r24, r24
    56a8:	99 1f       	adc	r25, r25
    56aa:	88 0f       	add	r24, r24
    56ac:	99 1f       	adc	r25, r25
    56ae:	82 0f       	add	r24, r18
    56b0:	93 1f       	adc	r25, r19
    56b2:	8f 55       	subi	r24, 0x5F	; 95
    56b4:	99 4f       	sbci	r25, 0xF9	; 249
    56b6:	48 17       	cp	r20, r24
    56b8:	59 07       	cpc	r21, r25
    56ba:	61 f5       	brne	.+88     	; 0x5714 <vTaskPriorityDisinheritAfterTimeout+0x12c>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    56bc:	8a 81       	ldd	r24, Y+2	; 0x02
    56be:	9b 81       	ldd	r25, Y+3	; 0x03
    56c0:	02 96       	adiw	r24, 0x02	; 2
    56c2:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    56c6:	8a 81       	ldd	r24, Y+2	; 0x02
    56c8:	9b 81       	ldd	r25, Y+3	; 0x03
    56ca:	fc 01       	movw	r30, r24
    56cc:	96 89       	ldd	r25, Z+22	; 0x16
    56ce:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    56d2:	89 17       	cp	r24, r25
    56d4:	30 f4       	brcc	.+12     	; 0x56e2 <vTaskPriorityDisinheritAfterTimeout+0xfa>
    56d6:	8a 81       	ldd	r24, Y+2	; 0x02
    56d8:	9b 81       	ldd	r25, Y+3	; 0x03
    56da:	fc 01       	movw	r30, r24
    56dc:	86 89       	ldd	r24, Z+22	; 0x16
    56de:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    56e2:	8a 81       	ldd	r24, Y+2	; 0x02
    56e4:	9b 81       	ldd	r25, Y+3	; 0x03
    56e6:	ac 01       	movw	r20, r24
    56e8:	4e 5f       	subi	r20, 0xFE	; 254
    56ea:	5f 4f       	sbci	r21, 0xFF	; 255
    56ec:	8a 81       	ldd	r24, Y+2	; 0x02
    56ee:	9b 81       	ldd	r25, Y+3	; 0x03
    56f0:	fc 01       	movw	r30, r24
    56f2:	86 89       	ldd	r24, Z+22	; 0x16
    56f4:	28 2f       	mov	r18, r24
    56f6:	30 e0       	ldi	r19, 0x00	; 0
    56f8:	c9 01       	movw	r24, r18
    56fa:	88 0f       	add	r24, r24
    56fc:	99 1f       	adc	r25, r25
    56fe:	88 0f       	add	r24, r24
    5700:	99 1f       	adc	r25, r25
    5702:	88 0f       	add	r24, r24
    5704:	99 1f       	adc	r25, r25
    5706:	82 0f       	add	r24, r18
    5708:	93 1f       	adc	r25, r19
    570a:	8f 55       	subi	r24, 0x5F	; 95
    570c:	99 4f       	sbci	r25, 0xF9	; 249
    570e:	ba 01       	movw	r22, r20
    5710:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5714:	00 00       	nop
    5716:	28 96       	adiw	r28, 0x08	; 8
    5718:	0f b6       	in	r0, 0x3f	; 63
    571a:	f8 94       	cli
    571c:	de bf       	out	0x3e, r29	; 62
    571e:	0f be       	out	0x3f, r0	; 63
    5720:	cd bf       	out	0x3d, r28	; 61
    5722:	df 91       	pop	r29
    5724:	cf 91       	pop	r28
    5726:	08 95       	ret

00005728 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5728:	cf 93       	push	r28
    572a:	df 93       	push	r29
    572c:	00 d0       	rcall	.+0      	; 0x572e <uxTaskResetEventItemValue+0x6>
    572e:	cd b7       	in	r28, 0x3d	; 61
    5730:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5732:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5736:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    573a:	fc 01       	movw	r30, r24
    573c:	84 85       	ldd	r24, Z+12	; 0x0c
    573e:	95 85       	ldd	r25, Z+13	; 0x0d
    5740:	9a 83       	std	Y+2, r25	; 0x02
    5742:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5744:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5748:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    574c:	20 91 9f 06 	lds	r18, 0x069F	; 0x80069f <pxCurrentTCB>
    5750:	30 91 a0 06 	lds	r19, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5754:	f9 01       	movw	r30, r18
    5756:	26 89       	ldd	r18, Z+22	; 0x16
    5758:	22 2f       	mov	r18, r18
    575a:	30 e0       	ldi	r19, 0x00	; 0
    575c:	45 e0       	ldi	r20, 0x05	; 5
    575e:	50 e0       	ldi	r21, 0x00	; 0
    5760:	ba 01       	movw	r22, r20
    5762:	62 1b       	sub	r22, r18
    5764:	73 0b       	sbc	r23, r19
    5766:	9b 01       	movw	r18, r22
    5768:	fc 01       	movw	r30, r24
    576a:	35 87       	std	Z+13, r19	; 0x0d
    576c:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    576e:	89 81       	ldd	r24, Y+1	; 0x01
    5770:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5772:	0f 90       	pop	r0
    5774:	0f 90       	pop	r0
    5776:	df 91       	pop	r29
    5778:	cf 91       	pop	r28
    577a:	08 95       	ret

0000577c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    577c:	cf 93       	push	r28
    577e:	df 93       	push	r29
    5780:	cd b7       	in	r28, 0x3d	; 61
    5782:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    5784:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5788:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    578c:	89 2b       	or	r24, r25
    578e:	49 f0       	breq	.+18     	; 0x57a2 <pvTaskIncrementMutexHeldCount+0x26>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    5790:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5794:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5798:	fc 01       	movw	r30, r24
    579a:	22 a1       	ldd	r18, Z+34	; 0x22
    579c:	2f 5f       	subi	r18, 0xFF	; 255
    579e:	fc 01       	movw	r30, r24
    57a0:	22 a3       	std	Z+34, r18	; 0x22
		}

		return pxCurrentTCB;
    57a2:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    57a6:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
	}
    57aa:	df 91       	pop	r29
    57ac:	cf 91       	pop	r28
    57ae:	08 95       	ret

000057b0 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    57b0:	cf 93       	push	r28
    57b2:	df 93       	push	r29
    57b4:	cd b7       	in	r28, 0x3d	; 61
    57b6:	de b7       	in	r29, 0x3e	; 62
    57b8:	27 97       	sbiw	r28, 0x07	; 7
    57ba:	0f b6       	in	r0, 0x3f	; 63
    57bc:	f8 94       	cli
    57be:	de bf       	out	0x3e, r29	; 62
    57c0:	0f be       	out	0x3f, r0	; 63
    57c2:	cd bf       	out	0x3d, r28	; 61
    57c4:	8d 83       	std	Y+5, r24	; 0x05
    57c6:	7f 83       	std	Y+7, r23	; 0x07
    57c8:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    57ca:	0f b6       	in	r0, 0x3f	; 63
    57cc:	f8 94       	cli
    57ce:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    57d0:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    57d4:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    57d8:	fc 01       	movw	r30, r24
    57da:	83 a1       	ldd	r24, Z+35	; 0x23
    57dc:	94 a1       	ldd	r25, Z+36	; 0x24
    57de:	a5 a1       	ldd	r26, Z+37	; 0x25
    57e0:	b6 a1       	ldd	r27, Z+38	; 0x26
    57e2:	89 2b       	or	r24, r25
    57e4:	8a 2b       	or	r24, r26
    57e6:	8b 2b       	or	r24, r27
    57e8:	91 f4       	brne	.+36     	; 0x580e <ulTaskNotifyTake+0x5e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    57ea:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    57ee:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    57f2:	21 e0       	ldi	r18, 0x01	; 1
    57f4:	fc 01       	movw	r30, r24
    57f6:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    57f8:	8e 81       	ldd	r24, Y+6	; 0x06
    57fa:	9f 81       	ldd	r25, Y+7	; 0x07
    57fc:	89 2b       	or	r24, r25
    57fe:	39 f0       	breq	.+14     	; 0x580e <ulTaskNotifyTake+0x5e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5800:	8e 81       	ldd	r24, Y+6	; 0x06
    5802:	9f 81       	ldd	r25, Y+7	; 0x07
    5804:	61 e0       	ldi	r22, 0x01	; 1
    5806:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    580a:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    580e:	0f 90       	pop	r0
    5810:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5812:	0f b6       	in	r0, 0x3f	; 63
    5814:	f8 94       	cli
    5816:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5818:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    581c:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5820:	fc 01       	movw	r30, r24
    5822:	83 a1       	ldd	r24, Z+35	; 0x23
    5824:	94 a1       	ldd	r25, Z+36	; 0x24
    5826:	a5 a1       	ldd	r26, Z+37	; 0x25
    5828:	b6 a1       	ldd	r27, Z+38	; 0x26
    582a:	89 83       	std	Y+1, r24	; 0x01
    582c:	9a 83       	std	Y+2, r25	; 0x02
    582e:	ab 83       	std	Y+3, r26	; 0x03
    5830:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5832:	89 81       	ldd	r24, Y+1	; 0x01
    5834:	9a 81       	ldd	r25, Y+2	; 0x02
    5836:	ab 81       	ldd	r26, Y+3	; 0x03
    5838:	bc 81       	ldd	r27, Y+4	; 0x04
    583a:	89 2b       	or	r24, r25
    583c:	8a 2b       	or	r24, r26
    583e:	8b 2b       	or	r24, r27
    5840:	e9 f0       	breq	.+58     	; 0x587c <ulTaskNotifyTake+0xcc>
			{
				if( xClearCountOnExit != pdFALSE )
    5842:	8d 81       	ldd	r24, Y+5	; 0x05
    5844:	88 23       	and	r24, r24
    5846:	51 f0       	breq	.+20     	; 0x585c <ulTaskNotifyTake+0xac>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5848:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    584c:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5850:	fc 01       	movw	r30, r24
    5852:	13 a2       	std	Z+35, r1	; 0x23
    5854:	14 a2       	std	Z+36, r1	; 0x24
    5856:	15 a2       	std	Z+37, r1	; 0x25
    5858:	16 a2       	std	Z+38, r1	; 0x26
    585a:	10 c0       	rjmp	.+32     	; 0x587c <ulTaskNotifyTake+0xcc>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    585c:	20 91 9f 06 	lds	r18, 0x069F	; 0x80069f <pxCurrentTCB>
    5860:	30 91 a0 06 	lds	r19, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5864:	89 81       	ldd	r24, Y+1	; 0x01
    5866:	9a 81       	ldd	r25, Y+2	; 0x02
    5868:	ab 81       	ldd	r26, Y+3	; 0x03
    586a:	bc 81       	ldd	r27, Y+4	; 0x04
    586c:	01 97       	sbiw	r24, 0x01	; 1
    586e:	a1 09       	sbc	r26, r1
    5870:	b1 09       	sbc	r27, r1
    5872:	f9 01       	movw	r30, r18
    5874:	83 a3       	std	Z+35, r24	; 0x23
    5876:	94 a3       	std	Z+36, r25	; 0x24
    5878:	a5 a3       	std	Z+37, r26	; 0x25
    587a:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    587c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5880:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5884:	fc 01       	movw	r30, r24
    5886:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5888:	0f 90       	pop	r0
    588a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    588c:	89 81       	ldd	r24, Y+1	; 0x01
    588e:	9a 81       	ldd	r25, Y+2	; 0x02
    5890:	ab 81       	ldd	r26, Y+3	; 0x03
    5892:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5894:	bc 01       	movw	r22, r24
    5896:	cd 01       	movw	r24, r26
    5898:	27 96       	adiw	r28, 0x07	; 7
    589a:	0f b6       	in	r0, 0x3f	; 63
    589c:	f8 94       	cli
    589e:	de bf       	out	0x3e, r29	; 62
    58a0:	0f be       	out	0x3f, r0	; 63
    58a2:	cd bf       	out	0x3d, r28	; 61
    58a4:	df 91       	pop	r29
    58a6:	cf 91       	pop	r28
    58a8:	08 95       	ret

000058aa <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    58aa:	ef 92       	push	r14
    58ac:	ff 92       	push	r15
    58ae:	0f 93       	push	r16
    58b0:	1f 93       	push	r17
    58b2:	cf 93       	push	r28
    58b4:	df 93       	push	r29
    58b6:	cd b7       	in	r28, 0x3d	; 61
    58b8:	de b7       	in	r29, 0x3e	; 62
    58ba:	2d 97       	sbiw	r28, 0x0d	; 13
    58bc:	0f b6       	in	r0, 0x3f	; 63
    58be:	f8 94       	cli
    58c0:	de bf       	out	0x3e, r29	; 62
    58c2:	0f be       	out	0x3f, r0	; 63
    58c4:	cd bf       	out	0x3d, r28	; 61
    58c6:	6a 83       	std	Y+2, r22	; 0x02
    58c8:	7b 83       	std	Y+3, r23	; 0x03
    58ca:	8c 83       	std	Y+4, r24	; 0x04
    58cc:	9d 83       	std	Y+5, r25	; 0x05
    58ce:	2e 83       	std	Y+6, r18	; 0x06
    58d0:	3f 83       	std	Y+7, r19	; 0x07
    58d2:	48 87       	std	Y+8, r20	; 0x08
    58d4:	59 87       	std	Y+9, r21	; 0x09
    58d6:	1b 87       	std	Y+11, r17	; 0x0b
    58d8:	0a 87       	std	Y+10, r16	; 0x0a
    58da:	fd 86       	std	Y+13, r15	; 0x0d
    58dc:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    58de:	0f b6       	in	r0, 0x3f	; 63
    58e0:	f8 94       	cli
    58e2:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    58e4:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    58e8:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    58ec:	fc 01       	movw	r30, r24
    58ee:	87 a1       	ldd	r24, Z+39	; 0x27
    58f0:	82 30       	cpi	r24, 0x02	; 2
    58f2:	61 f1       	breq	.+88     	; 0x594c <xTaskNotifyWait+0xa2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    58f4:	60 91 9f 06 	lds	r22, 0x069F	; 0x80069f <pxCurrentTCB>
    58f8:	70 91 a0 06 	lds	r23, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    58fc:	fb 01       	movw	r30, r22
    58fe:	23 a1       	ldd	r18, Z+35	; 0x23
    5900:	34 a1       	ldd	r19, Z+36	; 0x24
    5902:	45 a1       	ldd	r20, Z+37	; 0x25
    5904:	56 a1       	ldd	r21, Z+38	; 0x26
    5906:	8a 81       	ldd	r24, Y+2	; 0x02
    5908:	9b 81       	ldd	r25, Y+3	; 0x03
    590a:	ac 81       	ldd	r26, Y+4	; 0x04
    590c:	bd 81       	ldd	r27, Y+5	; 0x05
    590e:	80 95       	com	r24
    5910:	90 95       	com	r25
    5912:	a0 95       	com	r26
    5914:	b0 95       	com	r27
    5916:	82 23       	and	r24, r18
    5918:	93 23       	and	r25, r19
    591a:	a4 23       	and	r26, r20
    591c:	b5 23       	and	r27, r21
    591e:	fb 01       	movw	r30, r22
    5920:	83 a3       	std	Z+35, r24	; 0x23
    5922:	94 a3       	std	Z+36, r25	; 0x24
    5924:	a5 a3       	std	Z+37, r26	; 0x25
    5926:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5928:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    592c:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5930:	21 e0       	ldi	r18, 0x01	; 1
    5932:	fc 01       	movw	r30, r24
    5934:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5936:	8c 85       	ldd	r24, Y+12	; 0x0c
    5938:	9d 85       	ldd	r25, Y+13	; 0x0d
    593a:	89 2b       	or	r24, r25
    593c:	39 f0       	breq	.+14     	; 0x594c <xTaskNotifyWait+0xa2>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    593e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5940:	9d 85       	ldd	r25, Y+13	; 0x0d
    5942:	61 e0       	ldi	r22, 0x01	; 1
    5944:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5948:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    594c:	0f 90       	pop	r0
    594e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5950:	0f b6       	in	r0, 0x3f	; 63
    5952:	f8 94       	cli
    5954:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5956:	8a 85       	ldd	r24, Y+10	; 0x0a
    5958:	9b 85       	ldd	r25, Y+11	; 0x0b
    595a:	89 2b       	or	r24, r25
    595c:	81 f0       	breq	.+32     	; 0x597e <xTaskNotifyWait+0xd4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    595e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5962:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5966:	fc 01       	movw	r30, r24
    5968:	83 a1       	ldd	r24, Z+35	; 0x23
    596a:	94 a1       	ldd	r25, Z+36	; 0x24
    596c:	a5 a1       	ldd	r26, Z+37	; 0x25
    596e:	b6 a1       	ldd	r27, Z+38	; 0x26
    5970:	2a 85       	ldd	r18, Y+10	; 0x0a
    5972:	3b 85       	ldd	r19, Y+11	; 0x0b
    5974:	f9 01       	movw	r30, r18
    5976:	80 83       	st	Z, r24
    5978:	91 83       	std	Z+1, r25	; 0x01
    597a:	a2 83       	std	Z+2, r26	; 0x02
    597c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    597e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5982:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5986:	fc 01       	movw	r30, r24
    5988:	87 a1       	ldd	r24, Z+39	; 0x27
    598a:	82 30       	cpi	r24, 0x02	; 2
    598c:	11 f0       	breq	.+4      	; 0x5992 <xTaskNotifyWait+0xe8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    598e:	19 82       	std	Y+1, r1	; 0x01
    5990:	1c c0       	rjmp	.+56     	; 0x59ca <xTaskNotifyWait+0x120>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5992:	60 91 9f 06 	lds	r22, 0x069F	; 0x80069f <pxCurrentTCB>
    5996:	70 91 a0 06 	lds	r23, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    599a:	fb 01       	movw	r30, r22
    599c:	23 a1       	ldd	r18, Z+35	; 0x23
    599e:	34 a1       	ldd	r19, Z+36	; 0x24
    59a0:	45 a1       	ldd	r20, Z+37	; 0x25
    59a2:	56 a1       	ldd	r21, Z+38	; 0x26
    59a4:	8e 81       	ldd	r24, Y+6	; 0x06
    59a6:	9f 81       	ldd	r25, Y+7	; 0x07
    59a8:	a8 85       	ldd	r26, Y+8	; 0x08
    59aa:	b9 85       	ldd	r27, Y+9	; 0x09
    59ac:	80 95       	com	r24
    59ae:	90 95       	com	r25
    59b0:	a0 95       	com	r26
    59b2:	b0 95       	com	r27
    59b4:	82 23       	and	r24, r18
    59b6:	93 23       	and	r25, r19
    59b8:	a4 23       	and	r26, r20
    59ba:	b5 23       	and	r27, r21
    59bc:	fb 01       	movw	r30, r22
    59be:	83 a3       	std	Z+35, r24	; 0x23
    59c0:	94 a3       	std	Z+36, r25	; 0x24
    59c2:	a5 a3       	std	Z+37, r26	; 0x25
    59c4:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    59c6:	81 e0       	ldi	r24, 0x01	; 1
    59c8:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    59ca:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    59ce:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    59d2:	fc 01       	movw	r30, r24
    59d4:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    59d6:	0f 90       	pop	r0
    59d8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    59da:	89 81       	ldd	r24, Y+1	; 0x01
	}
    59dc:	2d 96       	adiw	r28, 0x0d	; 13
    59de:	0f b6       	in	r0, 0x3f	; 63
    59e0:	f8 94       	cli
    59e2:	de bf       	out	0x3e, r29	; 62
    59e4:	0f be       	out	0x3f, r0	; 63
    59e6:	cd bf       	out	0x3d, r28	; 61
    59e8:	df 91       	pop	r29
    59ea:	cf 91       	pop	r28
    59ec:	1f 91       	pop	r17
    59ee:	0f 91       	pop	r16
    59f0:	ff 90       	pop	r15
    59f2:	ef 90       	pop	r14
    59f4:	08 95       	ret

000059f6 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    59f6:	0f 93       	push	r16
    59f8:	1f 93       	push	r17
    59fa:	cf 93       	push	r28
    59fc:	df 93       	push	r29
    59fe:	cd b7       	in	r28, 0x3d	; 61
    5a00:	de b7       	in	r29, 0x3e	; 62
    5a02:	2d 97       	sbiw	r28, 0x0d	; 13
    5a04:	0f b6       	in	r0, 0x3f	; 63
    5a06:	f8 94       	cli
    5a08:	de bf       	out	0x3e, r29	; 62
    5a0a:	0f be       	out	0x3f, r0	; 63
    5a0c:	cd bf       	out	0x3d, r28	; 61
    5a0e:	9e 83       	std	Y+6, r25	; 0x06
    5a10:	8d 83       	std	Y+5, r24	; 0x05
    5a12:	4f 83       	std	Y+7, r20	; 0x07
    5a14:	58 87       	std	Y+8, r21	; 0x08
    5a16:	69 87       	std	Y+9, r22	; 0x09
    5a18:	7a 87       	std	Y+10, r23	; 0x0a
    5a1a:	2b 87       	std	Y+11, r18	; 0x0b
    5a1c:	1d 87       	std	Y+13, r17	; 0x0d
    5a1e:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5a20:	81 e0       	ldi	r24, 0x01	; 1
    5a22:	89 83       	std	Y+1, r24	; 0x01
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5a24:	8d 81       	ldd	r24, Y+5	; 0x05
    5a26:	9e 81       	ldd	r25, Y+6	; 0x06
    5a28:	9b 83       	std	Y+3, r25	; 0x03
    5a2a:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5a2c:	0f b6       	in	r0, 0x3f	; 63
    5a2e:	f8 94       	cli
    5a30:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5a32:	8c 85       	ldd	r24, Y+12	; 0x0c
    5a34:	9d 85       	ldd	r25, Y+13	; 0x0d
    5a36:	89 2b       	or	r24, r25
    5a38:	71 f0       	breq	.+28     	; 0x5a56 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5a3a:	8a 81       	ldd	r24, Y+2	; 0x02
    5a3c:	9b 81       	ldd	r25, Y+3	; 0x03
    5a3e:	fc 01       	movw	r30, r24
    5a40:	83 a1       	ldd	r24, Z+35	; 0x23
    5a42:	94 a1       	ldd	r25, Z+36	; 0x24
    5a44:	a5 a1       	ldd	r26, Z+37	; 0x25
    5a46:	b6 a1       	ldd	r27, Z+38	; 0x26
    5a48:	2c 85       	ldd	r18, Y+12	; 0x0c
    5a4a:	3d 85       	ldd	r19, Y+13	; 0x0d
    5a4c:	f9 01       	movw	r30, r18
    5a4e:	80 83       	st	Z, r24
    5a50:	91 83       	std	Z+1, r25	; 0x01
    5a52:	a2 83       	std	Z+2, r26	; 0x02
    5a54:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5a56:	8a 81       	ldd	r24, Y+2	; 0x02
    5a58:	9b 81       	ldd	r25, Y+3	; 0x03
    5a5a:	fc 01       	movw	r30, r24
    5a5c:	87 a1       	ldd	r24, Z+39	; 0x27
    5a5e:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5a60:	8a 81       	ldd	r24, Y+2	; 0x02
    5a62:	9b 81       	ldd	r25, Y+3	; 0x03
    5a64:	22 e0       	ldi	r18, 0x02	; 2
    5a66:	fc 01       	movw	r30, r24
    5a68:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5a6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    5a6c:	88 2f       	mov	r24, r24
    5a6e:	90 e0       	ldi	r25, 0x00	; 0
    5a70:	82 30       	cpi	r24, 0x02	; 2
    5a72:	91 05       	cpc	r25, r1
    5a74:	31 f1       	breq	.+76     	; 0x5ac2 <xTaskGenericNotify+0xcc>
    5a76:	83 30       	cpi	r24, 0x03	; 3
    5a78:	91 05       	cpc	r25, r1
    5a7a:	34 f4       	brge	.+12     	; 0x5a88 <xTaskGenericNotify+0x92>
    5a7c:	00 97       	sbiw	r24, 0x00	; 0
    5a7e:	09 f4       	brne	.+2      	; 0x5a82 <xTaskGenericNotify+0x8c>
    5a80:	4f c0       	rjmp	.+158    	; 0x5b20 <xTaskGenericNotify+0x12a>
    5a82:	01 97       	sbiw	r24, 0x01	; 1
    5a84:	39 f0       	breq	.+14     	; 0x5a94 <xTaskGenericNotify+0x9e>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a86:	4d c0       	rjmp	.+154    	; 0x5b22 <xTaskGenericNotify+0x12c>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5a88:	83 30       	cpi	r24, 0x03	; 3
    5a8a:	91 05       	cpc	r25, r1
    5a8c:	61 f1       	breq	.+88     	; 0x5ae6 <xTaskGenericNotify+0xf0>
    5a8e:	04 97       	sbiw	r24, 0x04	; 4
    5a90:	b1 f1       	breq	.+108    	; 0x5afe <xTaskGenericNotify+0x108>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a92:	47 c0       	rjmp	.+142    	; 0x5b22 <xTaskGenericNotify+0x12c>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5a94:	8a 81       	ldd	r24, Y+2	; 0x02
    5a96:	9b 81       	ldd	r25, Y+3	; 0x03
    5a98:	fc 01       	movw	r30, r24
    5a9a:	23 a1       	ldd	r18, Z+35	; 0x23
    5a9c:	34 a1       	ldd	r19, Z+36	; 0x24
    5a9e:	45 a1       	ldd	r20, Z+37	; 0x25
    5aa0:	56 a1       	ldd	r21, Z+38	; 0x26
    5aa2:	8f 81       	ldd	r24, Y+7	; 0x07
    5aa4:	98 85       	ldd	r25, Y+8	; 0x08
    5aa6:	a9 85       	ldd	r26, Y+9	; 0x09
    5aa8:	ba 85       	ldd	r27, Y+10	; 0x0a
    5aaa:	82 2b       	or	r24, r18
    5aac:	93 2b       	or	r25, r19
    5aae:	a4 2b       	or	r26, r20
    5ab0:	b5 2b       	or	r27, r21
    5ab2:	2a 81       	ldd	r18, Y+2	; 0x02
    5ab4:	3b 81       	ldd	r19, Y+3	; 0x03
    5ab6:	f9 01       	movw	r30, r18
    5ab8:	83 a3       	std	Z+35, r24	; 0x23
    5aba:	94 a3       	std	Z+36, r25	; 0x24
    5abc:	a5 a3       	std	Z+37, r26	; 0x25
    5abe:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5ac0:	30 c0       	rjmp	.+96     	; 0x5b22 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ac4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ac6:	fc 01       	movw	r30, r24
    5ac8:	83 a1       	ldd	r24, Z+35	; 0x23
    5aca:	94 a1       	ldd	r25, Z+36	; 0x24
    5acc:	a5 a1       	ldd	r26, Z+37	; 0x25
    5ace:	b6 a1       	ldd	r27, Z+38	; 0x26
    5ad0:	01 96       	adiw	r24, 0x01	; 1
    5ad2:	a1 1d       	adc	r26, r1
    5ad4:	b1 1d       	adc	r27, r1
    5ad6:	2a 81       	ldd	r18, Y+2	; 0x02
    5ad8:	3b 81       	ldd	r19, Y+3	; 0x03
    5ada:	f9 01       	movw	r30, r18
    5adc:	83 a3       	std	Z+35, r24	; 0x23
    5ade:	94 a3       	std	Z+36, r25	; 0x24
    5ae0:	a5 a3       	std	Z+37, r26	; 0x25
    5ae2:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5ae4:	1e c0       	rjmp	.+60     	; 0x5b22 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5ae6:	2a 81       	ldd	r18, Y+2	; 0x02
    5ae8:	3b 81       	ldd	r19, Y+3	; 0x03
    5aea:	8f 81       	ldd	r24, Y+7	; 0x07
    5aec:	98 85       	ldd	r25, Y+8	; 0x08
    5aee:	a9 85       	ldd	r26, Y+9	; 0x09
    5af0:	ba 85       	ldd	r27, Y+10	; 0x0a
    5af2:	f9 01       	movw	r30, r18
    5af4:	83 a3       	std	Z+35, r24	; 0x23
    5af6:	94 a3       	std	Z+36, r25	; 0x24
    5af8:	a5 a3       	std	Z+37, r26	; 0x25
    5afa:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5afc:	12 c0       	rjmp	.+36     	; 0x5b22 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5afe:	8c 81       	ldd	r24, Y+4	; 0x04
    5b00:	82 30       	cpi	r24, 0x02	; 2
    5b02:	61 f0       	breq	.+24     	; 0x5b1c <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5b04:	2a 81       	ldd	r18, Y+2	; 0x02
    5b06:	3b 81       	ldd	r19, Y+3	; 0x03
    5b08:	8f 81       	ldd	r24, Y+7	; 0x07
    5b0a:	98 85       	ldd	r25, Y+8	; 0x08
    5b0c:	a9 85       	ldd	r26, Y+9	; 0x09
    5b0e:	ba 85       	ldd	r27, Y+10	; 0x0a
    5b10:	f9 01       	movw	r30, r18
    5b12:	83 a3       	std	Z+35, r24	; 0x23
    5b14:	94 a3       	std	Z+36, r25	; 0x24
    5b16:	a5 a3       	std	Z+37, r26	; 0x25
    5b18:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5b1a:	03 c0       	rjmp	.+6      	; 0x5b22 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5b1c:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5b1e:	01 c0       	rjmp	.+2      	; 0x5b22 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    5b20:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5b22:	8c 81       	ldd	r24, Y+4	; 0x04
    5b24:	81 30       	cpi	r24, 0x01	; 1
    5b26:	d1 f5       	brne	.+116    	; 0x5b9c <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5b28:	8a 81       	ldd	r24, Y+2	; 0x02
    5b2a:	9b 81       	ldd	r25, Y+3	; 0x03
    5b2c:	02 96       	adiw	r24, 0x02	; 2
    5b2e:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5b32:	8a 81       	ldd	r24, Y+2	; 0x02
    5b34:	9b 81       	ldd	r25, Y+3	; 0x03
    5b36:	fc 01       	movw	r30, r24
    5b38:	96 89       	ldd	r25, Z+22	; 0x16
    5b3a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5b3e:	89 17       	cp	r24, r25
    5b40:	30 f4       	brcc	.+12     	; 0x5b4e <xTaskGenericNotify+0x158>
    5b42:	8a 81       	ldd	r24, Y+2	; 0x02
    5b44:	9b 81       	ldd	r25, Y+3	; 0x03
    5b46:	fc 01       	movw	r30, r24
    5b48:	86 89       	ldd	r24, Z+22	; 0x16
    5b4a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5b4e:	8a 81       	ldd	r24, Y+2	; 0x02
    5b50:	9b 81       	ldd	r25, Y+3	; 0x03
    5b52:	ac 01       	movw	r20, r24
    5b54:	4e 5f       	subi	r20, 0xFE	; 254
    5b56:	5f 4f       	sbci	r21, 0xFF	; 255
    5b58:	8a 81       	ldd	r24, Y+2	; 0x02
    5b5a:	9b 81       	ldd	r25, Y+3	; 0x03
    5b5c:	fc 01       	movw	r30, r24
    5b5e:	86 89       	ldd	r24, Z+22	; 0x16
    5b60:	28 2f       	mov	r18, r24
    5b62:	30 e0       	ldi	r19, 0x00	; 0
    5b64:	c9 01       	movw	r24, r18
    5b66:	88 0f       	add	r24, r24
    5b68:	99 1f       	adc	r25, r25
    5b6a:	88 0f       	add	r24, r24
    5b6c:	99 1f       	adc	r25, r25
    5b6e:	88 0f       	add	r24, r24
    5b70:	99 1f       	adc	r25, r25
    5b72:	82 0f       	add	r24, r18
    5b74:	93 1f       	adc	r25, r19
    5b76:	8f 55       	subi	r24, 0x5F	; 95
    5b78:	99 4f       	sbci	r25, 0xF9	; 249
    5b7a:	ba 01       	movw	r22, r20
    5b7c:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5b80:	8a 81       	ldd	r24, Y+2	; 0x02
    5b82:	9b 81       	ldd	r25, Y+3	; 0x03
    5b84:	fc 01       	movw	r30, r24
    5b86:	26 89       	ldd	r18, Z+22	; 0x16
    5b88:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5b8c:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5b90:	fc 01       	movw	r30, r24
    5b92:	86 89       	ldd	r24, Z+22	; 0x16
    5b94:	82 17       	cp	r24, r18
    5b96:	10 f4       	brcc	.+4      	; 0x5b9c <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5b98:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5b9c:	0f 90       	pop	r0
    5b9e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5ba0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5ba2:	2d 96       	adiw	r28, 0x0d	; 13
    5ba4:	0f b6       	in	r0, 0x3f	; 63
    5ba6:	f8 94       	cli
    5ba8:	de bf       	out	0x3e, r29	; 62
    5baa:	0f be       	out	0x3f, r0	; 63
    5bac:	cd bf       	out	0x3d, r28	; 61
    5bae:	df 91       	pop	r29
    5bb0:	cf 91       	pop	r28
    5bb2:	1f 91       	pop	r17
    5bb4:	0f 91       	pop	r16
    5bb6:	08 95       	ret

00005bb8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5bb8:	ef 92       	push	r14
    5bba:	ff 92       	push	r15
    5bbc:	0f 93       	push	r16
    5bbe:	1f 93       	push	r17
    5bc0:	cf 93       	push	r28
    5bc2:	df 93       	push	r29
    5bc4:	cd b7       	in	r28, 0x3d	; 61
    5bc6:	de b7       	in	r29, 0x3e	; 62
    5bc8:	60 97       	sbiw	r28, 0x10	; 16
    5bca:	0f b6       	in	r0, 0x3f	; 63
    5bcc:	f8 94       	cli
    5bce:	de bf       	out	0x3e, r29	; 62
    5bd0:	0f be       	out	0x3f, r0	; 63
    5bd2:	cd bf       	out	0x3d, r28	; 61
    5bd4:	9f 83       	std	Y+7, r25	; 0x07
    5bd6:	8e 83       	std	Y+6, r24	; 0x06
    5bd8:	48 87       	std	Y+8, r20	; 0x08
    5bda:	59 87       	std	Y+9, r21	; 0x09
    5bdc:	6a 87       	std	Y+10, r22	; 0x0a
    5bde:	7b 87       	std	Y+11, r23	; 0x0b
    5be0:	2c 87       	std	Y+12, r18	; 0x0c
    5be2:	1e 87       	std	Y+14, r17	; 0x0e
    5be4:	0d 87       	std	Y+13, r16	; 0x0d
    5be6:	f8 8a       	std	Y+16, r15	; 0x10
    5be8:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5bea:	81 e0       	ldi	r24, 0x01	; 1
    5bec:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5bee:	8e 81       	ldd	r24, Y+6	; 0x06
    5bf0:	9f 81       	ldd	r25, Y+7	; 0x07
    5bf2:	9b 83       	std	Y+3, r25	; 0x03
    5bf4:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5bf6:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    5bf8:	8d 85       	ldd	r24, Y+13	; 0x0d
    5bfa:	9e 85       	ldd	r25, Y+14	; 0x0e
    5bfc:	89 2b       	or	r24, r25
    5bfe:	71 f0       	breq	.+28     	; 0x5c1c <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5c00:	8a 81       	ldd	r24, Y+2	; 0x02
    5c02:	9b 81       	ldd	r25, Y+3	; 0x03
    5c04:	fc 01       	movw	r30, r24
    5c06:	83 a1       	ldd	r24, Z+35	; 0x23
    5c08:	94 a1       	ldd	r25, Z+36	; 0x24
    5c0a:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c0c:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c0e:	2d 85       	ldd	r18, Y+13	; 0x0d
    5c10:	3e 85       	ldd	r19, Y+14	; 0x0e
    5c12:	f9 01       	movw	r30, r18
    5c14:	80 83       	st	Z, r24
    5c16:	91 83       	std	Z+1, r25	; 0x01
    5c18:	a2 83       	std	Z+2, r26	; 0x02
    5c1a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    5c20:	fc 01       	movw	r30, r24
    5c22:	87 a1       	ldd	r24, Z+39	; 0x27
    5c24:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5c26:	8a 81       	ldd	r24, Y+2	; 0x02
    5c28:	9b 81       	ldd	r25, Y+3	; 0x03
    5c2a:	22 e0       	ldi	r18, 0x02	; 2
    5c2c:	fc 01       	movw	r30, r24
    5c2e:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5c30:	8c 85       	ldd	r24, Y+12	; 0x0c
    5c32:	88 2f       	mov	r24, r24
    5c34:	90 e0       	ldi	r25, 0x00	; 0
    5c36:	82 30       	cpi	r24, 0x02	; 2
    5c38:	91 05       	cpc	r25, r1
    5c3a:	31 f1       	breq	.+76     	; 0x5c88 <xTaskGenericNotifyFromISR+0xd0>
    5c3c:	83 30       	cpi	r24, 0x03	; 3
    5c3e:	91 05       	cpc	r25, r1
    5c40:	34 f4       	brge	.+12     	; 0x5c4e <xTaskGenericNotifyFromISR+0x96>
    5c42:	00 97       	sbiw	r24, 0x00	; 0
    5c44:	09 f4       	brne	.+2      	; 0x5c48 <xTaskGenericNotifyFromISR+0x90>
    5c46:	4f c0       	rjmp	.+158    	; 0x5ce6 <xTaskGenericNotifyFromISR+0x12e>
    5c48:	01 97       	sbiw	r24, 0x01	; 1
    5c4a:	39 f0       	breq	.+14     	; 0x5c5a <xTaskGenericNotifyFromISR+0xa2>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5c4c:	4d c0       	rjmp	.+154    	; 0x5ce8 <xTaskGenericNotifyFromISR+0x130>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5c4e:	83 30       	cpi	r24, 0x03	; 3
    5c50:	91 05       	cpc	r25, r1
    5c52:	61 f1       	breq	.+88     	; 0x5cac <xTaskGenericNotifyFromISR+0xf4>
    5c54:	04 97       	sbiw	r24, 0x04	; 4
    5c56:	b1 f1       	breq	.+108    	; 0x5cc4 <xTaskGenericNotifyFromISR+0x10c>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5c58:	47 c0       	rjmp	.+142    	; 0x5ce8 <xTaskGenericNotifyFromISR+0x130>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5c5a:	8a 81       	ldd	r24, Y+2	; 0x02
    5c5c:	9b 81       	ldd	r25, Y+3	; 0x03
    5c5e:	fc 01       	movw	r30, r24
    5c60:	23 a1       	ldd	r18, Z+35	; 0x23
    5c62:	34 a1       	ldd	r19, Z+36	; 0x24
    5c64:	45 a1       	ldd	r20, Z+37	; 0x25
    5c66:	56 a1       	ldd	r21, Z+38	; 0x26
    5c68:	88 85       	ldd	r24, Y+8	; 0x08
    5c6a:	99 85       	ldd	r25, Y+9	; 0x09
    5c6c:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c6e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c70:	82 2b       	or	r24, r18
    5c72:	93 2b       	or	r25, r19
    5c74:	a4 2b       	or	r26, r20
    5c76:	b5 2b       	or	r27, r21
    5c78:	2a 81       	ldd	r18, Y+2	; 0x02
    5c7a:	3b 81       	ldd	r19, Y+3	; 0x03
    5c7c:	f9 01       	movw	r30, r18
    5c7e:	83 a3       	std	Z+35, r24	; 0x23
    5c80:	94 a3       	std	Z+36, r25	; 0x24
    5c82:	a5 a3       	std	Z+37, r26	; 0x25
    5c84:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c86:	30 c0       	rjmp	.+96     	; 0x5ce8 <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5c88:	8a 81       	ldd	r24, Y+2	; 0x02
    5c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c8c:	fc 01       	movw	r30, r24
    5c8e:	83 a1       	ldd	r24, Z+35	; 0x23
    5c90:	94 a1       	ldd	r25, Z+36	; 0x24
    5c92:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c94:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c96:	01 96       	adiw	r24, 0x01	; 1
    5c98:	a1 1d       	adc	r26, r1
    5c9a:	b1 1d       	adc	r27, r1
    5c9c:	2a 81       	ldd	r18, Y+2	; 0x02
    5c9e:	3b 81       	ldd	r19, Y+3	; 0x03
    5ca0:	f9 01       	movw	r30, r18
    5ca2:	83 a3       	std	Z+35, r24	; 0x23
    5ca4:	94 a3       	std	Z+36, r25	; 0x24
    5ca6:	a5 a3       	std	Z+37, r26	; 0x25
    5ca8:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5caa:	1e c0       	rjmp	.+60     	; 0x5ce8 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5cac:	2a 81       	ldd	r18, Y+2	; 0x02
    5cae:	3b 81       	ldd	r19, Y+3	; 0x03
    5cb0:	88 85       	ldd	r24, Y+8	; 0x08
    5cb2:	99 85       	ldd	r25, Y+9	; 0x09
    5cb4:	aa 85       	ldd	r26, Y+10	; 0x0a
    5cb6:	bb 85       	ldd	r27, Y+11	; 0x0b
    5cb8:	f9 01       	movw	r30, r18
    5cba:	83 a3       	std	Z+35, r24	; 0x23
    5cbc:	94 a3       	std	Z+36, r25	; 0x24
    5cbe:	a5 a3       	std	Z+37, r26	; 0x25
    5cc0:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5cc2:	12 c0       	rjmp	.+36     	; 0x5ce8 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5cc4:	8d 81       	ldd	r24, Y+5	; 0x05
    5cc6:	82 30       	cpi	r24, 0x02	; 2
    5cc8:	61 f0       	breq	.+24     	; 0x5ce2 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5cca:	2a 81       	ldd	r18, Y+2	; 0x02
    5ccc:	3b 81       	ldd	r19, Y+3	; 0x03
    5cce:	88 85       	ldd	r24, Y+8	; 0x08
    5cd0:	99 85       	ldd	r25, Y+9	; 0x09
    5cd2:	aa 85       	ldd	r26, Y+10	; 0x0a
    5cd4:	bb 85       	ldd	r27, Y+11	; 0x0b
    5cd6:	f9 01       	movw	r30, r18
    5cd8:	83 a3       	std	Z+35, r24	; 0x23
    5cda:	94 a3       	std	Z+36, r25	; 0x24
    5cdc:	a5 a3       	std	Z+37, r26	; 0x25
    5cde:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5ce0:	03 c0       	rjmp	.+6      	; 0x5ce8 <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5ce2:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5ce4:	01 c0       	rjmp	.+2      	; 0x5ce8 <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    5ce6:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5ce8:	8d 81       	ldd	r24, Y+5	; 0x05
    5cea:	81 30       	cpi	r24, 0x01	; 1
    5cec:	09 f0       	breq	.+2      	; 0x5cf0 <xTaskGenericNotifyFromISR+0x138>
    5cee:	51 c0       	rjmp	.+162    	; 0x5d92 <xTaskGenericNotifyFromISR+0x1da>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5cf0:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    5cf4:	88 23       	and	r24, r24
    5cf6:	69 f5       	brne	.+90     	; 0x5d52 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5cf8:	8a 81       	ldd	r24, Y+2	; 0x02
    5cfa:	9b 81       	ldd	r25, Y+3	; 0x03
    5cfc:	02 96       	adiw	r24, 0x02	; 2
    5cfe:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5d02:	8a 81       	ldd	r24, Y+2	; 0x02
    5d04:	9b 81       	ldd	r25, Y+3	; 0x03
    5d06:	fc 01       	movw	r30, r24
    5d08:	96 89       	ldd	r25, Z+22	; 0x16
    5d0a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5d0e:	89 17       	cp	r24, r25
    5d10:	30 f4       	brcc	.+12     	; 0x5d1e <xTaskGenericNotifyFromISR+0x166>
    5d12:	8a 81       	ldd	r24, Y+2	; 0x02
    5d14:	9b 81       	ldd	r25, Y+3	; 0x03
    5d16:	fc 01       	movw	r30, r24
    5d18:	86 89       	ldd	r24, Z+22	; 0x16
    5d1a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5d1e:	8a 81       	ldd	r24, Y+2	; 0x02
    5d20:	9b 81       	ldd	r25, Y+3	; 0x03
    5d22:	ac 01       	movw	r20, r24
    5d24:	4e 5f       	subi	r20, 0xFE	; 254
    5d26:	5f 4f       	sbci	r21, 0xFF	; 255
    5d28:	8a 81       	ldd	r24, Y+2	; 0x02
    5d2a:	9b 81       	ldd	r25, Y+3	; 0x03
    5d2c:	fc 01       	movw	r30, r24
    5d2e:	86 89       	ldd	r24, Z+22	; 0x16
    5d30:	28 2f       	mov	r18, r24
    5d32:	30 e0       	ldi	r19, 0x00	; 0
    5d34:	c9 01       	movw	r24, r18
    5d36:	88 0f       	add	r24, r24
    5d38:	99 1f       	adc	r25, r25
    5d3a:	88 0f       	add	r24, r24
    5d3c:	99 1f       	adc	r25, r25
    5d3e:	88 0f       	add	r24, r24
    5d40:	99 1f       	adc	r25, r25
    5d42:	82 0f       	add	r24, r18
    5d44:	93 1f       	adc	r25, r19
    5d46:	8f 55       	subi	r24, 0x5F	; 95
    5d48:	99 4f       	sbci	r25, 0xF9	; 249
    5d4a:	ba 01       	movw	r22, r20
    5d4c:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
    5d50:	08 c0       	rjmp	.+16     	; 0x5d62 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5d52:	8a 81       	ldd	r24, Y+2	; 0x02
    5d54:	9b 81       	ldd	r25, Y+3	; 0x03
    5d56:	0c 96       	adiw	r24, 0x0c	; 12
    5d58:	bc 01       	movw	r22, r24
    5d5a:	84 ee       	ldi	r24, 0xE4	; 228
    5d5c:	96 e0       	ldi	r25, 0x06	; 6
    5d5e:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5d62:	8a 81       	ldd	r24, Y+2	; 0x02
    5d64:	9b 81       	ldd	r25, Y+3	; 0x03
    5d66:	fc 01       	movw	r30, r24
    5d68:	26 89       	ldd	r18, Z+22	; 0x16
    5d6a:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5d6e:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5d72:	fc 01       	movw	r30, r24
    5d74:	86 89       	ldd	r24, Z+22	; 0x16
    5d76:	82 17       	cp	r24, r18
    5d78:	60 f4       	brcc	.+24     	; 0x5d92 <xTaskGenericNotifyFromISR+0x1da>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5d7a:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d7c:	98 89       	ldd	r25, Y+16	; 0x10
    5d7e:	89 2b       	or	r24, r25
    5d80:	29 f0       	breq	.+10     	; 0x5d8c <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5d82:	8f 85       	ldd	r24, Y+15	; 0x0f
    5d84:	98 89       	ldd	r25, Y+16	; 0x10
    5d86:	21 e0       	ldi	r18, 0x01	; 1
    5d88:	fc 01       	movw	r30, r24
    5d8a:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5d8c:	81 e0       	ldi	r24, 0x01	; 1
    5d8e:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5d92:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5d94:	60 96       	adiw	r28, 0x10	; 16
    5d96:	0f b6       	in	r0, 0x3f	; 63
    5d98:	f8 94       	cli
    5d9a:	de bf       	out	0x3e, r29	; 62
    5d9c:	0f be       	out	0x3f, r0	; 63
    5d9e:	cd bf       	out	0x3d, r28	; 61
    5da0:	df 91       	pop	r29
    5da2:	cf 91       	pop	r28
    5da4:	1f 91       	pop	r17
    5da6:	0f 91       	pop	r16
    5da8:	ff 90       	pop	r15
    5daa:	ef 90       	pop	r14
    5dac:	08 95       	ret

00005dae <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5dae:	cf 93       	push	r28
    5db0:	df 93       	push	r29
    5db2:	cd b7       	in	r28, 0x3d	; 61
    5db4:	de b7       	in	r29, 0x3e	; 62
    5db6:	28 97       	sbiw	r28, 0x08	; 8
    5db8:	0f b6       	in	r0, 0x3f	; 63
    5dba:	f8 94       	cli
    5dbc:	de bf       	out	0x3e, r29	; 62
    5dbe:	0f be       	out	0x3f, r0	; 63
    5dc0:	cd bf       	out	0x3d, r28	; 61
    5dc2:	9e 83       	std	Y+6, r25	; 0x06
    5dc4:	8d 83       	std	Y+5, r24	; 0x05
    5dc6:	78 87       	std	Y+8, r23	; 0x08
    5dc8:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5dca:	8d 81       	ldd	r24, Y+5	; 0x05
    5dcc:	9e 81       	ldd	r25, Y+6	; 0x06
    5dce:	9a 83       	std	Y+2, r25	; 0x02
    5dd0:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5dd2:	1b 82       	std	Y+3, r1	; 0x03
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5dd4:	89 81       	ldd	r24, Y+1	; 0x01
    5dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    5dd8:	fc 01       	movw	r30, r24
    5dda:	87 a1       	ldd	r24, Z+39	; 0x27
    5ddc:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5dde:	89 81       	ldd	r24, Y+1	; 0x01
    5de0:	9a 81       	ldd	r25, Y+2	; 0x02
    5de2:	22 e0       	ldi	r18, 0x02	; 2
    5de4:	fc 01       	movw	r30, r24
    5de6:	27 a3       	std	Z+39, r18	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5de8:	89 81       	ldd	r24, Y+1	; 0x01
    5dea:	9a 81       	ldd	r25, Y+2	; 0x02
    5dec:	fc 01       	movw	r30, r24
    5dee:	83 a1       	ldd	r24, Z+35	; 0x23
    5df0:	94 a1       	ldd	r25, Z+36	; 0x24
    5df2:	a5 a1       	ldd	r26, Z+37	; 0x25
    5df4:	b6 a1       	ldd	r27, Z+38	; 0x26
    5df6:	01 96       	adiw	r24, 0x01	; 1
    5df8:	a1 1d       	adc	r26, r1
    5dfa:	b1 1d       	adc	r27, r1
    5dfc:	29 81       	ldd	r18, Y+1	; 0x01
    5dfe:	3a 81       	ldd	r19, Y+2	; 0x02
    5e00:	f9 01       	movw	r30, r18
    5e02:	83 a3       	std	Z+35, r24	; 0x23
    5e04:	94 a3       	std	Z+36, r25	; 0x24
    5e06:	a5 a3       	std	Z+37, r26	; 0x25
    5e08:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5e0a:	8c 81       	ldd	r24, Y+4	; 0x04
    5e0c:	81 30       	cpi	r24, 0x01	; 1
    5e0e:	09 f0       	breq	.+2      	; 0x5e12 <vTaskNotifyGiveFromISR+0x64>
    5e10:	51 c0       	rjmp	.+162    	; 0x5eb4 <vTaskNotifyGiveFromISR+0x106>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5e12:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxSchedulerSuspended>
    5e16:	88 23       	and	r24, r24
    5e18:	69 f5       	brne	.+90     	; 0x5e74 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5e1a:	89 81       	ldd	r24, Y+1	; 0x01
    5e1c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e1e:	02 96       	adiw	r24, 0x02	; 2
    5e20:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5e24:	89 81       	ldd	r24, Y+1	; 0x01
    5e26:	9a 81       	ldd	r25, Y+2	; 0x02
    5e28:	fc 01       	movw	r30, r24
    5e2a:	96 89       	ldd	r25, Z+22	; 0x16
    5e2c:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTopReadyPriority>
    5e30:	89 17       	cp	r24, r25
    5e32:	30 f4       	brcc	.+12     	; 0x5e40 <vTaskNotifyGiveFromISR+0x92>
    5e34:	89 81       	ldd	r24, Y+1	; 0x01
    5e36:	9a 81       	ldd	r25, Y+2	; 0x02
    5e38:	fc 01       	movw	r30, r24
    5e3a:	86 89       	ldd	r24, Z+22	; 0x16
    5e3c:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTopReadyPriority>
    5e40:	89 81       	ldd	r24, Y+1	; 0x01
    5e42:	9a 81       	ldd	r25, Y+2	; 0x02
    5e44:	ac 01       	movw	r20, r24
    5e46:	4e 5f       	subi	r20, 0xFE	; 254
    5e48:	5f 4f       	sbci	r21, 0xFF	; 255
    5e4a:	89 81       	ldd	r24, Y+1	; 0x01
    5e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e4e:	fc 01       	movw	r30, r24
    5e50:	86 89       	ldd	r24, Z+22	; 0x16
    5e52:	28 2f       	mov	r18, r24
    5e54:	30 e0       	ldi	r19, 0x00	; 0
    5e56:	c9 01       	movw	r24, r18
    5e58:	88 0f       	add	r24, r24
    5e5a:	99 1f       	adc	r25, r25
    5e5c:	88 0f       	add	r24, r24
    5e5e:	99 1f       	adc	r25, r25
    5e60:	88 0f       	add	r24, r24
    5e62:	99 1f       	adc	r25, r25
    5e64:	82 0f       	add	r24, r18
    5e66:	93 1f       	adc	r25, r19
    5e68:	8f 55       	subi	r24, 0x5F	; 95
    5e6a:	99 4f       	sbci	r25, 0xF9	; 249
    5e6c:	ba 01       	movw	r22, r20
    5e6e:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
    5e72:	08 c0       	rjmp	.+16     	; 0x5e84 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5e74:	89 81       	ldd	r24, Y+1	; 0x01
    5e76:	9a 81       	ldd	r25, Y+2	; 0x02
    5e78:	0c 96       	adiw	r24, 0x0c	; 12
    5e7a:	bc 01       	movw	r22, r24
    5e7c:	84 ee       	ldi	r24, 0xE4	; 228
    5e7e:	96 e0       	ldi	r25, 0x06	; 6
    5e80:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5e84:	89 81       	ldd	r24, Y+1	; 0x01
    5e86:	9a 81       	ldd	r25, Y+2	; 0x02
    5e88:	fc 01       	movw	r30, r24
    5e8a:	26 89       	ldd	r18, Z+22	; 0x16
    5e8c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5e90:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5e94:	fc 01       	movw	r30, r24
    5e96:	86 89       	ldd	r24, Z+22	; 0x16
    5e98:	82 17       	cp	r24, r18
    5e9a:	60 f4       	brcc	.+24     	; 0x5eb4 <vTaskNotifyGiveFromISR+0x106>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5e9c:	8f 81       	ldd	r24, Y+7	; 0x07
    5e9e:	98 85       	ldd	r25, Y+8	; 0x08
    5ea0:	89 2b       	or	r24, r25
    5ea2:	29 f0       	breq	.+10     	; 0x5eae <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5ea4:	8f 81       	ldd	r24, Y+7	; 0x07
    5ea6:	98 85       	ldd	r25, Y+8	; 0x08
    5ea8:	21 e0       	ldi	r18, 0x01	; 1
    5eaa:	fc 01       	movw	r30, r24
    5eac:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5eae:	81 e0       	ldi	r24, 0x01	; 1
    5eb0:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5eb4:	00 00       	nop
    5eb6:	28 96       	adiw	r28, 0x08	; 8
    5eb8:	0f b6       	in	r0, 0x3f	; 63
    5eba:	f8 94       	cli
    5ebc:	de bf       	out	0x3e, r29	; 62
    5ebe:	0f be       	out	0x3f, r0	; 63
    5ec0:	cd bf       	out	0x3d, r28	; 61
    5ec2:	df 91       	pop	r29
    5ec4:	cf 91       	pop	r28
    5ec6:	08 95       	ret

00005ec8 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5ec8:	cf 93       	push	r28
    5eca:	df 93       	push	r29
    5ecc:	00 d0       	rcall	.+0      	; 0x5ece <xTaskNotifyStateClear+0x6>
    5ece:	00 d0       	rcall	.+0      	; 0x5ed0 <xTaskNotifyStateClear+0x8>
    5ed0:	1f 92       	push	r1
    5ed2:	cd b7       	in	r28, 0x3d	; 61
    5ed4:	de b7       	in	r29, 0x3e	; 62
    5ed6:	9d 83       	std	Y+5, r25	; 0x05
    5ed8:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5eda:	8c 81       	ldd	r24, Y+4	; 0x04
    5edc:	9d 81       	ldd	r25, Y+5	; 0x05
    5ede:	89 2b       	or	r24, r25
    5ee0:	29 f4       	brne	.+10     	; 0x5eec <xTaskNotifyStateClear+0x24>
    5ee2:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5ee6:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5eea:	02 c0       	rjmp	.+4      	; 0x5ef0 <xTaskNotifyStateClear+0x28>
    5eec:	8c 81       	ldd	r24, Y+4	; 0x04
    5eee:	9d 81       	ldd	r25, Y+5	; 0x05
    5ef0:	9b 83       	std	Y+3, r25	; 0x03
    5ef2:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5ef4:	0f b6       	in	r0, 0x3f	; 63
    5ef6:	f8 94       	cli
    5ef8:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5efa:	8a 81       	ldd	r24, Y+2	; 0x02
    5efc:	9b 81       	ldd	r25, Y+3	; 0x03
    5efe:	fc 01       	movw	r30, r24
    5f00:	87 a1       	ldd	r24, Z+39	; 0x27
    5f02:	82 30       	cpi	r24, 0x02	; 2
    5f04:	39 f4       	brne	.+14     	; 0x5f14 <xTaskNotifyStateClear+0x4c>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5f06:	8a 81       	ldd	r24, Y+2	; 0x02
    5f08:	9b 81       	ldd	r25, Y+3	; 0x03
    5f0a:	fc 01       	movw	r30, r24
    5f0c:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5f0e:	81 e0       	ldi	r24, 0x01	; 1
    5f10:	89 83       	std	Y+1, r24	; 0x01
    5f12:	01 c0       	rjmp	.+2      	; 0x5f16 <xTaskNotifyStateClear+0x4e>
			}
			else
			{
				xReturn = pdFAIL;
    5f14:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5f16:	0f 90       	pop	r0
    5f18:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5f1a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5f1c:	0f 90       	pop	r0
    5f1e:	0f 90       	pop	r0
    5f20:	0f 90       	pop	r0
    5f22:	0f 90       	pop	r0
    5f24:	0f 90       	pop	r0
    5f26:	df 91       	pop	r29
    5f28:	cf 91       	pop	r28
    5f2a:	08 95       	ret

00005f2c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5f2c:	cf 93       	push	r28
    5f2e:	df 93       	push	r29
    5f30:	cd b7       	in	r28, 0x3d	; 61
    5f32:	de b7       	in	r29, 0x3e	; 62
    5f34:	27 97       	sbiw	r28, 0x07	; 7
    5f36:	0f b6       	in	r0, 0x3f	; 63
    5f38:	f8 94       	cli
    5f3a:	de bf       	out	0x3e, r29	; 62
    5f3c:	0f be       	out	0x3f, r0	; 63
    5f3e:	cd bf       	out	0x3d, r28	; 61
    5f40:	9e 83       	std	Y+6, r25	; 0x06
    5f42:	8d 83       	std	Y+5, r24	; 0x05
    5f44:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5f46:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xTickCount>
    5f4a:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xTickCount+0x1>
    5f4e:	9a 83       	std	Y+2, r25	; 0x02
    5f50:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5f52:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5f56:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5f5a:	02 96       	adiw	r24, 0x02	; 2
    5f5c:	0e 94 30 14 	call	0x2860	; 0x2860 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5f60:	8d 81       	ldd	r24, Y+5	; 0x05
    5f62:	9e 81       	ldd	r25, Y+6	; 0x06
    5f64:	01 96       	adiw	r24, 0x01	; 1
    5f66:	71 f4       	brne	.+28     	; 0x5f84 <prvAddCurrentTaskToDelayedList+0x58>
    5f68:	8f 81       	ldd	r24, Y+7	; 0x07
    5f6a:	88 23       	and	r24, r24
    5f6c:	59 f0       	breq	.+22     	; 0x5f84 <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5f6e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5f72:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5f76:	02 96       	adiw	r24, 0x02	; 2
    5f78:	bc 01       	movw	r22, r24
    5f7a:	87 ef       	ldi	r24, 0xF7	; 247
    5f7c:	96 e0       	ldi	r25, 0x06	; 6
    5f7e:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f82:	44 c0       	rjmp	.+136    	; 0x600c <prvAddCurrentTaskToDelayedList+0xe0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    5f84:	29 81       	ldd	r18, Y+1	; 0x01
    5f86:	3a 81       	ldd	r19, Y+2	; 0x02
    5f88:	8d 81       	ldd	r24, Y+5	; 0x05
    5f8a:	9e 81       	ldd	r25, Y+6	; 0x06
    5f8c:	82 0f       	add	r24, r18
    5f8e:	93 1f       	adc	r25, r19
    5f90:	9c 83       	std	Y+4, r25	; 0x04
    5f92:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5f94:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5f98:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5f9c:	2b 81       	ldd	r18, Y+3	; 0x03
    5f9e:	3c 81       	ldd	r19, Y+4	; 0x04
    5fa0:	fc 01       	movw	r30, r24
    5fa2:	33 83       	std	Z+3, r19	; 0x03
    5fa4:	22 83       	std	Z+2, r18	; 0x02

			if( xTimeToWake < xConstTickCount )
    5fa6:	2b 81       	ldd	r18, Y+3	; 0x03
    5fa8:	3c 81       	ldd	r19, Y+4	; 0x04
    5faa:	89 81       	ldd	r24, Y+1	; 0x01
    5fac:	9a 81       	ldd	r25, Y+2	; 0x02
    5fae:	28 17       	cp	r18, r24
    5fb0:	39 07       	cpc	r19, r25
    5fb2:	78 f4       	brcc	.+30     	; 0x5fd2 <prvAddCurrentTaskToDelayedList+0xa6>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5fb4:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5fb8:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5fbc:	9c 01       	movw	r18, r24
    5fbe:	2e 5f       	subi	r18, 0xFE	; 254
    5fc0:	3f 4f       	sbci	r19, 0xFF	; 255
    5fc2:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <pxOverflowDelayedTaskList>
    5fc6:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    5fca:	b9 01       	movw	r22, r18
    5fcc:	0e 94 b8 13 	call	0x2770	; 0x2770 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5fd0:	1d c0       	rjmp	.+58     	; 0x600c <prvAddCurrentTaskToDelayedList+0xe0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5fd2:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxCurrentTCB>
    5fd6:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <pxCurrentTCB+0x1>
    5fda:	9c 01       	movw	r18, r24
    5fdc:	2e 5f       	subi	r18, 0xFE	; 254
    5fde:	3f 4f       	sbci	r19, 0xFF	; 255
    5fe0:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxDelayedTaskList>
    5fe4:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxDelayedTaskList+0x1>
    5fe8:	b9 01       	movw	r22, r18
    5fea:	0e 94 b8 13 	call	0x2770	; 0x2770 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5fee:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xNextTaskUnblockTime>
    5ff2:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xNextTaskUnblockTime+0x1>
    5ff6:	2b 81       	ldd	r18, Y+3	; 0x03
    5ff8:	3c 81       	ldd	r19, Y+4	; 0x04
    5ffa:	28 17       	cp	r18, r24
    5ffc:	39 07       	cpc	r19, r25
    5ffe:	30 f4       	brcc	.+12     	; 0x600c <prvAddCurrentTaskToDelayedList+0xe0>
				{
					xNextTaskUnblockTime = xTimeToWake;
    6000:	8b 81       	ldd	r24, Y+3	; 0x03
    6002:	9c 81       	ldd	r25, Y+4	; 0x04
    6004:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xNextTaskUnblockTime+0x1>
    6008:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    600c:	00 00       	nop
    600e:	27 96       	adiw	r28, 0x07	; 7
    6010:	0f b6       	in	r0, 0x3f	; 63
    6012:	f8 94       	cli
    6014:	de bf       	out	0x3e, r29	; 62
    6016:	0f be       	out	0x3f, r0	; 63
    6018:	cd bf       	out	0x3d, r28	; 61
    601a:	df 91       	pop	r29
    601c:	cf 91       	pop	r28
    601e:	08 95       	ret

00006020 <__umulhisi3>:
    6020:	a2 9f       	mul	r26, r18
    6022:	b0 01       	movw	r22, r0
    6024:	b3 9f       	mul	r27, r19
    6026:	c0 01       	movw	r24, r0
    6028:	a3 9f       	mul	r26, r19
    602a:	70 0d       	add	r23, r0
    602c:	81 1d       	adc	r24, r1
    602e:	11 24       	eor	r1, r1
    6030:	91 1d       	adc	r25, r1
    6032:	b2 9f       	mul	r27, r18
    6034:	70 0d       	add	r23, r0
    6036:	81 1d       	adc	r24, r1
    6038:	11 24       	eor	r1, r1
    603a:	91 1d       	adc	r25, r1
    603c:	08 95       	ret

0000603e <__subsf3>:
    603e:	50 58       	subi	r21, 0x80	; 128

00006040 <__addsf3>:
    6040:	bb 27       	eor	r27, r27
    6042:	aa 27       	eor	r26, r26
    6044:	0e 94 37 30 	call	0x606e	; 0x606e <__addsf3x>
    6048:	0c 94 6d 31 	jmp	0x62da	; 0x62da <__fp_round>
    604c:	0e 94 5f 31 	call	0x62be	; 0x62be <__fp_pscA>
    6050:	38 f0       	brcs	.+14     	; 0x6060 <__addsf3+0x20>
    6052:	0e 94 66 31 	call	0x62cc	; 0x62cc <__fp_pscB>
    6056:	20 f0       	brcs	.+8      	; 0x6060 <__addsf3+0x20>
    6058:	39 f4       	brne	.+14     	; 0x6068 <__addsf3+0x28>
    605a:	9f 3f       	cpi	r25, 0xFF	; 255
    605c:	19 f4       	brne	.+6      	; 0x6064 <__addsf3+0x24>
    605e:	26 f4       	brtc	.+8      	; 0x6068 <__addsf3+0x28>
    6060:	0c 94 5c 31 	jmp	0x62b8	; 0x62b8 <__fp_nan>
    6064:	0e f4       	brtc	.+2      	; 0x6068 <__addsf3+0x28>
    6066:	e0 95       	com	r30
    6068:	e7 fb       	bst	r30, 7
    606a:	0c 94 56 31 	jmp	0x62ac	; 0x62ac <__fp_inf>

0000606e <__addsf3x>:
    606e:	e9 2f       	mov	r30, r25
    6070:	0e 94 7e 31 	call	0x62fc	; 0x62fc <__fp_split3>
    6074:	58 f3       	brcs	.-42     	; 0x604c <__addsf3+0xc>
    6076:	ba 17       	cp	r27, r26
    6078:	62 07       	cpc	r22, r18
    607a:	73 07       	cpc	r23, r19
    607c:	84 07       	cpc	r24, r20
    607e:	95 07       	cpc	r25, r21
    6080:	20 f0       	brcs	.+8      	; 0x608a <__addsf3x+0x1c>
    6082:	79 f4       	brne	.+30     	; 0x60a2 <__addsf3x+0x34>
    6084:	a6 f5       	brtc	.+104    	; 0x60ee <__addsf3x+0x80>
    6086:	0c 94 a0 31 	jmp	0x6340	; 0x6340 <__fp_zero>
    608a:	0e f4       	brtc	.+2      	; 0x608e <__addsf3x+0x20>
    608c:	e0 95       	com	r30
    608e:	0b 2e       	mov	r0, r27
    6090:	ba 2f       	mov	r27, r26
    6092:	a0 2d       	mov	r26, r0
    6094:	0b 01       	movw	r0, r22
    6096:	b9 01       	movw	r22, r18
    6098:	90 01       	movw	r18, r0
    609a:	0c 01       	movw	r0, r24
    609c:	ca 01       	movw	r24, r20
    609e:	a0 01       	movw	r20, r0
    60a0:	11 24       	eor	r1, r1
    60a2:	ff 27       	eor	r31, r31
    60a4:	59 1b       	sub	r21, r25
    60a6:	99 f0       	breq	.+38     	; 0x60ce <__addsf3x+0x60>
    60a8:	59 3f       	cpi	r21, 0xF9	; 249
    60aa:	50 f4       	brcc	.+20     	; 0x60c0 <__addsf3x+0x52>
    60ac:	50 3e       	cpi	r21, 0xE0	; 224
    60ae:	68 f1       	brcs	.+90     	; 0x610a <__addsf3x+0x9c>
    60b0:	1a 16       	cp	r1, r26
    60b2:	f0 40       	sbci	r31, 0x00	; 0
    60b4:	a2 2f       	mov	r26, r18
    60b6:	23 2f       	mov	r18, r19
    60b8:	34 2f       	mov	r19, r20
    60ba:	44 27       	eor	r20, r20
    60bc:	58 5f       	subi	r21, 0xF8	; 248
    60be:	f3 cf       	rjmp	.-26     	; 0x60a6 <__addsf3x+0x38>
    60c0:	46 95       	lsr	r20
    60c2:	37 95       	ror	r19
    60c4:	27 95       	ror	r18
    60c6:	a7 95       	ror	r26
    60c8:	f0 40       	sbci	r31, 0x00	; 0
    60ca:	53 95       	inc	r21
    60cc:	c9 f7       	brne	.-14     	; 0x60c0 <__addsf3x+0x52>
    60ce:	7e f4       	brtc	.+30     	; 0x60ee <__addsf3x+0x80>
    60d0:	1f 16       	cp	r1, r31
    60d2:	ba 0b       	sbc	r27, r26
    60d4:	62 0b       	sbc	r22, r18
    60d6:	73 0b       	sbc	r23, r19
    60d8:	84 0b       	sbc	r24, r20
    60da:	ba f0       	brmi	.+46     	; 0x610a <__addsf3x+0x9c>
    60dc:	91 50       	subi	r25, 0x01	; 1
    60de:	a1 f0       	breq	.+40     	; 0x6108 <__addsf3x+0x9a>
    60e0:	ff 0f       	add	r31, r31
    60e2:	bb 1f       	adc	r27, r27
    60e4:	66 1f       	adc	r22, r22
    60e6:	77 1f       	adc	r23, r23
    60e8:	88 1f       	adc	r24, r24
    60ea:	c2 f7       	brpl	.-16     	; 0x60dc <__addsf3x+0x6e>
    60ec:	0e c0       	rjmp	.+28     	; 0x610a <__addsf3x+0x9c>
    60ee:	ba 0f       	add	r27, r26
    60f0:	62 1f       	adc	r22, r18
    60f2:	73 1f       	adc	r23, r19
    60f4:	84 1f       	adc	r24, r20
    60f6:	48 f4       	brcc	.+18     	; 0x610a <__addsf3x+0x9c>
    60f8:	87 95       	ror	r24
    60fa:	77 95       	ror	r23
    60fc:	67 95       	ror	r22
    60fe:	b7 95       	ror	r27
    6100:	f7 95       	ror	r31
    6102:	9e 3f       	cpi	r25, 0xFE	; 254
    6104:	08 f0       	brcs	.+2      	; 0x6108 <__addsf3x+0x9a>
    6106:	b0 cf       	rjmp	.-160    	; 0x6068 <__addsf3+0x28>
    6108:	93 95       	inc	r25
    610a:	88 0f       	add	r24, r24
    610c:	08 f0       	brcs	.+2      	; 0x6110 <__addsf3x+0xa2>
    610e:	99 27       	eor	r25, r25
    6110:	ee 0f       	add	r30, r30
    6112:	97 95       	ror	r25
    6114:	87 95       	ror	r24
    6116:	08 95       	ret

00006118 <__cmpsf2>:
    6118:	0e 94 32 31 	call	0x6264	; 0x6264 <__fp_cmp>
    611c:	08 f4       	brcc	.+2      	; 0x6120 <__cmpsf2+0x8>
    611e:	81 e0       	ldi	r24, 0x01	; 1
    6120:	08 95       	ret

00006122 <__divsf3>:
    6122:	0e 94 a5 30 	call	0x614a	; 0x614a <__divsf3x>
    6126:	0c 94 6d 31 	jmp	0x62da	; 0x62da <__fp_round>
    612a:	0e 94 66 31 	call	0x62cc	; 0x62cc <__fp_pscB>
    612e:	58 f0       	brcs	.+22     	; 0x6146 <__divsf3+0x24>
    6130:	0e 94 5f 31 	call	0x62be	; 0x62be <__fp_pscA>
    6134:	40 f0       	brcs	.+16     	; 0x6146 <__divsf3+0x24>
    6136:	29 f4       	brne	.+10     	; 0x6142 <__divsf3+0x20>
    6138:	5f 3f       	cpi	r21, 0xFF	; 255
    613a:	29 f0       	breq	.+10     	; 0x6146 <__divsf3+0x24>
    613c:	0c 94 56 31 	jmp	0x62ac	; 0x62ac <__fp_inf>
    6140:	51 11       	cpse	r21, r1
    6142:	0c 94 a1 31 	jmp	0x6342	; 0x6342 <__fp_szero>
    6146:	0c 94 5c 31 	jmp	0x62b8	; 0x62b8 <__fp_nan>

0000614a <__divsf3x>:
    614a:	0e 94 7e 31 	call	0x62fc	; 0x62fc <__fp_split3>
    614e:	68 f3       	brcs	.-38     	; 0x612a <__divsf3+0x8>

00006150 <__divsf3_pse>:
    6150:	99 23       	and	r25, r25
    6152:	b1 f3       	breq	.-20     	; 0x6140 <__divsf3+0x1e>
    6154:	55 23       	and	r21, r21
    6156:	91 f3       	breq	.-28     	; 0x613c <__divsf3+0x1a>
    6158:	95 1b       	sub	r25, r21
    615a:	55 0b       	sbc	r21, r21
    615c:	bb 27       	eor	r27, r27
    615e:	aa 27       	eor	r26, r26
    6160:	62 17       	cp	r22, r18
    6162:	73 07       	cpc	r23, r19
    6164:	84 07       	cpc	r24, r20
    6166:	38 f0       	brcs	.+14     	; 0x6176 <__divsf3_pse+0x26>
    6168:	9f 5f       	subi	r25, 0xFF	; 255
    616a:	5f 4f       	sbci	r21, 0xFF	; 255
    616c:	22 0f       	add	r18, r18
    616e:	33 1f       	adc	r19, r19
    6170:	44 1f       	adc	r20, r20
    6172:	aa 1f       	adc	r26, r26
    6174:	a9 f3       	breq	.-22     	; 0x6160 <__divsf3_pse+0x10>
    6176:	35 d0       	rcall	.+106    	; 0x61e2 <__divsf3_pse+0x92>
    6178:	0e 2e       	mov	r0, r30
    617a:	3a f0       	brmi	.+14     	; 0x618a <__divsf3_pse+0x3a>
    617c:	e0 e8       	ldi	r30, 0x80	; 128
    617e:	32 d0       	rcall	.+100    	; 0x61e4 <__divsf3_pse+0x94>
    6180:	91 50       	subi	r25, 0x01	; 1
    6182:	50 40       	sbci	r21, 0x00	; 0
    6184:	e6 95       	lsr	r30
    6186:	00 1c       	adc	r0, r0
    6188:	ca f7       	brpl	.-14     	; 0x617c <__divsf3_pse+0x2c>
    618a:	2b d0       	rcall	.+86     	; 0x61e2 <__divsf3_pse+0x92>
    618c:	fe 2f       	mov	r31, r30
    618e:	29 d0       	rcall	.+82     	; 0x61e2 <__divsf3_pse+0x92>
    6190:	66 0f       	add	r22, r22
    6192:	77 1f       	adc	r23, r23
    6194:	88 1f       	adc	r24, r24
    6196:	bb 1f       	adc	r27, r27
    6198:	26 17       	cp	r18, r22
    619a:	37 07       	cpc	r19, r23
    619c:	48 07       	cpc	r20, r24
    619e:	ab 07       	cpc	r26, r27
    61a0:	b0 e8       	ldi	r27, 0x80	; 128
    61a2:	09 f0       	breq	.+2      	; 0x61a6 <__divsf3_pse+0x56>
    61a4:	bb 0b       	sbc	r27, r27
    61a6:	80 2d       	mov	r24, r0
    61a8:	bf 01       	movw	r22, r30
    61aa:	ff 27       	eor	r31, r31
    61ac:	93 58       	subi	r25, 0x83	; 131
    61ae:	5f 4f       	sbci	r21, 0xFF	; 255
    61b0:	3a f0       	brmi	.+14     	; 0x61c0 <__divsf3_pse+0x70>
    61b2:	9e 3f       	cpi	r25, 0xFE	; 254
    61b4:	51 05       	cpc	r21, r1
    61b6:	78 f0       	brcs	.+30     	; 0x61d6 <__divsf3_pse+0x86>
    61b8:	0c 94 56 31 	jmp	0x62ac	; 0x62ac <__fp_inf>
    61bc:	0c 94 a1 31 	jmp	0x6342	; 0x6342 <__fp_szero>
    61c0:	5f 3f       	cpi	r21, 0xFF	; 255
    61c2:	e4 f3       	brlt	.-8      	; 0x61bc <__divsf3_pse+0x6c>
    61c4:	98 3e       	cpi	r25, 0xE8	; 232
    61c6:	d4 f3       	brlt	.-12     	; 0x61bc <__divsf3_pse+0x6c>
    61c8:	86 95       	lsr	r24
    61ca:	77 95       	ror	r23
    61cc:	67 95       	ror	r22
    61ce:	b7 95       	ror	r27
    61d0:	f7 95       	ror	r31
    61d2:	9f 5f       	subi	r25, 0xFF	; 255
    61d4:	c9 f7       	brne	.-14     	; 0x61c8 <__divsf3_pse+0x78>
    61d6:	88 0f       	add	r24, r24
    61d8:	91 1d       	adc	r25, r1
    61da:	96 95       	lsr	r25
    61dc:	87 95       	ror	r24
    61de:	97 f9       	bld	r25, 7
    61e0:	08 95       	ret
    61e2:	e1 e0       	ldi	r30, 0x01	; 1
    61e4:	66 0f       	add	r22, r22
    61e6:	77 1f       	adc	r23, r23
    61e8:	88 1f       	adc	r24, r24
    61ea:	bb 1f       	adc	r27, r27
    61ec:	62 17       	cp	r22, r18
    61ee:	73 07       	cpc	r23, r19
    61f0:	84 07       	cpc	r24, r20
    61f2:	ba 07       	cpc	r27, r26
    61f4:	20 f0       	brcs	.+8      	; 0x61fe <__divsf3_pse+0xae>
    61f6:	62 1b       	sub	r22, r18
    61f8:	73 0b       	sbc	r23, r19
    61fa:	84 0b       	sbc	r24, r20
    61fc:	ba 0b       	sbc	r27, r26
    61fe:	ee 1f       	adc	r30, r30
    6200:	88 f7       	brcc	.-30     	; 0x61e4 <__divsf3_pse+0x94>
    6202:	e0 95       	com	r30
    6204:	08 95       	ret

00006206 <__fixunssfsi>:
    6206:	0e 94 86 31 	call	0x630c	; 0x630c <__fp_splitA>
    620a:	88 f0       	brcs	.+34     	; 0x622e <__fixunssfsi+0x28>
    620c:	9f 57       	subi	r25, 0x7F	; 127
    620e:	98 f0       	brcs	.+38     	; 0x6236 <__fixunssfsi+0x30>
    6210:	b9 2f       	mov	r27, r25
    6212:	99 27       	eor	r25, r25
    6214:	b7 51       	subi	r27, 0x17	; 23
    6216:	b0 f0       	brcs	.+44     	; 0x6244 <__fixunssfsi+0x3e>
    6218:	e1 f0       	breq	.+56     	; 0x6252 <__fixunssfsi+0x4c>
    621a:	66 0f       	add	r22, r22
    621c:	77 1f       	adc	r23, r23
    621e:	88 1f       	adc	r24, r24
    6220:	99 1f       	adc	r25, r25
    6222:	1a f0       	brmi	.+6      	; 0x622a <__fixunssfsi+0x24>
    6224:	ba 95       	dec	r27
    6226:	c9 f7       	brne	.-14     	; 0x621a <__fixunssfsi+0x14>
    6228:	14 c0       	rjmp	.+40     	; 0x6252 <__fixunssfsi+0x4c>
    622a:	b1 30       	cpi	r27, 0x01	; 1
    622c:	91 f0       	breq	.+36     	; 0x6252 <__fixunssfsi+0x4c>
    622e:	0e 94 a0 31 	call	0x6340	; 0x6340 <__fp_zero>
    6232:	b1 e0       	ldi	r27, 0x01	; 1
    6234:	08 95       	ret
    6236:	0c 94 a0 31 	jmp	0x6340	; 0x6340 <__fp_zero>
    623a:	67 2f       	mov	r22, r23
    623c:	78 2f       	mov	r23, r24
    623e:	88 27       	eor	r24, r24
    6240:	b8 5f       	subi	r27, 0xF8	; 248
    6242:	39 f0       	breq	.+14     	; 0x6252 <__fixunssfsi+0x4c>
    6244:	b9 3f       	cpi	r27, 0xF9	; 249
    6246:	cc f3       	brlt	.-14     	; 0x623a <__fixunssfsi+0x34>
    6248:	86 95       	lsr	r24
    624a:	77 95       	ror	r23
    624c:	67 95       	ror	r22
    624e:	b3 95       	inc	r27
    6250:	d9 f7       	brne	.-10     	; 0x6248 <__fixunssfsi+0x42>
    6252:	3e f4       	brtc	.+14     	; 0x6262 <__fixunssfsi+0x5c>
    6254:	90 95       	com	r25
    6256:	80 95       	com	r24
    6258:	70 95       	com	r23
    625a:	61 95       	neg	r22
    625c:	7f 4f       	sbci	r23, 0xFF	; 255
    625e:	8f 4f       	sbci	r24, 0xFF	; 255
    6260:	9f 4f       	sbci	r25, 0xFF	; 255
    6262:	08 95       	ret

00006264 <__fp_cmp>:
    6264:	99 0f       	add	r25, r25
    6266:	00 08       	sbc	r0, r0
    6268:	55 0f       	add	r21, r21
    626a:	aa 0b       	sbc	r26, r26
    626c:	e0 e8       	ldi	r30, 0x80	; 128
    626e:	fe ef       	ldi	r31, 0xFE	; 254
    6270:	16 16       	cp	r1, r22
    6272:	17 06       	cpc	r1, r23
    6274:	e8 07       	cpc	r30, r24
    6276:	f9 07       	cpc	r31, r25
    6278:	c0 f0       	brcs	.+48     	; 0x62aa <__fp_cmp+0x46>
    627a:	12 16       	cp	r1, r18
    627c:	13 06       	cpc	r1, r19
    627e:	e4 07       	cpc	r30, r20
    6280:	f5 07       	cpc	r31, r21
    6282:	98 f0       	brcs	.+38     	; 0x62aa <__fp_cmp+0x46>
    6284:	62 1b       	sub	r22, r18
    6286:	73 0b       	sbc	r23, r19
    6288:	84 0b       	sbc	r24, r20
    628a:	95 0b       	sbc	r25, r21
    628c:	39 f4       	brne	.+14     	; 0x629c <__fp_cmp+0x38>
    628e:	0a 26       	eor	r0, r26
    6290:	61 f0       	breq	.+24     	; 0x62aa <__fp_cmp+0x46>
    6292:	23 2b       	or	r18, r19
    6294:	24 2b       	or	r18, r20
    6296:	25 2b       	or	r18, r21
    6298:	21 f4       	brne	.+8      	; 0x62a2 <__fp_cmp+0x3e>
    629a:	08 95       	ret
    629c:	0a 26       	eor	r0, r26
    629e:	09 f4       	brne	.+2      	; 0x62a2 <__fp_cmp+0x3e>
    62a0:	a1 40       	sbci	r26, 0x01	; 1
    62a2:	a6 95       	lsr	r26
    62a4:	8f ef       	ldi	r24, 0xFF	; 255
    62a6:	81 1d       	adc	r24, r1
    62a8:	81 1d       	adc	r24, r1
    62aa:	08 95       	ret

000062ac <__fp_inf>:
    62ac:	97 f9       	bld	r25, 7
    62ae:	9f 67       	ori	r25, 0x7F	; 127
    62b0:	80 e8       	ldi	r24, 0x80	; 128
    62b2:	70 e0       	ldi	r23, 0x00	; 0
    62b4:	60 e0       	ldi	r22, 0x00	; 0
    62b6:	08 95       	ret

000062b8 <__fp_nan>:
    62b8:	9f ef       	ldi	r25, 0xFF	; 255
    62ba:	80 ec       	ldi	r24, 0xC0	; 192
    62bc:	08 95       	ret

000062be <__fp_pscA>:
    62be:	00 24       	eor	r0, r0
    62c0:	0a 94       	dec	r0
    62c2:	16 16       	cp	r1, r22
    62c4:	17 06       	cpc	r1, r23
    62c6:	18 06       	cpc	r1, r24
    62c8:	09 06       	cpc	r0, r25
    62ca:	08 95       	ret

000062cc <__fp_pscB>:
    62cc:	00 24       	eor	r0, r0
    62ce:	0a 94       	dec	r0
    62d0:	12 16       	cp	r1, r18
    62d2:	13 06       	cpc	r1, r19
    62d4:	14 06       	cpc	r1, r20
    62d6:	05 06       	cpc	r0, r21
    62d8:	08 95       	ret

000062da <__fp_round>:
    62da:	09 2e       	mov	r0, r25
    62dc:	03 94       	inc	r0
    62de:	00 0c       	add	r0, r0
    62e0:	11 f4       	brne	.+4      	; 0x62e6 <__fp_round+0xc>
    62e2:	88 23       	and	r24, r24
    62e4:	52 f0       	brmi	.+20     	; 0x62fa <__fp_round+0x20>
    62e6:	bb 0f       	add	r27, r27
    62e8:	40 f4       	brcc	.+16     	; 0x62fa <__fp_round+0x20>
    62ea:	bf 2b       	or	r27, r31
    62ec:	11 f4       	brne	.+4      	; 0x62f2 <__fp_round+0x18>
    62ee:	60 ff       	sbrs	r22, 0
    62f0:	04 c0       	rjmp	.+8      	; 0x62fa <__fp_round+0x20>
    62f2:	6f 5f       	subi	r22, 0xFF	; 255
    62f4:	7f 4f       	sbci	r23, 0xFF	; 255
    62f6:	8f 4f       	sbci	r24, 0xFF	; 255
    62f8:	9f 4f       	sbci	r25, 0xFF	; 255
    62fa:	08 95       	ret

000062fc <__fp_split3>:
    62fc:	57 fd       	sbrc	r21, 7
    62fe:	90 58       	subi	r25, 0x80	; 128
    6300:	44 0f       	add	r20, r20
    6302:	55 1f       	adc	r21, r21
    6304:	59 f0       	breq	.+22     	; 0x631c <__fp_splitA+0x10>
    6306:	5f 3f       	cpi	r21, 0xFF	; 255
    6308:	71 f0       	breq	.+28     	; 0x6326 <__fp_splitA+0x1a>
    630a:	47 95       	ror	r20

0000630c <__fp_splitA>:
    630c:	88 0f       	add	r24, r24
    630e:	97 fb       	bst	r25, 7
    6310:	99 1f       	adc	r25, r25
    6312:	61 f0       	breq	.+24     	; 0x632c <__fp_splitA+0x20>
    6314:	9f 3f       	cpi	r25, 0xFF	; 255
    6316:	79 f0       	breq	.+30     	; 0x6336 <__fp_splitA+0x2a>
    6318:	87 95       	ror	r24
    631a:	08 95       	ret
    631c:	12 16       	cp	r1, r18
    631e:	13 06       	cpc	r1, r19
    6320:	14 06       	cpc	r1, r20
    6322:	55 1f       	adc	r21, r21
    6324:	f2 cf       	rjmp	.-28     	; 0x630a <__fp_split3+0xe>
    6326:	46 95       	lsr	r20
    6328:	f1 df       	rcall	.-30     	; 0x630c <__fp_splitA>
    632a:	08 c0       	rjmp	.+16     	; 0x633c <__fp_splitA+0x30>
    632c:	16 16       	cp	r1, r22
    632e:	17 06       	cpc	r1, r23
    6330:	18 06       	cpc	r1, r24
    6332:	99 1f       	adc	r25, r25
    6334:	f1 cf       	rjmp	.-30     	; 0x6318 <__fp_splitA+0xc>
    6336:	86 95       	lsr	r24
    6338:	71 05       	cpc	r23, r1
    633a:	61 05       	cpc	r22, r1
    633c:	08 94       	sec
    633e:	08 95       	ret

00006340 <__fp_zero>:
    6340:	e8 94       	clt

00006342 <__fp_szero>:
    6342:	bb 27       	eor	r27, r27
    6344:	66 27       	eor	r22, r22
    6346:	77 27       	eor	r23, r23
    6348:	cb 01       	movw	r24, r22
    634a:	97 f9       	bld	r25, 7
    634c:	08 95       	ret

0000634e <__gesf2>:
    634e:	0e 94 32 31 	call	0x6264	; 0x6264 <__fp_cmp>
    6352:	08 f4       	brcc	.+2      	; 0x6356 <__gesf2+0x8>
    6354:	8f ef       	ldi	r24, 0xFF	; 255
    6356:	08 95       	ret

00006358 <__mulsf3>:
    6358:	0e 94 bf 31 	call	0x637e	; 0x637e <__mulsf3x>
    635c:	0c 94 6d 31 	jmp	0x62da	; 0x62da <__fp_round>
    6360:	0e 94 5f 31 	call	0x62be	; 0x62be <__fp_pscA>
    6364:	38 f0       	brcs	.+14     	; 0x6374 <__mulsf3+0x1c>
    6366:	0e 94 66 31 	call	0x62cc	; 0x62cc <__fp_pscB>
    636a:	20 f0       	brcs	.+8      	; 0x6374 <__mulsf3+0x1c>
    636c:	95 23       	and	r25, r21
    636e:	11 f0       	breq	.+4      	; 0x6374 <__mulsf3+0x1c>
    6370:	0c 94 56 31 	jmp	0x62ac	; 0x62ac <__fp_inf>
    6374:	0c 94 5c 31 	jmp	0x62b8	; 0x62b8 <__fp_nan>
    6378:	11 24       	eor	r1, r1
    637a:	0c 94 a1 31 	jmp	0x6342	; 0x6342 <__fp_szero>

0000637e <__mulsf3x>:
    637e:	0e 94 7e 31 	call	0x62fc	; 0x62fc <__fp_split3>
    6382:	70 f3       	brcs	.-36     	; 0x6360 <__mulsf3+0x8>

00006384 <__mulsf3_pse>:
    6384:	95 9f       	mul	r25, r21
    6386:	c1 f3       	breq	.-16     	; 0x6378 <__mulsf3+0x20>
    6388:	95 0f       	add	r25, r21
    638a:	50 e0       	ldi	r21, 0x00	; 0
    638c:	55 1f       	adc	r21, r21
    638e:	62 9f       	mul	r22, r18
    6390:	f0 01       	movw	r30, r0
    6392:	72 9f       	mul	r23, r18
    6394:	bb 27       	eor	r27, r27
    6396:	f0 0d       	add	r31, r0
    6398:	b1 1d       	adc	r27, r1
    639a:	63 9f       	mul	r22, r19
    639c:	aa 27       	eor	r26, r26
    639e:	f0 0d       	add	r31, r0
    63a0:	b1 1d       	adc	r27, r1
    63a2:	aa 1f       	adc	r26, r26
    63a4:	64 9f       	mul	r22, r20
    63a6:	66 27       	eor	r22, r22
    63a8:	b0 0d       	add	r27, r0
    63aa:	a1 1d       	adc	r26, r1
    63ac:	66 1f       	adc	r22, r22
    63ae:	82 9f       	mul	r24, r18
    63b0:	22 27       	eor	r18, r18
    63b2:	b0 0d       	add	r27, r0
    63b4:	a1 1d       	adc	r26, r1
    63b6:	62 1f       	adc	r22, r18
    63b8:	73 9f       	mul	r23, r19
    63ba:	b0 0d       	add	r27, r0
    63bc:	a1 1d       	adc	r26, r1
    63be:	62 1f       	adc	r22, r18
    63c0:	83 9f       	mul	r24, r19
    63c2:	a0 0d       	add	r26, r0
    63c4:	61 1d       	adc	r22, r1
    63c6:	22 1f       	adc	r18, r18
    63c8:	74 9f       	mul	r23, r20
    63ca:	33 27       	eor	r19, r19
    63cc:	a0 0d       	add	r26, r0
    63ce:	61 1d       	adc	r22, r1
    63d0:	23 1f       	adc	r18, r19
    63d2:	84 9f       	mul	r24, r20
    63d4:	60 0d       	add	r22, r0
    63d6:	21 1d       	adc	r18, r1
    63d8:	82 2f       	mov	r24, r18
    63da:	76 2f       	mov	r23, r22
    63dc:	6a 2f       	mov	r22, r26
    63de:	11 24       	eor	r1, r1
    63e0:	9f 57       	subi	r25, 0x7F	; 127
    63e2:	50 40       	sbci	r21, 0x00	; 0
    63e4:	9a f0       	brmi	.+38     	; 0x640c <__mulsf3_pse+0x88>
    63e6:	f1 f0       	breq	.+60     	; 0x6424 <__mulsf3_pse+0xa0>
    63e8:	88 23       	and	r24, r24
    63ea:	4a f0       	brmi	.+18     	; 0x63fe <__mulsf3_pse+0x7a>
    63ec:	ee 0f       	add	r30, r30
    63ee:	ff 1f       	adc	r31, r31
    63f0:	bb 1f       	adc	r27, r27
    63f2:	66 1f       	adc	r22, r22
    63f4:	77 1f       	adc	r23, r23
    63f6:	88 1f       	adc	r24, r24
    63f8:	91 50       	subi	r25, 0x01	; 1
    63fa:	50 40       	sbci	r21, 0x00	; 0
    63fc:	a9 f7       	brne	.-22     	; 0x63e8 <__mulsf3_pse+0x64>
    63fe:	9e 3f       	cpi	r25, 0xFE	; 254
    6400:	51 05       	cpc	r21, r1
    6402:	80 f0       	brcs	.+32     	; 0x6424 <__mulsf3_pse+0xa0>
    6404:	0c 94 56 31 	jmp	0x62ac	; 0x62ac <__fp_inf>
    6408:	0c 94 a1 31 	jmp	0x6342	; 0x6342 <__fp_szero>
    640c:	5f 3f       	cpi	r21, 0xFF	; 255
    640e:	e4 f3       	brlt	.-8      	; 0x6408 <__mulsf3_pse+0x84>
    6410:	98 3e       	cpi	r25, 0xE8	; 232
    6412:	d4 f3       	brlt	.-12     	; 0x6408 <__mulsf3_pse+0x84>
    6414:	86 95       	lsr	r24
    6416:	77 95       	ror	r23
    6418:	67 95       	ror	r22
    641a:	b7 95       	ror	r27
    641c:	f7 95       	ror	r31
    641e:	e7 95       	ror	r30
    6420:	9f 5f       	subi	r25, 0xFF	; 255
    6422:	c1 f7       	brne	.-16     	; 0x6414 <__mulsf3_pse+0x90>
    6424:	fe 2b       	or	r31, r30
    6426:	88 0f       	add	r24, r24
    6428:	91 1d       	adc	r25, r1
    642a:	96 95       	lsr	r25
    642c:	87 95       	ror	r24
    642e:	97 f9       	bld	r25, 7
    6430:	08 95       	ret

00006432 <memcpy>:
    6432:	fb 01       	movw	r30, r22
    6434:	dc 01       	movw	r26, r24
    6436:	02 c0       	rjmp	.+4      	; 0x643c <memcpy+0xa>
    6438:	01 90       	ld	r0, Z+
    643a:	0d 92       	st	X+, r0
    643c:	41 50       	subi	r20, 0x01	; 1
    643e:	50 40       	sbci	r21, 0x00	; 0
    6440:	d8 f7       	brcc	.-10     	; 0x6438 <memcpy+0x6>
    6442:	08 95       	ret

00006444 <_exit>:
    6444:	f8 94       	cli

00006446 <__stop_program>:
    6446:	ff cf       	rjmp	.-2      	; 0x6446 <__stop_program>

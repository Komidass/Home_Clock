
Home_Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000063c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000058  00800060  000063c2  00006456  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000065e  008000b8  008000b8  000064ae  2**0
                  ALLOC
  3 .stab         0000ad94  00000000  00000000  000064b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004d62  00000000  00000000  00011244  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00015fa6  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00015fb8  2**2
                  CONTENTS, READONLY
  7 .debug_info   000004e6  00000000  00000000  00015ff4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004a3  00000000  00000000  000164da  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0001697d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000196  00000000  00000000  00016997  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 98 17 	jmp	0x2f30	; 0x2f30 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ec       	ldi	r30, 0xC2	; 194
      68:	f3 e6       	ldi	r31, 0x63	; 99
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 3b       	cpi	r26, 0xB8	; 184
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a8 eb       	ldi	r26, 0xB8	; 184
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 31       	cpi	r26, 0x16	; 22
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 46 14 	call	0x288c	; 0x288c <main>
      8a:	0c 94 df 31 	jmp	0x63be	; 0x63be <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Clock_Second>:
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	00 d0       	rcall	.+0      	; 0x98 <Clock_Second+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <Clock_Second+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
      a2:	81 e0       	ldi	r24, 0x01	; 1
      a4:	0e 94 e7 18 	call	0x31ce	; 0x31ce <xQueueCreateMutex>
      a8:	90 93 0d 07 	sts	0x070D, r25	; 0x80070d <LCD+0x1>
      ac:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <LCD>
      b0:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskGetTickCount>
      b4:	9a 83       	std	Y+2, r25	; 0x02
      b6:	89 83       	std	Y+1, r24	; 0x01
      b8:	85 e0       	ldi	r24, 0x05	; 5
      ba:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
      be:	8a e3       	ldi	r24, 0x3A	; 58
      c0:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
      c4:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
      c8:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
      cc:	6a e0       	ldi	r22, 0x0A	; 10
      ce:	70 e0       	ldi	r23, 0x00	; 0
      d0:	0e 94 22 1b 	call	0x3644	; 0x3644 <xQueueSemaphoreTake>
      d4:	88 23       	and	r24, r24
      d6:	91 f0       	breq	.+36     	; 0xfc <Clock_Second+0x6a>
      d8:	86 e0       	ldi	r24, 0x06	; 6
      da:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
      de:	80 91 b8 00 	lds	r24, 0x00B8	; 0x8000b8 <__data_end>
      e2:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <LCD_Void_Write_Number_2>
      e6:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
      ea:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
      ee:	20 e0       	ldi	r18, 0x00	; 0
      f0:	40 e0       	ldi	r20, 0x00	; 0
      f2:	50 e0       	ldi	r21, 0x00	; 0
      f4:	60 e0       	ldi	r22, 0x00	; 0
      f6:	70 e0       	ldi	r23, 0x00	; 0
      f8:	0e 94 07 19 	call	0x320e	; 0x320e <xQueueGenericSend>
      fc:	6a e0       	ldi	r22, 0x0A	; 10
      fe:	70 e0       	ldi	r23, 0x00	; 0
     100:	ce 01       	movw	r24, r28
     102:	01 96       	adiw	r24, 0x01	; 1
     104:	0e 94 27 22 	call	0x444e	; 0x444e <vTaskDelayUntil>
     108:	80 91 b8 00 	lds	r24, 0x00B8	; 0x8000b8 <__data_end>
     10c:	8f 5f       	subi	r24, 0xFF	; 255
     10e:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__data_end>
     112:	90 91 b8 00 	lds	r25, 0x00B8	; 0x8000b8 <__data_end>
     116:	89 e8       	ldi	r24, 0x89	; 137
     118:	98 9f       	mul	r25, r24
     11a:	81 2d       	mov	r24, r1
     11c:	11 24       	eor	r1, r1
     11e:	82 95       	swap	r24
     120:	86 95       	lsr	r24
     122:	87 70       	andi	r24, 0x07	; 7
     124:	2c e3       	ldi	r18, 0x3C	; 60
     126:	82 9f       	mul	r24, r18
     128:	80 2d       	mov	r24, r0
     12a:	11 24       	eor	r1, r1
     12c:	29 2f       	mov	r18, r25
     12e:	28 1b       	sub	r18, r24
     130:	82 2f       	mov	r24, r18
     132:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__data_end>
     136:	c6 cf       	rjmp	.-116    	; 0xc4 <Clock_Second+0x32>

00000138 <Clock_Minute>:
		Seconds %= 60;
	}
}

void Clock_Minute(void *pvParameters)
{
     138:	cf 93       	push	r28
     13a:	df 93       	push	r29
     13c:	00 d0       	rcall	.+0      	; 0x13e <Clock_Minute+0x6>
     13e:	00 d0       	rcall	.+0      	; 0x140 <Clock_Minute+0x8>
     140:	cd b7       	in	r28, 0x3d	; 61
     142:	de b7       	in	r29, 0x3e	; 62
     144:	9c 83       	std	Y+4, r25	; 0x04
     146:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockM;
	MyLastUnblockM = xTaskGetTickCount();
     148:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskGetTickCount>
     14c:	9a 83       	std	Y+2, r25	; 0x02
     14e:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     150:	82 e0       	ldi	r24, 0x02	; 2
     152:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     156:	8a e3       	ldi	r24, 0x3A	; 58
     158:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     15c:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
     160:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
     164:	6a e0       	ldi	r22, 0x0A	; 10
     166:	70 e0       	ldi	r23, 0x00	; 0
     168:	0e 94 22 1b 	call	0x3644	; 0x3644 <xQueueSemaphoreTake>
     16c:	88 23       	and	r24, r24
     16e:	91 f0       	breq	.+36     	; 0x194 <Clock_Minute+0x5c>
		{
			LCD_Set_Block(minutes_position);
     170:	83 e0       	ldi	r24, 0x03	; 3
     172:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
			LCD_Void_Write_Number_2(Minutes);
     176:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <Minutes>
     17a:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     17e:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
     182:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
     186:	20 e0       	ldi	r18, 0x00	; 0
     188:	40 e0       	ldi	r20, 0x00	; 0
     18a:	50 e0       	ldi	r21, 0x00	; 0
     18c:	60 e0       	ldi	r22, 0x00	; 0
     18e:	70 e0       	ldi	r23, 0x00	; 0
     190:	0e 94 07 19 	call	0x320e	; 0x320e <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockM,minutes_frequency);
     194:	68 e5       	ldi	r22, 0x58	; 88
     196:	72 e0       	ldi	r23, 0x02	; 2
     198:	ce 01       	movw	r24, r28
     19a:	01 96       	adiw	r24, 0x01	; 1
     19c:	0e 94 27 22 	call	0x444e	; 0x444e <vTaskDelayUntil>
		Minutes++;
     1a0:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <Minutes>
     1a4:	8f 5f       	subi	r24, 0xFF	; 255
     1a6:	80 93 b9 00 	sts	0x00B9, r24	; 0x8000b9 <Minutes>
		Minutes %= 60;
     1aa:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <Minutes>
     1ae:	89 e8       	ldi	r24, 0x89	; 137
     1b0:	98 9f       	mul	r25, r24
     1b2:	81 2d       	mov	r24, r1
     1b4:	11 24       	eor	r1, r1
     1b6:	82 95       	swap	r24
     1b8:	86 95       	lsr	r24
     1ba:	87 70       	andi	r24, 0x07	; 7
     1bc:	2c e3       	ldi	r18, 0x3C	; 60
     1be:	82 9f       	mul	r24, r18
     1c0:	80 2d       	mov	r24, r0
     1c2:	11 24       	eor	r1, r1
     1c4:	29 2f       	mov	r18, r25
     1c6:	28 1b       	sub	r18, r24
     1c8:	82 2f       	mov	r24, r18
     1ca:	80 93 b9 00 	sts	0x00B9, r24	; 0x8000b9 <Minutes>
	}
     1ce:	c6 cf       	rjmp	.-116    	; 0x15c <Clock_Minute+0x24>

000001d0 <Clock_Hours>:
}
void Clock_Hours(void *pvParameters)
{
     1d0:	cf 93       	push	r28
     1d2:	df 93       	push	r29
     1d4:	00 d0       	rcall	.+0      	; 0x1d6 <Clock_Hours+0x6>
     1d6:	00 d0       	rcall	.+0      	; 0x1d8 <Clock_Hours+0x8>
     1d8:	cd b7       	in	r28, 0x3d	; 61
     1da:	de b7       	in	r29, 0x3e	; 62
     1dc:	9c 83       	std	Y+4, r25	; 0x04
     1de:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t MyLastUnblockH;
	MyLastUnblockH = xTaskGetTickCount();
     1e0:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskGetTickCount>
     1e4:	9a 83       	std	Y+2, r25	; 0x02
     1e6:	89 83       	std	Y+1, r24	; 0x01
	LCD_Set_Block(minutes_position-1);
     1e8:	82 e0       	ldi	r24, 0x02	; 2
     1ea:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
	LCD_Void_Write_Data(':');
     1ee:	8a e3       	ldi	r24, 0x3A	; 58
     1f0:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	while(1)
	{
		if(xSemaphoreTake(LCD,10))
     1f4:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
     1f8:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
     1fc:	6a e0       	ldi	r22, 0x0A	; 10
     1fe:	70 e0       	ldi	r23, 0x00	; 0
     200:	0e 94 22 1b 	call	0x3644	; 0x3644 <xQueueSemaphoreTake>
     204:	88 23       	and	r24, r24
     206:	19 f1       	breq	.+70     	; 0x24e <Clock_Hours+0x7e>
		{
			LCD_Set_Block(hours_position);
     208:	80 e0       	ldi	r24, 0x00	; 0
     20a:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
			LCD_Void_Write_Number_2((Hours%12)+1);
     20e:	20 91 ba 00 	lds	r18, 0x00BA	; 0x8000ba <Hours>
     212:	8b ea       	ldi	r24, 0xAB	; 171
     214:	28 9f       	mul	r18, r24
     216:	81 2d       	mov	r24, r1
     218:	11 24       	eor	r1, r1
     21a:	98 2f       	mov	r25, r24
     21c:	96 95       	lsr	r25
     21e:	96 95       	lsr	r25
     220:	96 95       	lsr	r25
     222:	89 2f       	mov	r24, r25
     224:	88 0f       	add	r24, r24
     226:	89 0f       	add	r24, r25
     228:	88 0f       	add	r24, r24
     22a:	88 0f       	add	r24, r24
     22c:	92 2f       	mov	r25, r18
     22e:	98 1b       	sub	r25, r24
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	89 0f       	add	r24, r25
     234:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <LCD_Void_Write_Number_2>
			xSemaphoreGive(LCD);
     238:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
     23c:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
     240:	20 e0       	ldi	r18, 0x00	; 0
     242:	40 e0       	ldi	r20, 0x00	; 0
     244:	50 e0       	ldi	r21, 0x00	; 0
     246:	60 e0       	ldi	r22, 0x00	; 0
     248:	70 e0       	ldi	r23, 0x00	; 0
     24a:	0e 94 07 19 	call	0x320e	; 0x320e <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockH,hours_frequency);
     24e:	60 ea       	ldi	r22, 0xA0	; 160
     250:	7c e8       	ldi	r23, 0x8C	; 140
     252:	ce 01       	movw	r24, r28
     254:	01 96       	adiw	r24, 0x01	; 1
     256:	0e 94 27 22 	call	0x444e	; 0x444e <vTaskDelayUntil>
		Hours++;
     25a:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <Hours>
     25e:	8f 5f       	subi	r24, 0xFF	; 255
     260:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <Hours>
		Hours %= 24;
     264:	90 91 ba 00 	lds	r25, 0x00BA	; 0x8000ba <Hours>
     268:	8b ea       	ldi	r24, 0xAB	; 171
     26a:	98 9f       	mul	r25, r24
     26c:	81 2d       	mov	r24, r1
     26e:	11 24       	eor	r1, r1
     270:	82 95       	swap	r24
     272:	8f 70       	andi	r24, 0x0F	; 15
     274:	28 e1       	ldi	r18, 0x18	; 24
     276:	82 9f       	mul	r24, r18
     278:	80 2d       	mov	r24, r0
     27a:	11 24       	eor	r1, r1
     27c:	29 2f       	mov	r18, r25
     27e:	28 1b       	sub	r18, r24
     280:	82 2f       	mov	r24, r18
     282:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <Hours>
	}
     286:	b6 cf       	rjmp	.-148    	; 0x1f4 <Clock_Hours+0x24>

00000288 <Clock_Check_KPD>:
}

void Clock_Check_KPD(void *pvParameters)
{
     288:	cf 93       	push	r28
     28a:	df 93       	push	r29
     28c:	cd b7       	in	r28, 0x3d	; 61
     28e:	de b7       	in	r29, 0x3e	; 62
     290:	65 97       	sbiw	r28, 0x15	; 21
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	f8 94       	cli
     296:	de bf       	out	0x3e, r29	; 62
     298:	0f be       	out	0x3f, r0	; 63
     29a:	cd bf       	out	0x3d, r28	; 61
     29c:	9d 8b       	std	Y+21, r25	; 0x15
     29e:	8c 8b       	std	Y+20, r24	; 0x14
	KPD_input = xQueueCreate(1,sizeof(u8));
     2a0:	40 e0       	ldi	r20, 0x00	; 0
     2a2:	61 e0       	ldi	r22, 0x01	; 1
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	0e 94 2f 18 	call	0x305e	; 0x305e <xQueueGenericCreate>
     2aa:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <KPD_input+0x1>
     2ae:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <KPD_input>
	TickType_t MyLastUnblockKPD;
	MyLastUnblockKPD = xTaskGetTickCount();
     2b2:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskGetTickCount>
     2b6:	9a 83       	std	Y+2, r25	; 0x02
     2b8:	89 83       	std	Y+1, r24	; 0x01
	u8 keys[16];
	u8 pressed;
	while(1)
	{	pressed = KBD_u8GetKeyPadState(keys);
     2ba:	ce 01       	movw	r24, r28
     2bc:	03 96       	adiw	r24, 0x03	; 3
     2be:	0e 94 2c 05 	call	0xa58	; 0xa58 <KBD_u8GetKeyPadState>
     2c2:	8b 8b       	std	Y+19, r24	; 0x13
		if(pressed != 0xff)
     2c4:	8b 89       	ldd	r24, Y+19	; 0x13
     2c6:	8f 3f       	cpi	r24, 0xFF	; 255
     2c8:	61 f0       	breq	.+24     	; 0x2e2 <Clock_Check_KPD+0x5a>
		{
			xQueueSend(KPD_input,&pressed,10);
     2ca:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <KPD_input>
     2ce:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <KPD_input+0x1>
     2d2:	be 01       	movw	r22, r28
     2d4:	6d 5e       	subi	r22, 0xED	; 237
     2d6:	7f 4f       	sbci	r23, 0xFF	; 255
     2d8:	20 e0       	ldi	r18, 0x00	; 0
     2da:	4a e0       	ldi	r20, 0x0A	; 10
     2dc:	50 e0       	ldi	r21, 0x00	; 0
     2de:	0e 94 07 19 	call	0x320e	; 0x320e <xQueueGenericSend>
		}

		vTaskDelayUntil(&MyLastUnblockKPD,KPD_Check_frequency);
     2e2:	62 e3       	ldi	r22, 0x32	; 50
     2e4:	70 e0       	ldi	r23, 0x00	; 0
     2e6:	ce 01       	movw	r24, r28
     2e8:	01 96       	adiw	r24, 0x01	; 1
     2ea:	0e 94 27 22 	call	0x444e	; 0x444e <vTaskDelayUntil>
	}
     2ee:	e5 cf       	rjmp	.-54     	; 0x2ba <Clock_Check_KPD+0x32>

000002f0 <Clock_Enter_Typing_Mode>:
}

void Clock_Enter_Typing_Mode(void *pvParameters)
{
     2f0:	cf 93       	push	r28
     2f2:	df 93       	push	r29
     2f4:	00 d0       	rcall	.+0      	; 0x2f6 <Clock_Enter_Typing_Mode+0x6>
     2f6:	00 d0       	rcall	.+0      	; 0x2f8 <Clock_Enter_Typing_Mode+0x8>
     2f8:	cd b7       	in	r28, 0x3d	; 61
     2fa:	de b7       	in	r29, 0x3e	; 62
     2fc:	9c 83       	std	Y+4, r25	; 0x04
     2fe:	8b 83       	std	Y+3, r24	; 0x03
	u8 pressed  = 0xff;
     300:	8f ef       	ldi	r24, 0xFF	; 255
     302:	8a 83       	std	Y+2, r24	; 0x02
	u8 take_lach = 0;
     304:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		if(xQueueReceive(KPD_input,&pressed,10))
     306:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <KPD_input>
     30a:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <KPD_input+0x1>
     30e:	9e 01       	movw	r18, r28
     310:	2e 5f       	subi	r18, 0xFE	; 254
     312:	3f 4f       	sbci	r19, 0xFF	; 255
     314:	4a e0       	ldi	r20, 0x0A	; 10
     316:	50 e0       	ldi	r21, 0x00	; 0
     318:	b9 01       	movw	r22, r18
     31a:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <xQueueReceive>
     31e:	88 23       	and	r24, r24
     320:	91 f3       	breq	.-28     	; 0x306 <Clock_Enter_Typing_Mode+0x16>
		{
			if((take_lach)&&(pressed != '#'))
     322:	89 81       	ldd	r24, Y+1	; 0x01
     324:	88 23       	and	r24, r24
     326:	51 f0       	breq	.+20     	; 0x33c <Clock_Enter_Typing_Mode+0x4c>
     328:	8a 81       	ldd	r24, Y+2	; 0x02
     32a:	83 32       	cpi	r24, 0x23	; 35
     32c:	39 f0       	breq	.+14     	; 0x33c <Clock_Enter_Typing_Mode+0x4c>
			{
				LCD_Set_Block(26);
     32e:	8a e1       	ldi	r24, 0x1A	; 26
     330:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
				LCD_Void_Write_Data(pressed);
     334:	8a 81       	ldd	r24, Y+2	; 0x02
     336:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
				continue;
     33a:	31 c0       	rjmp	.+98     	; 0x39e <Clock_Enter_Typing_Mode+0xae>
			}
			switch (pressed)
     33c:	8a 81       	ldd	r24, Y+2	; 0x02
     33e:	88 2f       	mov	r24, r24
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	83 32       	cpi	r24, 0x23	; 35
     344:	91 05       	cpc	r25, r1
     346:	b1 f0       	breq	.+44     	; 0x374 <Clock_Enter_Typing_Mode+0x84>
     348:	8a 97       	sbiw	r24, 0x2a	; 42
     34a:	49 f5       	brne	.+82     	; 0x39e <Clock_Enter_Typing_Mode+0xae>
			{
			case '*':
				if(xSemaphoreTake(LCD,10))
     34c:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
     350:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
     354:	6a e0       	ldi	r22, 0x0A	; 10
     356:	70 e0       	ldi	r23, 0x00	; 0
     358:	0e 94 22 1b 	call	0x3644	; 0x3644 <xQueueSemaphoreTake>
     35c:	88 23       	and	r24, r24
     35e:	f1 f0       	breq	.+60     	; 0x39c <Clock_Enter_Typing_Mode+0xac>
				{
					LCD_Set_Block(16);
     360:	80 e1       	ldi	r24, 0x10	; 16
     362:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
					LCD_Void_Write_String("taken  ");
     366:	80 e7       	ldi	r24, 0x70	; 112
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <LCD_Void_Write_String>
					take_lach = 1;
     36e:	81 e0       	ldi	r24, 0x01	; 1
     370:	89 83       	std	Y+1, r24	; 0x01
				}
				break;
     372:	14 c0       	rjmp	.+40     	; 0x39c <Clock_Enter_Typing_Mode+0xac>
			case '#':
				xSemaphoreGive(LCD);
     374:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <LCD>
     378:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <LCD+0x1>
     37c:	20 e0       	ldi	r18, 0x00	; 0
     37e:	40 e0       	ldi	r20, 0x00	; 0
     380:	50 e0       	ldi	r21, 0x00	; 0
     382:	60 e0       	ldi	r22, 0x00	; 0
     384:	70 e0       	ldi	r23, 0x00	; 0
     386:	0e 94 07 19 	call	0x320e	; 0x320e <xQueueGenericSend>
				LCD_Set_Block(16);
     38a:	80 e1       	ldi	r24, 0x10	; 16
     38c:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
				LCD_Void_Write_String("released");
     390:	88 e7       	ldi	r24, 0x78	; 120
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <LCD_Void_Write_String>
				take_lach = 0;
     398:	19 82       	std	Y+1, r1	; 0x01
				break;
     39a:	01 c0       	rjmp	.+2      	; 0x39e <Clock_Enter_Typing_Mode+0xae>
				{
					LCD_Set_Block(16);
					LCD_Void_Write_String("taken  ");
					take_lach = 1;
				}
				break;
     39c:	00 00       	nop

			}

		}

	}
     39e:	b3 cf       	rjmp	.-154    	; 0x306 <Clock_Enter_Typing_Mode+0x16>

000003a0 <DIO_voidInitialize>:

/* Description: This function shall initialize the     */
/*              direction and initial value for DIO    */
/*              pins                                   */
void DIO_voidInitialize(void)
{
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	cd b7       	in	r28, 0x3d	; 61
     3a6:	de b7       	in	r29, 0x3e	; 62
	DIO_u8_DDRA->ByteAccess = CONC_8BIT(DIO_u8_PIN0_DIR,
     3a8:	8a e3       	ldi	r24, 0x3A	; 58
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	fc 01       	movw	r30, r24
     3ae:	10 82       	st	Z, r1
										DIO_u8_PIN4_DIR,
										DIO_u8_PIN5_DIR,
										DIO_u8_PIN6_DIR,
										DIO_u8_PIN7_DIR);

	DIO_u8_DDRB->ByteAccess = CONC_8BIT(DIO_u8_PIN8_DIR,
     3b0:	87 e3       	ldi	r24, 0x37	; 55
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	fc 01       	movw	r30, r24
     3b6:	10 82       	st	Z, r1
										DIO_u8_PIN12_DIR,
										DIO_u8_PIN13_DIR,
										DIO_u8_PIN14_DIR,
										DIO_u8_PIN15_DIR);

	DIO_u8_DDRC->ByteAccess = CONC_8BIT(DIO_u8_PIN16_DIR,
     3b8:	84 e3       	ldi	r24, 0x34	; 52
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	fc 01       	movw	r30, r24
     3be:	10 82       	st	Z, r1
										DIO_u8_PIN20_DIR,
										DIO_u8_PIN21_DIR,
										DIO_u8_PIN22_DIR,
										DIO_u8_PIN23_DIR);

	DIO_u8_DDRD->ByteAccess = CONC_8BIT(DIO_u8_PIN24_DIR,
     3c0:	81 e3       	ldi	r24, 0x31	; 49
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	fc 01       	movw	r30, r24
     3c6:	10 82       	st	Z, r1
										DIO_u8_PIN27_DIR,
										DIO_u8_PIN28_DIR,
										DIO_u8_PIN29_DIR,
										DIO_u8_PIN30_DIR,
										DIO_u8_PIN31_DIR);
}
     3c8:	00 00       	nop
     3ca:	df 91       	pop	r29
     3cc:	cf 91       	pop	r28
     3ce:	08 95       	ret

000003d0 <DIO_u8SetPinDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_pin           */
u8 DIO_u8SetPinDirection(u8 Copy_u8PinNB, u8 Copy_u8PinDirection)
{
     3d0:	cf 93       	push	r28
     3d2:	df 93       	push	r29
     3d4:	00 d0       	rcall	.+0      	; 0x3d6 <DIO_u8SetPinDirection+0x6>
     3d6:	00 d0       	rcall	.+0      	; 0x3d8 <DIO_u8SetPinDirection+0x8>
     3d8:	1f 92       	push	r1
     3da:	cd b7       	in	r28, 0x3d	; 61
     3dc:	de b7       	in	r29, 0x3e	; 62
     3de:	8c 83       	std	Y+4, r24	; 0x04
     3e0:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     3e2:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     3e4:	8c 81       	ldd	r24, Y+4	; 0x04
     3e6:	80 32       	cpi	r24, 0x20	; 32
     3e8:	18 f0       	brcs	.+6      	; 0x3f0 <DIO_u8SetPinDirection+0x20>
	{
		u8ErrorState = 1;
     3ea:	81 e0       	ldi	r24, 0x01	; 1
     3ec:	89 83       	std	Y+1, r24	; 0x01
     3ee:	dd c0       	rjmp	.+442    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
	}else if ((Copy_u8PinDirection != DIO_u8_INPUT) && (Copy_u8PinDirection != DIO_u8_OUTPUT))
     3f0:	8d 81       	ldd	r24, Y+5	; 0x05
     3f2:	88 23       	and	r24, r24
     3f4:	31 f0       	breq	.+12     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
     3f6:	8d 81       	ldd	r24, Y+5	; 0x05
     3f8:	81 30       	cpi	r24, 0x01	; 1
     3fa:	19 f0       	breq	.+6      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
	{
		u8ErrorState = 1;
     3fc:	81 e0       	ldi	r24, 0x01	; 1
     3fe:	89 83       	std	Y+1, r24	; 0x01
     400:	d4 c0       	rjmp	.+424    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     402:	8c 81       	ldd	r24, Y+4	; 0x04
     404:	86 95       	lsr	r24
     406:	86 95       	lsr	r24
     408:	86 95       	lsr	r24
     40a:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     40c:	8c 81       	ldd	r24, Y+4	; 0x04
     40e:	87 70       	andi	r24, 0x07	; 7
     410:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     412:	8a 81       	ldd	r24, Y+2	; 0x02
     414:	88 2f       	mov	r24, r24
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	81 30       	cpi	r24, 0x01	; 1
     41a:	91 05       	cpc	r25, r1
     41c:	e1 f1       	breq	.+120    	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
     41e:	82 30       	cpi	r24, 0x02	; 2
     420:	91 05       	cpc	r25, r1
     422:	1c f4       	brge	.+6      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     424:	89 2b       	or	r24, r25
     426:	49 f0       	breq	.+18     	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     428:	c0 c0       	rjmp	.+384    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     42a:	82 30       	cpi	r24, 0x02	; 2
     42c:	91 05       	cpc	r25, r1
     42e:	09 f4       	brne	.+2      	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
     430:	60 c0       	rjmp	.+192    	; 0x4f2 <__LOCK_REGION_LENGTH__+0xf2>
     432:	03 97       	sbiw	r24, 0x03	; 3
     434:	09 f4       	brne	.+2      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
     436:	8b c0       	rjmp	.+278    	; 0x54e <__LOCK_REGION_LENGTH__+0x14e>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		default:

			break;
     438:	b8 c0       	rjmp	.+368    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     43a:	8d 81       	ldd	r24, Y+5	; 0x05
     43c:	81 30       	cpi	r24, 0x01	; 1
     43e:	a9 f4       	brne	.+42     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
     440:	8a e3       	ldi	r24, 0x3A	; 58
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	2a e3       	ldi	r18, 0x3A	; 58
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	f9 01       	movw	r30, r18
     44a:	20 81       	ld	r18, Z
     44c:	62 2f       	mov	r22, r18
     44e:	2b 81       	ldd	r18, Y+3	; 0x03
     450:	42 2f       	mov	r20, r18
     452:	50 e0       	ldi	r21, 0x00	; 0
     454:	21 e0       	ldi	r18, 0x01	; 1
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	02 c0       	rjmp	.+4      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45a:	22 0f       	add	r18, r18
     45c:	33 1f       	adc	r19, r19
     45e:	4a 95       	dec	r20
     460:	e2 f7       	brpl	.-8      	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
     462:	26 2b       	or	r18, r22
     464:	fc 01       	movw	r30, r24
     466:	20 83       	st	Z, r18
			break;
     468:	a0 c0       	rjmp	.+320    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_DDRA->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     46a:	8a e3       	ldi	r24, 0x3A	; 58
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	2a e3       	ldi	r18, 0x3A	; 58
     470:	30 e0       	ldi	r19, 0x00	; 0
     472:	f9 01       	movw	r30, r18
     474:	20 81       	ld	r18, Z
     476:	62 2f       	mov	r22, r18
     478:	2b 81       	ldd	r18, Y+3	; 0x03
     47a:	42 2f       	mov	r20, r18
     47c:	50 e0       	ldi	r21, 0x00	; 0
     47e:	21 e0       	ldi	r18, 0x01	; 1
     480:	30 e0       	ldi	r19, 0x00	; 0
     482:	02 c0       	rjmp	.+4      	; 0x488 <__LOCK_REGION_LENGTH__+0x88>
     484:	22 0f       	add	r18, r18
     486:	33 1f       	adc	r19, r19
     488:	4a 95       	dec	r20
     48a:	e2 f7       	brpl	.-8      	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
     48c:	20 95       	com	r18
     48e:	26 23       	and	r18, r22
     490:	fc 01       	movw	r30, r24
     492:	20 83       	st	Z, r18
			break;
     494:	8a c0       	rjmp	.+276    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
		case GROUP_B :
			if(Copy_u8PinDirection == DIO_u8_INPUT)
     496:	8d 81       	ldd	r24, Y+5	; 0x05
     498:	88 23       	and	r24, r24
     49a:	b1 f4       	brne	.+44     	; 0x4c8 <__LOCK_REGION_LENGTH__+0xc8>
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     49c:	87 e3       	ldi	r24, 0x37	; 55
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	27 e3       	ldi	r18, 0x37	; 55
     4a2:	30 e0       	ldi	r19, 0x00	; 0
     4a4:	f9 01       	movw	r30, r18
     4a6:	20 81       	ld	r18, Z
     4a8:	62 2f       	mov	r22, r18
     4aa:	2b 81       	ldd	r18, Y+3	; 0x03
     4ac:	42 2f       	mov	r20, r18
     4ae:	50 e0       	ldi	r21, 0x00	; 0
     4b0:	21 e0       	ldi	r18, 0x01	; 1
     4b2:	30 e0       	ldi	r19, 0x00	; 0
     4b4:	02 c0       	rjmp	.+4      	; 0x4ba <__LOCK_REGION_LENGTH__+0xba>
     4b6:	22 0f       	add	r18, r18
     4b8:	33 1f       	adc	r19, r19
     4ba:	4a 95       	dec	r20
     4bc:	e2 f7       	brpl	.-8      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4be:	20 95       	com	r18
     4c0:	26 23       	and	r18, r22
     4c2:	fc 01       	movw	r30, r24
     4c4:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
     4c6:	71 c0       	rjmp	.+226    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
			if(Copy_u8PinDirection == DIO_u8_INPUT)
			{
				Clear_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
     4c8:	87 e3       	ldi	r24, 0x37	; 55
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	27 e3       	ldi	r18, 0x37	; 55
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	f9 01       	movw	r30, r18
     4d2:	20 81       	ld	r18, Z
     4d4:	62 2f       	mov	r22, r18
     4d6:	2b 81       	ldd	r18, Y+3	; 0x03
     4d8:	42 2f       	mov	r20, r18
     4da:	50 e0       	ldi	r21, 0x00	; 0
     4dc:	21 e0       	ldi	r18, 0x01	; 1
     4de:	30 e0       	ldi	r19, 0x00	; 0
     4e0:	02 c0       	rjmp	.+4      	; 0x4e6 <__LOCK_REGION_LENGTH__+0xe6>
     4e2:	22 0f       	add	r18, r18
     4e4:	33 1f       	adc	r19, r19
     4e6:	4a 95       	dec	r20
     4e8:	e2 f7       	brpl	.-8      	; 0x4e2 <__LOCK_REGION_LENGTH__+0xe2>
     4ea:	26 2b       	or	r18, r22
     4ec:	fc 01       	movw	r30, r24
     4ee:	20 83       	st	Z, r18
			}
			break;
     4f0:	5c c0       	rjmp	.+184    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     4f2:	8d 81       	ldd	r24, Y+5	; 0x05
     4f4:	81 30       	cpi	r24, 0x01	; 1
     4f6:	a9 f4       	brne	.+42     	; 0x522 <__LOCK_REGION_LENGTH__+0x122>
     4f8:	84 e3       	ldi	r24, 0x34	; 52
     4fa:	90 e0       	ldi	r25, 0x00	; 0
     4fc:	24 e3       	ldi	r18, 0x34	; 52
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	f9 01       	movw	r30, r18
     502:	20 81       	ld	r18, Z
     504:	62 2f       	mov	r22, r18
     506:	2b 81       	ldd	r18, Y+3	; 0x03
     508:	42 2f       	mov	r20, r18
     50a:	50 e0       	ldi	r21, 0x00	; 0
     50c:	21 e0       	ldi	r18, 0x01	; 1
     50e:	30 e0       	ldi	r19, 0x00	; 0
     510:	02 c0       	rjmp	.+4      	; 0x516 <__LOCK_REGION_LENGTH__+0x116>
     512:	22 0f       	add	r18, r18
     514:	33 1f       	adc	r19, r19
     516:	4a 95       	dec	r20
     518:	e2 f7       	brpl	.-8      	; 0x512 <__LOCK_REGION_LENGTH__+0x112>
     51a:	26 2b       	or	r18, r22
     51c:	fc 01       	movw	r30, r24
     51e:	20 83       	st	Z, r18
			break;
     520:	44 c0       	rjmp	.+136    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
			{
				Set_Bit(DIO_u8_DDRB->ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     522:	84 e3       	ldi	r24, 0x34	; 52
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	24 e3       	ldi	r18, 0x34	; 52
     528:	30 e0       	ldi	r19, 0x00	; 0
     52a:	f9 01       	movw	r30, r18
     52c:	20 81       	ld	r18, Z
     52e:	62 2f       	mov	r22, r18
     530:	2b 81       	ldd	r18, Y+3	; 0x03
     532:	42 2f       	mov	r20, r18
     534:	50 e0       	ldi	r21, 0x00	; 0
     536:	21 e0       	ldi	r18, 0x01	; 1
     538:	30 e0       	ldi	r19, 0x00	; 0
     53a:	02 c0       	rjmp	.+4      	; 0x540 <__LOCK_REGION_LENGTH__+0x140>
     53c:	22 0f       	add	r18, r18
     53e:	33 1f       	adc	r19, r19
     540:	4a 95       	dec	r20
     542:	e2 f7       	brpl	.-8      	; 0x53c <__LOCK_REGION_LENGTH__+0x13c>
     544:	20 95       	com	r18
     546:	26 23       	and	r18, r22
     548:	fc 01       	movw	r30, r24
     54a:	20 83       	st	Z, r18
			break;
     54c:	2e c0       	rjmp	.+92     	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     54e:	8d 81       	ldd	r24, Y+5	; 0x05
     550:	81 30       	cpi	r24, 0x01	; 1
     552:	a9 f4       	brne	.+42     	; 0x57e <__LOCK_REGION_LENGTH__+0x17e>
     554:	81 e3       	ldi	r24, 0x31	; 49
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	21 e3       	ldi	r18, 0x31	; 49
     55a:	30 e0       	ldi	r19, 0x00	; 0
     55c:	f9 01       	movw	r30, r18
     55e:	20 81       	ld	r18, Z
     560:	62 2f       	mov	r22, r18
     562:	2b 81       	ldd	r18, Y+3	; 0x03
     564:	42 2f       	mov	r20, r18
     566:	50 e0       	ldi	r21, 0x00	; 0
     568:	21 e0       	ldi	r18, 0x01	; 1
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	02 c0       	rjmp	.+4      	; 0x572 <__LOCK_REGION_LENGTH__+0x172>
     56e:	22 0f       	add	r18, r18
     570:	33 1f       	adc	r19, r19
     572:	4a 95       	dec	r20
     574:	e2 f7       	brpl	.-8      	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     576:	26 2b       	or	r18, r22
     578:	fc 01       	movw	r30, r24
     57a:	20 83       	st	Z, r18
			break;
     57c:	15 c0       	rjmp	.+42     	; 0x5a8 <__LOCK_REGION_LENGTH__+0x1a8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_DDRC->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_DDRD->ByteAccess, u8PIN_ID, Copy_u8PinDirection);
     57e:	81 e3       	ldi	r24, 0x31	; 49
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	f9 01       	movw	r30, r18
     588:	20 81       	ld	r18, Z
     58a:	62 2f       	mov	r22, r18
     58c:	2b 81       	ldd	r18, Y+3	; 0x03
     58e:	42 2f       	mov	r20, r18
     590:	50 e0       	ldi	r21, 0x00	; 0
     592:	21 e0       	ldi	r18, 0x01	; 1
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	02 c0       	rjmp	.+4      	; 0x59c <__LOCK_REGION_LENGTH__+0x19c>
     598:	22 0f       	add	r18, r18
     59a:	33 1f       	adc	r19, r19
     59c:	4a 95       	dec	r20
     59e:	e2 f7       	brpl	.-8      	; 0x598 <__LOCK_REGION_LENGTH__+0x198>
     5a0:	20 95       	com	r18
     5a2:	26 23       	and	r18, r22
     5a4:	fc 01       	movw	r30, r24
     5a6:	20 83       	st	Z, r18
			break;
     5a8:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     5aa:	89 81       	ldd	r24, Y+1	; 0x01
}
     5ac:	0f 90       	pop	r0
     5ae:	0f 90       	pop	r0
     5b0:	0f 90       	pop	r0
     5b2:	0f 90       	pop	r0
     5b4:	0f 90       	pop	r0
     5b6:	df 91       	pop	r29
     5b8:	cf 91       	pop	r28
     5ba:	08 95       	ret

000005bc <DIO_u8SetPinValue>:
/* Description: This function shall set certain value  */
/*              to certain DIO pin                     */
u8 DIO_u8SetPinValue(u8 Copy_u8PinNB, u8 Copy_u8PinValue)
{
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	00 d0       	rcall	.+0      	; 0x5c2 <DIO_u8SetPinValue+0x6>
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <DIO_u8SetPinValue+0x8>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	8c 83       	std	Y+4, r24	; 0x04
     5cc:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     5ce:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     5d0:	8c 81       	ldd	r24, Y+4	; 0x04
     5d2:	80 32       	cpi	r24, 0x20	; 32
     5d4:	18 f0       	brcs	.+6      	; 0x5dc <DIO_u8SetPinValue+0x20>
	{
		u8ErrorState = 1;
     5d6:	81 e0       	ldi	r24, 0x01	; 1
     5d8:	89 83       	std	Y+1, r24	; 0x01
     5da:	dd c0       	rjmp	.+442    	; 0x796 <DIO_u8SetPinValue+0x1da>
	}else if ((Copy_u8PinValue != DIO_u8_HIGH) && (Copy_u8PinValue != DIO_u8_LOW))
     5dc:	8d 81       	ldd	r24, Y+5	; 0x05
     5de:	81 30       	cpi	r24, 0x01	; 1
     5e0:	31 f0       	breq	.+12     	; 0x5ee <DIO_u8SetPinValue+0x32>
     5e2:	8d 81       	ldd	r24, Y+5	; 0x05
     5e4:	88 23       	and	r24, r24
     5e6:	19 f0       	breq	.+6      	; 0x5ee <DIO_u8SetPinValue+0x32>
	{
		u8ErrorState = 1;
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	89 83       	std	Y+1, r24	; 0x01
     5ec:	d4 c0       	rjmp	.+424    	; 0x796 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     5ee:	8c 81       	ldd	r24, Y+4	; 0x04
     5f0:	86 95       	lsr	r24
     5f2:	86 95       	lsr	r24
     5f4:	86 95       	lsr	r24
     5f6:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     5f8:	8c 81       	ldd	r24, Y+4	; 0x04
     5fa:	87 70       	andi	r24, 0x07	; 7
     5fc:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     5fe:	8a 81       	ldd	r24, Y+2	; 0x02
     600:	88 2f       	mov	r24, r24
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	81 30       	cpi	r24, 0x01	; 1
     606:	91 05       	cpc	r25, r1
     608:	e1 f1       	breq	.+120    	; 0x682 <DIO_u8SetPinValue+0xc6>
     60a:	82 30       	cpi	r24, 0x02	; 2
     60c:	91 05       	cpc	r25, r1
     60e:	1c f4       	brge	.+6      	; 0x616 <DIO_u8SetPinValue+0x5a>
     610:	89 2b       	or	r24, r25
     612:	49 f0       	breq	.+18     	; 0x626 <DIO_u8SetPinValue+0x6a>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     614:	c0 c0       	rjmp	.+384    	; 0x796 <DIO_u8SetPinValue+0x1da>
	}else
	{
//		u8ErrorState = 0;
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     616:	82 30       	cpi	r24, 0x02	; 2
     618:	91 05       	cpc	r25, r1
     61a:	09 f4       	brne	.+2      	; 0x61e <DIO_u8SetPinValue+0x62>
     61c:	60 c0       	rjmp	.+192    	; 0x6de <DIO_u8SetPinValue+0x122>
     61e:	03 97       	sbiw	r24, 0x03	; 3
     620:	09 f4       	brne	.+2      	; 0x624 <DIO_u8SetPinValue+0x68>
     622:	8b c0       	rjmp	.+278    	; 0x73a <DIO_u8SetPinValue+0x17e>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		default:

			break;
     624:	b8 c0       	rjmp	.+368    	; 0x796 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     626:	8d 81       	ldd	r24, Y+5	; 0x05
     628:	81 30       	cpi	r24, 0x01	; 1
     62a:	a9 f4       	brne	.+42     	; 0x656 <DIO_u8SetPinValue+0x9a>
     62c:	8b e3       	ldi	r24, 0x3B	; 59
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	2b e3       	ldi	r18, 0x3B	; 59
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	f9 01       	movw	r30, r18
     636:	20 81       	ld	r18, Z
     638:	62 2f       	mov	r22, r18
     63a:	2b 81       	ldd	r18, Y+3	; 0x03
     63c:	42 2f       	mov	r20, r18
     63e:	50 e0       	ldi	r21, 0x00	; 0
     640:	21 e0       	ldi	r18, 0x01	; 1
     642:	30 e0       	ldi	r19, 0x00	; 0
     644:	02 c0       	rjmp	.+4      	; 0x64a <DIO_u8SetPinValue+0x8e>
     646:	22 0f       	add	r18, r18
     648:	33 1f       	adc	r19, r19
     64a:	4a 95       	dec	r20
     64c:	e2 f7       	brpl	.-8      	; 0x646 <DIO_u8SetPinValue+0x8a>
     64e:	26 2b       	or	r18, r22
     650:	fc 01       	movw	r30, r24
     652:	20 83       	st	Z, r18
			break;
     654:	a0 c0       	rjmp	.+320    	; 0x796 <DIO_u8SetPinValue+0x1da>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			Assign_Bit(DIO_u8_PORTA -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     656:	8b e3       	ldi	r24, 0x3B	; 59
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	2b e3       	ldi	r18, 0x3B	; 59
     65c:	30 e0       	ldi	r19, 0x00	; 0
     65e:	f9 01       	movw	r30, r18
     660:	20 81       	ld	r18, Z
     662:	62 2f       	mov	r22, r18
     664:	2b 81       	ldd	r18, Y+3	; 0x03
     666:	42 2f       	mov	r20, r18
     668:	50 e0       	ldi	r21, 0x00	; 0
     66a:	21 e0       	ldi	r18, 0x01	; 1
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	02 c0       	rjmp	.+4      	; 0x674 <DIO_u8SetPinValue+0xb8>
     670:	22 0f       	add	r18, r18
     672:	33 1f       	adc	r19, r19
     674:	4a 95       	dec	r20
     676:	e2 f7       	brpl	.-8      	; 0x670 <DIO_u8SetPinValue+0xb4>
     678:	20 95       	com	r18
     67a:	26 23       	and	r18, r22
     67c:	fc 01       	movw	r30, r24
     67e:	20 83       	st	Z, r18
			break;
     680:	8a c0       	rjmp	.+276    	; 0x796 <DIO_u8SetPinValue+0x1da>
		case GROUP_B :
			if(Copy_u8PinValue == DIO_u8_LOW)
     682:	8d 81       	ldd	r24, Y+5	; 0x05
     684:	88 23       	and	r24, r24
     686:	b1 f4       	brne	.+44     	; 0x6b4 <DIO_u8SetPinValue+0xf8>
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     688:	88 e3       	ldi	r24, 0x38	; 56
     68a:	90 e0       	ldi	r25, 0x00	; 0
     68c:	28 e3       	ldi	r18, 0x38	; 56
     68e:	30 e0       	ldi	r19, 0x00	; 0
     690:	f9 01       	movw	r30, r18
     692:	20 81       	ld	r18, Z
     694:	62 2f       	mov	r22, r18
     696:	2b 81       	ldd	r18, Y+3	; 0x03
     698:	42 2f       	mov	r20, r18
     69a:	50 e0       	ldi	r21, 0x00	; 0
     69c:	21 e0       	ldi	r18, 0x01	; 1
     69e:	30 e0       	ldi	r19, 0x00	; 0
     6a0:	02 c0       	rjmp	.+4      	; 0x6a6 <DIO_u8SetPinValue+0xea>
     6a2:	22 0f       	add	r18, r18
     6a4:	33 1f       	adc	r19, r19
     6a6:	4a 95       	dec	r20
     6a8:	e2 f7       	brpl	.-8      	; 0x6a2 <DIO_u8SetPinValue+0xe6>
     6aa:	20 95       	com	r18
     6ac:	26 23       	and	r18, r22
     6ae:	fc 01       	movw	r30, r24
     6b0:	20 83       	st	Z, r18
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
     6b2:	71 c0       	rjmp	.+226    	; 0x796 <DIO_u8SetPinValue+0x1da>
			if(Copy_u8PinValue == DIO_u8_LOW)
			{
				Clear_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}else
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
     6b4:	88 e3       	ldi	r24, 0x38	; 56
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	28 e3       	ldi	r18, 0x38	; 56
     6ba:	30 e0       	ldi	r19, 0x00	; 0
     6bc:	f9 01       	movw	r30, r18
     6be:	20 81       	ld	r18, Z
     6c0:	62 2f       	mov	r22, r18
     6c2:	2b 81       	ldd	r18, Y+3	; 0x03
     6c4:	42 2f       	mov	r20, r18
     6c6:	50 e0       	ldi	r21, 0x00	; 0
     6c8:	21 e0       	ldi	r18, 0x01	; 1
     6ca:	30 e0       	ldi	r19, 0x00	; 0
     6cc:	02 c0       	rjmp	.+4      	; 0x6d2 <DIO_u8SetPinValue+0x116>
     6ce:	22 0f       	add	r18, r18
     6d0:	33 1f       	adc	r19, r19
     6d2:	4a 95       	dec	r20
     6d4:	e2 f7       	brpl	.-8      	; 0x6ce <DIO_u8SetPinValue+0x112>
     6d6:	26 2b       	or	r18, r22
     6d8:	fc 01       	movw	r30, r24
     6da:	20 83       	st	Z, r18
			}
			break;
     6dc:	5c c0       	rjmp	.+184    	; 0x796 <DIO_u8SetPinValue+0x1da>
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     6de:	8d 81       	ldd	r24, Y+5	; 0x05
     6e0:	81 30       	cpi	r24, 0x01	; 1
     6e2:	a9 f4       	brne	.+42     	; 0x70e <DIO_u8SetPinValue+0x152>
     6e4:	85 e3       	ldi	r24, 0x35	; 53
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	25 e3       	ldi	r18, 0x35	; 53
     6ea:	30 e0       	ldi	r19, 0x00	; 0
     6ec:	f9 01       	movw	r30, r18
     6ee:	20 81       	ld	r18, Z
     6f0:	62 2f       	mov	r22, r18
     6f2:	2b 81       	ldd	r18, Y+3	; 0x03
     6f4:	42 2f       	mov	r20, r18
     6f6:	50 e0       	ldi	r21, 0x00	; 0
     6f8:	21 e0       	ldi	r18, 0x01	; 1
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	02 c0       	rjmp	.+4      	; 0x702 <DIO_u8SetPinValue+0x146>
     6fe:	22 0f       	add	r18, r18
     700:	33 1f       	adc	r19, r19
     702:	4a 95       	dec	r20
     704:	e2 f7       	brpl	.-8      	; 0x6fe <DIO_u8SetPinValue+0x142>
     706:	26 2b       	or	r18, r22
     708:	fc 01       	movw	r30, r24
     70a:	20 83       	st	Z, r18
			break;
     70c:	44 c0       	rjmp	.+136    	; 0x796 <DIO_u8SetPinValue+0x1da>
			{
				Set_Bit(DIO_u8_PORTB -> ByteAccess, u8PIN_ID);
			}
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     70e:	85 e3       	ldi	r24, 0x35	; 53
     710:	90 e0       	ldi	r25, 0x00	; 0
     712:	25 e3       	ldi	r18, 0x35	; 53
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	f9 01       	movw	r30, r18
     718:	20 81       	ld	r18, Z
     71a:	62 2f       	mov	r22, r18
     71c:	2b 81       	ldd	r18, Y+3	; 0x03
     71e:	42 2f       	mov	r20, r18
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	21 e0       	ldi	r18, 0x01	; 1
     724:	30 e0       	ldi	r19, 0x00	; 0
     726:	02 c0       	rjmp	.+4      	; 0x72c <DIO_u8SetPinValue+0x170>
     728:	22 0f       	add	r18, r18
     72a:	33 1f       	adc	r19, r19
     72c:	4a 95       	dec	r20
     72e:	e2 f7       	brpl	.-8      	; 0x728 <DIO_u8SetPinValue+0x16c>
     730:	20 95       	com	r18
     732:	26 23       	and	r18, r22
     734:	fc 01       	movw	r30, r24
     736:	20 83       	st	Z, r18
			break;
     738:	2e c0       	rjmp	.+92     	; 0x796 <DIO_u8SetPinValue+0x1da>
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     73a:	8d 81       	ldd	r24, Y+5	; 0x05
     73c:	81 30       	cpi	r24, 0x01	; 1
     73e:	a9 f4       	brne	.+42     	; 0x76a <DIO_u8SetPinValue+0x1ae>
     740:	82 e3       	ldi	r24, 0x32	; 50
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	22 e3       	ldi	r18, 0x32	; 50
     746:	30 e0       	ldi	r19, 0x00	; 0
     748:	f9 01       	movw	r30, r18
     74a:	20 81       	ld	r18, Z
     74c:	62 2f       	mov	r22, r18
     74e:	2b 81       	ldd	r18, Y+3	; 0x03
     750:	42 2f       	mov	r20, r18
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	21 e0       	ldi	r18, 0x01	; 1
     756:	30 e0       	ldi	r19, 0x00	; 0
     758:	02 c0       	rjmp	.+4      	; 0x75e <DIO_u8SetPinValue+0x1a2>
     75a:	22 0f       	add	r18, r18
     75c:	33 1f       	adc	r19, r19
     75e:	4a 95       	dec	r20
     760:	e2 f7       	brpl	.-8      	; 0x75a <DIO_u8SetPinValue+0x19e>
     762:	26 2b       	or	r18, r22
     764:	fc 01       	movw	r30, r24
     766:	20 83       	st	Z, r18
			break;
     768:	15 c0       	rjmp	.+42     	; 0x794 <DIO_u8SetPinValue+0x1d8>
			break;
		case GROUP_C :
			Assign_Bit(DIO_u8_PORTC -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
			break;
		case GROUP_D :
			Assign_Bit(DIO_u8_PORTD -> ByteAccess, u8PIN_ID, Copy_u8PinValue);
     76a:	82 e3       	ldi	r24, 0x32	; 50
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	22 e3       	ldi	r18, 0x32	; 50
     770:	30 e0       	ldi	r19, 0x00	; 0
     772:	f9 01       	movw	r30, r18
     774:	20 81       	ld	r18, Z
     776:	62 2f       	mov	r22, r18
     778:	2b 81       	ldd	r18, Y+3	; 0x03
     77a:	42 2f       	mov	r20, r18
     77c:	50 e0       	ldi	r21, 0x00	; 0
     77e:	21 e0       	ldi	r18, 0x01	; 1
     780:	30 e0       	ldi	r19, 0x00	; 0
     782:	02 c0       	rjmp	.+4      	; 0x788 <DIO_u8SetPinValue+0x1cc>
     784:	22 0f       	add	r18, r18
     786:	33 1f       	adc	r19, r19
     788:	4a 95       	dec	r20
     78a:	e2 f7       	brpl	.-8      	; 0x784 <DIO_u8SetPinValue+0x1c8>
     78c:	20 95       	com	r18
     78e:	26 23       	and	r18, r22
     790:	fc 01       	movw	r30, r24
     792:	20 83       	st	Z, r18
			break;
     794:	00 00       	nop
			break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     796:	89 81       	ldd	r24, Y+1	; 0x01
}
     798:	0f 90       	pop	r0
     79a:	0f 90       	pop	r0
     79c:	0f 90       	pop	r0
     79e:	0f 90       	pop	r0
     7a0:	0f 90       	pop	r0
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	08 95       	ret

000007a8 <DIO_u8SetPortDirection>:

/* Description: This function shall set certain        */
/*              direction to certain DIO_port          */
u8 DIO_u8SetPortDirection(u8 Copy_u8PortNB, u8 Copy_u8PortDirection)
{
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <DIO_u8SetPortDirection+0x6>
     7ae:	1f 92       	push	r1
     7b0:	cd b7       	in	r28, 0x3d	; 61
     7b2:	de b7       	in	r29, 0x3e	; 62
     7b4:	8a 83       	std	Y+2, r24	; 0x02
     7b6:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     7b8:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
		if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     7ba:	8a 81       	ldd	r24, Y+2	; 0x02
     7bc:	84 30       	cpi	r24, 0x04	; 4
     7be:	18 f0       	brcs	.+6      	; 0x7c6 <DIO_u8SetPortDirection+0x1e>
		{
			u8ErrorState = 1;
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	89 83       	std	Y+1, r24	; 0x01
     7c4:	2a c0       	rjmp	.+84     	; 0x81a <DIO_u8SetPortDirection+0x72>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     7c6:	8a 81       	ldd	r24, Y+2	; 0x02
     7c8:	88 2f       	mov	r24, r24
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	81 30       	cpi	r24, 0x01	; 1
     7ce:	91 05       	cpc	r25, r1
     7d0:	91 f0       	breq	.+36     	; 0x7f6 <DIO_u8SetPortDirection+0x4e>
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	91 05       	cpc	r25, r1
     7d6:	1c f4       	brge	.+6      	; 0x7de <DIO_u8SetPortDirection+0x36>
     7d8:	89 2b       	or	r24, r25
     7da:	39 f0       	breq	.+14     	; 0x7ea <DIO_u8SetPortDirection+0x42>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     7dc:	1e c0       	rjmp	.+60     	; 0x81a <DIO_u8SetPortDirection+0x72>
			u8ErrorState = 1;
		}else
		{
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
     7de:	82 30       	cpi	r24, 0x02	; 2
     7e0:	91 05       	cpc	r25, r1
     7e2:	79 f0       	breq	.+30     	; 0x802 <DIO_u8SetPortDirection+0x5a>
     7e4:	03 97       	sbiw	r24, 0x03	; 3
     7e6:	99 f0       	breq	.+38     	; 0x80e <DIO_u8SetPortDirection+0x66>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
				break;
			default:

				break;
     7e8:	18 c0       	rjmp	.+48     	; 0x81a <DIO_u8SetPortDirection+0x72>
	//		u8ErrorState = 0;

			switch(Copy_u8PortNB)
			{
			case GROUP_A :
				DIO_u8_DDRA->ByteAccess = Copy_u8PortDirection;
     7ea:	8a e3       	ldi	r24, 0x3A	; 58
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	2b 81       	ldd	r18, Y+3	; 0x03
     7f0:	fc 01       	movw	r30, r24
     7f2:	20 83       	st	Z, r18
				break;
     7f4:	12 c0       	rjmp	.+36     	; 0x81a <DIO_u8SetPortDirection+0x72>
			case GROUP_B :
				DIO_u8_DDRB->ByteAccess = Copy_u8PortDirection;
     7f6:	87 e3       	ldi	r24, 0x37	; 55
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	2b 81       	ldd	r18, Y+3	; 0x03
     7fc:	fc 01       	movw	r30, r24
     7fe:	20 83       	st	Z, r18
				break;
     800:	0c c0       	rjmp	.+24     	; 0x81a <DIO_u8SetPortDirection+0x72>
			case GROUP_C :
				DIO_u8_DDRC->ByteAccess = Copy_u8PortDirection;
     802:	84 e3       	ldi	r24, 0x34	; 52
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	2b 81       	ldd	r18, Y+3	; 0x03
     808:	fc 01       	movw	r30, r24
     80a:	20 83       	st	Z, r18
				break;
     80c:	06 c0       	rjmp	.+12     	; 0x81a <DIO_u8SetPortDirection+0x72>
			case GROUP_D :
				DIO_u8_DDRD->ByteAccess = Copy_u8PortDirection;
     80e:	81 e3       	ldi	r24, 0x31	; 49
     810:	90 e0       	ldi	r25, 0x00	; 0
     812:	2b 81       	ldd	r18, Y+3	; 0x03
     814:	fc 01       	movw	r30, r24
     816:	20 83       	st	Z, r18
				break;
     818:	00 00       	nop

				break;
			}
		}
	/*Function return*/
	return u8ErrorState;
     81a:	89 81       	ldd	r24, Y+1	; 0x01
}
     81c:	0f 90       	pop	r0
     81e:	0f 90       	pop	r0
     820:	0f 90       	pop	r0
     822:	df 91       	pop	r29
     824:	cf 91       	pop	r28
     826:	08 95       	ret

00000828 <DIO_u8SetPortValue>:

/* Description: This function shall set certain        */
/*              value to certain DIO_port              */
u8 DIO_u8SetPortValue(u8 Copy_u8PortNB, u8 Copy_u8PortValue)
{
     828:	cf 93       	push	r28
     82a:	df 93       	push	r29
     82c:	00 d0       	rcall	.+0      	; 0x82e <DIO_u8SetPortValue+0x6>
     82e:	1f 92       	push	r1
     830:	cd b7       	in	r28, 0x3d	; 61
     832:	de b7       	in	r29, 0x3e	; 62
     834:	8a 83       	std	Y+2, r24	; 0x02
     836:	6b 83       	std	Y+3, r22	; 0x03
		/*Local variables*/
		u8 u8ErrorState = 0;
     838:	19 82       	std	Y+1, r1	; 0x01

		/*validate inputs*/
			if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     83a:	8a 81       	ldd	r24, Y+2	; 0x02
     83c:	84 30       	cpi	r24, 0x04	; 4
     83e:	18 f0       	brcs	.+6      	; 0x846 <DIO_u8SetPortValue+0x1e>
			{
				u8ErrorState = 1;
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	89 83       	std	Y+1, r24	; 0x01
     844:	2a c0       	rjmp	.+84     	; 0x89a <__stack+0x3b>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     846:	8a 81       	ldd	r24, Y+2	; 0x02
     848:	88 2f       	mov	r24, r24
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	81 30       	cpi	r24, 0x01	; 1
     84e:	91 05       	cpc	r25, r1
     850:	91 f0       	breq	.+36     	; 0x876 <__stack+0x17>
     852:	82 30       	cpi	r24, 0x02	; 2
     854:	91 05       	cpc	r25, r1
     856:	1c f4       	brge	.+6      	; 0x85e <DIO_u8SetPortValue+0x36>
     858:	89 2b       	or	r24, r25
     85a:	39 f0       	breq	.+14     	; 0x86a <__stack+0xb>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     85c:	1e c0       	rjmp	.+60     	; 0x89a <__stack+0x3b>
				u8ErrorState = 1;
			}else
			{
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
     85e:	82 30       	cpi	r24, 0x02	; 2
     860:	91 05       	cpc	r25, r1
     862:	79 f0       	breq	.+30     	; 0x882 <__stack+0x23>
     864:	03 97       	sbiw	r24, 0x03	; 3
     866:	99 f0       	breq	.+38     	; 0x88e <__stack+0x2f>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
					break;
				default:

					break;
     868:	18 c0       	rjmp	.+48     	; 0x89a <__stack+0x3b>
		//		u8ErrorState = 0;

				switch(Copy_u8PortNB)
				{
				case GROUP_A :
					DIO_u8_PORTA->ByteAccess = Copy_u8PortValue;
     86a:	8b e3       	ldi	r24, 0x3B	; 59
     86c:	90 e0       	ldi	r25, 0x00	; 0
     86e:	2b 81       	ldd	r18, Y+3	; 0x03
     870:	fc 01       	movw	r30, r24
     872:	20 83       	st	Z, r18
					break;
     874:	12 c0       	rjmp	.+36     	; 0x89a <__stack+0x3b>
				case GROUP_B :
					DIO_u8_PORTB->ByteAccess = Copy_u8PortValue;
     876:	88 e3       	ldi	r24, 0x38	; 56
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	2b 81       	ldd	r18, Y+3	; 0x03
     87c:	fc 01       	movw	r30, r24
     87e:	20 83       	st	Z, r18
					break;
     880:	0c c0       	rjmp	.+24     	; 0x89a <__stack+0x3b>
				case GROUP_C :
					DIO_u8_PORTC->ByteAccess = Copy_u8PortValue;
     882:	85 e3       	ldi	r24, 0x35	; 53
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	2b 81       	ldd	r18, Y+3	; 0x03
     888:	fc 01       	movw	r30, r24
     88a:	20 83       	st	Z, r18
					break;
     88c:	06 c0       	rjmp	.+12     	; 0x89a <__stack+0x3b>
				case GROUP_D :
					DIO_u8_PORTD->ByteAccess = Copy_u8PortValue;
     88e:	82 e3       	ldi	r24, 0x32	; 50
     890:	90 e0       	ldi	r25, 0x00	; 0
     892:	2b 81       	ldd	r18, Y+3	; 0x03
     894:	fc 01       	movw	r30, r24
     896:	20 83       	st	Z, r18
					break;
     898:	00 00       	nop

					break;
				}
			}
		/*Function return*/
		return u8ErrorState;
     89a:	89 81       	ldd	r24, Y+1	; 0x01
}
     89c:	0f 90       	pop	r0
     89e:	0f 90       	pop	r0
     8a0:	0f 90       	pop	r0
     8a2:	df 91       	pop	r29
     8a4:	cf 91       	pop	r28
     8a6:	08 95       	ret

000008a8 <DIO_u8GetPinValue>:

/* */
/* */
u8 DIO_u8GetPinValue(u8 Copy_u8PinNB, u8 *Copy_u8PinValue)
{
     8a8:	cf 93       	push	r28
     8aa:	df 93       	push	r29
     8ac:	00 d0       	rcall	.+0      	; 0x8ae <DIO_u8GetPinValue+0x6>
     8ae:	00 d0       	rcall	.+0      	; 0x8b0 <DIO_u8GetPinValue+0x8>
     8b0:	00 d0       	rcall	.+0      	; 0x8b2 <DIO_u8GetPinValue+0xa>
     8b2:	cd b7       	in	r28, 0x3d	; 61
     8b4:	de b7       	in	r29, 0x3e	; 62
     8b6:	8c 83       	std	Y+4, r24	; 0x04
     8b8:	7e 83       	std	Y+6, r23	; 0x06
     8ba:	6d 83       	std	Y+5, r22	; 0x05
	/*Local variables*/
	u8 u8ErrorState = 0;
     8bc:	19 82       	std	Y+1, r1	; 0x01
	u8 u8PORT_ID;
	u8 u8PIN_ID;

	/*validate inputs*/
	if (Copy_u8PinNB >= DIO_u8_MAXPINNB)
     8be:	8c 81       	ldd	r24, Y+4	; 0x04
     8c0:	80 32       	cpi	r24, 0x20	; 32
     8c2:	18 f0       	brcs	.+6      	; 0x8ca <DIO_u8GetPinValue+0x22>
	{
		u8ErrorState = 1;
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	89 83       	std	Y+1, r24	; 0x01
     8c8:	6f c0       	rjmp	.+222    	; 0x9a8 <DIO_u8GetPinValue+0x100>
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
     8ca:	8c 81       	ldd	r24, Y+4	; 0x04
     8cc:	86 95       	lsr	r24
     8ce:	86 95       	lsr	r24
     8d0:	86 95       	lsr	r24
     8d2:	8a 83       	std	Y+2, r24	; 0x02
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
     8d4:	8c 81       	ldd	r24, Y+4	; 0x04
     8d6:	87 70       	andi	r24, 0x07	; 7
     8d8:	8b 83       	std	Y+3, r24	; 0x03
		switch(u8PORT_ID)
     8da:	8a 81       	ldd	r24, Y+2	; 0x02
     8dc:	88 2f       	mov	r24, r24
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	81 30       	cpi	r24, 0x01	; 1
     8e2:	91 05       	cpc	r25, r1
     8e4:	11 f1       	breq	.+68     	; 0x92a <DIO_u8GetPinValue+0x82>
     8e6:	82 30       	cpi	r24, 0x02	; 2
     8e8:	91 05       	cpc	r25, r1
     8ea:	1c f4       	brge	.+6      	; 0x8f2 <DIO_u8GetPinValue+0x4a>
     8ec:	89 2b       	or	r24, r25
     8ee:	41 f0       	breq	.+16     	; 0x900 <DIO_u8GetPinValue+0x58>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     8f0:	5b c0       	rjmp	.+182    	; 0x9a8 <DIO_u8GetPinValue+0x100>
		u8ErrorState = 1;
	}else
	{
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	91 05       	cpc	r25, r1
     8f6:	71 f1       	breq	.+92     	; 0x954 <DIO_u8GetPinValue+0xac>
     8f8:	03 97       	sbiw	r24, 0x03	; 3
     8fa:	09 f4       	brne	.+2      	; 0x8fe <DIO_u8GetPinValue+0x56>
     8fc:	40 c0       	rjmp	.+128    	; 0x97e <DIO_u8GetPinValue+0xd6>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
			break;
		default:

			break;
     8fe:	54 c0       	rjmp	.+168    	; 0x9a8 <DIO_u8GetPinValue+0x100>
		u8PORT_ID = Copy_u8PinNB/DIO_u8_PINS_PER_PORT;
		u8PIN_ID = Copy_u8PinNB%DIO_u8_PINS_PER_PORT;
		switch(u8PORT_ID)
		{
		case GROUP_A :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINA -> ByteAccess, u8PIN_ID);
     900:	89 e3       	ldi	r24, 0x39	; 57
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	fc 01       	movw	r30, r24
     906:	80 81       	ld	r24, Z
     908:	88 2f       	mov	r24, r24
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	2b 81       	ldd	r18, Y+3	; 0x03
     90e:	22 2f       	mov	r18, r18
     910:	30 e0       	ldi	r19, 0x00	; 0
     912:	02 c0       	rjmp	.+4      	; 0x918 <DIO_u8GetPinValue+0x70>
     914:	95 95       	asr	r25
     916:	87 95       	ror	r24
     918:	2a 95       	dec	r18
     91a:	e2 f7       	brpl	.-8      	; 0x914 <DIO_u8GetPinValue+0x6c>
     91c:	28 2f       	mov	r18, r24
     91e:	21 70       	andi	r18, 0x01	; 1
     920:	8d 81       	ldd	r24, Y+5	; 0x05
     922:	9e 81       	ldd	r25, Y+6	; 0x06
     924:	fc 01       	movw	r30, r24
     926:	20 83       	st	Z, r18
			break;
     928:	3f c0       	rjmp	.+126    	; 0x9a8 <DIO_u8GetPinValue+0x100>
		case GROUP_B :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINB -> ByteAccess, u8PIN_ID);
     92a:	86 e3       	ldi	r24, 0x36	; 54
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	fc 01       	movw	r30, r24
     930:	80 81       	ld	r24, Z
     932:	88 2f       	mov	r24, r24
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	2b 81       	ldd	r18, Y+3	; 0x03
     938:	22 2f       	mov	r18, r18
     93a:	30 e0       	ldi	r19, 0x00	; 0
     93c:	02 c0       	rjmp	.+4      	; 0x942 <DIO_u8GetPinValue+0x9a>
     93e:	95 95       	asr	r25
     940:	87 95       	ror	r24
     942:	2a 95       	dec	r18
     944:	e2 f7       	brpl	.-8      	; 0x93e <DIO_u8GetPinValue+0x96>
     946:	28 2f       	mov	r18, r24
     948:	21 70       	andi	r18, 0x01	; 1
     94a:	8d 81       	ldd	r24, Y+5	; 0x05
     94c:	9e 81       	ldd	r25, Y+6	; 0x06
     94e:	fc 01       	movw	r30, r24
     950:	20 83       	st	Z, r18
			break;
     952:	2a c0       	rjmp	.+84     	; 0x9a8 <DIO_u8GetPinValue+0x100>
		case GROUP_C :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PINC -> ByteAccess, u8PIN_ID);
     954:	83 e3       	ldi	r24, 0x33	; 51
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	fc 01       	movw	r30, r24
     95a:	80 81       	ld	r24, Z
     95c:	88 2f       	mov	r24, r24
     95e:	90 e0       	ldi	r25, 0x00	; 0
     960:	2b 81       	ldd	r18, Y+3	; 0x03
     962:	22 2f       	mov	r18, r18
     964:	30 e0       	ldi	r19, 0x00	; 0
     966:	02 c0       	rjmp	.+4      	; 0x96c <DIO_u8GetPinValue+0xc4>
     968:	95 95       	asr	r25
     96a:	87 95       	ror	r24
     96c:	2a 95       	dec	r18
     96e:	e2 f7       	brpl	.-8      	; 0x968 <DIO_u8GetPinValue+0xc0>
     970:	28 2f       	mov	r18, r24
     972:	21 70       	andi	r18, 0x01	; 1
     974:	8d 81       	ldd	r24, Y+5	; 0x05
     976:	9e 81       	ldd	r25, Y+6	; 0x06
     978:	fc 01       	movw	r30, r24
     97a:	20 83       	st	Z, r18
			break;
     97c:	15 c0       	rjmp	.+42     	; 0x9a8 <DIO_u8GetPinValue+0x100>
		case GROUP_D :
			*Copy_u8PinValue = Get_Bit(DIO_u8_PIND -> ByteAccess, u8PIN_ID);
     97e:	80 e3       	ldi	r24, 0x30	; 48
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	fc 01       	movw	r30, r24
     984:	80 81       	ld	r24, Z
     986:	88 2f       	mov	r24, r24
     988:	90 e0       	ldi	r25, 0x00	; 0
     98a:	2b 81       	ldd	r18, Y+3	; 0x03
     98c:	22 2f       	mov	r18, r18
     98e:	30 e0       	ldi	r19, 0x00	; 0
     990:	02 c0       	rjmp	.+4      	; 0x996 <DIO_u8GetPinValue+0xee>
     992:	95 95       	asr	r25
     994:	87 95       	ror	r24
     996:	2a 95       	dec	r18
     998:	e2 f7       	brpl	.-8      	; 0x992 <DIO_u8GetPinValue+0xea>
     99a:	28 2f       	mov	r18, r24
     99c:	21 70       	andi	r18, 0x01	; 1
     99e:	8d 81       	ldd	r24, Y+5	; 0x05
     9a0:	9e 81       	ldd	r25, Y+6	; 0x06
     9a2:	fc 01       	movw	r30, r24
     9a4:	20 83       	st	Z, r18
			break;
     9a6:	00 00       	nop

			break;
		}
	}
	/*Function return*/
	return u8ErrorState;
     9a8:	89 81       	ldd	r24, Y+1	; 0x01
}
     9aa:	26 96       	adiw	r28, 0x06	; 6
     9ac:	0f b6       	in	r0, 0x3f	; 63
     9ae:	f8 94       	cli
     9b0:	de bf       	out	0x3e, r29	; 62
     9b2:	0f be       	out	0x3f, r0	; 63
     9b4:	cd bf       	out	0x3d, r28	; 61
     9b6:	df 91       	pop	r29
     9b8:	cf 91       	pop	r28
     9ba:	08 95       	ret

000009bc <DIO_u8GetPortValue>:

/* */
/* */
u8 DIO_u8GetPortValue(u8 Copy_u8PortNB, u8 *Copy_u8PortValue)
{
     9bc:	cf 93       	push	r28
     9be:	df 93       	push	r29
     9c0:	00 d0       	rcall	.+0      	; 0x9c2 <DIO_u8GetPortValue+0x6>
     9c2:	00 d0       	rcall	.+0      	; 0x9c4 <DIO_u8GetPortValue+0x8>
     9c4:	cd b7       	in	r28, 0x3d	; 61
     9c6:	de b7       	in	r29, 0x3e	; 62
     9c8:	8a 83       	std	Y+2, r24	; 0x02
     9ca:	7c 83       	std	Y+4, r23	; 0x04
     9cc:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variables*/
	u8 u8ErrorState = 0;
     9ce:	19 82       	std	Y+1, r1	; 0x01

	/*validate inputs*/
	if (Copy_u8PortNB >= DIO_u8_MAXPORTNB)
     9d0:	8a 81       	ldd	r24, Y+2	; 0x02
     9d2:	84 30       	cpi	r24, 0x04	; 4
     9d4:	18 f0       	brcs	.+6      	; 0x9dc <DIO_u8GetPortValue+0x20>
	{
		u8ErrorState = 1;
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	89 83       	std	Y+1, r24	; 0x01
     9da:	36 c0       	rjmp	.+108    	; 0xa48 <DIO_u8GetPortValue+0x8c>
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     9dc:	8a 81       	ldd	r24, Y+2	; 0x02
     9de:	88 2f       	mov	r24, r24
     9e0:	90 e0       	ldi	r25, 0x00	; 0
     9e2:	81 30       	cpi	r24, 0x01	; 1
     9e4:	91 05       	cpc	r25, r1
     9e6:	a9 f0       	breq	.+42     	; 0xa12 <DIO_u8GetPortValue+0x56>
     9e8:	82 30       	cpi	r24, 0x02	; 2
     9ea:	91 05       	cpc	r25, r1
     9ec:	1c f4       	brge	.+6      	; 0x9f4 <DIO_u8GetPortValue+0x38>
     9ee:	89 2b       	or	r24, r25
     9f0:	39 f0       	breq	.+14     	; 0xa00 <DIO_u8GetPortValue+0x44>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     9f2:	2a c0       	rjmp	.+84     	; 0xa48 <DIO_u8GetPortValue+0x8c>
		u8ErrorState = 1;
	}else
	{
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
     9f4:	82 30       	cpi	r24, 0x02	; 2
     9f6:	91 05       	cpc	r25, r1
     9f8:	a9 f0       	breq	.+42     	; 0xa24 <DIO_u8GetPortValue+0x68>
     9fa:	03 97       	sbiw	r24, 0x03	; 3
     9fc:	e1 f0       	breq	.+56     	; 0xa36 <DIO_u8GetPortValue+0x7a>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
				break;
			default:

				break;
     9fe:	24 c0       	rjmp	.+72     	; 0xa48 <DIO_u8GetPortValue+0x8c>
	//		u8ErrorState = 0;

		switch(Copy_u8PortNB)
		{
			case GROUP_A :
				*Copy_u8PortValue = DIO_u8_PINA->ByteAccess;
     a00:	89 e3       	ldi	r24, 0x39	; 57
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	fc 01       	movw	r30, r24
     a06:	20 81       	ld	r18, Z
     a08:	8b 81       	ldd	r24, Y+3	; 0x03
     a0a:	9c 81       	ldd	r25, Y+4	; 0x04
     a0c:	fc 01       	movw	r30, r24
     a0e:	20 83       	st	Z, r18
				break;
     a10:	1b c0       	rjmp	.+54     	; 0xa48 <DIO_u8GetPortValue+0x8c>
			case GROUP_B :
				*Copy_u8PortValue = DIO_u8_PINB->ByteAccess;
     a12:	86 e3       	ldi	r24, 0x36	; 54
     a14:	90 e0       	ldi	r25, 0x00	; 0
     a16:	fc 01       	movw	r30, r24
     a18:	20 81       	ld	r18, Z
     a1a:	8b 81       	ldd	r24, Y+3	; 0x03
     a1c:	9c 81       	ldd	r25, Y+4	; 0x04
     a1e:	fc 01       	movw	r30, r24
     a20:	20 83       	st	Z, r18
				break;
     a22:	12 c0       	rjmp	.+36     	; 0xa48 <DIO_u8GetPortValue+0x8c>
			case GROUP_C :
				*Copy_u8PortValue = DIO_u8_PINC->ByteAccess;
     a24:	83 e3       	ldi	r24, 0x33	; 51
     a26:	90 e0       	ldi	r25, 0x00	; 0
     a28:	fc 01       	movw	r30, r24
     a2a:	20 81       	ld	r18, Z
     a2c:	8b 81       	ldd	r24, Y+3	; 0x03
     a2e:	9c 81       	ldd	r25, Y+4	; 0x04
     a30:	fc 01       	movw	r30, r24
     a32:	20 83       	st	Z, r18
				break;
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <DIO_u8GetPortValue+0x8c>
			case GROUP_D :
				*Copy_u8PortValue = DIO_u8_PIND->ByteAccess;
     a36:	80 e3       	ldi	r24, 0x30	; 48
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	fc 01       	movw	r30, r24
     a3c:	20 81       	ld	r18, Z
     a3e:	8b 81       	ldd	r24, Y+3	; 0x03
     a40:	9c 81       	ldd	r25, Y+4	; 0x04
     a42:	fc 01       	movw	r30, r24
     a44:	20 83       	st	Z, r18
				break;
     a46:	00 00       	nop
				break;
		}
	}

	/*Function return*/
	return u8ErrorState;
     a48:	89 81       	ldd	r24, Y+1	; 0x01
}
     a4a:	0f 90       	pop	r0
     a4c:	0f 90       	pop	r0
     a4e:	0f 90       	pop	r0
     a50:	0f 90       	pop	r0
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <KBD_u8GetKeyPadState>:
#include "KBD_interface.h"
#include "KBD_private.h"


u8 KBD_u8GetKeyPadState(u8* Copy_Au8KeysState/*[KBD_u8_KEYS_NB]*/)
{
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
     a5c:	cd b7       	in	r28, 0x3d	; 61
     a5e:	de b7       	in	r29, 0x3e	; 62
     a60:	27 97       	sbiw	r28, 0x07	; 7
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	f8 94       	cli
     a66:	de bf       	out	0x3e, r29	; 62
     a68:	0f be       	out	0x3f, r0	; 63
     a6a:	cd bf       	out	0x3d, r28	; 61
     a6c:	9f 83       	std	Y+7, r25	; 0x07
     a6e:	8e 83       	std	Y+6, r24	; 0x06
	u8 LOCAL_u8ColIndex = 0;
     a70:	19 82       	std	Y+1, r1	; 0x01
	u8 LOCAL_u8RowIndex = 0;
     a72:	1a 82       	std	Y+2, r1	; 0x02
	
	u8 Local_u8CurrentPinValue=0;
     a74:	1d 82       	std	Y+5, r1	; 0x05
	u8 Local_u8KeyIndex=0;
     a76:	1c 82       	std	Y+4, r1	; 0x04
	u8 pressed = 0xff;
     a78:	8f ef       	ldi	r24, 0xFF	; 255
     a7a:	8b 83       	std	Y+3, r24	; 0x03
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     a7c:	19 82       	std	Y+1, r1	; 0x01
     a7e:	52 c0       	rjmp	.+164    	; 0xb24 <KBD_u8GetKeyPadState+0xcc>
		{
			//activate current col
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
     a80:	89 81       	ldd	r24, Y+1	; 0x01
     a82:	88 2f       	mov	r24, r24
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	82 5f       	subi	r24, 0xF2	; 242
     a88:	98 4f       	sbci	r25, 0xF8	; 248
     a8a:	fc 01       	movw	r30, r24
     a8c:	80 81       	ld	r24, Z
     a8e:	60 e0       	ldi	r22, 0x00	; 0
     a90:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     a94:	1a 82       	std	Y+2, r1	; 0x02
     a96:	36 c0       	rjmp	.+108    	; 0xb04 <KBD_u8GetKeyPadState+0xac>
			{
				DIO_u8GetPinValue(KBD_Au8RowsPins[LOCAL_u8RowIndex], &Local_u8CurrentPinValue);
     a98:	8a 81       	ldd	r24, Y+2	; 0x02
     a9a:	88 2f       	mov	r24, r24
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	8e 5e       	subi	r24, 0xEE	; 238
     aa0:	98 4f       	sbci	r25, 0xF8	; 248
     aa2:	fc 01       	movw	r30, r24
     aa4:	20 81       	ld	r18, Z
     aa6:	ce 01       	movw	r24, r28
     aa8:	05 96       	adiw	r24, 0x05	; 5
     aaa:	bc 01       	movw	r22, r24
     aac:	82 2f       	mov	r24, r18
     aae:	0e 94 54 04 	call	0x8a8	; 0x8a8 <DIO_u8GetPinValue>
				
				Local_u8KeyIndex = LOCAL_u8ColIndex + (LOCAL_u8RowIndex*KBD_u8_COL);
     ab2:	8a 81       	ldd	r24, Y+2	; 0x02
     ab4:	98 2f       	mov	r25, r24
     ab6:	99 0f       	add	r25, r25
     ab8:	99 0f       	add	r25, r25
     aba:	89 81       	ldd	r24, Y+1	; 0x01
     abc:	89 0f       	add	r24, r25
     abe:	8c 83       	std	Y+4, r24	; 0x04
				
				if(Local_u8CurrentPinValue == DIO_u8_HIGH)
     ac0:	8d 81       	ldd	r24, Y+5	; 0x05
     ac2:	81 30       	cpi	r24, 0x01	; 1
     ac4:	51 f4       	brne	.+20     	; 0xada <KBD_u8GetKeyPadState+0x82>
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Not Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
     ac6:	8c 81       	ldd	r24, Y+4	; 0x04
     ac8:	88 2f       	mov	r24, r24
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	2e 81       	ldd	r18, Y+6	; 0x06
     ace:	3f 81       	ldd	r19, Y+7	; 0x07
     ad0:	82 0f       	add	r24, r18
     ad2:	93 1f       	adc	r25, r19
     ad4:	fc 01       	movw	r30, r24
     ad6:	10 82       	st	Z, r1
     ad8:	12 c0       	rjmp	.+36     	; 0xafe <KBD_u8GetKeyPadState+0xa6>
					#endif
				}else
				{
					#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
					//Pressed
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_PRESSED;
     ada:	8c 81       	ldd	r24, Y+4	; 0x04
     adc:	88 2f       	mov	r24, r24
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	2e 81       	ldd	r18, Y+6	; 0x06
     ae2:	3f 81       	ldd	r19, Y+7	; 0x07
     ae4:	82 0f       	add	r24, r18
     ae6:	93 1f       	adc	r25, r19
     ae8:	21 e0       	ldi	r18, 0x01	; 1
     aea:	fc 01       	movw	r30, r24
     aec:	20 83       	st	Z, r18
						pressed = key_map[Local_u8KeyIndex];
     aee:	8c 81       	ldd	r24, Y+4	; 0x04
     af0:	88 2f       	mov	r24, r24
     af2:	90 e0       	ldi	r25, 0x00	; 0
     af4:	80 5a       	subi	r24, 0xA0	; 160
     af6:	9f 4f       	sbci	r25, 0xFF	; 255
     af8:	fc 01       	movw	r30, r24
     afa:	80 81       	ld	r24, Z
     afc:	8b 83       	std	Y+3, r24	; 0x03
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#endif
			
			//Check on active ROW
			
			for(LOCAL_u8RowIndex = 0; LOCAL_u8RowIndex < KBD_u8_ROWS; LOCAL_u8RowIndex ++)
     afe:	8a 81       	ldd	r24, Y+2	; 0x02
     b00:	8f 5f       	subi	r24, 0xFF	; 255
     b02:	8a 83       	std	Y+2, r24	; 0x02
     b04:	8a 81       	ldd	r24, Y+2	; 0x02
     b06:	84 30       	cpi	r24, 0x04	; 4
     b08:	38 f2       	brcs	.-114    	; 0xa98 <KBD_u8GetKeyPadState+0x40>
						Copy_Au8KeysState[Local_u8KeyIndex]= KBD_u8_NOT_PRESSED;
					#endif
				}
			}
			#if KBD_u8_CONNECTION_TYPE==KBD_u8_CON_PULLUP
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
     b0a:	89 81       	ldd	r24, Y+1	; 0x01
     b0c:	88 2f       	mov	r24, r24
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	82 5f       	subi	r24, 0xF2	; 242
     b12:	98 4f       	sbci	r25, 0xF8	; 248
     b14:	fc 01       	movw	r30, r24
     b16:	80 81       	ld	r24, Z
     b18:	61 e0       	ldi	r22, 0x01	; 1
     b1a:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	u8 Local_u8CurrentPinValue=0;
	u8 Local_u8KeyIndex=0;
	u8 pressed = 0xff;
	// check on Activation type
	#if KBD_u8_ACTIVATION_TYPE==KBD_u8_ACTIVE_COL
		for(LOCAL_u8ColIndex = 0; LOCAL_u8ColIndex < KBD_u8_COL; LOCAL_u8ColIndex ++ )
     b1e:	89 81       	ldd	r24, Y+1	; 0x01
     b20:	8f 5f       	subi	r24, 0xFF	; 255
     b22:	89 83       	std	Y+1, r24	; 0x01
     b24:	89 81       	ldd	r24, Y+1	; 0x01
     b26:	84 30       	cpi	r24, 0x04	; 4
     b28:	08 f4       	brcc	.+2      	; 0xb2c <KBD_u8GetKeyPadState+0xd4>
     b2a:	aa cf       	rjmp	.-172    	; 0xa80 <KBD_u8GetKeyPadState+0x28>
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_HIGH);
			#else
				DIO_u8SetPinValue(KBD_Au8ColsPins[LOCAL_u8ColIndex], DIO_u8_LOW);
			#endif
		}
		return pressed;
     b2c:	8b 81       	ldd	r24, Y+3	; 0x03
			#endif
		}

	#endif

}
     b2e:	27 96       	adiw	r28, 0x07	; 7
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	f8 94       	cli
     b34:	de bf       	out	0x3e, r29	; 62
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	cd bf       	out	0x3d, r28	; 61
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret

00000b40 <KBD_u8Initialize>:
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
     b40:	cf 93       	push	r28
     b42:	df 93       	push	r29
     b44:	cd b7       	in	r28, 0x3d	; 61
     b46:	de b7       	in	r29, 0x3e	; 62
     b48:	29 97       	sbiw	r28, 0x09	; 9
     b4a:	0f b6       	in	r0, 0x3f	; 63
     b4c:	f8 94       	cli
     b4e:	de bf       	out	0x3e, r29	; 62
     b50:	0f be       	out	0x3f, r0	; 63
     b52:	cd bf       	out	0x3d, r28	; 61
     b54:	89 87       	std	Y+9, r24	; 0x09
		switch (group_nb)
     b56:	89 85       	ldd	r24, Y+9	; 0x09
     b58:	88 2f       	mov	r24, r24
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	81 30       	cpi	r24, 0x01	; 1
     b5e:	91 05       	cpc	r25, r1
     b60:	09 f4       	brne	.+2      	; 0xb64 <KBD_u8Initialize+0x24>
     b62:	42 c0       	rjmp	.+132    	; 0xbe8 <KBD_u8Initialize+0xa8>
     b64:	82 30       	cpi	r24, 0x02	; 2
     b66:	91 05       	cpc	r25, r1
     b68:	1c f4       	brge	.+6      	; 0xb70 <KBD_u8Initialize+0x30>
     b6a:	89 2b       	or	r24, r25
     b6c:	49 f0       	breq	.+18     	; 0xb80 <KBD_u8Initialize+0x40>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     b6e:	d8 c0       	rjmp	.+432    	; 0xd20 <KBD_u8Initialize+0x1e0>
	#endif

}
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
     b70:	82 30       	cpi	r24, 0x02	; 2
     b72:	91 05       	cpc	r25, r1
     b74:	09 f4       	brne	.+2      	; 0xb78 <KBD_u8Initialize+0x38>
     b76:	6c c0       	rjmp	.+216    	; 0xc50 <KBD_u8Initialize+0x110>
     b78:	03 97       	sbiw	r24, 0x03	; 3
     b7a:	09 f4       	brne	.+2      	; 0xb7e <KBD_u8Initialize+0x3e>
     b7c:	9d c0       	rjmp	.+314    	; 0xcb8 <KBD_u8Initialize+0x178>
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
		}
	}
     b7e:	d0 c0       	rjmp	.+416    	; 0xd20 <KBD_u8Initialize+0x1e0>
void KBD_u8Initialize(u8 group_nb) //initialize keypad active col pull up with Row 4 to be the the 8th pin in the port and col 4 to the 1st pin
	{
		switch (group_nb)
		{
		case 0:
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
     b80:	6f e0       	ldi	r22, 0x0F	; 15
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(A4,1);
     b88:	61 e0       	ldi	r22, 0x01	; 1
     b8a:	84 e0       	ldi	r24, 0x04	; 4
     b8c:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A5,1);
     b90:	61 e0       	ldi	r22, 0x01	; 1
     b92:	85 e0       	ldi	r24, 0x05	; 5
     b94:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A6,1);
     b98:	61 e0       	ldi	r22, 0x01	; 1
     b9a:	86 e0       	ldi	r24, 0x06	; 6
     b9c:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(A7,1);
     ba0:	61 e0       	ldi	r22, 0x01	; 1
     ba2:	87 e0       	ldi	r24, 0x07	; 7
     ba4:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     ba8:	1a 82       	std	Y+2, r1	; 0x02
     baa:	19 82       	std	Y+1, r1	; 0x01
     bac:	18 c0       	rjmp	.+48     	; 0xbde <KBD_u8Initialize+0x9e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
     bae:	89 81       	ldd	r24, Y+1	; 0x01
     bb0:	24 e0       	ldi	r18, 0x04	; 4
     bb2:	28 0f       	add	r18, r24
     bb4:	89 81       	ldd	r24, Y+1	; 0x01
     bb6:	9a 81       	ldd	r25, Y+2	; 0x02
     bb8:	8e 5e       	subi	r24, 0xEE	; 238
     bba:	98 4f       	sbci	r25, 0xF8	; 248
     bbc:	fc 01       	movw	r30, r24
     bbe:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = A3 - i;
     bc0:	89 81       	ldd	r24, Y+1	; 0x01
     bc2:	93 e0       	ldi	r25, 0x03	; 3
     bc4:	29 2f       	mov	r18, r25
     bc6:	28 1b       	sub	r18, r24
     bc8:	89 81       	ldd	r24, Y+1	; 0x01
     bca:	9a 81       	ldd	r25, Y+2	; 0x02
     bcc:	82 5f       	subi	r24, 0xF2	; 242
     bce:	98 4f       	sbci	r25, 0xF8	; 248
     bd0:	fc 01       	movw	r30, r24
     bd2:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_A,0b00001111);
			DIO_u8SetPinValue(A4,1);
			DIO_u8SetPinValue(A5,1);
			DIO_u8SetPinValue(A6,1);
			DIO_u8SetPinValue(A7,1);
			for (int i=0;i<4;i++)
     bd4:	89 81       	ldd	r24, Y+1	; 0x01
     bd6:	9a 81       	ldd	r25, Y+2	; 0x02
     bd8:	01 96       	adiw	r24, 0x01	; 1
     bda:	9a 83       	std	Y+2, r25	; 0x02
     bdc:	89 83       	std	Y+1, r24	; 0x01
     bde:	89 81       	ldd	r24, Y+1	; 0x01
     be0:	9a 81       	ldd	r25, Y+2	; 0x02
     be2:	04 97       	sbiw	r24, 0x04	; 4
     be4:	24 f3       	brlt	.-56     	; 0xbae <KBD_u8Initialize+0x6e>
			{
				KBD_Au8RowsPins[i] = A4 + i;
				KBD_Au8ColsPins[i] = A3 - i;
			}
			break;
     be6:	9c c0       	rjmp	.+312    	; 0xd20 <KBD_u8Initialize+0x1e0>
		case 1:
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
     be8:	6f e0       	ldi	r22, 0x0F	; 15
     bea:	81 e0       	ldi	r24, 0x01	; 1
     bec:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(B4,1);
     bf0:	61 e0       	ldi	r22, 0x01	; 1
     bf2:	8c e0       	ldi	r24, 0x0C	; 12
     bf4:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B5,1);
     bf8:	61 e0       	ldi	r22, 0x01	; 1
     bfa:	8d e0       	ldi	r24, 0x0D	; 13
     bfc:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B6,1);
     c00:	61 e0       	ldi	r22, 0x01	; 1
     c02:	8e e0       	ldi	r24, 0x0E	; 14
     c04:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(B7,1);
     c08:	61 e0       	ldi	r22, 0x01	; 1
     c0a:	8f e0       	ldi	r24, 0x0F	; 15
     c0c:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c10:	1c 82       	std	Y+4, r1	; 0x04
     c12:	1b 82       	std	Y+3, r1	; 0x03
     c14:	18 c0       	rjmp	.+48     	; 0xc46 <KBD_u8Initialize+0x106>
			{
				KBD_Au8RowsPins[i] = B4 + i;
     c16:	8b 81       	ldd	r24, Y+3	; 0x03
     c18:	2c e0       	ldi	r18, 0x0C	; 12
     c1a:	28 0f       	add	r18, r24
     c1c:	8b 81       	ldd	r24, Y+3	; 0x03
     c1e:	9c 81       	ldd	r25, Y+4	; 0x04
     c20:	8e 5e       	subi	r24, 0xEE	; 238
     c22:	98 4f       	sbci	r25, 0xF8	; 248
     c24:	fc 01       	movw	r30, r24
     c26:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = B3 - i;
     c28:	8b 81       	ldd	r24, Y+3	; 0x03
     c2a:	9b e0       	ldi	r25, 0x0B	; 11
     c2c:	29 2f       	mov	r18, r25
     c2e:	28 1b       	sub	r18, r24
     c30:	8b 81       	ldd	r24, Y+3	; 0x03
     c32:	9c 81       	ldd	r25, Y+4	; 0x04
     c34:	82 5f       	subi	r24, 0xF2	; 242
     c36:	98 4f       	sbci	r25, 0xF8	; 248
     c38:	fc 01       	movw	r30, r24
     c3a:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_B,0b00001111);
			DIO_u8SetPinValue(B4,1);
			DIO_u8SetPinValue(B5,1);
			DIO_u8SetPinValue(B6,1);
			DIO_u8SetPinValue(B7,1);
			for (int i=0;i<4;i++)
     c3c:	8b 81       	ldd	r24, Y+3	; 0x03
     c3e:	9c 81       	ldd	r25, Y+4	; 0x04
     c40:	01 96       	adiw	r24, 0x01	; 1
     c42:	9c 83       	std	Y+4, r25	; 0x04
     c44:	8b 83       	std	Y+3, r24	; 0x03
     c46:	8b 81       	ldd	r24, Y+3	; 0x03
     c48:	9c 81       	ldd	r25, Y+4	; 0x04
     c4a:	04 97       	sbiw	r24, 0x04	; 4
     c4c:	24 f3       	brlt	.-56     	; 0xc16 <KBD_u8Initialize+0xd6>
			{
				KBD_Au8RowsPins[i] = B4 + i;
				KBD_Au8ColsPins[i] = B3 - i;
			}
			break;
     c4e:	68 c0       	rjmp	.+208    	; 0xd20 <KBD_u8Initialize+0x1e0>
		case 2:
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
     c50:	6f e0       	ldi	r22, 0x0F	; 15
     c52:	82 e0       	ldi	r24, 0x02	; 2
     c54:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(C4,1);
     c58:	61 e0       	ldi	r22, 0x01	; 1
     c5a:	84 e1       	ldi	r24, 0x14	; 20
     c5c:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C5,1);
     c60:	61 e0       	ldi	r22, 0x01	; 1
     c62:	85 e1       	ldi	r24, 0x15	; 21
     c64:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C6,1);
     c68:	61 e0       	ldi	r22, 0x01	; 1
     c6a:	86 e1       	ldi	r24, 0x16	; 22
     c6c:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(C7,1);
     c70:	61 e0       	ldi	r22, 0x01	; 1
     c72:	87 e1       	ldi	r24, 0x17	; 23
     c74:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     c78:	1e 82       	std	Y+6, r1	; 0x06
     c7a:	1d 82       	std	Y+5, r1	; 0x05
     c7c:	18 c0       	rjmp	.+48     	; 0xcae <KBD_u8Initialize+0x16e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
     c7e:	8d 81       	ldd	r24, Y+5	; 0x05
     c80:	24 e1       	ldi	r18, 0x14	; 20
     c82:	28 0f       	add	r18, r24
     c84:	8d 81       	ldd	r24, Y+5	; 0x05
     c86:	9e 81       	ldd	r25, Y+6	; 0x06
     c88:	8e 5e       	subi	r24, 0xEE	; 238
     c8a:	98 4f       	sbci	r25, 0xF8	; 248
     c8c:	fc 01       	movw	r30, r24
     c8e:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = C3 - i;
     c90:	8d 81       	ldd	r24, Y+5	; 0x05
     c92:	93 e1       	ldi	r25, 0x13	; 19
     c94:	29 2f       	mov	r18, r25
     c96:	28 1b       	sub	r18, r24
     c98:	8d 81       	ldd	r24, Y+5	; 0x05
     c9a:	9e 81       	ldd	r25, Y+6	; 0x06
     c9c:	82 5f       	subi	r24, 0xF2	; 242
     c9e:	98 4f       	sbci	r25, 0xF8	; 248
     ca0:	fc 01       	movw	r30, r24
     ca2:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_C,0b00001111);
			DIO_u8SetPinValue(C4,1);
			DIO_u8SetPinValue(C5,1);
			DIO_u8SetPinValue(C6,1);
			DIO_u8SetPinValue(C7,1);
			for (int i=0;i<4;i++)
     ca4:	8d 81       	ldd	r24, Y+5	; 0x05
     ca6:	9e 81       	ldd	r25, Y+6	; 0x06
     ca8:	01 96       	adiw	r24, 0x01	; 1
     caa:	9e 83       	std	Y+6, r25	; 0x06
     cac:	8d 83       	std	Y+5, r24	; 0x05
     cae:	8d 81       	ldd	r24, Y+5	; 0x05
     cb0:	9e 81       	ldd	r25, Y+6	; 0x06
     cb2:	04 97       	sbiw	r24, 0x04	; 4
     cb4:	24 f3       	brlt	.-56     	; 0xc7e <KBD_u8Initialize+0x13e>
			{
				KBD_Au8RowsPins[i] = C4 + i;
				KBD_Au8ColsPins[i] = C3 - i;
			}
			break;
     cb6:	34 c0       	rjmp	.+104    	; 0xd20 <KBD_u8Initialize+0x1e0>
		case 3:
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
     cb8:	6f e0       	ldi	r22, 0x0F	; 15
     cba:	83 e0       	ldi	r24, 0x03	; 3
     cbc:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <DIO_u8SetPortDirection>
			DIO_u8SetPinValue(D4,1);
     cc0:	61 e0       	ldi	r22, 0x01	; 1
     cc2:	8c e1       	ldi	r24, 0x1C	; 28
     cc4:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D5,1);
     cc8:	61 e0       	ldi	r22, 0x01	; 1
     cca:	8d e1       	ldi	r24, 0x1D	; 29
     ccc:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D6,1);
     cd0:	61 e0       	ldi	r22, 0x01	; 1
     cd2:	8e e1       	ldi	r24, 0x1E	; 30
     cd4:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			DIO_u8SetPinValue(D7,1);
     cd8:	61 e0       	ldi	r22, 0x01	; 1
     cda:	8f e1       	ldi	r24, 0x1F	; 31
     cdc:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
			for (int i=0;i<4;i++)
     ce0:	18 86       	std	Y+8, r1	; 0x08
     ce2:	1f 82       	std	Y+7, r1	; 0x07
     ce4:	18 c0       	rjmp	.+48     	; 0xd16 <KBD_u8Initialize+0x1d6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
     ce6:	8f 81       	ldd	r24, Y+7	; 0x07
     ce8:	2c e1       	ldi	r18, 0x1C	; 28
     cea:	28 0f       	add	r18, r24
     cec:	8f 81       	ldd	r24, Y+7	; 0x07
     cee:	98 85       	ldd	r25, Y+8	; 0x08
     cf0:	8e 5e       	subi	r24, 0xEE	; 238
     cf2:	98 4f       	sbci	r25, 0xF8	; 248
     cf4:	fc 01       	movw	r30, r24
     cf6:	20 83       	st	Z, r18
				KBD_Au8ColsPins[i] = D3 - i;
     cf8:	8f 81       	ldd	r24, Y+7	; 0x07
     cfa:	9b e1       	ldi	r25, 0x1B	; 27
     cfc:	29 2f       	mov	r18, r25
     cfe:	28 1b       	sub	r18, r24
     d00:	8f 81       	ldd	r24, Y+7	; 0x07
     d02:	98 85       	ldd	r25, Y+8	; 0x08
     d04:	82 5f       	subi	r24, 0xF2	; 242
     d06:	98 4f       	sbci	r25, 0xF8	; 248
     d08:	fc 01       	movw	r30, r24
     d0a:	20 83       	st	Z, r18
			DIO_u8SetPortDirection(GROUP_D,0b00001111);
			DIO_u8SetPinValue(D4,1);
			DIO_u8SetPinValue(D5,1);
			DIO_u8SetPinValue(D6,1);
			DIO_u8SetPinValue(D7,1);
			for (int i=0;i<4;i++)
     d0c:	8f 81       	ldd	r24, Y+7	; 0x07
     d0e:	98 85       	ldd	r25, Y+8	; 0x08
     d10:	01 96       	adiw	r24, 0x01	; 1
     d12:	98 87       	std	Y+8, r25	; 0x08
     d14:	8f 83       	std	Y+7, r24	; 0x07
     d16:	8f 81       	ldd	r24, Y+7	; 0x07
     d18:	98 85       	ldd	r25, Y+8	; 0x08
     d1a:	04 97       	sbiw	r24, 0x04	; 4
     d1c:	24 f3       	brlt	.-56     	; 0xce6 <KBD_u8Initialize+0x1a6>
			{
				KBD_Au8RowsPins[i] = D4 + i;
				KBD_Au8ColsPins[i] = D3 - i;
			}
			break;
     d1e:	00 00       	nop
		}
	}
     d20:	00 00       	nop
     d22:	29 96       	adiw	r28, 0x09	; 9
     d24:	0f b6       	in	r0, 0x3f	; 63
     d26:	f8 94       	cli
     d28:	de bf       	out	0x3e, r29	; 62
     d2a:	0f be       	out	0x3f, r0	; 63
     d2c:	cd bf       	out	0x3d, r28	; 61
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	08 95       	ret

00000d34 <KBD_keys_map>:
u8 KBD_keys_map(u8* keys)
{
     d34:	cf 93       	push	r28
     d36:	df 93       	push	r29
     d38:	00 d0       	rcall	.+0      	; 0xd3a <KBD_keys_map+0x6>
     d3a:	1f 92       	push	r1
     d3c:	cd b7       	in	r28, 0x3d	; 61
     d3e:	de b7       	in	r29, 0x3e	; 62
     d40:	9b 83       	std	Y+3, r25	; 0x03
     d42:	8a 83       	std	Y+2, r24	; 0x02
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     d44:	19 82       	std	Y+1, r1	; 0x01
     d46:	16 c0       	rjmp	.+44     	; 0xd74 <KBD_keys_map+0x40>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
     d48:	89 81       	ldd	r24, Y+1	; 0x01
     d4a:	88 2f       	mov	r24, r24
     d4c:	90 e0       	ldi	r25, 0x00	; 0
     d4e:	2a 81       	ldd	r18, Y+2	; 0x02
     d50:	3b 81       	ldd	r19, Y+3	; 0x03
     d52:	82 0f       	add	r24, r18
     d54:	93 1f       	adc	r25, r19
     d56:	fc 01       	movw	r30, r24
     d58:	80 81       	ld	r24, Z
     d5a:	81 30       	cpi	r24, 0x01	; 1
     d5c:	41 f4       	brne	.+16     	; 0xd6e <KBD_keys_map+0x3a>
     d5e:	89 81       	ldd	r24, Y+1	; 0x01
     d60:	88 2f       	mov	r24, r24
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	80 5a       	subi	r24, 0xA0	; 160
     d66:	9f 4f       	sbci	r25, 0xFF	; 255
     d68:	fc 01       	movw	r30, r24
     d6a:	80 81       	ld	r24, Z
     d6c:	07 c0       	rjmp	.+14     	; 0xd7c <KBD_keys_map+0x48>
		}
	}
u8 KBD_keys_map(u8* keys)
{
    u8 key_index;
    for(key_index = 0;key_index < KBD_u8_ROWS*KBD_u8_COL;key_index++)
     d6e:	89 81       	ldd	r24, Y+1	; 0x01
     d70:	8f 5f       	subi	r24, 0xFF	; 255
     d72:	89 83       	std	Y+1, r24	; 0x01
     d74:	89 81       	ldd	r24, Y+1	; 0x01
     d76:	80 31       	cpi	r24, 0x10	; 16
     d78:	38 f3       	brcs	.-50     	; 0xd48 <KBD_keys_map+0x14>
    {
        if (keys[key_index] == KBD_u8_PRESSED) return key_map[key_index];
    }
    return 0xff;
     d7a:	8f ef       	ldi	r24, 0xFF	; 255
}
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	0f 90       	pop	r0
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	08 95       	ret

00000d88 <LCD_Void_Write>:
#define F_CPU 8000000
#include "avr/delay.h"

static void LCD_Void_Write(u8 copy_u8_value) // the user wont use this func because only other functions will use it so the prototype will be in private.h
//and to make this func visible only in this file not on the whole project we will put static in front of it
{
     d88:	cf 93       	push	r28
     d8a:	df 93       	push	r29
     d8c:	cd b7       	in	r28, 0x3d	; 61
     d8e:	de b7       	in	r29, 0x3e	; 62
     d90:	2f 97       	sbiw	r28, 0x0f	; 15
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	f8 94       	cli
     d96:	de bf       	out	0x3e, r29	; 62
     d98:	0f be       	out	0x3f, r0	; 63
     d9a:	cd bf       	out	0x3d, r28	; 61
     d9c:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_u8SetPinValue(LCD_u8_RW_Pin,DIO_u8_LOW);
     d9e:	60 e0       	ldi	r22, 0x00	; 0
     da0:	81 e1       	ldi	r24, 0x11	; 17
     da2:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D0_Pin,Get_Bit(copy_u8_value,0));
     da6:	8f 85       	ldd	r24, Y+15	; 0x0f
     da8:	81 70       	andi	r24, 0x01	; 1
     daa:	68 2f       	mov	r22, r24
     dac:	87 e0       	ldi	r24, 0x07	; 7
     dae:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D1_Pin,Get_Bit(copy_u8_value,1));
     db2:	8f 85       	ldd	r24, Y+15	; 0x0f
     db4:	86 95       	lsr	r24
     db6:	81 70       	andi	r24, 0x01	; 1
     db8:	68 2f       	mov	r22, r24
     dba:	86 e0       	ldi	r24, 0x06	; 6
     dbc:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D2_Pin,Get_Bit(copy_u8_value,2));
     dc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     dc2:	86 95       	lsr	r24
     dc4:	86 95       	lsr	r24
     dc6:	81 70       	andi	r24, 0x01	; 1
     dc8:	68 2f       	mov	r22, r24
     dca:	85 e0       	ldi	r24, 0x05	; 5
     dcc:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D3_Pin,Get_Bit(copy_u8_value,3));
     dd0:	8f 85       	ldd	r24, Y+15	; 0x0f
     dd2:	86 95       	lsr	r24
     dd4:	86 95       	lsr	r24
     dd6:	86 95       	lsr	r24
     dd8:	81 70       	andi	r24, 0x01	; 1
     dda:	68 2f       	mov	r22, r24
     ddc:	84 e0       	ldi	r24, 0x04	; 4
     dde:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D4_Pin,Get_Bit(copy_u8_value,4));
     de2:	8f 85       	ldd	r24, Y+15	; 0x0f
     de4:	82 95       	swap	r24
     de6:	8f 70       	andi	r24, 0x0F	; 15
     de8:	81 70       	andi	r24, 0x01	; 1
     dea:	68 2f       	mov	r22, r24
     dec:	83 e0       	ldi	r24, 0x03	; 3
     dee:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D5_Pin,Get_Bit(copy_u8_value,5));
     df2:	8f 85       	ldd	r24, Y+15	; 0x0f
     df4:	82 95       	swap	r24
     df6:	86 95       	lsr	r24
     df8:	87 70       	andi	r24, 0x07	; 7
     dfa:	81 70       	andi	r24, 0x01	; 1
     dfc:	68 2f       	mov	r22, r24
     dfe:	82 e0       	ldi	r24, 0x02	; 2
     e00:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D6_Pin,Get_Bit(copy_u8_value,6));
     e04:	8f 85       	ldd	r24, Y+15	; 0x0f
     e06:	82 95       	swap	r24
     e08:	86 95       	lsr	r24
     e0a:	86 95       	lsr	r24
     e0c:	83 70       	andi	r24, 0x03	; 3
     e0e:	81 70       	andi	r24, 0x01	; 1
     e10:	68 2f       	mov	r22, r24
     e12:	81 e0       	ldi	r24, 0x01	; 1
     e14:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_D7_Pin,Get_Bit(copy_u8_value,7));
     e18:	8f 85       	ldd	r24, Y+15	; 0x0f
     e1a:	88 1f       	adc	r24, r24
     e1c:	88 27       	eor	r24, r24
     e1e:	88 1f       	adc	r24, r24
     e20:	68 2f       	mov	r22, r24
     e22:	80 e0       	ldi	r24, 0x00	; 0
     e24:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_HIGH);
     e28:	61 e0       	ldi	r22, 0x01	; 1
     e2a:	82 e1       	ldi	r24, 0x12	; 18
     e2c:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	a0 e8       	ldi	r26, 0x80	; 128
     e36:	bf e3       	ldi	r27, 0x3F	; 63
     e38:	89 83       	std	Y+1, r24	; 0x01
     e3a:	9a 83       	std	Y+2, r25	; 0x02
     e3c:	ab 83       	std	Y+3, r26	; 0x03
     e3e:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     e40:	20 e0       	ldi	r18, 0x00	; 0
     e42:	30 e0       	ldi	r19, 0x00	; 0
     e44:	4a ef       	ldi	r20, 0xFA	; 250
     e46:	54 e4       	ldi	r21, 0x44	; 68
     e48:	69 81       	ldd	r22, Y+1	; 0x01
     e4a:	7a 81       	ldd	r23, Y+2	; 0x02
     e4c:	8b 81       	ldd	r24, Y+3	; 0x03
     e4e:	9c 81       	ldd	r25, Y+4	; 0x04
     e50:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
     e54:	dc 01       	movw	r26, r24
     e56:	cb 01       	movw	r24, r22
     e58:	8d 83       	std	Y+5, r24	; 0x05
     e5a:	9e 83       	std	Y+6, r25	; 0x06
     e5c:	af 83       	std	Y+7, r26	; 0x07
     e5e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     e60:	20 e0       	ldi	r18, 0x00	; 0
     e62:	30 e0       	ldi	r19, 0x00	; 0
     e64:	40 e8       	ldi	r20, 0x80	; 128
     e66:	5f e3       	ldi	r21, 0x3F	; 63
     e68:	6d 81       	ldd	r22, Y+5	; 0x05
     e6a:	7e 81       	ldd	r23, Y+6	; 0x06
     e6c:	8f 81       	ldd	r24, Y+7	; 0x07
     e6e:	98 85       	ldd	r25, Y+8	; 0x08
     e70:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
     e74:	88 23       	and	r24, r24
     e76:	2c f4       	brge	.+10     	; 0xe82 <LCD_Void_Write+0xfa>
		__ticks = 1;
     e78:	81 e0       	ldi	r24, 0x01	; 1
     e7a:	90 e0       	ldi	r25, 0x00	; 0
     e7c:	9a 87       	std	Y+10, r25	; 0x0a
     e7e:	89 87       	std	Y+9, r24	; 0x09
     e80:	3f c0       	rjmp	.+126    	; 0xf00 <LCD_Void_Write+0x178>
	else if (__tmp > 65535)
     e82:	20 e0       	ldi	r18, 0x00	; 0
     e84:	3f ef       	ldi	r19, 0xFF	; 255
     e86:	4f e7       	ldi	r20, 0x7F	; 127
     e88:	57 e4       	ldi	r21, 0x47	; 71
     e8a:	6d 81       	ldd	r22, Y+5	; 0x05
     e8c:	7e 81       	ldd	r23, Y+6	; 0x06
     e8e:	8f 81       	ldd	r24, Y+7	; 0x07
     e90:	98 85       	ldd	r25, Y+8	; 0x08
     e92:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
     e96:	18 16       	cp	r1, r24
     e98:	4c f5       	brge	.+82     	; 0xeec <LCD_Void_Write+0x164>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e9a:	20 e0       	ldi	r18, 0x00	; 0
     e9c:	30 e0       	ldi	r19, 0x00	; 0
     e9e:	40 e2       	ldi	r20, 0x20	; 32
     ea0:	51 e4       	ldi	r21, 0x41	; 65
     ea2:	69 81       	ldd	r22, Y+1	; 0x01
     ea4:	7a 81       	ldd	r23, Y+2	; 0x02
     ea6:	8b 81       	ldd	r24, Y+3	; 0x03
     ea8:	9c 81       	ldd	r25, Y+4	; 0x04
     eaa:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
     eae:	dc 01       	movw	r26, r24
     eb0:	cb 01       	movw	r24, r22
     eb2:	bc 01       	movw	r22, r24
     eb4:	cd 01       	movw	r24, r26
     eb6:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
     eba:	dc 01       	movw	r26, r24
     ebc:	cb 01       	movw	r24, r22
     ebe:	9a 87       	std	Y+10, r25	; 0x0a
     ec0:	89 87       	std	Y+9, r24	; 0x09
     ec2:	0f c0       	rjmp	.+30     	; 0xee2 <LCD_Void_Write+0x15a>
     ec4:	88 ec       	ldi	r24, 0xC8	; 200
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	9c 87       	std	Y+12, r25	; 0x0c
     eca:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ecc:	8b 85       	ldd	r24, Y+11	; 0x0b
     ece:	9c 85       	ldd	r25, Y+12	; 0x0c
     ed0:	01 97       	sbiw	r24, 0x01	; 1
     ed2:	f1 f7       	brne	.-4      	; 0xed0 <LCD_Void_Write+0x148>
     ed4:	9c 87       	std	Y+12, r25	; 0x0c
     ed6:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ed8:	89 85       	ldd	r24, Y+9	; 0x09
     eda:	9a 85       	ldd	r25, Y+10	; 0x0a
     edc:	01 97       	sbiw	r24, 0x01	; 1
     ede:	9a 87       	std	Y+10, r25	; 0x0a
     ee0:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ee2:	89 85       	ldd	r24, Y+9	; 0x09
     ee4:	9a 85       	ldd	r25, Y+10	; 0x0a
     ee6:	89 2b       	or	r24, r25
     ee8:	69 f7       	brne	.-38     	; 0xec4 <LCD_Void_Write+0x13c>
     eea:	14 c0       	rjmp	.+40     	; 0xf14 <LCD_Void_Write+0x18c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     eec:	6d 81       	ldd	r22, Y+5	; 0x05
     eee:	7e 81       	ldd	r23, Y+6	; 0x06
     ef0:	8f 81       	ldd	r24, Y+7	; 0x07
     ef2:	98 85       	ldd	r25, Y+8	; 0x08
     ef4:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
     ef8:	dc 01       	movw	r26, r24
     efa:	cb 01       	movw	r24, r22
     efc:	9a 87       	std	Y+10, r25	; 0x0a
     efe:	89 87       	std	Y+9, r24	; 0x09
     f00:	89 85       	ldd	r24, Y+9	; 0x09
     f02:	9a 85       	ldd	r25, Y+10	; 0x0a
     f04:	9e 87       	std	Y+14, r25	; 0x0e
     f06:	8d 87       	std	Y+13, r24	; 0x0d
     f08:	8d 85       	ldd	r24, Y+13	; 0x0d
     f0a:	9e 85       	ldd	r25, Y+14	; 0x0e
     f0c:	01 97       	sbiw	r24, 0x01	; 1
     f0e:	f1 f7       	brne	.-4      	; 0xf0c <LCD_Void_Write+0x184>
     f10:	9e 87       	std	Y+14, r25	; 0x0e
     f12:	8d 87       	std	Y+13, r24	; 0x0d
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_E_Pin,DIO_u8_LOW);
     f14:	60 e0       	ldi	r22, 0x00	; 0
     f16:	82 e1       	ldi	r24, 0x12	; 18
     f18:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
}
     f1c:	00 00       	nop
     f1e:	2f 96       	adiw	r28, 0x0f	; 15
     f20:	0f b6       	in	r0, 0x3f	; 63
     f22:	f8 94       	cli
     f24:	de bf       	out	0x3e, r29	; 62
     f26:	0f be       	out	0x3f, r0	; 63
     f28:	cd bf       	out	0x3d, r28	; 61
     f2a:	df 91       	pop	r29
     f2c:	cf 91       	pop	r28
     f2e:	08 95       	ret

00000f30 <LCD_Void_Write_Cmd>:

void LCD_Void_Write_Cmd(u8 copy_u8_cmd)
{
     f30:	cf 93       	push	r28
     f32:	df 93       	push	r29
     f34:	1f 92       	push	r1
     f36:	cd b7       	in	r28, 0x3d	; 61
     f38:	de b7       	in	r29, 0x3e	; 62
     f3a:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue (LCD_u8_RS_Pin,DIO_u8_LOW);
     f3c:	60 e0       	ldi	r22, 0x00	; 0
     f3e:	80 e1       	ldi	r24, 0x10	; 16
     f40:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_cmd);
     f44:	89 81       	ldd	r24, Y+1	; 0x01
     f46:	0e 94 c4 06 	call	0xd88	; 0xd88 <LCD_Void_Write>
}
     f4a:	00 00       	nop
     f4c:	0f 90       	pop	r0
     f4e:	df 91       	pop	r29
     f50:	cf 91       	pop	r28
     f52:	08 95       	ret

00000f54 <LCD_Void_Write_Data>:

void LCD_Void_Write_Data(u8 copy_u8_data)
{
     f54:	cf 93       	push	r28
     f56:	df 93       	push	r29
     f58:	1f 92       	push	r1
     f5a:	cd b7       	in	r28, 0x3d	; 61
     f5c:	de b7       	in	r29, 0x3e	; 62
     f5e:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue(LCD_u8_RS_Pin,DIO_u8_HIGH);
     f60:	61 e0       	ldi	r22, 0x01	; 1
     f62:	80 e1       	ldi	r24, 0x10	; 16
     f64:	0e 94 de 02 	call	0x5bc	; 0x5bc <DIO_u8SetPinValue>
	LCD_Void_Write(copy_u8_data);
     f68:	89 81       	ldd	r24, Y+1	; 0x01
     f6a:	0e 94 c4 06 	call	0xd88	; 0xd88 <LCD_Void_Write>
}
     f6e:	00 00       	nop
     f70:	0f 90       	pop	r0
     f72:	df 91       	pop	r29
     f74:	cf 91       	pop	r28
     f76:	08 95       	ret

00000f78 <LCD_initialize>:


void LCD_initialize(void)
{
     f78:	0f 93       	push	r16
     f7a:	1f 93       	push	r17
     f7c:	cf 93       	push	r28
     f7e:	df 93       	push	r29
     f80:	cd b7       	in	r28, 0x3d	; 61
     f82:	de b7       	in	r29, 0x3e	; 62
     f84:	ca 56       	subi	r28, 0x6A	; 106
     f86:	d1 09       	sbc	r29, r1
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	de bf       	out	0x3e, r29	; 62
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	cd bf       	out	0x3d, r28	; 61
	DIO_u8SetPinDirection(LCD_u8_RS_Pin,1);
     f92:	61 e0       	ldi	r22, 0x01	; 1
     f94:	80 e1       	ldi	r24, 0x10	; 16
     f96:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_RW_Pin,1);
     f9a:	61 e0       	ldi	r22, 0x01	; 1
     f9c:	81 e1       	ldi	r24, 0x11	; 17
     f9e:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_E_Pin,1);
     fa2:	61 e0       	ldi	r22, 0x01	; 1
     fa4:	82 e1       	ldi	r24, 0x12	; 18
     fa6:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D0_Pin,1);
     faa:	61 e0       	ldi	r22, 0x01	; 1
     fac:	87 e0       	ldi	r24, 0x07	; 7
     fae:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D1_Pin,1);
     fb2:	61 e0       	ldi	r22, 0x01	; 1
     fb4:	86 e0       	ldi	r24, 0x06	; 6
     fb6:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D2_Pin,1);
     fba:	61 e0       	ldi	r22, 0x01	; 1
     fbc:	85 e0       	ldi	r24, 0x05	; 5
     fbe:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D3_Pin,1);
     fc2:	61 e0       	ldi	r22, 0x01	; 1
     fc4:	84 e0       	ldi	r24, 0x04	; 4
     fc6:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D4_Pin,1);
     fca:	61 e0       	ldi	r22, 0x01	; 1
     fcc:	83 e0       	ldi	r24, 0x03	; 3
     fce:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D5_Pin,1);
     fd2:	61 e0       	ldi	r22, 0x01	; 1
     fd4:	82 e0       	ldi	r24, 0x02	; 2
     fd6:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D6_Pin,1);
     fda:	61 e0       	ldi	r22, 0x01	; 1
     fdc:	81 e0       	ldi	r24, 0x01	; 1
     fde:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(LCD_u8_D7_Pin,1);
     fe2:	61 e0       	ldi	r22, 0x01	; 1
     fe4:	80 e0       	ldi	r24, 0x00	; 0
     fe6:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DIO_u8SetPinDirection>
     fea:	80 e0       	ldi	r24, 0x00	; 0
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	a8 e4       	ldi	r26, 0x48	; 72
     ff0:	b2 e4       	ldi	r27, 0x42	; 66
     ff2:	89 83       	std	Y+1, r24	; 0x01
     ff4:	9a 83       	std	Y+2, r25	; 0x02
     ff6:	ab 83       	std	Y+3, r26	; 0x03
     ff8:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     ffa:	8e 01       	movw	r16, r28
     ffc:	0f 59       	subi	r16, 0x9F	; 159
     ffe:	1f 4f       	sbci	r17, 0xFF	; 255
    1000:	20 e0       	ldi	r18, 0x00	; 0
    1002:	30 e0       	ldi	r19, 0x00	; 0
    1004:	4a ef       	ldi	r20, 0xFA	; 250
    1006:	54 e4       	ldi	r21, 0x44	; 68
    1008:	69 81       	ldd	r22, Y+1	; 0x01
    100a:	7a 81       	ldd	r23, Y+2	; 0x02
    100c:	8b 81       	ldd	r24, Y+3	; 0x03
    100e:	9c 81       	ldd	r25, Y+4	; 0x04
    1010:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1014:	dc 01       	movw	r26, r24
    1016:	cb 01       	movw	r24, r22
    1018:	f8 01       	movw	r30, r16
    101a:	80 83       	st	Z, r24
    101c:	91 83       	std	Z+1, r25	; 0x01
    101e:	a2 83       	std	Z+2, r26	; 0x02
    1020:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1022:	ce 01       	movw	r24, r28
    1024:	8f 59       	subi	r24, 0x9F	; 159
    1026:	9f 4f       	sbci	r25, 0xFF	; 255
    1028:	20 e0       	ldi	r18, 0x00	; 0
    102a:	30 e0       	ldi	r19, 0x00	; 0
    102c:	40 e8       	ldi	r20, 0x80	; 128
    102e:	5f e3       	ldi	r21, 0x3F	; 63
    1030:	fc 01       	movw	r30, r24
    1032:	60 81       	ld	r22, Z
    1034:	71 81       	ldd	r23, Z+1	; 0x01
    1036:	82 81       	ldd	r24, Z+2	; 0x02
    1038:	93 81       	ldd	r25, Z+3	; 0x03
    103a:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    103e:	88 23       	and	r24, r24
    1040:	4c f4       	brge	.+18     	; 0x1054 <LCD_initialize+0xdc>
		__ticks = 1;
    1042:	ce 01       	movw	r24, r28
    1044:	8b 59       	subi	r24, 0x9B	; 155
    1046:	9f 4f       	sbci	r25, 0xFF	; 255
    1048:	21 e0       	ldi	r18, 0x01	; 1
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	fc 01       	movw	r30, r24
    104e:	31 83       	std	Z+1, r19	; 0x01
    1050:	20 83       	st	Z, r18
    1052:	69 c0       	rjmp	.+210    	; 0x1126 <LCD_initialize+0x1ae>
	else if (__tmp > 65535)
    1054:	ce 01       	movw	r24, r28
    1056:	8f 59       	subi	r24, 0x9F	; 159
    1058:	9f 4f       	sbci	r25, 0xFF	; 255
    105a:	20 e0       	ldi	r18, 0x00	; 0
    105c:	3f ef       	ldi	r19, 0xFF	; 255
    105e:	4f e7       	ldi	r20, 0x7F	; 127
    1060:	57 e4       	ldi	r21, 0x47	; 71
    1062:	fc 01       	movw	r30, r24
    1064:	60 81       	ld	r22, Z
    1066:	71 81       	ldd	r23, Z+1	; 0x01
    1068:	82 81       	ldd	r24, Z+2	; 0x02
    106a:	93 81       	ldd	r25, Z+3	; 0x03
    106c:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    1070:	18 16       	cp	r1, r24
    1072:	0c f0       	brlt	.+2      	; 0x1076 <LCD_initialize+0xfe>
    1074:	46 c0       	rjmp	.+140    	; 0x1102 <LCD_initialize+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1076:	20 e0       	ldi	r18, 0x00	; 0
    1078:	30 e0       	ldi	r19, 0x00	; 0
    107a:	40 e2       	ldi	r20, 0x20	; 32
    107c:	51 e4       	ldi	r21, 0x41	; 65
    107e:	69 81       	ldd	r22, Y+1	; 0x01
    1080:	7a 81       	ldd	r23, Y+2	; 0x02
    1082:	8b 81       	ldd	r24, Y+3	; 0x03
    1084:	9c 81       	ldd	r25, Y+4	; 0x04
    1086:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    108a:	dc 01       	movw	r26, r24
    108c:	cb 01       	movw	r24, r22
    108e:	8e 01       	movw	r16, r28
    1090:	0b 59       	subi	r16, 0x9B	; 155
    1092:	1f 4f       	sbci	r17, 0xFF	; 255
    1094:	bc 01       	movw	r22, r24
    1096:	cd 01       	movw	r24, r26
    1098:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    109c:	dc 01       	movw	r26, r24
    109e:	cb 01       	movw	r24, r22
    10a0:	f8 01       	movw	r30, r16
    10a2:	91 83       	std	Z+1, r25	; 0x01
    10a4:	80 83       	st	Z, r24
    10a6:	24 c0       	rjmp	.+72     	; 0x10f0 <LCD_initialize+0x178>
    10a8:	ce 01       	movw	r24, r28
    10aa:	89 59       	subi	r24, 0x99	; 153
    10ac:	9f 4f       	sbci	r25, 0xFF	; 255
    10ae:	28 ec       	ldi	r18, 0xC8	; 200
    10b0:	30 e0       	ldi	r19, 0x00	; 0
    10b2:	fc 01       	movw	r30, r24
    10b4:	31 83       	std	Z+1, r19	; 0x01
    10b6:	20 83       	st	Z, r18
    10b8:	ce 01       	movw	r24, r28
    10ba:	89 59       	subi	r24, 0x99	; 153
    10bc:	9f 4f       	sbci	r25, 0xFF	; 255
    10be:	fc 01       	movw	r30, r24
    10c0:	80 81       	ld	r24, Z
    10c2:	91 81       	ldd	r25, Z+1	; 0x01
    10c4:	01 97       	sbiw	r24, 0x01	; 1
    10c6:	f1 f7       	brne	.-4      	; 0x10c4 <LCD_initialize+0x14c>
    10c8:	9e 01       	movw	r18, r28
    10ca:	29 59       	subi	r18, 0x99	; 153
    10cc:	3f 4f       	sbci	r19, 0xFF	; 255
    10ce:	f9 01       	movw	r30, r18
    10d0:	91 83       	std	Z+1, r25	; 0x01
    10d2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    10d4:	ce 01       	movw	r24, r28
    10d6:	8b 59       	subi	r24, 0x9B	; 155
    10d8:	9f 4f       	sbci	r25, 0xFF	; 255
    10da:	9e 01       	movw	r18, r28
    10dc:	2b 59       	subi	r18, 0x9B	; 155
    10de:	3f 4f       	sbci	r19, 0xFF	; 255
    10e0:	f9 01       	movw	r30, r18
    10e2:	20 81       	ld	r18, Z
    10e4:	31 81       	ldd	r19, Z+1	; 0x01
    10e6:	21 50       	subi	r18, 0x01	; 1
    10e8:	31 09       	sbc	r19, r1
    10ea:	fc 01       	movw	r30, r24
    10ec:	31 83       	std	Z+1, r19	; 0x01
    10ee:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    10f0:	ce 01       	movw	r24, r28
    10f2:	8b 59       	subi	r24, 0x9B	; 155
    10f4:	9f 4f       	sbci	r25, 0xFF	; 255
    10f6:	fc 01       	movw	r30, r24
    10f8:	80 81       	ld	r24, Z
    10fa:	91 81       	ldd	r25, Z+1	; 0x01
    10fc:	89 2b       	or	r24, r25
    10fe:	a1 f6       	brne	.-88     	; 0x10a8 <LCD_initialize+0x130>
    1100:	2c c0       	rjmp	.+88     	; 0x115a <LCD_initialize+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1102:	8e 01       	movw	r16, r28
    1104:	0b 59       	subi	r16, 0x9B	; 155
    1106:	1f 4f       	sbci	r17, 0xFF	; 255
    1108:	ce 01       	movw	r24, r28
    110a:	8f 59       	subi	r24, 0x9F	; 159
    110c:	9f 4f       	sbci	r25, 0xFF	; 255
    110e:	fc 01       	movw	r30, r24
    1110:	60 81       	ld	r22, Z
    1112:	71 81       	ldd	r23, Z+1	; 0x01
    1114:	82 81       	ldd	r24, Z+2	; 0x02
    1116:	93 81       	ldd	r25, Z+3	; 0x03
    1118:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    111c:	dc 01       	movw	r26, r24
    111e:	cb 01       	movw	r24, r22
    1120:	f8 01       	movw	r30, r16
    1122:	91 83       	std	Z+1, r25	; 0x01
    1124:	80 83       	st	Z, r24
    1126:	ce 01       	movw	r24, r28
    1128:	87 59       	subi	r24, 0x97	; 151
    112a:	9f 4f       	sbci	r25, 0xFF	; 255
    112c:	9e 01       	movw	r18, r28
    112e:	2b 59       	subi	r18, 0x9B	; 155
    1130:	3f 4f       	sbci	r19, 0xFF	; 255
    1132:	f9 01       	movw	r30, r18
    1134:	20 81       	ld	r18, Z
    1136:	31 81       	ldd	r19, Z+1	; 0x01
    1138:	fc 01       	movw	r30, r24
    113a:	31 83       	std	Z+1, r19	; 0x01
    113c:	20 83       	st	Z, r18
    113e:	ce 01       	movw	r24, r28
    1140:	87 59       	subi	r24, 0x97	; 151
    1142:	9f 4f       	sbci	r25, 0xFF	; 255
    1144:	fc 01       	movw	r30, r24
    1146:	80 81       	ld	r24, Z
    1148:	91 81       	ldd	r25, Z+1	; 0x01
    114a:	01 97       	sbiw	r24, 0x01	; 1
    114c:	f1 f7       	brne	.-4      	; 0x114a <LCD_initialize+0x1d2>
    114e:	9e 01       	movw	r18, r28
    1150:	27 59       	subi	r18, 0x97	; 151
    1152:	3f 4f       	sbci	r19, 0xFF	; 255
    1154:	f9 01       	movw	r30, r18
    1156:	91 83       	std	Z+1, r25	; 0x01
    1158:	80 83       	st	Z, r24
    115a:	80 e0       	ldi	r24, 0x00	; 0
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	a0 e2       	ldi	r26, 0x20	; 32
    1160:	b2 e4       	ldi	r27, 0x42	; 66
    1162:	8d 83       	std	Y+5, r24	; 0x05
    1164:	9e 83       	std	Y+6, r25	; 0x06
    1166:	af 83       	std	Y+7, r26	; 0x07
    1168:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    116a:	8e 01       	movw	r16, r28
    116c:	09 5a       	subi	r16, 0xA9	; 169
    116e:	1f 4f       	sbci	r17, 0xFF	; 255
    1170:	20 e0       	ldi	r18, 0x00	; 0
    1172:	30 e0       	ldi	r19, 0x00	; 0
    1174:	4a ef       	ldi	r20, 0xFA	; 250
    1176:	54 e4       	ldi	r21, 0x44	; 68
    1178:	6d 81       	ldd	r22, Y+5	; 0x05
    117a:	7e 81       	ldd	r23, Y+6	; 0x06
    117c:	8f 81       	ldd	r24, Y+7	; 0x07
    117e:	98 85       	ldd	r25, Y+8	; 0x08
    1180:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1184:	dc 01       	movw	r26, r24
    1186:	cb 01       	movw	r24, r22
    1188:	f8 01       	movw	r30, r16
    118a:	80 83       	st	Z, r24
    118c:	91 83       	std	Z+1, r25	; 0x01
    118e:	a2 83       	std	Z+2, r26	; 0x02
    1190:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1192:	ce 01       	movw	r24, r28
    1194:	89 5a       	subi	r24, 0xA9	; 169
    1196:	9f 4f       	sbci	r25, 0xFF	; 255
    1198:	20 e0       	ldi	r18, 0x00	; 0
    119a:	30 e0       	ldi	r19, 0x00	; 0
    119c:	40 e8       	ldi	r20, 0x80	; 128
    119e:	5f e3       	ldi	r21, 0x3F	; 63
    11a0:	fc 01       	movw	r30, r24
    11a2:	60 81       	ld	r22, Z
    11a4:	71 81       	ldd	r23, Z+1	; 0x01
    11a6:	82 81       	ldd	r24, Z+2	; 0x02
    11a8:	93 81       	ldd	r25, Z+3	; 0x03
    11aa:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    11ae:	88 23       	and	r24, r24
    11b0:	4c f4       	brge	.+18     	; 0x11c4 <LCD_initialize+0x24c>
		__ticks = 1;
    11b2:	ce 01       	movw	r24, r28
    11b4:	85 5a       	subi	r24, 0xA5	; 165
    11b6:	9f 4f       	sbci	r25, 0xFF	; 255
    11b8:	21 e0       	ldi	r18, 0x01	; 1
    11ba:	30 e0       	ldi	r19, 0x00	; 0
    11bc:	fc 01       	movw	r30, r24
    11be:	31 83       	std	Z+1, r19	; 0x01
    11c0:	20 83       	st	Z, r18
    11c2:	69 c0       	rjmp	.+210    	; 0x1296 <LCD_initialize+0x31e>
	else if (__tmp > 65535)
    11c4:	ce 01       	movw	r24, r28
    11c6:	89 5a       	subi	r24, 0xA9	; 169
    11c8:	9f 4f       	sbci	r25, 0xFF	; 255
    11ca:	20 e0       	ldi	r18, 0x00	; 0
    11cc:	3f ef       	ldi	r19, 0xFF	; 255
    11ce:	4f e7       	ldi	r20, 0x7F	; 127
    11d0:	57 e4       	ldi	r21, 0x47	; 71
    11d2:	fc 01       	movw	r30, r24
    11d4:	60 81       	ld	r22, Z
    11d6:	71 81       	ldd	r23, Z+1	; 0x01
    11d8:	82 81       	ldd	r24, Z+2	; 0x02
    11da:	93 81       	ldd	r25, Z+3	; 0x03
    11dc:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    11e0:	18 16       	cp	r1, r24
    11e2:	0c f0       	brlt	.+2      	; 0x11e6 <LCD_initialize+0x26e>
    11e4:	46 c0       	rjmp	.+140    	; 0x1272 <LCD_initialize+0x2fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    11e6:	20 e0       	ldi	r18, 0x00	; 0
    11e8:	30 e0       	ldi	r19, 0x00	; 0
    11ea:	40 e2       	ldi	r20, 0x20	; 32
    11ec:	51 e4       	ldi	r21, 0x41	; 65
    11ee:	6d 81       	ldd	r22, Y+5	; 0x05
    11f0:	7e 81       	ldd	r23, Y+6	; 0x06
    11f2:	8f 81       	ldd	r24, Y+7	; 0x07
    11f4:	98 85       	ldd	r25, Y+8	; 0x08
    11f6:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    11fa:	dc 01       	movw	r26, r24
    11fc:	cb 01       	movw	r24, r22
    11fe:	8e 01       	movw	r16, r28
    1200:	05 5a       	subi	r16, 0xA5	; 165
    1202:	1f 4f       	sbci	r17, 0xFF	; 255
    1204:	bc 01       	movw	r22, r24
    1206:	cd 01       	movw	r24, r26
    1208:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    120c:	dc 01       	movw	r26, r24
    120e:	cb 01       	movw	r24, r22
    1210:	f8 01       	movw	r30, r16
    1212:	91 83       	std	Z+1, r25	; 0x01
    1214:	80 83       	st	Z, r24
    1216:	24 c0       	rjmp	.+72     	; 0x1260 <LCD_initialize+0x2e8>
    1218:	ce 01       	movw	r24, r28
    121a:	83 5a       	subi	r24, 0xA3	; 163
    121c:	9f 4f       	sbci	r25, 0xFF	; 255
    121e:	28 ec       	ldi	r18, 0xC8	; 200
    1220:	30 e0       	ldi	r19, 0x00	; 0
    1222:	fc 01       	movw	r30, r24
    1224:	31 83       	std	Z+1, r19	; 0x01
    1226:	20 83       	st	Z, r18
    1228:	ce 01       	movw	r24, r28
    122a:	83 5a       	subi	r24, 0xA3	; 163
    122c:	9f 4f       	sbci	r25, 0xFF	; 255
    122e:	fc 01       	movw	r30, r24
    1230:	80 81       	ld	r24, Z
    1232:	91 81       	ldd	r25, Z+1	; 0x01
    1234:	01 97       	sbiw	r24, 0x01	; 1
    1236:	f1 f7       	brne	.-4      	; 0x1234 <LCD_initialize+0x2bc>
    1238:	9e 01       	movw	r18, r28
    123a:	23 5a       	subi	r18, 0xA3	; 163
    123c:	3f 4f       	sbci	r19, 0xFF	; 255
    123e:	f9 01       	movw	r30, r18
    1240:	91 83       	std	Z+1, r25	; 0x01
    1242:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1244:	ce 01       	movw	r24, r28
    1246:	85 5a       	subi	r24, 0xA5	; 165
    1248:	9f 4f       	sbci	r25, 0xFF	; 255
    124a:	9e 01       	movw	r18, r28
    124c:	25 5a       	subi	r18, 0xA5	; 165
    124e:	3f 4f       	sbci	r19, 0xFF	; 255
    1250:	f9 01       	movw	r30, r18
    1252:	20 81       	ld	r18, Z
    1254:	31 81       	ldd	r19, Z+1	; 0x01
    1256:	21 50       	subi	r18, 0x01	; 1
    1258:	31 09       	sbc	r19, r1
    125a:	fc 01       	movw	r30, r24
    125c:	31 83       	std	Z+1, r19	; 0x01
    125e:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1260:	ce 01       	movw	r24, r28
    1262:	85 5a       	subi	r24, 0xA5	; 165
    1264:	9f 4f       	sbci	r25, 0xFF	; 255
    1266:	fc 01       	movw	r30, r24
    1268:	80 81       	ld	r24, Z
    126a:	91 81       	ldd	r25, Z+1	; 0x01
    126c:	89 2b       	or	r24, r25
    126e:	a1 f6       	brne	.-88     	; 0x1218 <LCD_initialize+0x2a0>
    1270:	2c c0       	rjmp	.+88     	; 0x12ca <LCD_initialize+0x352>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1272:	8e 01       	movw	r16, r28
    1274:	05 5a       	subi	r16, 0xA5	; 165
    1276:	1f 4f       	sbci	r17, 0xFF	; 255
    1278:	ce 01       	movw	r24, r28
    127a:	89 5a       	subi	r24, 0xA9	; 169
    127c:	9f 4f       	sbci	r25, 0xFF	; 255
    127e:	fc 01       	movw	r30, r24
    1280:	60 81       	ld	r22, Z
    1282:	71 81       	ldd	r23, Z+1	; 0x01
    1284:	82 81       	ldd	r24, Z+2	; 0x02
    1286:	93 81       	ldd	r25, Z+3	; 0x03
    1288:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    128c:	dc 01       	movw	r26, r24
    128e:	cb 01       	movw	r24, r22
    1290:	f8 01       	movw	r30, r16
    1292:	91 83       	std	Z+1, r25	; 0x01
    1294:	80 83       	st	Z, r24
    1296:	ce 01       	movw	r24, r28
    1298:	81 5a       	subi	r24, 0xA1	; 161
    129a:	9f 4f       	sbci	r25, 0xFF	; 255
    129c:	9e 01       	movw	r18, r28
    129e:	25 5a       	subi	r18, 0xA5	; 165
    12a0:	3f 4f       	sbci	r19, 0xFF	; 255
    12a2:	f9 01       	movw	r30, r18
    12a4:	20 81       	ld	r18, Z
    12a6:	31 81       	ldd	r19, Z+1	; 0x01
    12a8:	fc 01       	movw	r30, r24
    12aa:	31 83       	std	Z+1, r19	; 0x01
    12ac:	20 83       	st	Z, r18
    12ae:	ce 01       	movw	r24, r28
    12b0:	81 5a       	subi	r24, 0xA1	; 161
    12b2:	9f 4f       	sbci	r25, 0xFF	; 255
    12b4:	fc 01       	movw	r30, r24
    12b6:	80 81       	ld	r24, Z
    12b8:	91 81       	ldd	r25, Z+1	; 0x01
    12ba:	01 97       	sbiw	r24, 0x01	; 1
    12bc:	f1 f7       	brne	.-4      	; 0x12ba <LCD_initialize+0x342>
    12be:	9e 01       	movw	r18, r28
    12c0:	21 5a       	subi	r18, 0xA1	; 161
    12c2:	3f 4f       	sbci	r19, 0xFF	; 255
    12c4:	f9 01       	movw	r30, r18
    12c6:	91 83       	std	Z+1, r25	; 0x01
    12c8:	80 83       	st	Z, r24
	_delay_ms(50);
	_delay_ms(40);
	LCD_Void_Write_Cmd(0b00111000);
    12ca:	88 e3       	ldi	r24, 0x38	; 56
    12cc:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
    12d0:	80 e0       	ldi	r24, 0x00	; 0
    12d2:	90 e0       	ldi	r25, 0x00	; 0
    12d4:	a8 e4       	ldi	r26, 0x48	; 72
    12d6:	b2 e4       	ldi	r27, 0x42	; 66
    12d8:	89 87       	std	Y+9, r24	; 0x09
    12da:	9a 87       	std	Y+10, r25	; 0x0a
    12dc:	ab 87       	std	Y+11, r26	; 0x0b
    12de:	bc 87       	std	Y+12, r27	; 0x0c
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    12e0:	2b ea       	ldi	r18, 0xAB	; 171
    12e2:	3a ea       	ldi	r19, 0xAA	; 170
    12e4:	4a e2       	ldi	r20, 0x2A	; 42
    12e6:	50 e4       	ldi	r21, 0x40	; 64
    12e8:	69 85       	ldd	r22, Y+9	; 0x09
    12ea:	7a 85       	ldd	r23, Y+10	; 0x0a
    12ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    12ee:	9c 85       	ldd	r25, Y+12	; 0x0c
    12f0:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    12f4:	dc 01       	movw	r26, r24
    12f6:	cb 01       	movw	r24, r22
    12f8:	8b af       	std	Y+59, r24	; 0x3b
    12fa:	9c af       	std	Y+60, r25	; 0x3c
    12fc:	ad af       	std	Y+61, r26	; 0x3d
    12fe:	be af       	std	Y+62, r27	; 0x3e
	__tmp2 = ((F_CPU) / 4e6) * __us;
    1300:	8e 01       	movw	r16, r28
    1302:	01 5c       	subi	r16, 0xC1	; 193
    1304:	1f 4f       	sbci	r17, 0xFF	; 255
    1306:	89 85       	ldd	r24, Y+9	; 0x09
    1308:	9a 85       	ldd	r25, Y+10	; 0x0a
    130a:	ab 85       	ldd	r26, Y+11	; 0x0b
    130c:	bc 85       	ldd	r27, Y+12	; 0x0c
    130e:	9c 01       	movw	r18, r24
    1310:	ad 01       	movw	r20, r26
    1312:	bc 01       	movw	r22, r24
    1314:	cd 01       	movw	r24, r26
    1316:	0e 94 dd 2f 	call	0x5fba	; 0x5fba <__addsf3>
    131a:	dc 01       	movw	r26, r24
    131c:	cb 01       	movw	r24, r22
    131e:	f8 01       	movw	r30, r16
    1320:	80 83       	st	Z, r24
    1322:	91 83       	std	Z+1, r25	; 0x01
    1324:	a2 83       	std	Z+2, r26	; 0x02
    1326:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1328:	20 e0       	ldi	r18, 0x00	; 0
    132a:	30 e0       	ldi	r19, 0x00	; 0
    132c:	40 e8       	ldi	r20, 0x80	; 128
    132e:	5f e3       	ldi	r21, 0x3F	; 63
    1330:	6b ad       	ldd	r22, Y+59	; 0x3b
    1332:	7c ad       	ldd	r23, Y+60	; 0x3c
    1334:	8d ad       	ldd	r24, Y+61	; 0x3d
    1336:	9e ad       	ldd	r25, Y+62	; 0x3e
    1338:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    133c:	88 23       	and	r24, r24
    133e:	3c f4       	brge	.+14     	; 0x134e <LCD_initialize+0x3d6>
		__ticks = 1;
    1340:	ce 01       	movw	r24, r28
    1342:	8d 5b       	subi	r24, 0xBD	; 189
    1344:	9f 4f       	sbci	r25, 0xFF	; 255
    1346:	21 e0       	ldi	r18, 0x01	; 1
    1348:	fc 01       	movw	r30, r24
    134a:	20 83       	st	Z, r18
    134c:	22 c1       	rjmp	.+580    	; 0x1592 <LCD_initialize+0x61a>
	else if (__tmp2 > 65535)
    134e:	ce 01       	movw	r24, r28
    1350:	cf 96       	adiw	r24, 0x3f	; 63
    1352:	20 e0       	ldi	r18, 0x00	; 0
    1354:	3f ef       	ldi	r19, 0xFF	; 255
    1356:	4f e7       	ldi	r20, 0x7F	; 127
    1358:	57 e4       	ldi	r21, 0x47	; 71
    135a:	fc 01       	movw	r30, r24
    135c:	60 81       	ld	r22, Z
    135e:	71 81       	ldd	r23, Z+1	; 0x01
    1360:	82 81       	ldd	r24, Z+2	; 0x02
    1362:	93 81       	ldd	r25, Z+3	; 0x03
    1364:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    1368:	18 16       	cp	r1, r24
    136a:	0c f0       	brlt	.+2      	; 0x136e <LCD_initialize+0x3f6>
    136c:	cd c0       	rjmp	.+410    	; 0x1508 <LCD_initialize+0x590>
	{
		_delay_ms(__us / 1000.0);
    136e:	20 e0       	ldi	r18, 0x00	; 0
    1370:	30 e0       	ldi	r19, 0x00	; 0
    1372:	4a e7       	ldi	r20, 0x7A	; 122
    1374:	54 e4       	ldi	r21, 0x44	; 68
    1376:	69 85       	ldd	r22, Y+9	; 0x09
    1378:	7a 85       	ldd	r23, Y+10	; 0x0a
    137a:	8b 85       	ldd	r24, Y+11	; 0x0b
    137c:	9c 85       	ldd	r25, Y+12	; 0x0c
    137e:	0e 94 4e 30 	call	0x609c	; 0x609c <__divsf3>
    1382:	dc 01       	movw	r26, r24
    1384:	cb 01       	movw	r24, r22
    1386:	9e 01       	movw	r18, r28
    1388:	2c 5b       	subi	r18, 0xBC	; 188
    138a:	3f 4f       	sbci	r19, 0xFF	; 255
    138c:	f9 01       	movw	r30, r18
    138e:	80 83       	st	Z, r24
    1390:	91 83       	std	Z+1, r25	; 0x01
    1392:	a2 83       	std	Z+2, r26	; 0x02
    1394:	b3 83       	std	Z+3, r27	; 0x03

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1396:	8e 01       	movw	r16, r28
    1398:	08 5b       	subi	r16, 0xB8	; 184
    139a:	1f 4f       	sbci	r17, 0xFF	; 255
    139c:	ce 01       	movw	r24, r28
    139e:	8c 5b       	subi	r24, 0xBC	; 188
    13a0:	9f 4f       	sbci	r25, 0xFF	; 255
    13a2:	20 e0       	ldi	r18, 0x00	; 0
    13a4:	30 e0       	ldi	r19, 0x00	; 0
    13a6:	4a ef       	ldi	r20, 0xFA	; 250
    13a8:	54 e4       	ldi	r21, 0x44	; 68
    13aa:	fc 01       	movw	r30, r24
    13ac:	60 81       	ld	r22, Z
    13ae:	71 81       	ldd	r23, Z+1	; 0x01
    13b0:	82 81       	ldd	r24, Z+2	; 0x02
    13b2:	93 81       	ldd	r25, Z+3	; 0x03
    13b4:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    13b8:	dc 01       	movw	r26, r24
    13ba:	cb 01       	movw	r24, r22
    13bc:	f8 01       	movw	r30, r16
    13be:	80 83       	st	Z, r24
    13c0:	91 83       	std	Z+1, r25	; 0x01
    13c2:	a2 83       	std	Z+2, r26	; 0x02
    13c4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    13c6:	ce 01       	movw	r24, r28
    13c8:	88 5b       	subi	r24, 0xB8	; 184
    13ca:	9f 4f       	sbci	r25, 0xFF	; 255
    13cc:	20 e0       	ldi	r18, 0x00	; 0
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	40 e8       	ldi	r20, 0x80	; 128
    13d2:	5f e3       	ldi	r21, 0x3F	; 63
    13d4:	fc 01       	movw	r30, r24
    13d6:	60 81       	ld	r22, Z
    13d8:	71 81       	ldd	r23, Z+1	; 0x01
    13da:	82 81       	ldd	r24, Z+2	; 0x02
    13dc:	93 81       	ldd	r25, Z+3	; 0x03
    13de:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    13e2:	88 23       	and	r24, r24
    13e4:	4c f4       	brge	.+18     	; 0x13f8 <LCD_initialize+0x480>
		__ticks = 1;
    13e6:	ce 01       	movw	r24, r28
    13e8:	84 5b       	subi	r24, 0xB4	; 180
    13ea:	9f 4f       	sbci	r25, 0xFF	; 255
    13ec:	21 e0       	ldi	r18, 0x01	; 1
    13ee:	30 e0       	ldi	r19, 0x00	; 0
    13f0:	fc 01       	movw	r30, r24
    13f2:	31 83       	std	Z+1, r19	; 0x01
    13f4:	20 83       	st	Z, r18
    13f6:	6d c0       	rjmp	.+218    	; 0x14d2 <LCD_initialize+0x55a>
	else if (__tmp > 65535)
    13f8:	ce 01       	movw	r24, r28
    13fa:	88 5b       	subi	r24, 0xB8	; 184
    13fc:	9f 4f       	sbci	r25, 0xFF	; 255
    13fe:	20 e0       	ldi	r18, 0x00	; 0
    1400:	3f ef       	ldi	r19, 0xFF	; 255
    1402:	4f e7       	ldi	r20, 0x7F	; 127
    1404:	57 e4       	ldi	r21, 0x47	; 71
    1406:	fc 01       	movw	r30, r24
    1408:	60 81       	ld	r22, Z
    140a:	71 81       	ldd	r23, Z+1	; 0x01
    140c:	82 81       	ldd	r24, Z+2	; 0x02
    140e:	93 81       	ldd	r25, Z+3	; 0x03
    1410:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    1414:	18 16       	cp	r1, r24
    1416:	0c f0       	brlt	.+2      	; 0x141a <LCD_initialize+0x4a2>
    1418:	4a c0       	rjmp	.+148    	; 0x14ae <LCD_initialize+0x536>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    141a:	ce 01       	movw	r24, r28
    141c:	8c 5b       	subi	r24, 0xBC	; 188
    141e:	9f 4f       	sbci	r25, 0xFF	; 255
    1420:	20 e0       	ldi	r18, 0x00	; 0
    1422:	30 e0       	ldi	r19, 0x00	; 0
    1424:	40 e2       	ldi	r20, 0x20	; 32
    1426:	51 e4       	ldi	r21, 0x41	; 65
    1428:	fc 01       	movw	r30, r24
    142a:	60 81       	ld	r22, Z
    142c:	71 81       	ldd	r23, Z+1	; 0x01
    142e:	82 81       	ldd	r24, Z+2	; 0x02
    1430:	93 81       	ldd	r25, Z+3	; 0x03
    1432:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1436:	dc 01       	movw	r26, r24
    1438:	cb 01       	movw	r24, r22
    143a:	8e 01       	movw	r16, r28
    143c:	04 5b       	subi	r16, 0xB4	; 180
    143e:	1f 4f       	sbci	r17, 0xFF	; 255
    1440:	bc 01       	movw	r22, r24
    1442:	cd 01       	movw	r24, r26
    1444:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1448:	dc 01       	movw	r26, r24
    144a:	cb 01       	movw	r24, r22
    144c:	f8 01       	movw	r30, r16
    144e:	91 83       	std	Z+1, r25	; 0x01
    1450:	80 83       	st	Z, r24
    1452:	24 c0       	rjmp	.+72     	; 0x149c <LCD_initialize+0x524>
    1454:	ce 01       	movw	r24, r28
    1456:	82 5b       	subi	r24, 0xB2	; 178
    1458:	9f 4f       	sbci	r25, 0xFF	; 255
    145a:	28 ec       	ldi	r18, 0xC8	; 200
    145c:	30 e0       	ldi	r19, 0x00	; 0
    145e:	fc 01       	movw	r30, r24
    1460:	31 83       	std	Z+1, r19	; 0x01
    1462:	20 83       	st	Z, r18
    1464:	ce 01       	movw	r24, r28
    1466:	82 5b       	subi	r24, 0xB2	; 178
    1468:	9f 4f       	sbci	r25, 0xFF	; 255
    146a:	fc 01       	movw	r30, r24
    146c:	80 81       	ld	r24, Z
    146e:	91 81       	ldd	r25, Z+1	; 0x01
    1470:	01 97       	sbiw	r24, 0x01	; 1
    1472:	f1 f7       	brne	.-4      	; 0x1470 <LCD_initialize+0x4f8>
    1474:	9e 01       	movw	r18, r28
    1476:	22 5b       	subi	r18, 0xB2	; 178
    1478:	3f 4f       	sbci	r19, 0xFF	; 255
    147a:	f9 01       	movw	r30, r18
    147c:	91 83       	std	Z+1, r25	; 0x01
    147e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1480:	ce 01       	movw	r24, r28
    1482:	84 5b       	subi	r24, 0xB4	; 180
    1484:	9f 4f       	sbci	r25, 0xFF	; 255
    1486:	9e 01       	movw	r18, r28
    1488:	24 5b       	subi	r18, 0xB4	; 180
    148a:	3f 4f       	sbci	r19, 0xFF	; 255
    148c:	f9 01       	movw	r30, r18
    148e:	20 81       	ld	r18, Z
    1490:	31 81       	ldd	r19, Z+1	; 0x01
    1492:	21 50       	subi	r18, 0x01	; 1
    1494:	31 09       	sbc	r19, r1
    1496:	fc 01       	movw	r30, r24
    1498:	31 83       	std	Z+1, r19	; 0x01
    149a:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    149c:	ce 01       	movw	r24, r28
    149e:	84 5b       	subi	r24, 0xB4	; 180
    14a0:	9f 4f       	sbci	r25, 0xFF	; 255
    14a2:	fc 01       	movw	r30, r24
    14a4:	80 81       	ld	r24, Z
    14a6:	91 81       	ldd	r25, Z+1	; 0x01
    14a8:	89 2b       	or	r24, r25
    14aa:	a1 f6       	brne	.-88     	; 0x1454 <LCD_initialize+0x4dc>
    14ac:	72 c0       	rjmp	.+228    	; 0x1592 <LCD_initialize+0x61a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14ae:	8e 01       	movw	r16, r28
    14b0:	04 5b       	subi	r16, 0xB4	; 180
    14b2:	1f 4f       	sbci	r17, 0xFF	; 255
    14b4:	ce 01       	movw	r24, r28
    14b6:	88 5b       	subi	r24, 0xB8	; 184
    14b8:	9f 4f       	sbci	r25, 0xFF	; 255
    14ba:	fc 01       	movw	r30, r24
    14bc:	60 81       	ld	r22, Z
    14be:	71 81       	ldd	r23, Z+1	; 0x01
    14c0:	82 81       	ldd	r24, Z+2	; 0x02
    14c2:	93 81       	ldd	r25, Z+3	; 0x03
    14c4:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    14c8:	dc 01       	movw	r26, r24
    14ca:	cb 01       	movw	r24, r22
    14cc:	f8 01       	movw	r30, r16
    14ce:	91 83       	std	Z+1, r25	; 0x01
    14d0:	80 83       	st	Z, r24
    14d2:	ce 01       	movw	r24, r28
    14d4:	80 5b       	subi	r24, 0xB0	; 176
    14d6:	9f 4f       	sbci	r25, 0xFF	; 255
    14d8:	9e 01       	movw	r18, r28
    14da:	24 5b       	subi	r18, 0xB4	; 180
    14dc:	3f 4f       	sbci	r19, 0xFF	; 255
    14de:	f9 01       	movw	r30, r18
    14e0:	20 81       	ld	r18, Z
    14e2:	31 81       	ldd	r19, Z+1	; 0x01
    14e4:	fc 01       	movw	r30, r24
    14e6:	31 83       	std	Z+1, r19	; 0x01
    14e8:	20 83       	st	Z, r18
    14ea:	ce 01       	movw	r24, r28
    14ec:	80 5b       	subi	r24, 0xB0	; 176
    14ee:	9f 4f       	sbci	r25, 0xFF	; 255
    14f0:	fc 01       	movw	r30, r24
    14f2:	80 81       	ld	r24, Z
    14f4:	91 81       	ldd	r25, Z+1	; 0x01
    14f6:	01 97       	sbiw	r24, 0x01	; 1
    14f8:	f1 f7       	brne	.-4      	; 0x14f6 <LCD_initialize+0x57e>
    14fa:	9e 01       	movw	r18, r28
    14fc:	20 5b       	subi	r18, 0xB0	; 176
    14fe:	3f 4f       	sbci	r19, 0xFF	; 255
    1500:	f9 01       	movw	r30, r18
    1502:	91 83       	std	Z+1, r25	; 0x01
    1504:	80 83       	st	Z, r24
    1506:	45 c0       	rjmp	.+138    	; 0x1592 <LCD_initialize+0x61a>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    1508:	20 e0       	ldi	r18, 0x00	; 0
    150a:	30 e0       	ldi	r19, 0x00	; 0
    150c:	4f e7       	ldi	r20, 0x7F	; 127
    150e:	53 e4       	ldi	r21, 0x43	; 67
    1510:	6b ad       	ldd	r22, Y+59	; 0x3b
    1512:	7c ad       	ldd	r23, Y+60	; 0x3c
    1514:	8d ad       	ldd	r24, Y+61	; 0x3d
    1516:	9e ad       	ldd	r25, Y+62	; 0x3e
    1518:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    151c:	18 16       	cp	r1, r24
    151e:	64 f5       	brge	.+88     	; 0x1578 <LCD_initialize+0x600>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    1520:	8e 01       	movw	r16, r28
    1522:	0e 5a       	subi	r16, 0xAE	; 174
    1524:	1f 4f       	sbci	r17, 0xFF	; 255
    1526:	ce 01       	movw	r24, r28
    1528:	cf 96       	adiw	r24, 0x3f	; 63
    152a:	fc 01       	movw	r30, r24
    152c:	60 81       	ld	r22, Z
    152e:	71 81       	ldd	r23, Z+1	; 0x01
    1530:	82 81       	ldd	r24, Z+2	; 0x02
    1532:	93 81       	ldd	r25, Z+3	; 0x03
    1534:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1538:	dc 01       	movw	r26, r24
    153a:	cb 01       	movw	r24, r22
    153c:	f8 01       	movw	r30, r16
    153e:	91 83       	std	Z+1, r25	; 0x01
    1540:	80 83       	st	Z, r24
    1542:	ce 01       	movw	r24, r28
    1544:	8c 5a       	subi	r24, 0xAC	; 172
    1546:	9f 4f       	sbci	r25, 0xFF	; 255
    1548:	9e 01       	movw	r18, r28
    154a:	2e 5a       	subi	r18, 0xAE	; 174
    154c:	3f 4f       	sbci	r19, 0xFF	; 255
    154e:	f9 01       	movw	r30, r18
    1550:	20 81       	ld	r18, Z
    1552:	31 81       	ldd	r19, Z+1	; 0x01
    1554:	fc 01       	movw	r30, r24
    1556:	31 83       	std	Z+1, r19	; 0x01
    1558:	20 83       	st	Z, r18
    155a:	ce 01       	movw	r24, r28
    155c:	8c 5a       	subi	r24, 0xAC	; 172
    155e:	9f 4f       	sbci	r25, 0xFF	; 255
    1560:	fc 01       	movw	r30, r24
    1562:	80 81       	ld	r24, Z
    1564:	91 81       	ldd	r25, Z+1	; 0x01
    1566:	01 97       	sbiw	r24, 0x01	; 1
    1568:	f1 f7       	brne	.-4      	; 0x1566 <LCD_initialize+0x5ee>
    156a:	9e 01       	movw	r18, r28
    156c:	2c 5a       	subi	r18, 0xAC	; 172
    156e:	3f 4f       	sbci	r19, 0xFF	; 255
    1570:	f9 01       	movw	r30, r18
    1572:	91 83       	std	Z+1, r25	; 0x01
    1574:	80 83       	st	Z, r24
    1576:	24 c0       	rjmp	.+72     	; 0x15c0 <LCD_initialize+0x648>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1578:	8e 01       	movw	r16, r28
    157a:	0d 5b       	subi	r16, 0xBD	; 189
    157c:	1f 4f       	sbci	r17, 0xFF	; 255
    157e:	6b ad       	ldd	r22, Y+59	; 0x3b
    1580:	7c ad       	ldd	r23, Y+60	; 0x3c
    1582:	8d ad       	ldd	r24, Y+61	; 0x3d
    1584:	9e ad       	ldd	r25, Y+62	; 0x3e
    1586:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    158a:	dc 01       	movw	r26, r24
    158c:	cb 01       	movw	r24, r22
    158e:	f8 01       	movw	r30, r16
    1590:	80 83       	st	Z, r24
    1592:	ce 01       	movw	r24, r28
    1594:	8a 5a       	subi	r24, 0xAA	; 170
    1596:	9f 4f       	sbci	r25, 0xFF	; 255
    1598:	9e 01       	movw	r18, r28
    159a:	2d 5b       	subi	r18, 0xBD	; 189
    159c:	3f 4f       	sbci	r19, 0xFF	; 255
    159e:	f9 01       	movw	r30, r18
    15a0:	20 81       	ld	r18, Z
    15a2:	fc 01       	movw	r30, r24
    15a4:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    15a6:	ce 01       	movw	r24, r28
    15a8:	8a 5a       	subi	r24, 0xAA	; 170
    15aa:	9f 4f       	sbci	r25, 0xFF	; 255
    15ac:	fc 01       	movw	r30, r24
    15ae:	80 81       	ld	r24, Z
    15b0:	28 2f       	mov	r18, r24
    15b2:	2a 95       	dec	r18
    15b4:	f1 f7       	brne	.-4      	; 0x15b2 <LCD_initialize+0x63a>
    15b6:	ce 01       	movw	r24, r28
    15b8:	8a 5a       	subi	r24, 0xAA	; 170
    15ba:	9f 4f       	sbci	r25, 0xFF	; 255
    15bc:	fc 01       	movw	r30, r24
    15be:	20 83       	st	Z, r18
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00001100);
    15c0:	8c e0       	ldi	r24, 0x0C	; 12
    15c2:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	a8 e4       	ldi	r26, 0x48	; 72
    15cc:	b2 e4       	ldi	r27, 0x42	; 66
    15ce:	8d 87       	std	Y+13, r24	; 0x0d
    15d0:	9e 87       	std	Y+14, r25	; 0x0e
    15d2:	af 87       	std	Y+15, r26	; 0x0f
    15d4:	b8 8b       	std	Y+16, r27	; 0x10
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    15d6:	2b ea       	ldi	r18, 0xAB	; 171
    15d8:	3a ea       	ldi	r19, 0xAA	; 170
    15da:	4a e2       	ldi	r20, 0x2A	; 42
    15dc:	50 e4       	ldi	r21, 0x40	; 64
    15de:	6d 85       	ldd	r22, Y+13	; 0x0d
    15e0:	7e 85       	ldd	r23, Y+14	; 0x0e
    15e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    15e4:	98 89       	ldd	r25, Y+16	; 0x10
    15e6:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    15ea:	dc 01       	movw	r26, r24
    15ec:	cb 01       	movw	r24, r22
    15ee:	8f 8f       	std	Y+31, r24	; 0x1f
    15f0:	98 a3       	std	Y+32, r25	; 0x20
    15f2:	a9 a3       	std	Y+33, r26	; 0x21
    15f4:	ba a3       	std	Y+34, r27	; 0x22
	__tmp2 = ((F_CPU) / 4e6) * __us;
    15f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    15f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    15fa:	af 85       	ldd	r26, Y+15	; 0x0f
    15fc:	b8 89       	ldd	r27, Y+16	; 0x10
    15fe:	9c 01       	movw	r18, r24
    1600:	ad 01       	movw	r20, r26
    1602:	bc 01       	movw	r22, r24
    1604:	cd 01       	movw	r24, r26
    1606:	0e 94 dd 2f 	call	0x5fba	; 0x5fba <__addsf3>
    160a:	dc 01       	movw	r26, r24
    160c:	cb 01       	movw	r24, r22
    160e:	8b a3       	std	Y+35, r24	; 0x23
    1610:	9c a3       	std	Y+36, r25	; 0x24
    1612:	ad a3       	std	Y+37, r26	; 0x25
    1614:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1616:	20 e0       	ldi	r18, 0x00	; 0
    1618:	30 e0       	ldi	r19, 0x00	; 0
    161a:	40 e8       	ldi	r20, 0x80	; 128
    161c:	5f e3       	ldi	r21, 0x3F	; 63
    161e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1620:	78 a1       	ldd	r23, Y+32	; 0x20
    1622:	89 a1       	ldd	r24, Y+33	; 0x21
    1624:	9a a1       	ldd	r25, Y+34	; 0x22
    1626:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    162a:	88 23       	and	r24, r24
    162c:	1c f4       	brge	.+6      	; 0x1634 <LCD_initialize+0x6bc>
		__ticks = 1;
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	8f a3       	std	Y+39, r24	; 0x27
    1632:	b2 c0       	rjmp	.+356    	; 0x1798 <LCD_initialize+0x820>
	else if (__tmp2 > 65535)
    1634:	20 e0       	ldi	r18, 0x00	; 0
    1636:	3f ef       	ldi	r19, 0xFF	; 255
    1638:	4f e7       	ldi	r20, 0x7F	; 127
    163a:	57 e4       	ldi	r21, 0x47	; 71
    163c:	6b a1       	ldd	r22, Y+35	; 0x23
    163e:	7c a1       	ldd	r23, Y+36	; 0x24
    1640:	8d a1       	ldd	r24, Y+37	; 0x25
    1642:	9e a1       	ldd	r25, Y+38	; 0x26
    1644:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    1648:	18 16       	cp	r1, r24
    164a:	0c f0       	brlt	.+2      	; 0x164e <LCD_initialize+0x6d6>
    164c:	7b c0       	rjmp	.+246    	; 0x1744 <LCD_initialize+0x7cc>
	{
		_delay_ms(__us / 1000.0);
    164e:	20 e0       	ldi	r18, 0x00	; 0
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	4a e7       	ldi	r20, 0x7A	; 122
    1654:	54 e4       	ldi	r21, 0x44	; 68
    1656:	6d 85       	ldd	r22, Y+13	; 0x0d
    1658:	7e 85       	ldd	r23, Y+14	; 0x0e
    165a:	8f 85       	ldd	r24, Y+15	; 0x0f
    165c:	98 89       	ldd	r25, Y+16	; 0x10
    165e:	0e 94 4e 30 	call	0x609c	; 0x609c <__divsf3>
    1662:	dc 01       	movw	r26, r24
    1664:	cb 01       	movw	r24, r22
    1666:	88 a7       	std	Y+40, r24	; 0x28
    1668:	99 a7       	std	Y+41, r25	; 0x29
    166a:	aa a7       	std	Y+42, r26	; 0x2a
    166c:	bb a7       	std	Y+43, r27	; 0x2b

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    166e:	20 e0       	ldi	r18, 0x00	; 0
    1670:	30 e0       	ldi	r19, 0x00	; 0
    1672:	4a ef       	ldi	r20, 0xFA	; 250
    1674:	54 e4       	ldi	r21, 0x44	; 68
    1676:	68 a5       	ldd	r22, Y+40	; 0x28
    1678:	79 a5       	ldd	r23, Y+41	; 0x29
    167a:	8a a5       	ldd	r24, Y+42	; 0x2a
    167c:	9b a5       	ldd	r25, Y+43	; 0x2b
    167e:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1682:	dc 01       	movw	r26, r24
    1684:	cb 01       	movw	r24, r22
    1686:	8c a7       	std	Y+44, r24	; 0x2c
    1688:	9d a7       	std	Y+45, r25	; 0x2d
    168a:	ae a7       	std	Y+46, r26	; 0x2e
    168c:	bf a7       	std	Y+47, r27	; 0x2f
	if (__tmp < 1.0)
    168e:	20 e0       	ldi	r18, 0x00	; 0
    1690:	30 e0       	ldi	r19, 0x00	; 0
    1692:	40 e8       	ldi	r20, 0x80	; 128
    1694:	5f e3       	ldi	r21, 0x3F	; 63
    1696:	6c a5       	ldd	r22, Y+44	; 0x2c
    1698:	7d a5       	ldd	r23, Y+45	; 0x2d
    169a:	8e a5       	ldd	r24, Y+46	; 0x2e
    169c:	9f a5       	ldd	r25, Y+47	; 0x2f
    169e:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    16a2:	88 23       	and	r24, r24
    16a4:	2c f4       	brge	.+10     	; 0x16b0 <LCD_initialize+0x738>
		__ticks = 1;
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	99 ab       	std	Y+49, r25	; 0x31
    16ac:	88 ab       	std	Y+48, r24	; 0x30
    16ae:	3f c0       	rjmp	.+126    	; 0x172e <LCD_initialize+0x7b6>
	else if (__tmp > 65535)
    16b0:	20 e0       	ldi	r18, 0x00	; 0
    16b2:	3f ef       	ldi	r19, 0xFF	; 255
    16b4:	4f e7       	ldi	r20, 0x7F	; 127
    16b6:	57 e4       	ldi	r21, 0x47	; 71
    16b8:	6c a5       	ldd	r22, Y+44	; 0x2c
    16ba:	7d a5       	ldd	r23, Y+45	; 0x2d
    16bc:	8e a5       	ldd	r24, Y+46	; 0x2e
    16be:	9f a5       	ldd	r25, Y+47	; 0x2f
    16c0:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    16c4:	18 16       	cp	r1, r24
    16c6:	4c f5       	brge	.+82     	; 0x171a <LCD_initialize+0x7a2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    16c8:	20 e0       	ldi	r18, 0x00	; 0
    16ca:	30 e0       	ldi	r19, 0x00	; 0
    16cc:	40 e2       	ldi	r20, 0x20	; 32
    16ce:	51 e4       	ldi	r21, 0x41	; 65
    16d0:	68 a5       	ldd	r22, Y+40	; 0x28
    16d2:	79 a5       	ldd	r23, Y+41	; 0x29
    16d4:	8a a5       	ldd	r24, Y+42	; 0x2a
    16d6:	9b a5       	ldd	r25, Y+43	; 0x2b
    16d8:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    16dc:	dc 01       	movw	r26, r24
    16de:	cb 01       	movw	r24, r22
    16e0:	bc 01       	movw	r22, r24
    16e2:	cd 01       	movw	r24, r26
    16e4:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    16e8:	dc 01       	movw	r26, r24
    16ea:	cb 01       	movw	r24, r22
    16ec:	99 ab       	std	Y+49, r25	; 0x31
    16ee:	88 ab       	std	Y+48, r24	; 0x30
    16f0:	0f c0       	rjmp	.+30     	; 0x1710 <LCD_initialize+0x798>
    16f2:	88 ec       	ldi	r24, 0xC8	; 200
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	9b ab       	std	Y+51, r25	; 0x33
    16f8:	8a ab       	std	Y+50, r24	; 0x32
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    16fa:	8a a9       	ldd	r24, Y+50	; 0x32
    16fc:	9b a9       	ldd	r25, Y+51	; 0x33
    16fe:	01 97       	sbiw	r24, 0x01	; 1
    1700:	f1 f7       	brne	.-4      	; 0x16fe <LCD_initialize+0x786>
    1702:	9b ab       	std	Y+51, r25	; 0x33
    1704:	8a ab       	std	Y+50, r24	; 0x32
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1706:	88 a9       	ldd	r24, Y+48	; 0x30
    1708:	99 a9       	ldd	r25, Y+49	; 0x31
    170a:	01 97       	sbiw	r24, 0x01	; 1
    170c:	99 ab       	std	Y+49, r25	; 0x31
    170e:	88 ab       	std	Y+48, r24	; 0x30
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1710:	88 a9       	ldd	r24, Y+48	; 0x30
    1712:	99 a9       	ldd	r25, Y+49	; 0x31
    1714:	89 2b       	or	r24, r25
    1716:	69 f7       	brne	.-38     	; 0x16f2 <LCD_initialize+0x77a>
    1718:	3f c0       	rjmp	.+126    	; 0x1798 <LCD_initialize+0x820>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    171a:	6c a5       	ldd	r22, Y+44	; 0x2c
    171c:	7d a5       	ldd	r23, Y+45	; 0x2d
    171e:	8e a5       	ldd	r24, Y+46	; 0x2e
    1720:	9f a5       	ldd	r25, Y+47	; 0x2f
    1722:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1726:	dc 01       	movw	r26, r24
    1728:	cb 01       	movw	r24, r22
    172a:	99 ab       	std	Y+49, r25	; 0x31
    172c:	88 ab       	std	Y+48, r24	; 0x30
    172e:	88 a9       	ldd	r24, Y+48	; 0x30
    1730:	99 a9       	ldd	r25, Y+49	; 0x31
    1732:	9d ab       	std	Y+53, r25	; 0x35
    1734:	8c ab       	std	Y+52, r24	; 0x34
    1736:	8c a9       	ldd	r24, Y+52	; 0x34
    1738:	9d a9       	ldd	r25, Y+53	; 0x35
    173a:	01 97       	sbiw	r24, 0x01	; 1
    173c:	f1 f7       	brne	.-4      	; 0x173a <LCD_initialize+0x7c2>
    173e:	9d ab       	std	Y+53, r25	; 0x35
    1740:	8c ab       	std	Y+52, r24	; 0x34
    1742:	2a c0       	rjmp	.+84     	; 0x1798 <LCD_initialize+0x820>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    1744:	20 e0       	ldi	r18, 0x00	; 0
    1746:	30 e0       	ldi	r19, 0x00	; 0
    1748:	4f e7       	ldi	r20, 0x7F	; 127
    174a:	53 e4       	ldi	r21, 0x43	; 67
    174c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    174e:	78 a1       	ldd	r23, Y+32	; 0x20
    1750:	89 a1       	ldd	r24, Y+33	; 0x21
    1752:	9a a1       	ldd	r25, Y+34	; 0x22
    1754:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    1758:	18 16       	cp	r1, r24
    175a:	ac f4       	brge	.+42     	; 0x1786 <LCD_initialize+0x80e>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    175c:	6b a1       	ldd	r22, Y+35	; 0x23
    175e:	7c a1       	ldd	r23, Y+36	; 0x24
    1760:	8d a1       	ldd	r24, Y+37	; 0x25
    1762:	9e a1       	ldd	r25, Y+38	; 0x26
    1764:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1768:	dc 01       	movw	r26, r24
    176a:	cb 01       	movw	r24, r22
    176c:	9f ab       	std	Y+55, r25	; 0x37
    176e:	8e ab       	std	Y+54, r24	; 0x36
    1770:	8e a9       	ldd	r24, Y+54	; 0x36
    1772:	9f a9       	ldd	r25, Y+55	; 0x37
    1774:	99 af       	std	Y+57, r25	; 0x39
    1776:	88 af       	std	Y+56, r24	; 0x38
    1778:	88 ad       	ldd	r24, Y+56	; 0x38
    177a:	99 ad       	ldd	r25, Y+57	; 0x39
    177c:	01 97       	sbiw	r24, 0x01	; 1
    177e:	f1 f7       	brne	.-4      	; 0x177c <LCD_initialize+0x804>
    1780:	99 af       	std	Y+57, r25	; 0x39
    1782:	88 af       	std	Y+56, r24	; 0x38
    1784:	0f c0       	rjmp	.+30     	; 0x17a4 <LCD_initialize+0x82c>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1786:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1788:	78 a1       	ldd	r23, Y+32	; 0x20
    178a:	89 a1       	ldd	r24, Y+33	; 0x21
    178c:	9a a1       	ldd	r25, Y+34	; 0x22
    178e:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1792:	dc 01       	movw	r26, r24
    1794:	cb 01       	movw	r24, r22
    1796:	8f a3       	std	Y+39, r24	; 0x27
    1798:	8f a1       	ldd	r24, Y+39	; 0x27
    179a:	8a af       	std	Y+58, r24	; 0x3a
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    179c:	8a ad       	ldd	r24, Y+58	; 0x3a
    179e:	8a 95       	dec	r24
    17a0:	f1 f7       	brne	.-4      	; 0x179e <LCD_initialize+0x826>
    17a2:	8a af       	std	Y+58, r24	; 0x3a
	_delay_us(50);
	LCD_Void_Write_Cmd(0b00000001);
    17a4:	81 e0       	ldi	r24, 0x01	; 1
    17a6:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
    17aa:	80 e0       	ldi	r24, 0x00	; 0
    17ac:	90 e0       	ldi	r25, 0x00	; 0
    17ae:	a0 e0       	ldi	r26, 0x00	; 0
    17b0:	b0 e4       	ldi	r27, 0x40	; 64
    17b2:	89 8b       	std	Y+17, r24	; 0x11
    17b4:	9a 8b       	std	Y+18, r25	; 0x12
    17b6:	ab 8b       	std	Y+19, r26	; 0x13
    17b8:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    17ba:	20 e0       	ldi	r18, 0x00	; 0
    17bc:	30 e0       	ldi	r19, 0x00	; 0
    17be:	4a ef       	ldi	r20, 0xFA	; 250
    17c0:	54 e4       	ldi	r21, 0x44	; 68
    17c2:	69 89       	ldd	r22, Y+17	; 0x11
    17c4:	7a 89       	ldd	r23, Y+18	; 0x12
    17c6:	8b 89       	ldd	r24, Y+19	; 0x13
    17c8:	9c 89       	ldd	r25, Y+20	; 0x14
    17ca:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    17ce:	dc 01       	movw	r26, r24
    17d0:	cb 01       	movw	r24, r22
    17d2:	8d 8b       	std	Y+21, r24	; 0x15
    17d4:	9e 8b       	std	Y+22, r25	; 0x16
    17d6:	af 8b       	std	Y+23, r26	; 0x17
    17d8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    17da:	20 e0       	ldi	r18, 0x00	; 0
    17dc:	30 e0       	ldi	r19, 0x00	; 0
    17de:	40 e8       	ldi	r20, 0x80	; 128
    17e0:	5f e3       	ldi	r21, 0x3F	; 63
    17e2:	6d 89       	ldd	r22, Y+21	; 0x15
    17e4:	7e 89       	ldd	r23, Y+22	; 0x16
    17e6:	8f 89       	ldd	r24, Y+23	; 0x17
    17e8:	98 8d       	ldd	r25, Y+24	; 0x18
    17ea:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    17ee:	88 23       	and	r24, r24
    17f0:	2c f4       	brge	.+10     	; 0x17fc <LCD_initialize+0x884>
		__ticks = 1;
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	9a 8f       	std	Y+26, r25	; 0x1a
    17f8:	89 8f       	std	Y+25, r24	; 0x19
    17fa:	3f c0       	rjmp	.+126    	; 0x187a <LCD_initialize+0x902>
	else if (__tmp > 65535)
    17fc:	20 e0       	ldi	r18, 0x00	; 0
    17fe:	3f ef       	ldi	r19, 0xFF	; 255
    1800:	4f e7       	ldi	r20, 0x7F	; 127
    1802:	57 e4       	ldi	r21, 0x47	; 71
    1804:	6d 89       	ldd	r22, Y+21	; 0x15
    1806:	7e 89       	ldd	r23, Y+22	; 0x16
    1808:	8f 89       	ldd	r24, Y+23	; 0x17
    180a:	98 8d       	ldd	r25, Y+24	; 0x18
    180c:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    1810:	18 16       	cp	r1, r24
    1812:	4c f5       	brge	.+82     	; 0x1866 <LCD_initialize+0x8ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1814:	20 e0       	ldi	r18, 0x00	; 0
    1816:	30 e0       	ldi	r19, 0x00	; 0
    1818:	40 e2       	ldi	r20, 0x20	; 32
    181a:	51 e4       	ldi	r21, 0x41	; 65
    181c:	69 89       	ldd	r22, Y+17	; 0x11
    181e:	7a 89       	ldd	r23, Y+18	; 0x12
    1820:	8b 89       	ldd	r24, Y+19	; 0x13
    1822:	9c 89       	ldd	r25, Y+20	; 0x14
    1824:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1828:	dc 01       	movw	r26, r24
    182a:	cb 01       	movw	r24, r22
    182c:	bc 01       	movw	r22, r24
    182e:	cd 01       	movw	r24, r26
    1830:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1834:	dc 01       	movw	r26, r24
    1836:	cb 01       	movw	r24, r22
    1838:	9a 8f       	std	Y+26, r25	; 0x1a
    183a:	89 8f       	std	Y+25, r24	; 0x19
    183c:	0f c0       	rjmp	.+30     	; 0x185c <LCD_initialize+0x8e4>
    183e:	88 ec       	ldi	r24, 0xC8	; 200
    1840:	90 e0       	ldi	r25, 0x00	; 0
    1842:	9c 8f       	std	Y+28, r25	; 0x1c
    1844:	8b 8f       	std	Y+27, r24	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1846:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1848:	9c 8d       	ldd	r25, Y+28	; 0x1c
    184a:	01 97       	sbiw	r24, 0x01	; 1
    184c:	f1 f7       	brne	.-4      	; 0x184a <LCD_initialize+0x8d2>
    184e:	9c 8f       	std	Y+28, r25	; 0x1c
    1850:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1852:	89 8d       	ldd	r24, Y+25	; 0x19
    1854:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1856:	01 97       	sbiw	r24, 0x01	; 1
    1858:	9a 8f       	std	Y+26, r25	; 0x1a
    185a:	89 8f       	std	Y+25, r24	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    185c:	89 8d       	ldd	r24, Y+25	; 0x19
    185e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1860:	89 2b       	or	r24, r25
    1862:	69 f7       	brne	.-38     	; 0x183e <LCD_initialize+0x8c6>
	_delay_ms(2);

}
    1864:	14 c0       	rjmp	.+40     	; 0x188e <LCD_initialize+0x916>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1866:	6d 89       	ldd	r22, Y+21	; 0x15
    1868:	7e 89       	ldd	r23, Y+22	; 0x16
    186a:	8f 89       	ldd	r24, Y+23	; 0x17
    186c:	98 8d       	ldd	r25, Y+24	; 0x18
    186e:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1872:	dc 01       	movw	r26, r24
    1874:	cb 01       	movw	r24, r22
    1876:	9a 8f       	std	Y+26, r25	; 0x1a
    1878:	89 8f       	std	Y+25, r24	; 0x19
    187a:	89 8d       	ldd	r24, Y+25	; 0x19
    187c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    187e:	9e 8f       	std	Y+30, r25	; 0x1e
    1880:	8d 8f       	std	Y+29, r24	; 0x1d
    1882:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1884:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1886:	01 97       	sbiw	r24, 0x01	; 1
    1888:	f1 f7       	brne	.-4      	; 0x1886 <LCD_initialize+0x90e>
    188a:	9e 8f       	std	Y+30, r25	; 0x1e
    188c:	8d 8f       	std	Y+29, r24	; 0x1d
    188e:	00 00       	nop
    1890:	c6 59       	subi	r28, 0x96	; 150
    1892:	df 4f       	sbci	r29, 0xFF	; 255
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	f8 94       	cli
    1898:	de bf       	out	0x3e, r29	; 62
    189a:	0f be       	out	0x3f, r0	; 63
    189c:	cd bf       	out	0x3d, r28	; 61
    189e:	df 91       	pop	r29
    18a0:	cf 91       	pop	r28
    18a2:	1f 91       	pop	r17
    18a4:	0f 91       	pop	r16
    18a6:	08 95       	ret

000018a8 <LCD_Void_Write_String>:

void LCD_Void_Write_String(u8* copy_string)
{
    18a8:	cf 93       	push	r28
    18aa:	df 93       	push	r29
    18ac:	00 d0       	rcall	.+0      	; 0x18ae <LCD_Void_Write_String+0x6>
    18ae:	1f 92       	push	r1
    18b0:	cd b7       	in	r28, 0x3d	; 61
    18b2:	de b7       	in	r29, 0x3e	; 62
    18b4:	9b 83       	std	Y+3, r25	; 0x03
    18b6:	8a 83       	std	Y+2, r24	; 0x02
	u8 i = 0;
    18b8:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    18ba:	14 c0       	rjmp	.+40     	; 0x18e4 <LCD_Void_Write_String+0x3c>
	{	if(i==16)
    18bc:	89 81       	ldd	r24, Y+1	; 0x01
    18be:	80 31       	cpi	r24, 0x10	; 16
    18c0:	19 f4       	brne	.+6      	; 0x18c8 <LCD_Void_Write_String+0x20>
		{
			LCD_Set_Block(16);
    18c2:	80 e1       	ldi	r24, 0x10	; 16
    18c4:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
		}
		LCD_Void_Write_Data(copy_string[i]);
    18c8:	89 81       	ldd	r24, Y+1	; 0x01
    18ca:	88 2f       	mov	r24, r24
    18cc:	90 e0       	ldi	r25, 0x00	; 0
    18ce:	2a 81       	ldd	r18, Y+2	; 0x02
    18d0:	3b 81       	ldd	r19, Y+3	; 0x03
    18d2:	82 0f       	add	r24, r18
    18d4:	93 1f       	adc	r25, r19
    18d6:	fc 01       	movw	r30, r24
    18d8:	80 81       	ld	r24, Z
    18da:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
		i++;
    18de:	89 81       	ldd	r24, Y+1	; 0x01
    18e0:	8f 5f       	subi	r24, 0xFF	; 255
    18e2:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    18e4:	89 81       	ldd	r24, Y+1	; 0x01
    18e6:	88 2f       	mov	r24, r24
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	2a 81       	ldd	r18, Y+2	; 0x02
    18ec:	3b 81       	ldd	r19, Y+3	; 0x03
    18ee:	82 0f       	add	r24, r18
    18f0:	93 1f       	adc	r25, r19
    18f2:	fc 01       	movw	r30, r24
    18f4:	80 81       	ld	r24, Z
    18f6:	88 23       	and	r24, r24
    18f8:	09 f7       	brne	.-62     	; 0x18bc <LCD_Void_Write_String+0x14>
			LCD_Set_Block(16);
		}
		LCD_Void_Write_Data(copy_string[i]);
		i++;
	}
}
    18fa:	00 00       	nop
    18fc:	0f 90       	pop	r0
    18fe:	0f 90       	pop	r0
    1900:	0f 90       	pop	r0
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	08 95       	ret

00001908 <LCD_Void_Clear>:

void LCD_Void_Clear(void)
{
    1908:	cf 93       	push	r28
    190a:	df 93       	push	r29
    190c:	cd b7       	in	r28, 0x3d	; 61
    190e:	de b7       	in	r29, 0x3e	; 62
	LCD_Void_Write_Cmd(0b00000001);
    1910:	81 e0       	ldi	r24, 0x01	; 1
    1912:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
}
    1916:	00 00       	nop
    1918:	df 91       	pop	r29
    191a:	cf 91       	pop	r28
    191c:	08 95       	ret

0000191e <LCD_Void_Write_Blinking_String>:

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
    191e:	cf 93       	push	r28
    1920:	df 93       	push	r29
    1922:	cd b7       	in	r28, 0x3d	; 61
    1924:	de b7       	in	r29, 0x3e	; 62
    1926:	61 97       	sbiw	r28, 0x11	; 17
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	de bf       	out	0x3e, r29	; 62
    192e:	0f be       	out	0x3f, r0	; 63
    1930:	cd bf       	out	0x3d, r28	; 61
    1932:	99 8b       	std	Y+17, r25	; 0x11
    1934:	88 8b       	std	Y+16, r24	; 0x10
	u8 i = 0;
    1936:	19 82       	std	Y+1, r1	; 0x01
	while(copy_string[i] != '\0')
    1938:	80 c0       	rjmp	.+256    	; 0x1a3a <LCD_Void_Write_Blinking_String+0x11c>
	{
		LCD_Void_Write_Data(copy_string[i]);
    193a:	89 81       	ldd	r24, Y+1	; 0x01
    193c:	88 2f       	mov	r24, r24
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	28 89       	ldd	r18, Y+16	; 0x10
    1942:	39 89       	ldd	r19, Y+17	; 0x11
    1944:	82 0f       	add	r24, r18
    1946:	93 1f       	adc	r25, r19
    1948:	fc 01       	movw	r30, r24
    194a:	80 81       	ld	r24, Z
    194c:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
    1950:	80 e0       	ldi	r24, 0x00	; 0
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	aa ef       	ldi	r26, 0xFA	; 250
    1956:	b3 e4       	ldi	r27, 0x43	; 67
    1958:	8a 83       	std	Y+2, r24	; 0x02
    195a:	9b 83       	std	Y+3, r25	; 0x03
    195c:	ac 83       	std	Y+4, r26	; 0x04
    195e:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1960:	20 e0       	ldi	r18, 0x00	; 0
    1962:	30 e0       	ldi	r19, 0x00	; 0
    1964:	4a ef       	ldi	r20, 0xFA	; 250
    1966:	54 e4       	ldi	r21, 0x44	; 68
    1968:	6a 81       	ldd	r22, Y+2	; 0x02
    196a:	7b 81       	ldd	r23, Y+3	; 0x03
    196c:	8c 81       	ldd	r24, Y+4	; 0x04
    196e:	9d 81       	ldd	r25, Y+5	; 0x05
    1970:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1974:	dc 01       	movw	r26, r24
    1976:	cb 01       	movw	r24, r22
    1978:	8e 83       	std	Y+6, r24	; 0x06
    197a:	9f 83       	std	Y+7, r25	; 0x07
    197c:	a8 87       	std	Y+8, r26	; 0x08
    197e:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    1980:	20 e0       	ldi	r18, 0x00	; 0
    1982:	30 e0       	ldi	r19, 0x00	; 0
    1984:	40 e8       	ldi	r20, 0x80	; 128
    1986:	5f e3       	ldi	r21, 0x3F	; 63
    1988:	6e 81       	ldd	r22, Y+6	; 0x06
    198a:	7f 81       	ldd	r23, Y+7	; 0x07
    198c:	88 85       	ldd	r24, Y+8	; 0x08
    198e:	99 85       	ldd	r25, Y+9	; 0x09
    1990:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    1994:	88 23       	and	r24, r24
    1996:	2c f4       	brge	.+10     	; 0x19a2 <LCD_Void_Write_Blinking_String+0x84>
		__ticks = 1;
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	90 e0       	ldi	r25, 0x00	; 0
    199c:	9b 87       	std	Y+11, r25	; 0x0b
    199e:	8a 87       	std	Y+10, r24	; 0x0a
    19a0:	3f c0       	rjmp	.+126    	; 0x1a20 <LCD_Void_Write_Blinking_String+0x102>
	else if (__tmp > 65535)
    19a2:	20 e0       	ldi	r18, 0x00	; 0
    19a4:	3f ef       	ldi	r19, 0xFF	; 255
    19a6:	4f e7       	ldi	r20, 0x7F	; 127
    19a8:	57 e4       	ldi	r21, 0x47	; 71
    19aa:	6e 81       	ldd	r22, Y+6	; 0x06
    19ac:	7f 81       	ldd	r23, Y+7	; 0x07
    19ae:	88 85       	ldd	r24, Y+8	; 0x08
    19b0:	99 85       	ldd	r25, Y+9	; 0x09
    19b2:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    19b6:	18 16       	cp	r1, r24
    19b8:	4c f5       	brge	.+82     	; 0x1a0c <LCD_Void_Write_Blinking_String+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19ba:	20 e0       	ldi	r18, 0x00	; 0
    19bc:	30 e0       	ldi	r19, 0x00	; 0
    19be:	40 e2       	ldi	r20, 0x20	; 32
    19c0:	51 e4       	ldi	r21, 0x41	; 65
    19c2:	6a 81       	ldd	r22, Y+2	; 0x02
    19c4:	7b 81       	ldd	r23, Y+3	; 0x03
    19c6:	8c 81       	ldd	r24, Y+4	; 0x04
    19c8:	9d 81       	ldd	r25, Y+5	; 0x05
    19ca:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    19ce:	dc 01       	movw	r26, r24
    19d0:	cb 01       	movw	r24, r22
    19d2:	bc 01       	movw	r22, r24
    19d4:	cd 01       	movw	r24, r26
    19d6:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    19da:	dc 01       	movw	r26, r24
    19dc:	cb 01       	movw	r24, r22
    19de:	9b 87       	std	Y+11, r25	; 0x0b
    19e0:	8a 87       	std	Y+10, r24	; 0x0a
    19e2:	0f c0       	rjmp	.+30     	; 0x1a02 <LCD_Void_Write_Blinking_String+0xe4>
    19e4:	88 ec       	ldi	r24, 0xC8	; 200
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	9d 87       	std	Y+13, r25	; 0x0d
    19ea:	8c 87       	std	Y+12, r24	; 0x0c
    19ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    19ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    19f0:	01 97       	sbiw	r24, 0x01	; 1
    19f2:	f1 f7       	brne	.-4      	; 0x19f0 <LCD_Void_Write_Blinking_String+0xd2>
    19f4:	9d 87       	std	Y+13, r25	; 0x0d
    19f6:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    19fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    19fc:	01 97       	sbiw	r24, 0x01	; 1
    19fe:	9b 87       	std	Y+11, r25	; 0x0b
    1a00:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a02:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a04:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a06:	89 2b       	or	r24, r25
    1a08:	69 f7       	brne	.-38     	; 0x19e4 <LCD_Void_Write_Blinking_String+0xc6>
    1a0a:	14 c0       	rjmp	.+40     	; 0x1a34 <LCD_Void_Write_Blinking_String+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a0c:	6e 81       	ldd	r22, Y+6	; 0x06
    1a0e:	7f 81       	ldd	r23, Y+7	; 0x07
    1a10:	88 85       	ldd	r24, Y+8	; 0x08
    1a12:	99 85       	ldd	r25, Y+9	; 0x09
    1a14:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1a18:	dc 01       	movw	r26, r24
    1a1a:	cb 01       	movw	r24, r22
    1a1c:	9b 87       	std	Y+11, r25	; 0x0b
    1a1e:	8a 87       	std	Y+10, r24	; 0x0a
    1a20:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a22:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a24:	9f 87       	std	Y+15, r25	; 0x0f
    1a26:	8e 87       	std	Y+14, r24	; 0x0e
    1a28:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a2a:	9f 85       	ldd	r25, Y+15	; 0x0f
    1a2c:	01 97       	sbiw	r24, 0x01	; 1
    1a2e:	f1 f7       	brne	.-4      	; 0x1a2c <LCD_Void_Write_Blinking_String+0x10e>
    1a30:	9f 87       	std	Y+15, r25	; 0x0f
    1a32:	8e 87       	std	Y+14, r24	; 0x0e
		_delay_ms(500);
		i++;
    1a34:	89 81       	ldd	r24, Y+1	; 0x01
    1a36:	8f 5f       	subi	r24, 0xFF	; 255
    1a38:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_Void_Write_Blinking_String(u8* copy_string)
{
	u8 i = 0;
	while(copy_string[i] != '\0')
    1a3a:	89 81       	ldd	r24, Y+1	; 0x01
    1a3c:	88 2f       	mov	r24, r24
    1a3e:	90 e0       	ldi	r25, 0x00	; 0
    1a40:	28 89       	ldd	r18, Y+16	; 0x10
    1a42:	39 89       	ldd	r19, Y+17	; 0x11
    1a44:	82 0f       	add	r24, r18
    1a46:	93 1f       	adc	r25, r19
    1a48:	fc 01       	movw	r30, r24
    1a4a:	80 81       	ld	r24, Z
    1a4c:	88 23       	and	r24, r24
    1a4e:	09 f0       	breq	.+2      	; 0x1a52 <LCD_Void_Write_Blinking_String+0x134>
    1a50:	74 cf       	rjmp	.-280    	; 0x193a <LCD_Void_Write_Blinking_String+0x1c>
	{
		LCD_Void_Write_Data(copy_string[i]);
		_delay_ms(500);
		i++;
	}
}
    1a52:	00 00       	nop
    1a54:	61 96       	adiw	r28, 0x11	; 17
    1a56:	0f b6       	in	r0, 0x3f	; 63
    1a58:	f8 94       	cli
    1a5a:	de bf       	out	0x3e, r29	; 62
    1a5c:	0f be       	out	0x3f, r0	; 63
    1a5e:	cd bf       	out	0x3d, r28	; 61
    1a60:	df 91       	pop	r29
    1a62:	cf 91       	pop	r28
    1a64:	08 95       	ret

00001a66 <LCD_Set_Block>:

void LCD_Set_Block(u8 copy_block_nb) // sets the ddram address to the block you want to write
{
    1a66:	cf 93       	push	r28
    1a68:	df 93       	push	r29
    1a6a:	1f 92       	push	r1
    1a6c:	cd b7       	in	r28, 0x3d	; 61
    1a6e:	de b7       	in	r29, 0x3e	; 62
    1a70:	89 83       	std	Y+1, r24	; 0x01
	if(copy_block_nb<16)
    1a72:	89 81       	ldd	r24, Y+1	; 0x01
    1a74:	80 31       	cpi	r24, 0x10	; 16
    1a76:	28 f4       	brcc	.+10     	; 0x1a82 <LCD_Set_Block+0x1c>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
    1a78:	89 81       	ldd	r24, Y+1	; 0x01
    1a7a:	80 58       	subi	r24, 0x80	; 128
    1a7c:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
	}
}
    1a80:	04 c0       	rjmp	.+8      	; 0x1a8a <LCD_Set_Block+0x24>
	{
		LCD_Void_Write_Cmd(128+copy_block_nb);
	}
	else
	{
		LCD_Void_Write_Cmd(176+copy_block_nb);
    1a82:	89 81       	ldd	r24, Y+1	; 0x01
    1a84:	80 55       	subi	r24, 0x50	; 80
    1a86:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
	}
}
    1a8a:	00 00       	nop
    1a8c:	0f 90       	pop	r0
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	08 95       	ret

00001a94 <LCD_Void_Write_Moving_String>:

void LCD_Void_Write_Moving_String(u8* copy_string)
{
    1a94:	cf 93       	push	r28
    1a96:	df 93       	push	r29
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	63 97       	sbiw	r28, 0x13	; 19
    1a9e:	0f b6       	in	r0, 0x3f	; 63
    1aa0:	f8 94       	cli
    1aa2:	de bf       	out	0x3e, r29	; 62
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	cd bf       	out	0x3d, r28	; 61
    1aa8:	9b 8b       	std	Y+19, r25	; 0x13
    1aaa:	8a 8b       	std	Y+18, r24	; 0x12
	u8 i;
	for (int j = 0; j<5 ;j++)
    1aac:	1b 82       	std	Y+3, r1	; 0x03
    1aae:	1a 82       	std	Y+2, r1	; 0x02
    1ab0:	97 c0       	rjmp	.+302    	; 0x1be0 <LCD_Void_Write_Moving_String+0x14c>
	{
		LCD_Set_Block(j);
    1ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab4:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <LCD_Set_Block>
		i = 0;
    1ab8:	19 82       	std	Y+1, r1	; 0x01
		while(copy_string[i] != '\0')
    1aba:	0e c0       	rjmp	.+28     	; 0x1ad8 <LCD_Void_Write_Moving_String+0x44>
		{

			LCD_Void_Write_Data(copy_string[i]);
    1abc:	89 81       	ldd	r24, Y+1	; 0x01
    1abe:	88 2f       	mov	r24, r24
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	2a 89       	ldd	r18, Y+18	; 0x12
    1ac4:	3b 89       	ldd	r19, Y+19	; 0x13
    1ac6:	82 0f       	add	r24, r18
    1ac8:	93 1f       	adc	r25, r19
    1aca:	fc 01       	movw	r30, r24
    1acc:	80 81       	ld	r24, Z
    1ace:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
			i++;
    1ad2:	89 81       	ldd	r24, Y+1	; 0x01
    1ad4:	8f 5f       	subi	r24, 0xFF	; 255
    1ad6:	89 83       	std	Y+1, r24	; 0x01
	u8 i;
	for (int j = 0; j<5 ;j++)
	{
		LCD_Set_Block(j);
		i = 0;
		while(copy_string[i] != '\0')
    1ad8:	89 81       	ldd	r24, Y+1	; 0x01
    1ada:	88 2f       	mov	r24, r24
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	2a 89       	ldd	r18, Y+18	; 0x12
    1ae0:	3b 89       	ldd	r19, Y+19	; 0x13
    1ae2:	82 0f       	add	r24, r18
    1ae4:	93 1f       	adc	r25, r19
    1ae6:	fc 01       	movw	r30, r24
    1ae8:	80 81       	ld	r24, Z
    1aea:	88 23       	and	r24, r24
    1aec:	39 f7       	brne	.-50     	; 0x1abc <LCD_Void_Write_Moving_String+0x28>
    1aee:	80 e0       	ldi	r24, 0x00	; 0
    1af0:	90 e0       	ldi	r25, 0x00	; 0
    1af2:	aa e7       	ldi	r26, 0x7A	; 122
    1af4:	b4 e4       	ldi	r27, 0x44	; 68
    1af6:	8c 83       	std	Y+4, r24	; 0x04
    1af8:	9d 83       	std	Y+5, r25	; 0x05
    1afa:	ae 83       	std	Y+6, r26	; 0x06
    1afc:	bf 83       	std	Y+7, r27	; 0x07

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1afe:	20 e0       	ldi	r18, 0x00	; 0
    1b00:	30 e0       	ldi	r19, 0x00	; 0
    1b02:	4a ef       	ldi	r20, 0xFA	; 250
    1b04:	54 e4       	ldi	r21, 0x44	; 68
    1b06:	6c 81       	ldd	r22, Y+4	; 0x04
    1b08:	7d 81       	ldd	r23, Y+5	; 0x05
    1b0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b0c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b0e:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1b12:	dc 01       	movw	r26, r24
    1b14:	cb 01       	movw	r24, r22
    1b16:	88 87       	std	Y+8, r24	; 0x08
    1b18:	99 87       	std	Y+9, r25	; 0x09
    1b1a:	aa 87       	std	Y+10, r26	; 0x0a
    1b1c:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1b1e:	20 e0       	ldi	r18, 0x00	; 0
    1b20:	30 e0       	ldi	r19, 0x00	; 0
    1b22:	40 e8       	ldi	r20, 0x80	; 128
    1b24:	5f e3       	ldi	r21, 0x3F	; 63
    1b26:	68 85       	ldd	r22, Y+8	; 0x08
    1b28:	79 85       	ldd	r23, Y+9	; 0x09
    1b2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b2c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b2e:	0e 94 49 30 	call	0x6092	; 0x6092 <__cmpsf2>
    1b32:	88 23       	and	r24, r24
    1b34:	2c f4       	brge	.+10     	; 0x1b40 <LCD_Void_Write_Moving_String+0xac>
		__ticks = 1;
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	9d 87       	std	Y+13, r25	; 0x0d
    1b3c:	8c 87       	std	Y+12, r24	; 0x0c
    1b3e:	3f c0       	rjmp	.+126    	; 0x1bbe <LCD_Void_Write_Moving_String+0x12a>
	else if (__tmp > 65535)
    1b40:	20 e0       	ldi	r18, 0x00	; 0
    1b42:	3f ef       	ldi	r19, 0xFF	; 255
    1b44:	4f e7       	ldi	r20, 0x7F	; 127
    1b46:	57 e4       	ldi	r21, 0x47	; 71
    1b48:	68 85       	ldd	r22, Y+8	; 0x08
    1b4a:	79 85       	ldd	r23, Y+9	; 0x09
    1b4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b50:	0e 94 64 31 	call	0x62c8	; 0x62c8 <__gesf2>
    1b54:	18 16       	cp	r1, r24
    1b56:	4c f5       	brge	.+82     	; 0x1baa <LCD_Void_Write_Moving_String+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b58:	20 e0       	ldi	r18, 0x00	; 0
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	40 e2       	ldi	r20, 0x20	; 32
    1b5e:	51 e4       	ldi	r21, 0x41	; 65
    1b60:	6c 81       	ldd	r22, Y+4	; 0x04
    1b62:	7d 81       	ldd	r23, Y+5	; 0x05
    1b64:	8e 81       	ldd	r24, Y+6	; 0x06
    1b66:	9f 81       	ldd	r25, Y+7	; 0x07
    1b68:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__mulsf3>
    1b6c:	dc 01       	movw	r26, r24
    1b6e:	cb 01       	movw	r24, r22
    1b70:	bc 01       	movw	r22, r24
    1b72:	cd 01       	movw	r24, r26
    1b74:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1b78:	dc 01       	movw	r26, r24
    1b7a:	cb 01       	movw	r24, r22
    1b7c:	9d 87       	std	Y+13, r25	; 0x0d
    1b7e:	8c 87       	std	Y+12, r24	; 0x0c
    1b80:	0f c0       	rjmp	.+30     	; 0x1ba0 <LCD_Void_Write_Moving_String+0x10c>
    1b82:	88 ec       	ldi	r24, 0xC8	; 200
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	9f 87       	std	Y+15, r25	; 0x0f
    1b88:	8e 87       	std	Y+14, r24	; 0x0e
    1b8a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b8c:	9f 85       	ldd	r25, Y+15	; 0x0f
    1b8e:	01 97       	sbiw	r24, 0x01	; 1
    1b90:	f1 f7       	brne	.-4      	; 0x1b8e <LCD_Void_Write_Moving_String+0xfa>
    1b92:	9f 87       	std	Y+15, r25	; 0x0f
    1b94:	8e 87       	std	Y+14, r24	; 0x0e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b96:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b98:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b9a:	01 97       	sbiw	r24, 0x01	; 1
    1b9c:	9d 87       	std	Y+13, r25	; 0x0d
    1b9e:	8c 87       	std	Y+12, r24	; 0x0c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ba0:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ba2:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ba4:	89 2b       	or	r24, r25
    1ba6:	69 f7       	brne	.-38     	; 0x1b82 <LCD_Void_Write_Moving_String+0xee>
    1ba8:	14 c0       	rjmp	.+40     	; 0x1bd2 <LCD_Void_Write_Moving_String+0x13e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1baa:	68 85       	ldd	r22, Y+8	; 0x08
    1bac:	79 85       	ldd	r23, Y+9	; 0x09
    1bae:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bb0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bb2:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fixunssfsi>
    1bb6:	dc 01       	movw	r26, r24
    1bb8:	cb 01       	movw	r24, r22
    1bba:	9d 87       	std	Y+13, r25	; 0x0d
    1bbc:	8c 87       	std	Y+12, r24	; 0x0c
    1bbe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bc0:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bc2:	99 8b       	std	Y+17, r25	; 0x11
    1bc4:	88 8b       	std	Y+16, r24	; 0x10
    1bc6:	88 89       	ldd	r24, Y+16	; 0x10
    1bc8:	99 89       	ldd	r25, Y+17	; 0x11
    1bca:	01 97       	sbiw	r24, 0x01	; 1
    1bcc:	f1 f7       	brne	.-4      	; 0x1bca <LCD_Void_Write_Moving_String+0x136>
    1bce:	99 8b       	std	Y+17, r25	; 0x11
    1bd0:	88 8b       	std	Y+16, r24	; 0x10

			LCD_Void_Write_Data(copy_string[i]);
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
    1bd2:	0e 94 84 0c 	call	0x1908	; 0x1908 <LCD_Void_Clear>
}

void LCD_Void_Write_Moving_String(u8* copy_string)
{
	u8 i;
	for (int j = 0; j<5 ;j++)
    1bd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bd8:	9b 81       	ldd	r25, Y+3	; 0x03
    1bda:	01 96       	adiw	r24, 0x01	; 1
    1bdc:	9b 83       	std	Y+3, r25	; 0x03
    1bde:	8a 83       	std	Y+2, r24	; 0x02
    1be0:	8a 81       	ldd	r24, Y+2	; 0x02
    1be2:	9b 81       	ldd	r25, Y+3	; 0x03
    1be4:	05 97       	sbiw	r24, 0x05	; 5
    1be6:	0c f4       	brge	.+2      	; 0x1bea <LCD_Void_Write_Moving_String+0x156>
    1be8:	64 cf       	rjmp	.-312    	; 0x1ab2 <LCD_Void_Write_Moving_String+0x1e>
			i++;
		}
		_delay_ms(1000);
		LCD_Void_Clear();
	}
}
    1bea:	00 00       	nop
    1bec:	63 96       	adiw	r28, 0x13	; 19
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	de bf       	out	0x3e, r29	; 62
    1bf4:	0f be       	out	0x3f, r0	; 63
    1bf6:	cd bf       	out	0x3d, r28	; 61
    1bf8:	df 91       	pop	r29
    1bfa:	cf 91       	pop	r28
    1bfc:	08 95       	ret

00001bfe <LCD_Void_Write_CGRAM>:

void LCD_Void_Write_CGRAM(u8 copy_row_0,u8 copy_row_1,u8 copy_row_2,u8 copy_row_3,u8 copy_row_4,u8 copy_row_5,u8 copy_row_6,u8 copy_row_7,u8 copy_CGRAM_address)
{
    1bfe:	8f 92       	push	r8
    1c00:	af 92       	push	r10
    1c02:	cf 92       	push	r12
    1c04:	ef 92       	push	r14
    1c06:	0f 93       	push	r16
    1c08:	cf 93       	push	r28
    1c0a:	df 93       	push	r29
    1c0c:	cd b7       	in	r28, 0x3d	; 61
    1c0e:	de b7       	in	r29, 0x3e	; 62
    1c10:	29 97       	sbiw	r28, 0x09	; 9
    1c12:	0f b6       	in	r0, 0x3f	; 63
    1c14:	f8 94       	cli
    1c16:	de bf       	out	0x3e, r29	; 62
    1c18:	0f be       	out	0x3f, r0	; 63
    1c1a:	cd bf       	out	0x3d, r28	; 61
    1c1c:	89 83       	std	Y+1, r24	; 0x01
    1c1e:	6a 83       	std	Y+2, r22	; 0x02
    1c20:	4b 83       	std	Y+3, r20	; 0x03
    1c22:	2c 83       	std	Y+4, r18	; 0x04
    1c24:	0d 83       	std	Y+5, r16	; 0x05
    1c26:	ee 82       	std	Y+6, r14	; 0x06
    1c28:	cf 82       	std	Y+7, r12	; 0x07
    1c2a:	a8 86       	std	Y+8, r10	; 0x08
    1c2c:	89 86       	std	Y+9, r8	; 0x09
	LCD_Void_Write_Cmd(copy_CGRAM_address);
    1c2e:	89 85       	ldd	r24, Y+9	; 0x09
    1c30:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
	LCD_Void_Write_Data(copy_row_0);
    1c34:	89 81       	ldd	r24, Y+1	; 0x01
    1c36:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_1);
    1c3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c3c:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_2);
    1c40:	8b 81       	ldd	r24, Y+3	; 0x03
    1c42:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_3);
    1c46:	8c 81       	ldd	r24, Y+4	; 0x04
    1c48:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_4);
    1c4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4e:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_5);
    1c52:	8e 81       	ldd	r24, Y+6	; 0x06
    1c54:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_6);
    1c58:	8f 81       	ldd	r24, Y+7	; 0x07
    1c5a:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data(copy_row_7);
    1c5e:	88 85       	ldd	r24, Y+8	; 0x08
    1c60:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Cmd(0b10000000);
    1c64:	80 e8       	ldi	r24, 0x80	; 128
    1c66:	0e 94 98 07 	call	0xf30	; 0xf30 <LCD_Void_Write_Cmd>
}
    1c6a:	00 00       	nop
    1c6c:	29 96       	adiw	r28, 0x09	; 9
    1c6e:	0f b6       	in	r0, 0x3f	; 63
    1c70:	f8 94       	cli
    1c72:	de bf       	out	0x3e, r29	; 62
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	cd bf       	out	0x3d, r28	; 61
    1c78:	df 91       	pop	r29
    1c7a:	cf 91       	pop	r28
    1c7c:	0f 91       	pop	r16
    1c7e:	ef 90       	pop	r14
    1c80:	cf 90       	pop	r12
    1c82:	af 90       	pop	r10
    1c84:	8f 90       	pop	r8
    1c86:	08 95       	ret

00001c88 <LCD_Void_Write_Number>:

void LCD_Void_Write_Number(u32 Number)
{
    1c88:	cf 93       	push	r28
    1c8a:	df 93       	push	r29
    1c8c:	00 d0       	rcall	.+0      	; 0x1c8e <LCD_Void_Write_Number+0x6>
    1c8e:	00 d0       	rcall	.+0      	; 0x1c90 <LCD_Void_Write_Number+0x8>
    1c90:	1f 92       	push	r1
    1c92:	cd b7       	in	r28, 0x3d	; 61
    1c94:	de b7       	in	r29, 0x3e	; 62
    1c96:	9d 83       	std	Y+5, r25	; 0x05
    1c98:	8c 83       	std	Y+4, r24	; 0x04
	u32 Reversed_Num = 0;
    1c9a:	1a 82       	std	Y+2, r1	; 0x02
    1c9c:	19 82       	std	Y+1, r1	; 0x01
	u8 count = 0;
    1c9e:	1b 82       	std	Y+3, r1	; 0x03
	while(Number > 0)
    1ca0:	3c c0       	rjmp	.+120    	; 0x1d1a <LCD_Void_Write_Number+0x92>
	{
		Reversed_Num = (Number%10) + (Reversed_Num*10);
    1ca2:	4c 81       	ldd	r20, Y+4	; 0x04
    1ca4:	5d 81       	ldd	r21, Y+5	; 0x05
    1ca6:	9a 01       	movw	r18, r20
    1ca8:	ad ec       	ldi	r26, 0xCD	; 205
    1caa:	bc ec       	ldi	r27, 0xCC	; 204
    1cac:	0e 94 cd 2f 	call	0x5f9a	; 0x5f9a <__umulhisi3>
    1cb0:	9c 01       	movw	r18, r24
    1cb2:	36 95       	lsr	r19
    1cb4:	27 95       	ror	r18
    1cb6:	36 95       	lsr	r19
    1cb8:	27 95       	ror	r18
    1cba:	36 95       	lsr	r19
    1cbc:	27 95       	ror	r18
    1cbe:	c9 01       	movw	r24, r18
    1cc0:	88 0f       	add	r24, r24
    1cc2:	99 1f       	adc	r25, r25
    1cc4:	9c 01       	movw	r18, r24
    1cc6:	22 0f       	add	r18, r18
    1cc8:	33 1f       	adc	r19, r19
    1cca:	22 0f       	add	r18, r18
    1ccc:	33 1f       	adc	r19, r19
    1cce:	82 0f       	add	r24, r18
    1cd0:	93 1f       	adc	r25, r19
    1cd2:	9a 01       	movw	r18, r20
    1cd4:	28 1b       	sub	r18, r24
    1cd6:	39 0b       	sbc	r19, r25
    1cd8:	89 81       	ldd	r24, Y+1	; 0x01
    1cda:	9a 81       	ldd	r25, Y+2	; 0x02
    1cdc:	88 0f       	add	r24, r24
    1cde:	99 1f       	adc	r25, r25
    1ce0:	ac 01       	movw	r20, r24
    1ce2:	44 0f       	add	r20, r20
    1ce4:	55 1f       	adc	r21, r21
    1ce6:	44 0f       	add	r20, r20
    1ce8:	55 1f       	adc	r21, r21
    1cea:	84 0f       	add	r24, r20
    1cec:	95 1f       	adc	r25, r21
    1cee:	82 0f       	add	r24, r18
    1cf0:	93 1f       	adc	r25, r19
    1cf2:	9a 83       	std	Y+2, r25	; 0x02
    1cf4:	89 83       	std	Y+1, r24	; 0x01
		Number /= 10;
    1cf6:	8c 81       	ldd	r24, Y+4	; 0x04
    1cf8:	9d 81       	ldd	r25, Y+5	; 0x05
    1cfa:	9c 01       	movw	r18, r24
    1cfc:	ad ec       	ldi	r26, 0xCD	; 205
    1cfe:	bc ec       	ldi	r27, 0xCC	; 204
    1d00:	0e 94 cd 2f 	call	0x5f9a	; 0x5f9a <__umulhisi3>
    1d04:	96 95       	lsr	r25
    1d06:	87 95       	ror	r24
    1d08:	96 95       	lsr	r25
    1d0a:	87 95       	ror	r24
    1d0c:	96 95       	lsr	r25
    1d0e:	87 95       	ror	r24
    1d10:	9d 83       	std	Y+5, r25	; 0x05
    1d12:	8c 83       	std	Y+4, r24	; 0x04
		count ++;
    1d14:	8b 81       	ldd	r24, Y+3	; 0x03
    1d16:	8f 5f       	subi	r24, 0xFF	; 255
    1d18:	8b 83       	std	Y+3, r24	; 0x03

void LCD_Void_Write_Number(u32 Number)
{
	u32 Reversed_Num = 0;
	u8 count = 0;
	while(Number > 0)
    1d1a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d1c:	9d 81       	ldd	r25, Y+5	; 0x05
    1d1e:	89 2b       	or	r24, r25
    1d20:	09 f0       	breq	.+2      	; 0x1d24 <LCD_Void_Write_Number+0x9c>
    1d22:	bf cf       	rjmp	.-130    	; 0x1ca2 <LCD_Void_Write_Number+0x1a>
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1d24:	1d 82       	std	Y+5, r1	; 0x05
    1d26:	1c 82       	std	Y+4, r1	; 0x04
    1d28:	31 c0       	rjmp	.+98     	; 0x1d8c <LCD_Void_Write_Number+0x104>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
    1d2a:	49 81       	ldd	r20, Y+1	; 0x01
    1d2c:	5a 81       	ldd	r21, Y+2	; 0x02
    1d2e:	9a 01       	movw	r18, r20
    1d30:	ad ec       	ldi	r26, 0xCD	; 205
    1d32:	bc ec       	ldi	r27, 0xCC	; 204
    1d34:	0e 94 cd 2f 	call	0x5f9a	; 0x5f9a <__umulhisi3>
    1d38:	96 95       	lsr	r25
    1d3a:	87 95       	ror	r24
    1d3c:	96 95       	lsr	r25
    1d3e:	87 95       	ror	r24
    1d40:	96 95       	lsr	r25
    1d42:	87 95       	ror	r24
    1d44:	88 0f       	add	r24, r24
    1d46:	99 1f       	adc	r25, r25
    1d48:	9c 01       	movw	r18, r24
    1d4a:	22 0f       	add	r18, r18
    1d4c:	33 1f       	adc	r19, r19
    1d4e:	22 0f       	add	r18, r18
    1d50:	33 1f       	adc	r19, r19
    1d52:	82 0f       	add	r24, r18
    1d54:	93 1f       	adc	r25, r19
    1d56:	9a 01       	movw	r18, r20
    1d58:	28 1b       	sub	r18, r24
    1d5a:	39 0b       	sbc	r19, r25
    1d5c:	c9 01       	movw	r24, r18
    1d5e:	80 5d       	subi	r24, 0xD0	; 208
    1d60:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
		Reversed_Num /= 10;
    1d64:	89 81       	ldd	r24, Y+1	; 0x01
    1d66:	9a 81       	ldd	r25, Y+2	; 0x02
    1d68:	9c 01       	movw	r18, r24
    1d6a:	ad ec       	ldi	r26, 0xCD	; 205
    1d6c:	bc ec       	ldi	r27, 0xCC	; 204
    1d6e:	0e 94 cd 2f 	call	0x5f9a	; 0x5f9a <__umulhisi3>
    1d72:	96 95       	lsr	r25
    1d74:	87 95       	ror	r24
    1d76:	96 95       	lsr	r25
    1d78:	87 95       	ror	r24
    1d7a:	96 95       	lsr	r25
    1d7c:	87 95       	ror	r24
    1d7e:	9a 83       	std	Y+2, r25	; 0x02
    1d80:	89 83       	std	Y+1, r24	; 0x01
		Reversed_Num = (Number%10) + (Reversed_Num*10);
		Number /= 10;
		count ++;
	}

	for( Number=0;Number<count;Number++)
    1d82:	8c 81       	ldd	r24, Y+4	; 0x04
    1d84:	9d 81       	ldd	r25, Y+5	; 0x05
    1d86:	01 96       	adiw	r24, 0x01	; 1
    1d88:	9d 83       	std	Y+5, r25	; 0x05
    1d8a:	8c 83       	std	Y+4, r24	; 0x04
    1d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d8e:	28 2f       	mov	r18, r24
    1d90:	30 e0       	ldi	r19, 0x00	; 0
    1d92:	8c 81       	ldd	r24, Y+4	; 0x04
    1d94:	9d 81       	ldd	r25, Y+5	; 0x05
    1d96:	82 17       	cp	r24, r18
    1d98:	93 07       	cpc	r25, r19
    1d9a:	38 f2       	brcs	.-114    	; 0x1d2a <LCD_Void_Write_Number+0xa2>
	{
		LCD_Void_Write_Data((Reversed_Num%10)+'0');
		Reversed_Num /= 10;
	}

}
    1d9c:	00 00       	nop
    1d9e:	0f 90       	pop	r0
    1da0:	0f 90       	pop	r0
    1da2:	0f 90       	pop	r0
    1da4:	0f 90       	pop	r0
    1da6:	0f 90       	pop	r0
    1da8:	df 91       	pop	r29
    1daa:	cf 91       	pop	r28
    1dac:	08 95       	ret

00001dae <LCD_Void_Write_Number_2>:


void LCD_Void_Write_Number_2(u8 Number)
{
    1dae:	cf 93       	push	r28
    1db0:	df 93       	push	r29
    1db2:	1f 92       	push	r1
    1db4:	cd b7       	in	r28, 0x3d	; 61
    1db6:	de b7       	in	r29, 0x3e	; 62
    1db8:	89 83       	std	Y+1, r24	; 0x01

	LCD_Void_Write_Data((Number/10)+'0');
    1dba:	99 81       	ldd	r25, Y+1	; 0x01
    1dbc:	8d ec       	ldi	r24, 0xCD	; 205
    1dbe:	98 9f       	mul	r25, r24
    1dc0:	81 2d       	mov	r24, r1
    1dc2:	11 24       	eor	r1, r1
    1dc4:	86 95       	lsr	r24
    1dc6:	86 95       	lsr	r24
    1dc8:	86 95       	lsr	r24
    1dca:	80 5d       	subi	r24, 0xD0	; 208
    1dcc:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>
	LCD_Void_Write_Data((Number%10)+'0');
    1dd0:	99 81       	ldd	r25, Y+1	; 0x01
    1dd2:	8d ec       	ldi	r24, 0xCD	; 205
    1dd4:	98 9f       	mul	r25, r24
    1dd6:	81 2d       	mov	r24, r1
    1dd8:	11 24       	eor	r1, r1
    1dda:	86 95       	lsr	r24
    1ddc:	86 95       	lsr	r24
    1dde:	86 95       	lsr	r24
    1de0:	88 0f       	add	r24, r24
    1de2:	28 2f       	mov	r18, r24
    1de4:	22 0f       	add	r18, r18
    1de6:	22 0f       	add	r18, r18
    1de8:	82 0f       	add	r24, r18
    1dea:	29 2f       	mov	r18, r25
    1dec:	28 1b       	sub	r18, r24
    1dee:	82 2f       	mov	r24, r18
    1df0:	80 5d       	subi	r24, 0xD0	; 208
    1df2:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_Void_Write_Data>

}
    1df6:	00 00       	nop
    1df8:	0f 90       	pop	r0
    1dfa:	df 91       	pop	r29
    1dfc:	cf 91       	pop	r28
    1dfe:	08 95       	ret

00001e00 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
    1e04:	00 d0       	rcall	.+0      	; 0x1e06 <xEventGroupCreate+0x6>
    1e06:	cd b7       	in	r28, 0x3d	; 61
    1e08:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1e0a:	8b e0       	ldi	r24, 0x0B	; 11
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	0e 94 61 12 	call	0x24c2	; 0x24c2 <pvPortMalloc>
    1e12:	9a 83       	std	Y+2, r25	; 0x02
    1e14:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    1e16:	89 81       	ldd	r24, Y+1	; 0x01
    1e18:	9a 81       	ldd	r25, Y+2	; 0x02
    1e1a:	89 2b       	or	r24, r25
    1e1c:	51 f0       	breq	.+20     	; 0x1e32 <xEventGroupCreate+0x32>
		{
			pxEventBits->uxEventBits = 0;
    1e1e:	89 81       	ldd	r24, Y+1	; 0x01
    1e20:	9a 81       	ldd	r25, Y+2	; 0x02
    1e22:	fc 01       	movw	r30, r24
    1e24:	11 82       	std	Z+1, r1	; 0x01
    1e26:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1e28:	89 81       	ldd	r24, Y+1	; 0x01
    1e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e2c:	02 96       	adiw	r24, 0x02	; 2
    1e2e:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    1e32:	89 81       	ldd	r24, Y+1	; 0x01
    1e34:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1e36:	0f 90       	pop	r0
    1e38:	0f 90       	pop	r0
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	08 95       	ret

00001e40 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1e40:	cf 93       	push	r28
    1e42:	df 93       	push	r29
    1e44:	cd b7       	in	r28, 0x3d	; 61
    1e46:	de b7       	in	r29, 0x3e	; 62
    1e48:	60 97       	sbiw	r28, 0x10	; 16
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	f8 94       	cli
    1e4e:	de bf       	out	0x3e, r29	; 62
    1e50:	0f be       	out	0x3f, r0	; 63
    1e52:	cd bf       	out	0x3d, r28	; 61
    1e54:	9a 87       	std	Y+10, r25	; 0x0a
    1e56:	89 87       	std	Y+9, r24	; 0x09
    1e58:	7c 87       	std	Y+12, r23	; 0x0c
    1e5a:	6b 87       	std	Y+11, r22	; 0x0b
    1e5c:	5e 87       	std	Y+14, r21	; 0x0e
    1e5e:	4d 87       	std	Y+13, r20	; 0x0d
    1e60:	38 8b       	std	Y+16, r19	; 0x10
    1e62:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    1e64:	89 85       	ldd	r24, Y+9	; 0x09
    1e66:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e68:	9c 83       	std	Y+4, r25	; 0x04
    1e6a:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1e6c:	1d 82       	std	Y+5, r1	; 0x05
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1e6e:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1e72:	8b 81       	ldd	r24, Y+3	; 0x03
    1e74:	9c 81       	ldd	r25, Y+4	; 0x04
    1e76:	fc 01       	movw	r30, r24
    1e78:	80 81       	ld	r24, Z
    1e7a:	91 81       	ldd	r25, Z+1	; 0x01
    1e7c:	9f 83       	std	Y+7, r25	; 0x07
    1e7e:	8e 83       	std	Y+6, r24	; 0x06

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1e80:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e82:	3c 85       	ldd	r19, Y+12	; 0x0c
    1e84:	89 85       	ldd	r24, Y+9	; 0x09
    1e86:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e88:	b9 01       	movw	r22, r18
    1e8a:	0e 94 02 11 	call	0x2204	; 0x2204 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1e8e:	2e 81       	ldd	r18, Y+6	; 0x06
    1e90:	3f 81       	ldd	r19, Y+7	; 0x07
    1e92:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e94:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e96:	28 2b       	or	r18, r24
    1e98:	39 2b       	or	r19, r25
    1e9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e9e:	28 23       	and	r18, r24
    1ea0:	39 23       	and	r19, r25
    1ea2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ea4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ea6:	28 17       	cp	r18, r24
    1ea8:	39 07       	cpc	r19, r25
    1eaa:	d9 f4       	brne	.+54     	; 0x1ee2 <xEventGroupSync+0xa2>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1eac:	2e 81       	ldd	r18, Y+6	; 0x06
    1eae:	3f 81       	ldd	r19, Y+7	; 0x07
    1eb0:	8b 85       	ldd	r24, Y+11	; 0x0b
    1eb2:	9c 85       	ldd	r25, Y+12	; 0x0c
    1eb4:	82 2b       	or	r24, r18
    1eb6:	93 2b       	or	r25, r19
    1eb8:	9a 83       	std	Y+2, r25	; 0x02
    1eba:	89 83       	std	Y+1, r24	; 0x01

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec0:	fc 01       	movw	r30, r24
    1ec2:	20 81       	ld	r18, Z
    1ec4:	31 81       	ldd	r19, Z+1	; 0x01
    1ec6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ec8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eca:	80 95       	com	r24
    1ecc:	90 95       	com	r25
    1ece:	28 23       	and	r18, r24
    1ed0:	39 23       	and	r19, r25
    1ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed6:	fc 01       	movw	r30, r24
    1ed8:	31 83       	std	Z+1, r19	; 0x01
    1eda:	20 83       	st	Z, r18

			xTicksToWait = 0;
    1edc:	18 8a       	std	Y+16, r1	; 0x10
    1ede:	1f 86       	std	Y+15, r1	; 0x0f
    1ee0:	1c c0       	rjmp	.+56     	; 0x1f1a <xEventGroupSync+0xda>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1ee2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ee4:	98 89       	ldd	r25, Y+16	; 0x10
    1ee6:	89 2b       	or	r24, r25
    1ee8:	79 f0       	breq	.+30     	; 0x1f08 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1eea:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eec:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eee:	9c 01       	movw	r18, r24
    1ef0:	35 60       	ori	r19, 0x05	; 5
    1ef2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef6:	02 96       	adiw	r24, 0x02	; 2
    1ef8:	4f 85       	ldd	r20, Y+15	; 0x0f
    1efa:	58 89       	ldd	r21, Y+16	; 0x10
    1efc:	b9 01       	movw	r22, r18
    1efe:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1f02:	1a 82       	std	Y+2, r1	; 0x02
    1f04:	19 82       	std	Y+1, r1	; 0x01
    1f06:	09 c0       	rjmp	.+18     	; 0x1f1a <xEventGroupSync+0xda>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1f08:	8b 81       	ldd	r24, Y+3	; 0x03
    1f0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f0c:	fc 01       	movw	r30, r24
    1f0e:	80 81       	ld	r24, Z
    1f10:	91 81       	ldd	r25, Z+1	; 0x01
    1f12:	9a 83       	std	Y+2, r25	; 0x02
    1f14:	89 83       	std	Y+1, r24	; 0x01
				xTimeoutOccurred = pdTRUE;
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1f1a:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    1f1e:	88 87       	std	Y+8, r24	; 0x08

	if( xTicksToWait != ( TickType_t ) 0 )
    1f20:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f22:	98 89       	ldd	r25, Y+16	; 0x10
    1f24:	89 2b       	or	r24, r25
    1f26:	09 f4       	brne	.+2      	; 0x1f2a <xEventGroupSync+0xea>
    1f28:	3d c0       	rjmp	.+122    	; 0x1fa4 <xEventGroupSync+0x164>
	{
		if( xAlreadyYielded == pdFALSE )
    1f2a:	88 85       	ldd	r24, Y+8	; 0x08
    1f2c:	88 23       	and	r24, r24
    1f2e:	11 f4       	brne	.+4      	; 0x1f34 <xEventGroupSync+0xf4>
		{
			portYIELD_WITHIN_API();
    1f30:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1f34:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxTaskResetEventItemValue>
    1f38:	9a 83       	std	Y+2, r25	; 0x02
    1f3a:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1f3c:	89 81       	ldd	r24, Y+1	; 0x01
    1f3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f40:	88 27       	eor	r24, r24
    1f42:	92 70       	andi	r25, 0x02	; 2
    1f44:	89 2b       	or	r24, r25
    1f46:	49 f5       	brne	.+82     	; 0x1f9a <xEventGroupSync+0x15a>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1f48:	0f b6       	in	r0, 0x3f	; 63
    1f4a:	f8 94       	cli
    1f4c:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f50:	9c 81       	ldd	r25, Y+4	; 0x04
    1f52:	fc 01       	movw	r30, r24
    1f54:	80 81       	ld	r24, Z
    1f56:	91 81       	ldd	r25, Z+1	; 0x01
    1f58:	9a 83       	std	Y+2, r25	; 0x02
    1f5a:	89 83       	std	Y+1, r24	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f5c:	29 81       	ldd	r18, Y+1	; 0x01
    1f5e:	3a 81       	ldd	r19, Y+2	; 0x02
    1f60:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f62:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f64:	28 23       	and	r18, r24
    1f66:	39 23       	and	r19, r25
    1f68:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f6c:	28 17       	cp	r18, r24
    1f6e:	39 07       	cpc	r19, r25
    1f70:	81 f4       	brne	.+32     	; 0x1f92 <xEventGroupSync+0x152>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f72:	8b 81       	ldd	r24, Y+3	; 0x03
    1f74:	9c 81       	ldd	r25, Y+4	; 0x04
    1f76:	fc 01       	movw	r30, r24
    1f78:	20 81       	ld	r18, Z
    1f7a:	31 81       	ldd	r19, Z+1	; 0x01
    1f7c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f7e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f80:	80 95       	com	r24
    1f82:	90 95       	com	r25
    1f84:	28 23       	and	r18, r24
    1f86:	39 23       	and	r19, r25
    1f88:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8c:	fc 01       	movw	r30, r24
    1f8e:	31 83       	std	Z+1, r19	; 0x01
    1f90:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1f92:	0f 90       	pop	r0
    1f94:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1f96:	81 e0       	ldi	r24, 0x01	; 1
    1f98:	8d 83       	std	Y+5, r24	; 0x05
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1f9a:	89 81       	ldd	r24, Y+1	; 0x01
    1f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f9e:	99 27       	eor	r25, r25
    1fa0:	9a 83       	std	Y+2, r25	; 0x02
    1fa2:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1fa4:	89 81       	ldd	r24, Y+1	; 0x01
    1fa6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1fa8:	60 96       	adiw	r28, 0x10	; 16
    1faa:	0f b6       	in	r0, 0x3f	; 63
    1fac:	f8 94       	cli
    1fae:	de bf       	out	0x3e, r29	; 62
    1fb0:	0f be       	out	0x3f, r0	; 63
    1fb2:	cd bf       	out	0x3d, r28	; 61
    1fb4:	df 91       	pop	r29
    1fb6:	cf 91       	pop	r28
    1fb8:	08 95       	ret

00001fba <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1fba:	0f 93       	push	r16
    1fbc:	1f 93       	push	r17
    1fbe:	cf 93       	push	r28
    1fc0:	df 93       	push	r29
    1fc2:	cd b7       	in	r28, 0x3d	; 61
    1fc4:	de b7       	in	r29, 0x3e	; 62
    1fc6:	63 97       	sbiw	r28, 0x13	; 19
    1fc8:	0f b6       	in	r0, 0x3f	; 63
    1fca:	f8 94       	cli
    1fcc:	de bf       	out	0x3e, r29	; 62
    1fce:	0f be       	out	0x3f, r0	; 63
    1fd0:	cd bf       	out	0x3d, r28	; 61
    1fd2:	9d 87       	std	Y+13, r25	; 0x0d
    1fd4:	8c 87       	std	Y+12, r24	; 0x0c
    1fd6:	7f 87       	std	Y+15, r23	; 0x0f
    1fd8:	6e 87       	std	Y+14, r22	; 0x0e
    1fda:	48 8b       	std	Y+16, r20	; 0x10
    1fdc:	29 8b       	std	Y+17, r18	; 0x11
    1fde:	1b 8b       	std	Y+19, r17	; 0x13
    1fe0:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    1fe2:	8c 85       	ldd	r24, Y+12	; 0x0c
    1fe4:	9d 85       	ldd	r25, Y+13	; 0x0d
    1fe6:	9e 83       	std	Y+6, r25	; 0x06
    1fe8:	8d 83       	std	Y+5, r24	; 0x05
EventBits_t uxReturn, uxControlBits = 0;
    1fea:	1c 82       	std	Y+4, r1	; 0x04
    1fec:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1fee:	1f 82       	std	Y+7, r1	; 0x07
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1ff0:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1ff4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ff6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ff8:	fc 01       	movw	r30, r24
    1ffa:	80 81       	ld	r24, Z
    1ffc:	91 81       	ldd	r25, Z+1	; 0x01
    1ffe:	99 87       	std	Y+9, r25	; 0x09
    2000:	88 87       	std	Y+8, r24	; 0x08

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2002:	2e 85       	ldd	r18, Y+14	; 0x0e
    2004:	3f 85       	ldd	r19, Y+15	; 0x0f
    2006:	88 85       	ldd	r24, Y+8	; 0x08
    2008:	99 85       	ldd	r25, Y+9	; 0x09
    200a:	49 89       	ldd	r20, Y+17	; 0x11
    200c:	b9 01       	movw	r22, r18
    200e:	0e 94 2f 12 	call	0x245e	; 0x245e <prvTestWaitCondition>
    2012:	8a 87       	std	Y+10, r24	; 0x0a

		if( xWaitConditionMet != pdFALSE )
    2014:	8a 85       	ldd	r24, Y+10	; 0x0a
    2016:	88 23       	and	r24, r24
    2018:	d1 f0       	breq	.+52     	; 0x204e <xEventGroupWaitBits+0x94>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    201a:	88 85       	ldd	r24, Y+8	; 0x08
    201c:	99 85       	ldd	r25, Y+9	; 0x09
    201e:	9a 83       	std	Y+2, r25	; 0x02
    2020:	89 83       	std	Y+1, r24	; 0x01
			xTicksToWait = ( TickType_t ) 0;
    2022:	1b 8a       	std	Y+19, r1	; 0x13
    2024:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2026:	88 89       	ldd	r24, Y+16	; 0x10
    2028:	88 23       	and	r24, r24
    202a:	e1 f1       	breq	.+120    	; 0x20a4 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    202c:	8d 81       	ldd	r24, Y+5	; 0x05
    202e:	9e 81       	ldd	r25, Y+6	; 0x06
    2030:	fc 01       	movw	r30, r24
    2032:	20 81       	ld	r18, Z
    2034:	31 81       	ldd	r19, Z+1	; 0x01
    2036:	8e 85       	ldd	r24, Y+14	; 0x0e
    2038:	9f 85       	ldd	r25, Y+15	; 0x0f
    203a:	80 95       	com	r24
    203c:	90 95       	com	r25
    203e:	28 23       	and	r18, r24
    2040:	39 23       	and	r19, r25
    2042:	8d 81       	ldd	r24, Y+5	; 0x05
    2044:	9e 81       	ldd	r25, Y+6	; 0x06
    2046:	fc 01       	movw	r30, r24
    2048:	31 83       	std	Z+1, r19	; 0x01
    204a:	20 83       	st	Z, r18
    204c:	2b c0       	rjmp	.+86     	; 0x20a4 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    204e:	8a 89       	ldd	r24, Y+18	; 0x12
    2050:	9b 89       	ldd	r25, Y+19	; 0x13
    2052:	89 2b       	or	r24, r25
    2054:	39 f4       	brne	.+14     	; 0x2064 <xEventGroupWaitBits+0xaa>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2056:	88 85       	ldd	r24, Y+8	; 0x08
    2058:	99 85       	ldd	r25, Y+9	; 0x09
    205a:	9a 83       	std	Y+2, r25	; 0x02
    205c:	89 83       	std	Y+1, r24	; 0x01
			xTimeoutOccurred = pdTRUE;
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	8f 83       	std	Y+7, r24	; 0x07
    2062:	20 c0       	rjmp	.+64     	; 0x20a4 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2064:	88 89       	ldd	r24, Y+16	; 0x10
    2066:	88 23       	and	r24, r24
    2068:	29 f0       	breq	.+10     	; 0x2074 <xEventGroupWaitBits+0xba>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    206a:	8b 81       	ldd	r24, Y+3	; 0x03
    206c:	9c 81       	ldd	r25, Y+4	; 0x04
    206e:	91 60       	ori	r25, 0x01	; 1
    2070:	9c 83       	std	Y+4, r25	; 0x04
    2072:	8b 83       	std	Y+3, r24	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2074:	89 89       	ldd	r24, Y+17	; 0x11
    2076:	88 23       	and	r24, r24
    2078:	29 f0       	breq	.+10     	; 0x2084 <xEventGroupWaitBits+0xca>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    207a:	8b 81       	ldd	r24, Y+3	; 0x03
    207c:	9c 81       	ldd	r25, Y+4	; 0x04
    207e:	94 60       	ori	r25, 0x04	; 4
    2080:	9c 83       	std	Y+4, r25	; 0x04
    2082:	8b 83       	std	Y+3, r24	; 0x03
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2084:	2e 85       	ldd	r18, Y+14	; 0x0e
    2086:	3f 85       	ldd	r19, Y+15	; 0x0f
    2088:	8b 81       	ldd	r24, Y+3	; 0x03
    208a:	9c 81       	ldd	r25, Y+4	; 0x04
    208c:	28 2b       	or	r18, r24
    208e:	39 2b       	or	r19, r25
    2090:	8d 81       	ldd	r24, Y+5	; 0x05
    2092:	9e 81       	ldd	r25, Y+6	; 0x06
    2094:	02 96       	adiw	r24, 0x02	; 2
    2096:	4a 89       	ldd	r20, Y+18	; 0x12
    2098:	5b 89       	ldd	r21, Y+19	; 0x13
    209a:	b9 01       	movw	r22, r18
    209c:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    20a0:	1a 82       	std	Y+2, r1	; 0x02
    20a2:	19 82       	std	Y+1, r1	; 0x01

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    20a4:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    20a8:	8b 87       	std	Y+11, r24	; 0x0b

	if( xTicksToWait != ( TickType_t ) 0 )
    20aa:	8a 89       	ldd	r24, Y+18	; 0x12
    20ac:	9b 89       	ldd	r25, Y+19	; 0x13
    20ae:	89 2b       	or	r24, r25
    20b0:	09 f4       	brne	.+2      	; 0x20b4 <xEventGroupWaitBits+0xfa>
    20b2:	3f c0       	rjmp	.+126    	; 0x2132 <xEventGroupWaitBits+0x178>
	{
		if( xAlreadyYielded == pdFALSE )
    20b4:	8b 85       	ldd	r24, Y+11	; 0x0b
    20b6:	88 23       	and	r24, r24
    20b8:	11 f4       	brne	.+4      	; 0x20be <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    20ba:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    20be:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxTaskResetEventItemValue>
    20c2:	9a 83       	std	Y+2, r25	; 0x02
    20c4:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    20c6:	89 81       	ldd	r24, Y+1	; 0x01
    20c8:	9a 81       	ldd	r25, Y+2	; 0x02
    20ca:	88 27       	eor	r24, r24
    20cc:	92 70       	andi	r25, 0x02	; 2
    20ce:	89 2b       	or	r24, r25
    20d0:	59 f5       	brne	.+86     	; 0x2128 <xEventGroupWaitBits+0x16e>
		{
			taskENTER_CRITICAL();
    20d2:	0f b6       	in	r0, 0x3f	; 63
    20d4:	f8 94       	cli
    20d6:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    20d8:	8d 81       	ldd	r24, Y+5	; 0x05
    20da:	9e 81       	ldd	r25, Y+6	; 0x06
    20dc:	fc 01       	movw	r30, r24
    20de:	80 81       	ld	r24, Z
    20e0:	91 81       	ldd	r25, Z+1	; 0x01
    20e2:	9a 83       	std	Y+2, r25	; 0x02
    20e4:	89 83       	std	Y+1, r24	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    20e6:	2e 85       	ldd	r18, Y+14	; 0x0e
    20e8:	3f 85       	ldd	r19, Y+15	; 0x0f
    20ea:	89 81       	ldd	r24, Y+1	; 0x01
    20ec:	9a 81       	ldd	r25, Y+2	; 0x02
    20ee:	49 89       	ldd	r20, Y+17	; 0x11
    20f0:	b9 01       	movw	r22, r18
    20f2:	0e 94 2f 12 	call	0x245e	; 0x245e <prvTestWaitCondition>
    20f6:	88 23       	and	r24, r24
    20f8:	99 f0       	breq	.+38     	; 0x2120 <xEventGroupWaitBits+0x166>
				{
					if( xClearOnExit != pdFALSE )
    20fa:	88 89       	ldd	r24, Y+16	; 0x10
    20fc:	88 23       	and	r24, r24
    20fe:	81 f0       	breq	.+32     	; 0x2120 <xEventGroupWaitBits+0x166>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2100:	8d 81       	ldd	r24, Y+5	; 0x05
    2102:	9e 81       	ldd	r25, Y+6	; 0x06
    2104:	fc 01       	movw	r30, r24
    2106:	20 81       	ld	r18, Z
    2108:	31 81       	ldd	r19, Z+1	; 0x01
    210a:	8e 85       	ldd	r24, Y+14	; 0x0e
    210c:	9f 85       	ldd	r25, Y+15	; 0x0f
    210e:	80 95       	com	r24
    2110:	90 95       	com	r25
    2112:	28 23       	and	r18, r24
    2114:	39 23       	and	r19, r25
    2116:	8d 81       	ldd	r24, Y+5	; 0x05
    2118:	9e 81       	ldd	r25, Y+6	; 0x06
    211a:	fc 01       	movw	r30, r24
    211c:	31 83       	std	Z+1, r19	; 0x01
    211e:	20 83       	st	Z, r18
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	8f 83       	std	Y+7, r24	; 0x07
			}
			taskEXIT_CRITICAL();
    2124:	0f 90       	pop	r0
    2126:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2128:	89 81       	ldd	r24, Y+1	; 0x01
    212a:	9a 81       	ldd	r25, Y+2	; 0x02
    212c:	99 27       	eor	r25, r25
    212e:	9a 83       	std	Y+2, r25	; 0x02
    2130:	89 83       	std	Y+1, r24	; 0x01
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2132:	89 81       	ldd	r24, Y+1	; 0x01
    2134:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2136:	63 96       	adiw	r28, 0x13	; 19
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	de bf       	out	0x3e, r29	; 62
    213e:	0f be       	out	0x3f, r0	; 63
    2140:	cd bf       	out	0x3d, r28	; 61
    2142:	df 91       	pop	r29
    2144:	cf 91       	pop	r28
    2146:	1f 91       	pop	r17
    2148:	0f 91       	pop	r16
    214a:	08 95       	ret

0000214c <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    214c:	cf 93       	push	r28
    214e:	df 93       	push	r29
    2150:	cd b7       	in	r28, 0x3d	; 61
    2152:	de b7       	in	r29, 0x3e	; 62
    2154:	28 97       	sbiw	r28, 0x08	; 8
    2156:	0f b6       	in	r0, 0x3f	; 63
    2158:	f8 94       	cli
    215a:	de bf       	out	0x3e, r29	; 62
    215c:	0f be       	out	0x3f, r0	; 63
    215e:	cd bf       	out	0x3d, r28	; 61
    2160:	9e 83       	std	Y+6, r25	; 0x06
    2162:	8d 83       	std	Y+5, r24	; 0x05
    2164:	78 87       	std	Y+8, r23	; 0x08
    2166:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    2168:	8d 81       	ldd	r24, Y+5	; 0x05
    216a:	9e 81       	ldd	r25, Y+6	; 0x06
    216c:	9a 83       	std	Y+2, r25	; 0x02
    216e:	89 83       	std	Y+1, r24	; 0x01
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2170:	0f b6       	in	r0, 0x3f	; 63
    2172:	f8 94       	cli
    2174:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2176:	89 81       	ldd	r24, Y+1	; 0x01
    2178:	9a 81       	ldd	r25, Y+2	; 0x02
    217a:	fc 01       	movw	r30, r24
    217c:	80 81       	ld	r24, Z
    217e:	91 81       	ldd	r25, Z+1	; 0x01
    2180:	9c 83       	std	Y+4, r25	; 0x04
    2182:	8b 83       	std	Y+3, r24	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2184:	89 81       	ldd	r24, Y+1	; 0x01
    2186:	9a 81       	ldd	r25, Y+2	; 0x02
    2188:	fc 01       	movw	r30, r24
    218a:	20 81       	ld	r18, Z
    218c:	31 81       	ldd	r19, Z+1	; 0x01
    218e:	8f 81       	ldd	r24, Y+7	; 0x07
    2190:	98 85       	ldd	r25, Y+8	; 0x08
    2192:	80 95       	com	r24
    2194:	90 95       	com	r25
    2196:	28 23       	and	r18, r24
    2198:	39 23       	and	r19, r25
    219a:	89 81       	ldd	r24, Y+1	; 0x01
    219c:	9a 81       	ldd	r25, Y+2	; 0x02
    219e:	fc 01       	movw	r30, r24
    21a0:	31 83       	std	Z+1, r19	; 0x01
    21a2:	20 83       	st	Z, r18
	}
	taskEXIT_CRITICAL();
    21a4:	0f 90       	pop	r0
    21a6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    21a8:	8b 81       	ldd	r24, Y+3	; 0x03
    21aa:	9c 81       	ldd	r25, Y+4	; 0x04
}
    21ac:	28 96       	adiw	r28, 0x08	; 8
    21ae:	0f b6       	in	r0, 0x3f	; 63
    21b0:	f8 94       	cli
    21b2:	de bf       	out	0x3e, r29	; 62
    21b4:	0f be       	out	0x3f, r0	; 63
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	df 91       	pop	r29
    21ba:	cf 91       	pop	r28
    21bc:	08 95       	ret

000021be <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    21be:	cf 93       	push	r28
    21c0:	df 93       	push	r29
    21c2:	cd b7       	in	r28, 0x3d	; 61
    21c4:	de b7       	in	r29, 0x3e	; 62
    21c6:	27 97       	sbiw	r28, 0x07	; 7
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	de bf       	out	0x3e, r29	; 62
    21ce:	0f be       	out	0x3f, r0	; 63
    21d0:	cd bf       	out	0x3d, r28	; 61
    21d2:	9f 83       	std	Y+7, r25	; 0x07
    21d4:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    21d6:	8e 81       	ldd	r24, Y+6	; 0x06
    21d8:	9f 81       	ldd	r25, Y+7	; 0x07
    21da:	9a 83       	std	Y+2, r25	; 0x02
    21dc:	89 83       	std	Y+1, r24	; 0x01
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21de:	1b 82       	std	Y+3, r1	; 0x03
	{
		uxReturn = pxEventBits->uxEventBits;
    21e0:	89 81       	ldd	r24, Y+1	; 0x01
    21e2:	9a 81       	ldd	r25, Y+2	; 0x02
    21e4:	fc 01       	movw	r30, r24
    21e6:	80 81       	ld	r24, Z
    21e8:	91 81       	ldd	r25, Z+1	; 0x01
    21ea:	9d 83       	std	Y+5, r25	; 0x05
    21ec:	8c 83       	std	Y+4, r24	; 0x04
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    21ee:	8c 81       	ldd	r24, Y+4	; 0x04
    21f0:	9d 81       	ldd	r25, Y+5	; 0x05
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    21f2:	27 96       	adiw	r28, 0x07	; 7
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	f8 94       	cli
    21f8:	de bf       	out	0x3e, r29	; 62
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	cd bf       	out	0x3d, r28	; 61
    21fe:	df 91       	pop	r29
    2200:	cf 91       	pop	r28
    2202:	08 95       	ret

00002204 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2204:	cf 93       	push	r28
    2206:	df 93       	push	r29
    2208:	cd b7       	in	r28, 0x3d	; 61
    220a:	de b7       	in	r29, 0x3e	; 62
    220c:	65 97       	sbiw	r28, 0x15	; 21
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	de bf       	out	0x3e, r29	; 62
    2214:	0f be       	out	0x3f, r0	; 63
    2216:	cd bf       	out	0x3d, r28	; 61
    2218:	9b 8b       	std	Y+19, r25	; 0x13
    221a:	8a 8b       	std	Y+18, r24	; 0x12
    221c:	7d 8b       	std	Y+21, r23	; 0x15
    221e:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2220:	1c 82       	std	Y+4, r1	; 0x04
    2222:	1b 82       	std	Y+3, r1	; 0x03
EventGroup_t *pxEventBits = xEventGroup;
    2224:	8a 89       	ldd	r24, Y+18	; 0x12
    2226:	9b 89       	ldd	r25, Y+19	; 0x13
    2228:	9f 83       	std	Y+7, r25	; 0x07
    222a:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xMatchFound = pdFALSE;
    222c:	1d 82       	std	Y+5, r1	; 0x05
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    222e:	8e 81       	ldd	r24, Y+6	; 0x06
    2230:	9f 81       	ldd	r25, Y+7	; 0x07
    2232:	02 96       	adiw	r24, 0x02	; 2
    2234:	99 87       	std	Y+9, r25	; 0x09
    2236:	88 87       	std	Y+8, r24	; 0x08
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2238:	88 85       	ldd	r24, Y+8	; 0x08
    223a:	99 85       	ldd	r25, Y+9	; 0x09
    223c:	03 96       	adiw	r24, 0x03	; 3
    223e:	9b 87       	std	Y+11, r25	; 0x0b
    2240:	8a 87       	std	Y+10, r24	; 0x0a
	vTaskSuspendAll();
    2242:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2246:	88 85       	ldd	r24, Y+8	; 0x08
    2248:	99 85       	ldd	r25, Y+9	; 0x09
    224a:	fc 01       	movw	r30, r24
    224c:	85 81       	ldd	r24, Z+5	; 0x05
    224e:	96 81       	ldd	r25, Z+6	; 0x06
    2250:	9a 83       	std	Y+2, r25	; 0x02
    2252:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2254:	8e 81       	ldd	r24, Y+6	; 0x06
    2256:	9f 81       	ldd	r25, Y+7	; 0x07
    2258:	fc 01       	movw	r30, r24
    225a:	20 81       	ld	r18, Z
    225c:	31 81       	ldd	r19, Z+1	; 0x01
    225e:	8c 89       	ldd	r24, Y+20	; 0x14
    2260:	9d 89       	ldd	r25, Y+21	; 0x15
    2262:	28 2b       	or	r18, r24
    2264:	39 2b       	or	r19, r25
    2266:	8e 81       	ldd	r24, Y+6	; 0x06
    2268:	9f 81       	ldd	r25, Y+7	; 0x07
    226a:	fc 01       	movw	r30, r24
    226c:	31 83       	std	Z+1, r19	; 0x01
    226e:	20 83       	st	Z, r18

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2270:	5e c0       	rjmp	.+188    	; 0x232e <xEventGroupSetBits+0x12a>
		{
			pxNext = listGET_NEXT( pxListItem );
    2272:	89 81       	ldd	r24, Y+1	; 0x01
    2274:	9a 81       	ldd	r25, Y+2	; 0x02
    2276:	fc 01       	movw	r30, r24
    2278:	82 81       	ldd	r24, Z+2	; 0x02
    227a:	93 81       	ldd	r25, Z+3	; 0x03
    227c:	9d 87       	std	Y+13, r25	; 0x0d
    227e:	8c 87       	std	Y+12, r24	; 0x0c
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2280:	89 81       	ldd	r24, Y+1	; 0x01
    2282:	9a 81       	ldd	r25, Y+2	; 0x02
    2284:	fc 01       	movw	r30, r24
    2286:	80 81       	ld	r24, Z
    2288:	91 81       	ldd	r25, Z+1	; 0x01
    228a:	9f 87       	std	Y+15, r25	; 0x0f
    228c:	8e 87       	std	Y+14, r24	; 0x0e
			xMatchFound = pdFALSE;
    228e:	1d 82       	std	Y+5, r1	; 0x05

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2290:	8e 85       	ldd	r24, Y+14	; 0x0e
    2292:	9f 85       	ldd	r25, Y+15	; 0x0f
    2294:	88 27       	eor	r24, r24
    2296:	99 8b       	std	Y+17, r25	; 0x11
    2298:	88 8b       	std	Y+16, r24	; 0x10
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    229a:	8e 85       	ldd	r24, Y+14	; 0x0e
    229c:	9f 85       	ldd	r25, Y+15	; 0x0f
    229e:	99 27       	eor	r25, r25
    22a0:	9f 87       	std	Y+15, r25	; 0x0f
    22a2:	8e 87       	std	Y+14, r24	; 0x0e

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    22a4:	88 89       	ldd	r24, Y+16	; 0x10
    22a6:	99 89       	ldd	r25, Y+17	; 0x11
    22a8:	88 27       	eor	r24, r24
    22aa:	94 70       	andi	r25, 0x04	; 4
    22ac:	89 2b       	or	r24, r25
    22ae:	71 f4       	brne	.+28     	; 0x22cc <xEventGroupSetBits+0xc8>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    22b0:	8e 81       	ldd	r24, Y+6	; 0x06
    22b2:	9f 81       	ldd	r25, Y+7	; 0x07
    22b4:	fc 01       	movw	r30, r24
    22b6:	20 81       	ld	r18, Z
    22b8:	31 81       	ldd	r19, Z+1	; 0x01
    22ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    22bc:	9f 85       	ldd	r25, Y+15	; 0x0f
    22be:	82 23       	and	r24, r18
    22c0:	93 23       	and	r25, r19
    22c2:	89 2b       	or	r24, r25
    22c4:	99 f0       	breq	.+38     	; 0x22ec <xEventGroupSetBits+0xe8>
				{
					xMatchFound = pdTRUE;
    22c6:	81 e0       	ldi	r24, 0x01	; 1
    22c8:	8d 83       	std	Y+5, r24	; 0x05
    22ca:	10 c0       	rjmp	.+32     	; 0x22ec <xEventGroupSetBits+0xe8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    22cc:	8e 81       	ldd	r24, Y+6	; 0x06
    22ce:	9f 81       	ldd	r25, Y+7	; 0x07
    22d0:	fc 01       	movw	r30, r24
    22d2:	20 81       	ld	r18, Z
    22d4:	31 81       	ldd	r19, Z+1	; 0x01
    22d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    22d8:	9f 85       	ldd	r25, Y+15	; 0x0f
    22da:	28 23       	and	r18, r24
    22dc:	39 23       	and	r19, r25
    22de:	8e 85       	ldd	r24, Y+14	; 0x0e
    22e0:	9f 85       	ldd	r25, Y+15	; 0x0f
    22e2:	28 17       	cp	r18, r24
    22e4:	39 07       	cpc	r19, r25
    22e6:	11 f4       	brne	.+4      	; 0x22ec <xEventGroupSetBits+0xe8>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    22e8:	81 e0       	ldi	r24, 0x01	; 1
    22ea:	8d 83       	std	Y+5, r24	; 0x05
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    22ec:	8d 81       	ldd	r24, Y+5	; 0x05
    22ee:	88 23       	and	r24, r24
    22f0:	d1 f0       	breq	.+52     	; 0x2326 <xEventGroupSetBits+0x122>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    22f2:	88 89       	ldd	r24, Y+16	; 0x10
    22f4:	99 89       	ldd	r25, Y+17	; 0x11
    22f6:	88 27       	eor	r24, r24
    22f8:	91 70       	andi	r25, 0x01	; 1
    22fa:	89 2b       	or	r24, r25
    22fc:	41 f0       	breq	.+16     	; 0x230e <xEventGroupSetBits+0x10a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    22fe:	2b 81       	ldd	r18, Y+3	; 0x03
    2300:	3c 81       	ldd	r19, Y+4	; 0x04
    2302:	8e 85       	ldd	r24, Y+14	; 0x0e
    2304:	9f 85       	ldd	r25, Y+15	; 0x0f
    2306:	82 2b       	or	r24, r18
    2308:	93 2b       	or	r25, r19
    230a:	9c 83       	std	Y+4, r25	; 0x04
    230c:	8b 83       	std	Y+3, r24	; 0x03
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    230e:	8e 81       	ldd	r24, Y+6	; 0x06
    2310:	9f 81       	ldd	r25, Y+7	; 0x07
    2312:	fc 01       	movw	r30, r24
    2314:	80 81       	ld	r24, Z
    2316:	91 81       	ldd	r25, Z+1	; 0x01
    2318:	9c 01       	movw	r18, r24
    231a:	32 60       	ori	r19, 0x02	; 2
    231c:	89 81       	ldd	r24, Y+1	; 0x01
    231e:	9a 81       	ldd	r25, Y+2	; 0x02
    2320:	b9 01       	movw	r22, r18
    2322:	0e 94 8d 27 	call	0x4f1a	; 0x4f1a <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2326:	8c 85       	ldd	r24, Y+12	; 0x0c
    2328:	9d 85       	ldd	r25, Y+13	; 0x0d
    232a:	9a 83       	std	Y+2, r25	; 0x02
    232c:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    232e:	29 81       	ldd	r18, Y+1	; 0x01
    2330:	3a 81       	ldd	r19, Y+2	; 0x02
    2332:	8a 85       	ldd	r24, Y+10	; 0x0a
    2334:	9b 85       	ldd	r25, Y+11	; 0x0b
    2336:	28 17       	cp	r18, r24
    2338:	39 07       	cpc	r19, r25
    233a:	09 f0       	breq	.+2      	; 0x233e <xEventGroupSetBits+0x13a>
    233c:	9a cf       	rjmp	.-204    	; 0x2272 <xEventGroupSetBits+0x6e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    233e:	8e 81       	ldd	r24, Y+6	; 0x06
    2340:	9f 81       	ldd	r25, Y+7	; 0x07
    2342:	fc 01       	movw	r30, r24
    2344:	20 81       	ld	r18, Z
    2346:	31 81       	ldd	r19, Z+1	; 0x01
    2348:	8b 81       	ldd	r24, Y+3	; 0x03
    234a:	9c 81       	ldd	r25, Y+4	; 0x04
    234c:	80 95       	com	r24
    234e:	90 95       	com	r25
    2350:	28 23       	and	r18, r24
    2352:	39 23       	and	r19, r25
    2354:	8e 81       	ldd	r24, Y+6	; 0x06
    2356:	9f 81       	ldd	r25, Y+7	; 0x07
    2358:	fc 01       	movw	r30, r24
    235a:	31 83       	std	Z+1, r19	; 0x01
    235c:	20 83       	st	Z, r18
	}
	( void ) xTaskResumeAll();
    235e:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    2362:	8e 81       	ldd	r24, Y+6	; 0x06
    2364:	9f 81       	ldd	r25, Y+7	; 0x07
    2366:	fc 01       	movw	r30, r24
    2368:	80 81       	ld	r24, Z
    236a:	91 81       	ldd	r25, Z+1	; 0x01
}
    236c:	65 96       	adiw	r28, 0x15	; 21
    236e:	0f b6       	in	r0, 0x3f	; 63
    2370:	f8 94       	cli
    2372:	de bf       	out	0x3e, r29	; 62
    2374:	0f be       	out	0x3f, r0	; 63
    2376:	cd bf       	out	0x3d, r28	; 61
    2378:	df 91       	pop	r29
    237a:	cf 91       	pop	r28
    237c:	08 95       	ret

0000237e <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    237e:	cf 93       	push	r28
    2380:	df 93       	push	r29
    2382:	00 d0       	rcall	.+0      	; 0x2384 <vEventGroupDelete+0x6>
    2384:	00 d0       	rcall	.+0      	; 0x2386 <vEventGroupDelete+0x8>
    2386:	00 d0       	rcall	.+0      	; 0x2388 <vEventGroupDelete+0xa>
    2388:	cd b7       	in	r28, 0x3d	; 61
    238a:	de b7       	in	r29, 0x3e	; 62
    238c:	9e 83       	std	Y+6, r25	; 0x06
    238e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    2390:	8d 81       	ldd	r24, Y+5	; 0x05
    2392:	9e 81       	ldd	r25, Y+6	; 0x06
    2394:	9a 83       	std	Y+2, r25	; 0x02
    2396:	89 83       	std	Y+1, r24	; 0x01
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2398:	89 81       	ldd	r24, Y+1	; 0x01
    239a:	9a 81       	ldd	r25, Y+2	; 0x02
    239c:	02 96       	adiw	r24, 0x02	; 2
    239e:	9c 83       	std	Y+4, r25	; 0x04
    23a0:	8b 83       	std	Y+3, r24	; 0x03

	vTaskSuspendAll();
    23a2:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    23a6:	09 c0       	rjmp	.+18     	; 0x23ba <vEventGroupDelete+0x3c>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    23a8:	8b 81       	ldd	r24, Y+3	; 0x03
    23aa:	9c 81       	ldd	r25, Y+4	; 0x04
    23ac:	fc 01       	movw	r30, r24
    23ae:	85 81       	ldd	r24, Z+5	; 0x05
    23b0:	96 81       	ldd	r25, Z+6	; 0x06
    23b2:	60 e0       	ldi	r22, 0x00	; 0
    23b4:	72 e0       	ldi	r23, 0x02	; 2
    23b6:	0e 94 8d 27 	call	0x4f1a	; 0x4f1a <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    23ba:	8b 81       	ldd	r24, Y+3	; 0x03
    23bc:	9c 81       	ldd	r25, Y+4	; 0x04
    23be:	fc 01       	movw	r30, r24
    23c0:	80 81       	ld	r24, Z
    23c2:	88 23       	and	r24, r24
    23c4:	89 f7       	brne	.-30     	; 0x23a8 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    23c6:	89 81       	ldd	r24, Y+1	; 0x01
    23c8:	9a 81       	ldd	r25, Y+2	; 0x02
    23ca:	0e 94 b6 12 	call	0x256c	; 0x256c <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    23ce:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
}
    23d2:	00 00       	nop
    23d4:	26 96       	adiw	r28, 0x06	; 6
    23d6:	0f b6       	in	r0, 0x3f	; 63
    23d8:	f8 94       	cli
    23da:	de bf       	out	0x3e, r29	; 62
    23dc:	0f be       	out	0x3f, r0	; 63
    23de:	cd bf       	out	0x3d, r28	; 61
    23e0:	df 91       	pop	r29
    23e2:	cf 91       	pop	r28
    23e4:	08 95       	ret

000023e6 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    23e6:	cf 93       	push	r28
    23e8:	df 93       	push	r29
    23ea:	00 d0       	rcall	.+0      	; 0x23ec <vEventGroupSetBitsCallback+0x6>
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <vEventGroupSetBitsCallback+0x8>
    23ee:	00 d0       	rcall	.+0      	; 0x23f0 <vEventGroupSetBitsCallback+0xa>
    23f0:	cd b7       	in	r28, 0x3d	; 61
    23f2:	de b7       	in	r29, 0x3e	; 62
    23f4:	9a 83       	std	Y+2, r25	; 0x02
    23f6:	89 83       	std	Y+1, r24	; 0x01
    23f8:	4b 83       	std	Y+3, r20	; 0x03
    23fa:	5c 83       	std	Y+4, r21	; 0x04
    23fc:	6d 83       	std	Y+5, r22	; 0x05
    23fe:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2400:	2b 81       	ldd	r18, Y+3	; 0x03
    2402:	3c 81       	ldd	r19, Y+4	; 0x04
    2404:	89 81       	ldd	r24, Y+1	; 0x01
    2406:	9a 81       	ldd	r25, Y+2	; 0x02
    2408:	b9 01       	movw	r22, r18
    240a:	0e 94 02 11 	call	0x2204	; 0x2204 <xEventGroupSetBits>
}
    240e:	00 00       	nop
    2410:	26 96       	adiw	r28, 0x06	; 6
    2412:	0f b6       	in	r0, 0x3f	; 63
    2414:	f8 94       	cli
    2416:	de bf       	out	0x3e, r29	; 62
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	cd bf       	out	0x3d, r28	; 61
    241c:	df 91       	pop	r29
    241e:	cf 91       	pop	r28
    2420:	08 95       	ret

00002422 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    2422:	cf 93       	push	r28
    2424:	df 93       	push	r29
    2426:	00 d0       	rcall	.+0      	; 0x2428 <vEventGroupClearBitsCallback+0x6>
    2428:	00 d0       	rcall	.+0      	; 0x242a <vEventGroupClearBitsCallback+0x8>
    242a:	00 d0       	rcall	.+0      	; 0x242c <vEventGroupClearBitsCallback+0xa>
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	9a 83       	std	Y+2, r25	; 0x02
    2432:	89 83       	std	Y+1, r24	; 0x01
    2434:	4b 83       	std	Y+3, r20	; 0x03
    2436:	5c 83       	std	Y+4, r21	; 0x04
    2438:	6d 83       	std	Y+5, r22	; 0x05
    243a:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    243c:	2b 81       	ldd	r18, Y+3	; 0x03
    243e:	3c 81       	ldd	r19, Y+4	; 0x04
    2440:	89 81       	ldd	r24, Y+1	; 0x01
    2442:	9a 81       	ldd	r25, Y+2	; 0x02
    2444:	b9 01       	movw	r22, r18
    2446:	0e 94 a6 10 	call	0x214c	; 0x214c <xEventGroupClearBits>
}
    244a:	00 00       	nop
    244c:	26 96       	adiw	r28, 0x06	; 6
    244e:	0f b6       	in	r0, 0x3f	; 63
    2450:	f8 94       	cli
    2452:	de bf       	out	0x3e, r29	; 62
    2454:	0f be       	out	0x3f, r0	; 63
    2456:	cd bf       	out	0x3d, r28	; 61
    2458:	df 91       	pop	r29
    245a:	cf 91       	pop	r28
    245c:	08 95       	ret

0000245e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    245e:	cf 93       	push	r28
    2460:	df 93       	push	r29
    2462:	00 d0       	rcall	.+0      	; 0x2464 <prvTestWaitCondition+0x6>
    2464:	00 d0       	rcall	.+0      	; 0x2466 <prvTestWaitCondition+0x8>
    2466:	00 d0       	rcall	.+0      	; 0x2468 <prvTestWaitCondition+0xa>
    2468:	cd b7       	in	r28, 0x3d	; 61
    246a:	de b7       	in	r29, 0x3e	; 62
    246c:	9b 83       	std	Y+3, r25	; 0x03
    246e:	8a 83       	std	Y+2, r24	; 0x02
    2470:	7d 83       	std	Y+5, r23	; 0x05
    2472:	6c 83       	std	Y+4, r22	; 0x04
    2474:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    2476:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    2478:	8e 81       	ldd	r24, Y+6	; 0x06
    247a:	88 23       	and	r24, r24
    247c:	59 f4       	brne	.+22     	; 0x2494 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    247e:	2a 81       	ldd	r18, Y+2	; 0x02
    2480:	3b 81       	ldd	r19, Y+3	; 0x03
    2482:	8c 81       	ldd	r24, Y+4	; 0x04
    2484:	9d 81       	ldd	r25, Y+5	; 0x05
    2486:	82 23       	and	r24, r18
    2488:	93 23       	and	r25, r19
    248a:	89 2b       	or	r24, r25
    248c:	81 f0       	breq	.+32     	; 0x24ae <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    248e:	81 e0       	ldi	r24, 0x01	; 1
    2490:	89 83       	std	Y+1, r24	; 0x01
    2492:	0d c0       	rjmp	.+26     	; 0x24ae <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2494:	2a 81       	ldd	r18, Y+2	; 0x02
    2496:	3b 81       	ldd	r19, Y+3	; 0x03
    2498:	8c 81       	ldd	r24, Y+4	; 0x04
    249a:	9d 81       	ldd	r25, Y+5	; 0x05
    249c:	28 23       	and	r18, r24
    249e:	39 23       	and	r19, r25
    24a0:	8c 81       	ldd	r24, Y+4	; 0x04
    24a2:	9d 81       	ldd	r25, Y+5	; 0x05
    24a4:	28 17       	cp	r18, r24
    24a6:	39 07       	cpc	r19, r25
    24a8:	11 f4       	brne	.+4      	; 0x24ae <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    24aa:	81 e0       	ldi	r24, 0x01	; 1
    24ac:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    24ae:	89 81       	ldd	r24, Y+1	; 0x01
}
    24b0:	26 96       	adiw	r28, 0x06	; 6
    24b2:	0f b6       	in	r0, 0x3f	; 63
    24b4:	f8 94       	cli
    24b6:	de bf       	out	0x3e, r29	; 62
    24b8:	0f be       	out	0x3f, r0	; 63
    24ba:	cd bf       	out	0x3d, r28	; 61
    24bc:	df 91       	pop	r29
    24be:	cf 91       	pop	r28
    24c0:	08 95       	ret

000024c2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    24c2:	cf 93       	push	r28
    24c4:	df 93       	push	r29
    24c6:	00 d0       	rcall	.+0      	; 0x24c8 <pvPortMalloc+0x6>
    24c8:	00 d0       	rcall	.+0      	; 0x24ca <pvPortMalloc+0x8>
    24ca:	cd b7       	in	r28, 0x3d	; 61
    24cc:	de b7       	in	r29, 0x3e	; 62
    24ce:	9c 83       	std	Y+4, r25	; 0x04
    24d0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    24d2:	1a 82       	std	Y+2, r1	; 0x02
    24d4:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    24d6:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    24da:	80 91 9b 06 	lds	r24, 0x069B	; 0x80069b <pucAlignedHeap.2085>
    24de:	90 91 9c 06 	lds	r25, 0x069C	; 0x80069c <pucAlignedHeap.2085+0x1>
    24e2:	89 2b       	or	r24, r25
    24e4:	31 f4       	brne	.+12     	; 0x24f2 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    24e6:	8e eb       	ldi	r24, 0xBE	; 190
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	90 93 9c 06 	sts	0x069C, r25	; 0x80069c <pucAlignedHeap.2085+0x1>
    24ee:	80 93 9b 06 	sts	0x069B, r24	; 0x80069b <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    24f2:	20 91 99 06 	lds	r18, 0x0699	; 0x800699 <xNextFreeByte>
    24f6:	30 91 9a 06 	lds	r19, 0x069A	; 0x80069a <xNextFreeByte+0x1>
    24fa:	8b 81       	ldd	r24, Y+3	; 0x03
    24fc:	9c 81       	ldd	r25, Y+4	; 0x04
    24fe:	82 0f       	add	r24, r18
    2500:	93 1f       	adc	r25, r19
    2502:	8b 3d       	cpi	r24, 0xDB	; 219
    2504:	95 40       	sbci	r25, 0x05	; 5
    2506:	38 f5       	brcc	.+78     	; 0x2556 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2508:	20 91 99 06 	lds	r18, 0x0699	; 0x800699 <xNextFreeByte>
    250c:	30 91 9a 06 	lds	r19, 0x069A	; 0x80069a <xNextFreeByte+0x1>
    2510:	8b 81       	ldd	r24, Y+3	; 0x03
    2512:	9c 81       	ldd	r25, Y+4	; 0x04
    2514:	28 0f       	add	r18, r24
    2516:	39 1f       	adc	r19, r25
    2518:	80 91 99 06 	lds	r24, 0x0699	; 0x800699 <xNextFreeByte>
    251c:	90 91 9a 06 	lds	r25, 0x069A	; 0x80069a <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2520:	82 17       	cp	r24, r18
    2522:	93 07       	cpc	r25, r19
    2524:	c0 f4       	brcc	.+48     	; 0x2556 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2526:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <pucAlignedHeap.2085>
    252a:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <pucAlignedHeap.2085+0x1>
    252e:	80 91 99 06 	lds	r24, 0x0699	; 0x800699 <xNextFreeByte>
    2532:	90 91 9a 06 	lds	r25, 0x069A	; 0x80069a <xNextFreeByte+0x1>
    2536:	82 0f       	add	r24, r18
    2538:	93 1f       	adc	r25, r19
    253a:	9a 83       	std	Y+2, r25	; 0x02
    253c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    253e:	20 91 99 06 	lds	r18, 0x0699	; 0x800699 <xNextFreeByte>
    2542:	30 91 9a 06 	lds	r19, 0x069A	; 0x80069a <xNextFreeByte+0x1>
    2546:	8b 81       	ldd	r24, Y+3	; 0x03
    2548:	9c 81       	ldd	r25, Y+4	; 0x04
    254a:	82 0f       	add	r24, r18
    254c:	93 1f       	adc	r25, r19
    254e:	90 93 9a 06 	sts	0x069A, r25	; 0x80069a <xNextFreeByte+0x1>
    2552:	80 93 99 06 	sts	0x0699, r24	; 0x800699 <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2556:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    255a:	89 81       	ldd	r24, Y+1	; 0x01
    255c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    255e:	0f 90       	pop	r0
    2560:	0f 90       	pop	r0
    2562:	0f 90       	pop	r0
    2564:	0f 90       	pop	r0
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	08 95       	ret

0000256c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    256c:	cf 93       	push	r28
    256e:	df 93       	push	r29
    2570:	00 d0       	rcall	.+0      	; 0x2572 <vPortFree+0x6>
    2572:	cd b7       	in	r28, 0x3d	; 61
    2574:	de b7       	in	r29, 0x3e	; 62
    2576:	9a 83       	std	Y+2, r25	; 0x02
    2578:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    257a:	00 00       	nop
    257c:	0f 90       	pop	r0
    257e:	0f 90       	pop	r0
    2580:	df 91       	pop	r29
    2582:	cf 91       	pop	r28
    2584:	08 95       	ret

00002586 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2586:	cf 93       	push	r28
    2588:	df 93       	push	r29
    258a:	cd b7       	in	r28, 0x3d	; 61
    258c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    258e:	10 92 9a 06 	sts	0x069A, r1	; 0x80069a <xNextFreeByte+0x1>
    2592:	10 92 99 06 	sts	0x0699, r1	; 0x800699 <xNextFreeByte>
}
    2596:	00 00       	nop
    2598:	df 91       	pop	r29
    259a:	cf 91       	pop	r28
    259c:	08 95       	ret

0000259e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    259e:	cf 93       	push	r28
    25a0:	df 93       	push	r29
    25a2:	cd b7       	in	r28, 0x3d	; 61
    25a4:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    25a6:	80 91 99 06 	lds	r24, 0x0699	; 0x800699 <xNextFreeByte>
    25aa:	90 91 9a 06 	lds	r25, 0x069A	; 0x80069a <xNextFreeByte+0x1>
    25ae:	2b ed       	ldi	r18, 0xDB	; 219
    25b0:	35 e0       	ldi	r19, 0x05	; 5
    25b2:	a9 01       	movw	r20, r18
    25b4:	48 1b       	sub	r20, r24
    25b6:	59 0b       	sbc	r21, r25
    25b8:	ca 01       	movw	r24, r20
}
    25ba:	df 91       	pop	r29
    25bc:	cf 91       	pop	r28
    25be:	08 95       	ret

000025c0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    25c0:	cf 93       	push	r28
    25c2:	df 93       	push	r29
    25c4:	00 d0       	rcall	.+0      	; 0x25c6 <vListInitialise+0x6>
    25c6:	cd b7       	in	r28, 0x3d	; 61
    25c8:	de b7       	in	r29, 0x3e	; 62
    25ca:	9a 83       	std	Y+2, r25	; 0x02
    25cc:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    25ce:	89 81       	ldd	r24, Y+1	; 0x01
    25d0:	9a 81       	ldd	r25, Y+2	; 0x02
    25d2:	9c 01       	movw	r18, r24
    25d4:	2d 5f       	subi	r18, 0xFD	; 253
    25d6:	3f 4f       	sbci	r19, 0xFF	; 255
    25d8:	89 81       	ldd	r24, Y+1	; 0x01
    25da:	9a 81       	ldd	r25, Y+2	; 0x02
    25dc:	fc 01       	movw	r30, r24
    25de:	32 83       	std	Z+2, r19	; 0x02
    25e0:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    25e2:	89 81       	ldd	r24, Y+1	; 0x01
    25e4:	9a 81       	ldd	r25, Y+2	; 0x02
    25e6:	2f ef       	ldi	r18, 0xFF	; 255
    25e8:	3f ef       	ldi	r19, 0xFF	; 255
    25ea:	fc 01       	movw	r30, r24
    25ec:	34 83       	std	Z+4, r19	; 0x04
    25ee:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    25f0:	89 81       	ldd	r24, Y+1	; 0x01
    25f2:	9a 81       	ldd	r25, Y+2	; 0x02
    25f4:	9c 01       	movw	r18, r24
    25f6:	2d 5f       	subi	r18, 0xFD	; 253
    25f8:	3f 4f       	sbci	r19, 0xFF	; 255
    25fa:	89 81       	ldd	r24, Y+1	; 0x01
    25fc:	9a 81       	ldd	r25, Y+2	; 0x02
    25fe:	fc 01       	movw	r30, r24
    2600:	36 83       	std	Z+6, r19	; 0x06
    2602:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2604:	89 81       	ldd	r24, Y+1	; 0x01
    2606:	9a 81       	ldd	r25, Y+2	; 0x02
    2608:	9c 01       	movw	r18, r24
    260a:	2d 5f       	subi	r18, 0xFD	; 253
    260c:	3f 4f       	sbci	r19, 0xFF	; 255
    260e:	89 81       	ldd	r24, Y+1	; 0x01
    2610:	9a 81       	ldd	r25, Y+2	; 0x02
    2612:	fc 01       	movw	r30, r24
    2614:	30 87       	std	Z+8, r19	; 0x08
    2616:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2618:	89 81       	ldd	r24, Y+1	; 0x01
    261a:	9a 81       	ldd	r25, Y+2	; 0x02
    261c:	fc 01       	movw	r30, r24
    261e:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2620:	00 00       	nop
    2622:	0f 90       	pop	r0
    2624:	0f 90       	pop	r0
    2626:	df 91       	pop	r29
    2628:	cf 91       	pop	r28
    262a:	08 95       	ret

0000262c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    262c:	cf 93       	push	r28
    262e:	df 93       	push	r29
    2630:	00 d0       	rcall	.+0      	; 0x2632 <vListInitialiseItem+0x6>
    2632:	cd b7       	in	r28, 0x3d	; 61
    2634:	de b7       	in	r29, 0x3e	; 62
    2636:	9a 83       	std	Y+2, r25	; 0x02
    2638:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    263a:	89 81       	ldd	r24, Y+1	; 0x01
    263c:	9a 81       	ldd	r25, Y+2	; 0x02
    263e:	fc 01       	movw	r30, r24
    2640:	11 86       	std	Z+9, r1	; 0x09
    2642:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2644:	00 00       	nop
    2646:	0f 90       	pop	r0
    2648:	0f 90       	pop	r0
    264a:	df 91       	pop	r29
    264c:	cf 91       	pop	r28
    264e:	08 95       	ret

00002650 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2650:	cf 93       	push	r28
    2652:	df 93       	push	r29
    2654:	00 d0       	rcall	.+0      	; 0x2656 <vListInsertEnd+0x6>
    2656:	00 d0       	rcall	.+0      	; 0x2658 <vListInsertEnd+0x8>
    2658:	00 d0       	rcall	.+0      	; 0x265a <vListInsertEnd+0xa>
    265a:	cd b7       	in	r28, 0x3d	; 61
    265c:	de b7       	in	r29, 0x3e	; 62
    265e:	9c 83       	std	Y+4, r25	; 0x04
    2660:	8b 83       	std	Y+3, r24	; 0x03
    2662:	7e 83       	std	Y+6, r23	; 0x06
    2664:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2666:	8b 81       	ldd	r24, Y+3	; 0x03
    2668:	9c 81       	ldd	r25, Y+4	; 0x04
    266a:	fc 01       	movw	r30, r24
    266c:	81 81       	ldd	r24, Z+1	; 0x01
    266e:	92 81       	ldd	r25, Z+2	; 0x02
    2670:	9a 83       	std	Y+2, r25	; 0x02
    2672:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2674:	8d 81       	ldd	r24, Y+5	; 0x05
    2676:	9e 81       	ldd	r25, Y+6	; 0x06
    2678:	29 81       	ldd	r18, Y+1	; 0x01
    267a:	3a 81       	ldd	r19, Y+2	; 0x02
    267c:	fc 01       	movw	r30, r24
    267e:	33 83       	std	Z+3, r19	; 0x03
    2680:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2682:	89 81       	ldd	r24, Y+1	; 0x01
    2684:	9a 81       	ldd	r25, Y+2	; 0x02
    2686:	fc 01       	movw	r30, r24
    2688:	24 81       	ldd	r18, Z+4	; 0x04
    268a:	35 81       	ldd	r19, Z+5	; 0x05
    268c:	8d 81       	ldd	r24, Y+5	; 0x05
    268e:	9e 81       	ldd	r25, Y+6	; 0x06
    2690:	fc 01       	movw	r30, r24
    2692:	35 83       	std	Z+5, r19	; 0x05
    2694:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2696:	89 81       	ldd	r24, Y+1	; 0x01
    2698:	9a 81       	ldd	r25, Y+2	; 0x02
    269a:	fc 01       	movw	r30, r24
    269c:	84 81       	ldd	r24, Z+4	; 0x04
    269e:	95 81       	ldd	r25, Z+5	; 0x05
    26a0:	2d 81       	ldd	r18, Y+5	; 0x05
    26a2:	3e 81       	ldd	r19, Y+6	; 0x06
    26a4:	fc 01       	movw	r30, r24
    26a6:	33 83       	std	Z+3, r19	; 0x03
    26a8:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    26aa:	89 81       	ldd	r24, Y+1	; 0x01
    26ac:	9a 81       	ldd	r25, Y+2	; 0x02
    26ae:	2d 81       	ldd	r18, Y+5	; 0x05
    26b0:	3e 81       	ldd	r19, Y+6	; 0x06
    26b2:	fc 01       	movw	r30, r24
    26b4:	35 83       	std	Z+5, r19	; 0x05
    26b6:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    26b8:	8d 81       	ldd	r24, Y+5	; 0x05
    26ba:	9e 81       	ldd	r25, Y+6	; 0x06
    26bc:	2b 81       	ldd	r18, Y+3	; 0x03
    26be:	3c 81       	ldd	r19, Y+4	; 0x04
    26c0:	fc 01       	movw	r30, r24
    26c2:	31 87       	std	Z+9, r19	; 0x09
    26c4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    26c6:	8b 81       	ldd	r24, Y+3	; 0x03
    26c8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ca:	fc 01       	movw	r30, r24
    26cc:	80 81       	ld	r24, Z
    26ce:	21 e0       	ldi	r18, 0x01	; 1
    26d0:	28 0f       	add	r18, r24
    26d2:	8b 81       	ldd	r24, Y+3	; 0x03
    26d4:	9c 81       	ldd	r25, Y+4	; 0x04
    26d6:	fc 01       	movw	r30, r24
    26d8:	20 83       	st	Z, r18
}
    26da:	00 00       	nop
    26dc:	26 96       	adiw	r28, 0x06	; 6
    26de:	0f b6       	in	r0, 0x3f	; 63
    26e0:	f8 94       	cli
    26e2:	de bf       	out	0x3e, r29	; 62
    26e4:	0f be       	out	0x3f, r0	; 63
    26e6:	cd bf       	out	0x3d, r28	; 61
    26e8:	df 91       	pop	r29
    26ea:	cf 91       	pop	r28
    26ec:	08 95       	ret

000026ee <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    26ee:	cf 93       	push	r28
    26f0:	df 93       	push	r29
    26f2:	cd b7       	in	r28, 0x3d	; 61
    26f4:	de b7       	in	r29, 0x3e	; 62
    26f6:	28 97       	sbiw	r28, 0x08	; 8
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	de bf       	out	0x3e, r29	; 62
    26fe:	0f be       	out	0x3f, r0	; 63
    2700:	cd bf       	out	0x3d, r28	; 61
    2702:	9e 83       	std	Y+6, r25	; 0x06
    2704:	8d 83       	std	Y+5, r24	; 0x05
    2706:	78 87       	std	Y+8, r23	; 0x08
    2708:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    270a:	8f 81       	ldd	r24, Y+7	; 0x07
    270c:	98 85       	ldd	r25, Y+8	; 0x08
    270e:	fc 01       	movw	r30, r24
    2710:	80 81       	ld	r24, Z
    2712:	91 81       	ldd	r25, Z+1	; 0x01
    2714:	9c 83       	std	Y+4, r25	; 0x04
    2716:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2718:	8b 81       	ldd	r24, Y+3	; 0x03
    271a:	9c 81       	ldd	r25, Y+4	; 0x04
    271c:	01 96       	adiw	r24, 0x01	; 1
    271e:	41 f4       	brne	.+16     	; 0x2730 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2720:	8d 81       	ldd	r24, Y+5	; 0x05
    2722:	9e 81       	ldd	r25, Y+6	; 0x06
    2724:	fc 01       	movw	r30, r24
    2726:	87 81       	ldd	r24, Z+7	; 0x07
    2728:	90 85       	ldd	r25, Z+8	; 0x08
    272a:	9a 83       	std	Y+2, r25	; 0x02
    272c:	89 83       	std	Y+1, r24	; 0x01
    272e:	1a c0       	rjmp	.+52     	; 0x2764 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2730:	8d 81       	ldd	r24, Y+5	; 0x05
    2732:	9e 81       	ldd	r25, Y+6	; 0x06
    2734:	03 96       	adiw	r24, 0x03	; 3
    2736:	9a 83       	std	Y+2, r25	; 0x02
    2738:	89 83       	std	Y+1, r24	; 0x01
    273a:	07 c0       	rjmp	.+14     	; 0x274a <vListInsert+0x5c>
    273c:	89 81       	ldd	r24, Y+1	; 0x01
    273e:	9a 81       	ldd	r25, Y+2	; 0x02
    2740:	fc 01       	movw	r30, r24
    2742:	82 81       	ldd	r24, Z+2	; 0x02
    2744:	93 81       	ldd	r25, Z+3	; 0x03
    2746:	9a 83       	std	Y+2, r25	; 0x02
    2748:	89 83       	std	Y+1, r24	; 0x01
    274a:	89 81       	ldd	r24, Y+1	; 0x01
    274c:	9a 81       	ldd	r25, Y+2	; 0x02
    274e:	fc 01       	movw	r30, r24
    2750:	82 81       	ldd	r24, Z+2	; 0x02
    2752:	93 81       	ldd	r25, Z+3	; 0x03
    2754:	fc 01       	movw	r30, r24
    2756:	20 81       	ld	r18, Z
    2758:	31 81       	ldd	r19, Z+1	; 0x01
    275a:	8b 81       	ldd	r24, Y+3	; 0x03
    275c:	9c 81       	ldd	r25, Y+4	; 0x04
    275e:	82 17       	cp	r24, r18
    2760:	93 07       	cpc	r25, r19
    2762:	60 f7       	brcc	.-40     	; 0x273c <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2764:	89 81       	ldd	r24, Y+1	; 0x01
    2766:	9a 81       	ldd	r25, Y+2	; 0x02
    2768:	fc 01       	movw	r30, r24
    276a:	22 81       	ldd	r18, Z+2	; 0x02
    276c:	33 81       	ldd	r19, Z+3	; 0x03
    276e:	8f 81       	ldd	r24, Y+7	; 0x07
    2770:	98 85       	ldd	r25, Y+8	; 0x08
    2772:	fc 01       	movw	r30, r24
    2774:	33 83       	std	Z+3, r19	; 0x03
    2776:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2778:	8f 81       	ldd	r24, Y+7	; 0x07
    277a:	98 85       	ldd	r25, Y+8	; 0x08
    277c:	fc 01       	movw	r30, r24
    277e:	82 81       	ldd	r24, Z+2	; 0x02
    2780:	93 81       	ldd	r25, Z+3	; 0x03
    2782:	2f 81       	ldd	r18, Y+7	; 0x07
    2784:	38 85       	ldd	r19, Y+8	; 0x08
    2786:	fc 01       	movw	r30, r24
    2788:	35 83       	std	Z+5, r19	; 0x05
    278a:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    278c:	8f 81       	ldd	r24, Y+7	; 0x07
    278e:	98 85       	ldd	r25, Y+8	; 0x08
    2790:	29 81       	ldd	r18, Y+1	; 0x01
    2792:	3a 81       	ldd	r19, Y+2	; 0x02
    2794:	fc 01       	movw	r30, r24
    2796:	35 83       	std	Z+5, r19	; 0x05
    2798:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    279a:	89 81       	ldd	r24, Y+1	; 0x01
    279c:	9a 81       	ldd	r25, Y+2	; 0x02
    279e:	2f 81       	ldd	r18, Y+7	; 0x07
    27a0:	38 85       	ldd	r19, Y+8	; 0x08
    27a2:	fc 01       	movw	r30, r24
    27a4:	33 83       	std	Z+3, r19	; 0x03
    27a6:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    27a8:	8f 81       	ldd	r24, Y+7	; 0x07
    27aa:	98 85       	ldd	r25, Y+8	; 0x08
    27ac:	2d 81       	ldd	r18, Y+5	; 0x05
    27ae:	3e 81       	ldd	r19, Y+6	; 0x06
    27b0:	fc 01       	movw	r30, r24
    27b2:	31 87       	std	Z+9, r19	; 0x09
    27b4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    27b6:	8d 81       	ldd	r24, Y+5	; 0x05
    27b8:	9e 81       	ldd	r25, Y+6	; 0x06
    27ba:	fc 01       	movw	r30, r24
    27bc:	80 81       	ld	r24, Z
    27be:	21 e0       	ldi	r18, 0x01	; 1
    27c0:	28 0f       	add	r18, r24
    27c2:	8d 81       	ldd	r24, Y+5	; 0x05
    27c4:	9e 81       	ldd	r25, Y+6	; 0x06
    27c6:	fc 01       	movw	r30, r24
    27c8:	20 83       	st	Z, r18
}
    27ca:	00 00       	nop
    27cc:	28 96       	adiw	r28, 0x08	; 8
    27ce:	0f b6       	in	r0, 0x3f	; 63
    27d0:	f8 94       	cli
    27d2:	de bf       	out	0x3e, r29	; 62
    27d4:	0f be       	out	0x3f, r0	; 63
    27d6:	cd bf       	out	0x3d, r28	; 61
    27d8:	df 91       	pop	r29
    27da:	cf 91       	pop	r28
    27dc:	08 95       	ret

000027de <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    27de:	cf 93       	push	r28
    27e0:	df 93       	push	r29
    27e2:	00 d0       	rcall	.+0      	; 0x27e4 <uxListRemove+0x6>
    27e4:	00 d0       	rcall	.+0      	; 0x27e6 <uxListRemove+0x8>
    27e6:	cd b7       	in	r28, 0x3d	; 61
    27e8:	de b7       	in	r29, 0x3e	; 62
    27ea:	9c 83       	std	Y+4, r25	; 0x04
    27ec:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    27ee:	8b 81       	ldd	r24, Y+3	; 0x03
    27f0:	9c 81       	ldd	r25, Y+4	; 0x04
    27f2:	fc 01       	movw	r30, r24
    27f4:	80 85       	ldd	r24, Z+8	; 0x08
    27f6:	91 85       	ldd	r25, Z+9	; 0x09
    27f8:	9a 83       	std	Y+2, r25	; 0x02
    27fa:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    27fc:	8b 81       	ldd	r24, Y+3	; 0x03
    27fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2800:	fc 01       	movw	r30, r24
    2802:	82 81       	ldd	r24, Z+2	; 0x02
    2804:	93 81       	ldd	r25, Z+3	; 0x03
    2806:	2b 81       	ldd	r18, Y+3	; 0x03
    2808:	3c 81       	ldd	r19, Y+4	; 0x04
    280a:	f9 01       	movw	r30, r18
    280c:	24 81       	ldd	r18, Z+4	; 0x04
    280e:	35 81       	ldd	r19, Z+5	; 0x05
    2810:	fc 01       	movw	r30, r24
    2812:	35 83       	std	Z+5, r19	; 0x05
    2814:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2816:	8b 81       	ldd	r24, Y+3	; 0x03
    2818:	9c 81       	ldd	r25, Y+4	; 0x04
    281a:	fc 01       	movw	r30, r24
    281c:	84 81       	ldd	r24, Z+4	; 0x04
    281e:	95 81       	ldd	r25, Z+5	; 0x05
    2820:	2b 81       	ldd	r18, Y+3	; 0x03
    2822:	3c 81       	ldd	r19, Y+4	; 0x04
    2824:	f9 01       	movw	r30, r18
    2826:	22 81       	ldd	r18, Z+2	; 0x02
    2828:	33 81       	ldd	r19, Z+3	; 0x03
    282a:	fc 01       	movw	r30, r24
    282c:	33 83       	std	Z+3, r19	; 0x03
    282e:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2830:	89 81       	ldd	r24, Y+1	; 0x01
    2832:	9a 81       	ldd	r25, Y+2	; 0x02
    2834:	fc 01       	movw	r30, r24
    2836:	21 81       	ldd	r18, Z+1	; 0x01
    2838:	32 81       	ldd	r19, Z+2	; 0x02
    283a:	8b 81       	ldd	r24, Y+3	; 0x03
    283c:	9c 81       	ldd	r25, Y+4	; 0x04
    283e:	28 17       	cp	r18, r24
    2840:	39 07       	cpc	r19, r25
    2842:	51 f4       	brne	.+20     	; 0x2858 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2844:	8b 81       	ldd	r24, Y+3	; 0x03
    2846:	9c 81       	ldd	r25, Y+4	; 0x04
    2848:	fc 01       	movw	r30, r24
    284a:	24 81       	ldd	r18, Z+4	; 0x04
    284c:	35 81       	ldd	r19, Z+5	; 0x05
    284e:	89 81       	ldd	r24, Y+1	; 0x01
    2850:	9a 81       	ldd	r25, Y+2	; 0x02
    2852:	fc 01       	movw	r30, r24
    2854:	32 83       	std	Z+2, r19	; 0x02
    2856:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2858:	8b 81       	ldd	r24, Y+3	; 0x03
    285a:	9c 81       	ldd	r25, Y+4	; 0x04
    285c:	fc 01       	movw	r30, r24
    285e:	11 86       	std	Z+9, r1	; 0x09
    2860:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2862:	89 81       	ldd	r24, Y+1	; 0x01
    2864:	9a 81       	ldd	r25, Y+2	; 0x02
    2866:	fc 01       	movw	r30, r24
    2868:	80 81       	ld	r24, Z
    286a:	2f ef       	ldi	r18, 0xFF	; 255
    286c:	28 0f       	add	r18, r24
    286e:	89 81       	ldd	r24, Y+1	; 0x01
    2870:	9a 81       	ldd	r25, Y+2	; 0x02
    2872:	fc 01       	movw	r30, r24
    2874:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2876:	89 81       	ldd	r24, Y+1	; 0x01
    2878:	9a 81       	ldd	r25, Y+2	; 0x02
    287a:	fc 01       	movw	r30, r24
    287c:	80 81       	ld	r24, Z
}
    287e:	0f 90       	pop	r0
    2880:	0f 90       	pop	r0
    2882:	0f 90       	pop	r0
    2884:	0f 90       	pop	r0
    2886:	df 91       	pop	r29
    2888:	cf 91       	pop	r28
    288a:	08 95       	ret

0000288c <main>:
#include "avr/sleep.h"
#include "KBD_interface.h"


int main(void)
{
    288c:	ef 92       	push	r14
    288e:	ff 92       	push	r15
    2890:	0f 93       	push	r16
    2892:	cf 93       	push	r28
    2894:	df 93       	push	r29
    2896:	cd b7       	in	r28, 0x3d	; 61
    2898:	de b7       	in	r29, 0x3e	; 62
	LCD_initialize();
    289a:	0e 94 bc 07 	call	0xf78	; 0xf78 <LCD_initialize>
	LCD_Void_Clear();
    289e:	0e 94 84 0c 	call	0x1908	; 0x1908 <LCD_Void_Clear>
	KBD_u8Initialize(GROUP_B);
    28a2:	81 e0       	ldi	r24, 0x01	; 1
    28a4:	0e 94 a0 05 	call	0xb40	; 0xb40 <KBD_u8Initialize>
	xTaskCreate(Clock_Second,"seconds",150,NULL,1,NULL);
    28a8:	e1 2c       	mov	r14, r1
    28aa:	f1 2c       	mov	r15, r1
    28ac:	01 e0       	ldi	r16, 0x01	; 1
    28ae:	20 e0       	ldi	r18, 0x00	; 0
    28b0:	30 e0       	ldi	r19, 0x00	; 0
    28b2:	46 e9       	ldi	r20, 0x96	; 150
    28b4:	50 e0       	ldi	r21, 0x00	; 0
    28b6:	61 e8       	ldi	r22, 0x81	; 129
    28b8:	70 e0       	ldi	r23, 0x00	; 0
    28ba:	89 e4       	ldi	r24, 0x49	; 73
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <xTaskCreate>
	xTaskCreate(Clock_Minute,"minutes",150,NULL,1,NULL);
    28c2:	e1 2c       	mov	r14, r1
    28c4:	f1 2c       	mov	r15, r1
    28c6:	01 e0       	ldi	r16, 0x01	; 1
    28c8:	20 e0       	ldi	r18, 0x00	; 0
    28ca:	30 e0       	ldi	r19, 0x00	; 0
    28cc:	46 e9       	ldi	r20, 0x96	; 150
    28ce:	50 e0       	ldi	r21, 0x00	; 0
    28d0:	69 e8       	ldi	r22, 0x89	; 137
    28d2:	70 e0       	ldi	r23, 0x00	; 0
    28d4:	8c e9       	ldi	r24, 0x9C	; 156
    28d6:	90 e0       	ldi	r25, 0x00	; 0
    28d8:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <xTaskCreate>
	xTaskCreate(Clock_Hours,"hours",150,NULL,1,NULL);
    28dc:	e1 2c       	mov	r14, r1
    28de:	f1 2c       	mov	r15, r1
    28e0:	01 e0       	ldi	r16, 0x01	; 1
    28e2:	20 e0       	ldi	r18, 0x00	; 0
    28e4:	30 e0       	ldi	r19, 0x00	; 0
    28e6:	46 e9       	ldi	r20, 0x96	; 150
    28e8:	50 e0       	ldi	r21, 0x00	; 0
    28ea:	61 e9       	ldi	r22, 0x91	; 145
    28ec:	70 e0       	ldi	r23, 0x00	; 0
    28ee:	88 ee       	ldi	r24, 0xE8	; 232
    28f0:	90 e0       	ldi	r25, 0x00	; 0
    28f2:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <xTaskCreate>
	xTaskCreate(Clock_Check_KPD,"KPD_check",150,NULL,2,NULL);
    28f6:	e1 2c       	mov	r14, r1
    28f8:	f1 2c       	mov	r15, r1
    28fa:	02 e0       	ldi	r16, 0x02	; 2
    28fc:	20 e0       	ldi	r18, 0x00	; 0
    28fe:	30 e0       	ldi	r19, 0x00	; 0
    2900:	46 e9       	ldi	r20, 0x96	; 150
    2902:	50 e0       	ldi	r21, 0x00	; 0
    2904:	67 e9       	ldi	r22, 0x97	; 151
    2906:	70 e0       	ldi	r23, 0x00	; 0
    2908:	84 e4       	ldi	r24, 0x44	; 68
    290a:	91 e0       	ldi	r25, 0x01	; 1
    290c:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <xTaskCreate>
	xTaskCreate(Clock_Enter_Typing_Mode,"Enter typing mode",300,NULL,2,NULL);
    2910:	e1 2c       	mov	r14, r1
    2912:	f1 2c       	mov	r15, r1
    2914:	02 e0       	ldi	r16, 0x02	; 2
    2916:	20 e0       	ldi	r18, 0x00	; 0
    2918:	30 e0       	ldi	r19, 0x00	; 0
    291a:	4c e2       	ldi	r20, 0x2C	; 44
    291c:	51 e0       	ldi	r21, 0x01	; 1
    291e:	61 ea       	ldi	r22, 0xA1	; 161
    2920:	70 e0       	ldi	r23, 0x00	; 0
    2922:	88 e7       	ldi	r24, 0x78	; 120
    2924:	91 e0       	ldi	r25, 0x01	; 1
    2926:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <xTaskCreate>
	vTaskStartScheduler();
    292a:	0e 94 30 24 	call	0x4860	; 0x4860 <vTaskStartScheduler>

	while(1)
	{

	}
    292e:	ff cf       	rjmp	.-2      	; 0x292e <main+0xa2>

00002930 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2930:	cf 93       	push	r28
    2932:	df 93       	push	r29
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	28 97       	sbiw	r28, 0x08	; 8
    293a:	0f b6       	in	r0, 0x3f	; 63
    293c:	f8 94       	cli
    293e:	de bf       	out	0x3e, r29	; 62
    2940:	0f be       	out	0x3f, r0	; 63
    2942:	cd bf       	out	0x3d, r28	; 61
    2944:	9c 83       	std	Y+4, r25	; 0x04
    2946:	8b 83       	std	Y+3, r24	; 0x03
    2948:	7e 83       	std	Y+6, r23	; 0x06
    294a:	6d 83       	std	Y+5, r22	; 0x05
    294c:	58 87       	std	Y+8, r21	; 0x08
    294e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2950:	8b 81       	ldd	r24, Y+3	; 0x03
    2952:	9c 81       	ldd	r25, Y+4	; 0x04
    2954:	21 e1       	ldi	r18, 0x11	; 17
    2956:	fc 01       	movw	r30, r24
    2958:	20 83       	st	Z, r18
	pxTopOfStack--;
    295a:	8b 81       	ldd	r24, Y+3	; 0x03
    295c:	9c 81       	ldd	r25, Y+4	; 0x04
    295e:	01 97       	sbiw	r24, 0x01	; 1
    2960:	9c 83       	std	Y+4, r25	; 0x04
    2962:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2964:	8b 81       	ldd	r24, Y+3	; 0x03
    2966:	9c 81       	ldd	r25, Y+4	; 0x04
    2968:	22 e2       	ldi	r18, 0x22	; 34
    296a:	fc 01       	movw	r30, r24
    296c:	20 83       	st	Z, r18
	pxTopOfStack--;
    296e:	8b 81       	ldd	r24, Y+3	; 0x03
    2970:	9c 81       	ldd	r25, Y+4	; 0x04
    2972:	01 97       	sbiw	r24, 0x01	; 1
    2974:	9c 83       	std	Y+4, r25	; 0x04
    2976:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2978:	8b 81       	ldd	r24, Y+3	; 0x03
    297a:	9c 81       	ldd	r25, Y+4	; 0x04
    297c:	23 e3       	ldi	r18, 0x33	; 51
    297e:	fc 01       	movw	r30, r24
    2980:	20 83       	st	Z, r18
	pxTopOfStack--;
    2982:	8b 81       	ldd	r24, Y+3	; 0x03
    2984:	9c 81       	ldd	r25, Y+4	; 0x04
    2986:	01 97       	sbiw	r24, 0x01	; 1
    2988:	9c 83       	std	Y+4, r25	; 0x04
    298a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    298c:	8d 81       	ldd	r24, Y+5	; 0x05
    298e:	9e 81       	ldd	r25, Y+6	; 0x06
    2990:	9a 83       	std	Y+2, r25	; 0x02
    2992:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2994:	29 81       	ldd	r18, Y+1	; 0x01
    2996:	8b 81       	ldd	r24, Y+3	; 0x03
    2998:	9c 81       	ldd	r25, Y+4	; 0x04
    299a:	fc 01       	movw	r30, r24
    299c:	20 83       	st	Z, r18
	pxTopOfStack--;
    299e:	8b 81       	ldd	r24, Y+3	; 0x03
    29a0:	9c 81       	ldd	r25, Y+4	; 0x04
    29a2:	01 97       	sbiw	r24, 0x01	; 1
    29a4:	9c 83       	std	Y+4, r25	; 0x04
    29a6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    29a8:	89 81       	ldd	r24, Y+1	; 0x01
    29aa:	9a 81       	ldd	r25, Y+2	; 0x02
    29ac:	89 2f       	mov	r24, r25
    29ae:	99 27       	eor	r25, r25
    29b0:	9a 83       	std	Y+2, r25	; 0x02
    29b2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29b4:	29 81       	ldd	r18, Y+1	; 0x01
    29b6:	8b 81       	ldd	r24, Y+3	; 0x03
    29b8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ba:	fc 01       	movw	r30, r24
    29bc:	20 83       	st	Z, r18
	pxTopOfStack--;
    29be:	8b 81       	ldd	r24, Y+3	; 0x03
    29c0:	9c 81       	ldd	r25, Y+4	; 0x04
    29c2:	01 97       	sbiw	r24, 0x01	; 1
    29c4:	9c 83       	std	Y+4, r25	; 0x04
    29c6:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    29c8:	8b 81       	ldd	r24, Y+3	; 0x03
    29ca:	9c 81       	ldd	r25, Y+4	; 0x04
    29cc:	fc 01       	movw	r30, r24
    29ce:	10 82       	st	Z, r1
	pxTopOfStack--;
    29d0:	8b 81       	ldd	r24, Y+3	; 0x03
    29d2:	9c 81       	ldd	r25, Y+4	; 0x04
    29d4:	01 97       	sbiw	r24, 0x01	; 1
    29d6:	9c 83       	std	Y+4, r25	; 0x04
    29d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    29da:	8b 81       	ldd	r24, Y+3	; 0x03
    29dc:	9c 81       	ldd	r25, Y+4	; 0x04
    29de:	20 e8       	ldi	r18, 0x80	; 128
    29e0:	fc 01       	movw	r30, r24
    29e2:	20 83       	st	Z, r18
	pxTopOfStack--;
    29e4:	8b 81       	ldd	r24, Y+3	; 0x03
    29e6:	9c 81       	ldd	r25, Y+4	; 0x04
    29e8:	01 97       	sbiw	r24, 0x01	; 1
    29ea:	9c 83       	std	Y+4, r25	; 0x04
    29ec:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    29ee:	8b 81       	ldd	r24, Y+3	; 0x03
    29f0:	9c 81       	ldd	r25, Y+4	; 0x04
    29f2:	fc 01       	movw	r30, r24
    29f4:	10 82       	st	Z, r1
	pxTopOfStack--;
    29f6:	8b 81       	ldd	r24, Y+3	; 0x03
    29f8:	9c 81       	ldd	r25, Y+4	; 0x04
    29fa:	01 97       	sbiw	r24, 0x01	; 1
    29fc:	9c 83       	std	Y+4, r25	; 0x04
    29fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2a00:	8b 81       	ldd	r24, Y+3	; 0x03
    2a02:	9c 81       	ldd	r25, Y+4	; 0x04
    2a04:	22 e0       	ldi	r18, 0x02	; 2
    2a06:	fc 01       	movw	r30, r24
    2a08:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a0e:	01 97       	sbiw	r24, 0x01	; 1
    2a10:	9c 83       	std	Y+4, r25	; 0x04
    2a12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2a14:	8b 81       	ldd	r24, Y+3	; 0x03
    2a16:	9c 81       	ldd	r25, Y+4	; 0x04
    2a18:	23 e0       	ldi	r18, 0x03	; 3
    2a1a:	fc 01       	movw	r30, r24
    2a1c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a20:	9c 81       	ldd	r25, Y+4	; 0x04
    2a22:	01 97       	sbiw	r24, 0x01	; 1
    2a24:	9c 83       	std	Y+4, r25	; 0x04
    2a26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2a28:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2c:	24 e0       	ldi	r18, 0x04	; 4
    2a2e:	fc 01       	movw	r30, r24
    2a30:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a32:	8b 81       	ldd	r24, Y+3	; 0x03
    2a34:	9c 81       	ldd	r25, Y+4	; 0x04
    2a36:	01 97       	sbiw	r24, 0x01	; 1
    2a38:	9c 83       	std	Y+4, r25	; 0x04
    2a3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a40:	25 e0       	ldi	r18, 0x05	; 5
    2a42:	fc 01       	movw	r30, r24
    2a44:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a46:	8b 81       	ldd	r24, Y+3	; 0x03
    2a48:	9c 81       	ldd	r25, Y+4	; 0x04
    2a4a:	01 97       	sbiw	r24, 0x01	; 1
    2a4c:	9c 83       	std	Y+4, r25	; 0x04
    2a4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2a50:	8b 81       	ldd	r24, Y+3	; 0x03
    2a52:	9c 81       	ldd	r25, Y+4	; 0x04
    2a54:	26 e0       	ldi	r18, 0x06	; 6
    2a56:	fc 01       	movw	r30, r24
    2a58:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5e:	01 97       	sbiw	r24, 0x01	; 1
    2a60:	9c 83       	std	Y+4, r25	; 0x04
    2a62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2a64:	8b 81       	ldd	r24, Y+3	; 0x03
    2a66:	9c 81       	ldd	r25, Y+4	; 0x04
    2a68:	27 e0       	ldi	r18, 0x07	; 7
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a70:	9c 81       	ldd	r25, Y+4	; 0x04
    2a72:	01 97       	sbiw	r24, 0x01	; 1
    2a74:	9c 83       	std	Y+4, r25	; 0x04
    2a76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2a78:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7c:	28 e0       	ldi	r18, 0x08	; 8
    2a7e:	fc 01       	movw	r30, r24
    2a80:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a82:	8b 81       	ldd	r24, Y+3	; 0x03
    2a84:	9c 81       	ldd	r25, Y+4	; 0x04
    2a86:	01 97       	sbiw	r24, 0x01	; 1
    2a88:	9c 83       	std	Y+4, r25	; 0x04
    2a8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a90:	29 e0       	ldi	r18, 0x09	; 9
    2a92:	fc 01       	movw	r30, r24
    2a94:	20 83       	st	Z, r18
	pxTopOfStack--;
    2a96:	8b 81       	ldd	r24, Y+3	; 0x03
    2a98:	9c 81       	ldd	r25, Y+4	; 0x04
    2a9a:	01 97       	sbiw	r24, 0x01	; 1
    2a9c:	9c 83       	std	Y+4, r25	; 0x04
    2a9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa4:	20 e1       	ldi	r18, 0x10	; 16
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2aac:	9c 81       	ldd	r25, Y+4	; 0x04
    2aae:	01 97       	sbiw	r24, 0x01	; 1
    2ab0:	9c 83       	std	Y+4, r25	; 0x04
    2ab2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab8:	21 e1       	ldi	r18, 0x11	; 17
    2aba:	fc 01       	movw	r30, r24
    2abc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2abe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac2:	01 97       	sbiw	r24, 0x01	; 1
    2ac4:	9c 83       	std	Y+4, r25	; 0x04
    2ac6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aca:	9c 81       	ldd	r25, Y+4	; 0x04
    2acc:	22 e1       	ldi	r18, 0x12	; 18
    2ace:	fc 01       	movw	r30, r24
    2ad0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad6:	01 97       	sbiw	r24, 0x01	; 1
    2ad8:	9c 83       	std	Y+4, r25	; 0x04
    2ada:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2adc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ade:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae0:	23 e1       	ldi	r18, 0x13	; 19
    2ae2:	fc 01       	movw	r30, r24
    2ae4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aea:	01 97       	sbiw	r24, 0x01	; 1
    2aec:	9c 83       	std	Y+4, r25	; 0x04
    2aee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2af0:	8b 81       	ldd	r24, Y+3	; 0x03
    2af2:	9c 81       	ldd	r25, Y+4	; 0x04
    2af4:	24 e1       	ldi	r18, 0x14	; 20
    2af6:	fc 01       	movw	r30, r24
    2af8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2afa:	8b 81       	ldd	r24, Y+3	; 0x03
    2afc:	9c 81       	ldd	r25, Y+4	; 0x04
    2afe:	01 97       	sbiw	r24, 0x01	; 1
    2b00:	9c 83       	std	Y+4, r25	; 0x04
    2b02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2b04:	8b 81       	ldd	r24, Y+3	; 0x03
    2b06:	9c 81       	ldd	r25, Y+4	; 0x04
    2b08:	25 e1       	ldi	r18, 0x15	; 21
    2b0a:	fc 01       	movw	r30, r24
    2b0c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b10:	9c 81       	ldd	r25, Y+4	; 0x04
    2b12:	01 97       	sbiw	r24, 0x01	; 1
    2b14:	9c 83       	std	Y+4, r25	; 0x04
    2b16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2b18:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b1c:	26 e1       	ldi	r18, 0x16	; 22
    2b1e:	fc 01       	movw	r30, r24
    2b20:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b22:	8b 81       	ldd	r24, Y+3	; 0x03
    2b24:	9c 81       	ldd	r25, Y+4	; 0x04
    2b26:	01 97       	sbiw	r24, 0x01	; 1
    2b28:	9c 83       	std	Y+4, r25	; 0x04
    2b2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b30:	27 e1       	ldi	r18, 0x17	; 23
    2b32:	fc 01       	movw	r30, r24
    2b34:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b36:	8b 81       	ldd	r24, Y+3	; 0x03
    2b38:	9c 81       	ldd	r25, Y+4	; 0x04
    2b3a:	01 97       	sbiw	r24, 0x01	; 1
    2b3c:	9c 83       	std	Y+4, r25	; 0x04
    2b3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2b40:	8b 81       	ldd	r24, Y+3	; 0x03
    2b42:	9c 81       	ldd	r25, Y+4	; 0x04
    2b44:	28 e1       	ldi	r18, 0x18	; 24
    2b46:	fc 01       	movw	r30, r24
    2b48:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4e:	01 97       	sbiw	r24, 0x01	; 1
    2b50:	9c 83       	std	Y+4, r25	; 0x04
    2b52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2b54:	8b 81       	ldd	r24, Y+3	; 0x03
    2b56:	9c 81       	ldd	r25, Y+4	; 0x04
    2b58:	29 e1       	ldi	r18, 0x19	; 25
    2b5a:	fc 01       	movw	r30, r24
    2b5c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b60:	9c 81       	ldd	r25, Y+4	; 0x04
    2b62:	01 97       	sbiw	r24, 0x01	; 1
    2b64:	9c 83       	std	Y+4, r25	; 0x04
    2b66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2b68:	8b 81       	ldd	r24, Y+3	; 0x03
    2b6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6c:	20 e2       	ldi	r18, 0x20	; 32
    2b6e:	fc 01       	movw	r30, r24
    2b70:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b72:	8b 81       	ldd	r24, Y+3	; 0x03
    2b74:	9c 81       	ldd	r25, Y+4	; 0x04
    2b76:	01 97       	sbiw	r24, 0x01	; 1
    2b78:	9c 83       	std	Y+4, r25	; 0x04
    2b7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b80:	21 e2       	ldi	r18, 0x21	; 33
    2b82:	fc 01       	movw	r30, r24
    2b84:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b86:	8b 81       	ldd	r24, Y+3	; 0x03
    2b88:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8a:	01 97       	sbiw	r24, 0x01	; 1
    2b8c:	9c 83       	std	Y+4, r25	; 0x04
    2b8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2b90:	8b 81       	ldd	r24, Y+3	; 0x03
    2b92:	9c 81       	ldd	r25, Y+4	; 0x04
    2b94:	22 e2       	ldi	r18, 0x22	; 34
    2b96:	fc 01       	movw	r30, r24
    2b98:	20 83       	st	Z, r18
	pxTopOfStack--;
    2b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b9e:	01 97       	sbiw	r24, 0x01	; 1
    2ba0:	9c 83       	std	Y+4, r25	; 0x04
    2ba2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2ba4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba8:	23 e2       	ldi	r18, 0x23	; 35
    2baa:	fc 01       	movw	r30, r24
    2bac:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bae:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb2:	01 97       	sbiw	r24, 0x01	; 1
    2bb4:	9c 83       	std	Y+4, r25	; 0x04
    2bb6:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2bb8:	8f 81       	ldd	r24, Y+7	; 0x07
    2bba:	98 85       	ldd	r25, Y+8	; 0x08
    2bbc:	9a 83       	std	Y+2, r25	; 0x02
    2bbe:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2bc0:	29 81       	ldd	r18, Y+1	; 0x01
    2bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc6:	fc 01       	movw	r30, r24
    2bc8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bca:	8b 81       	ldd	r24, Y+3	; 0x03
    2bcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bce:	01 97       	sbiw	r24, 0x01	; 1
    2bd0:	9c 83       	std	Y+4, r25	; 0x04
    2bd2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2bd4:	89 81       	ldd	r24, Y+1	; 0x01
    2bd6:	9a 81       	ldd	r25, Y+2	; 0x02
    2bd8:	89 2f       	mov	r24, r25
    2bda:	99 27       	eor	r25, r25
    2bdc:	9a 83       	std	Y+2, r25	; 0x02
    2bde:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2be0:	29 81       	ldd	r18, Y+1	; 0x01
    2be2:	8b 81       	ldd	r24, Y+3	; 0x03
    2be4:	9c 81       	ldd	r25, Y+4	; 0x04
    2be6:	fc 01       	movw	r30, r24
    2be8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bea:	8b 81       	ldd	r24, Y+3	; 0x03
    2bec:	9c 81       	ldd	r25, Y+4	; 0x04
    2bee:	01 97       	sbiw	r24, 0x01	; 1
    2bf0:	9c 83       	std	Y+4, r25	; 0x04
    2bf2:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf8:	26 e2       	ldi	r18, 0x26	; 38
    2bfa:	fc 01       	movw	r30, r24
    2bfc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2c00:	9c 81       	ldd	r25, Y+4	; 0x04
    2c02:	01 97       	sbiw	r24, 0x01	; 1
    2c04:	9c 83       	std	Y+4, r25	; 0x04
    2c06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2c08:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c0c:	27 e2       	ldi	r18, 0x27	; 39
    2c0e:	fc 01       	movw	r30, r24
    2c10:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c12:	8b 81       	ldd	r24, Y+3	; 0x03
    2c14:	9c 81       	ldd	r25, Y+4	; 0x04
    2c16:	01 97       	sbiw	r24, 0x01	; 1
    2c18:	9c 83       	std	Y+4, r25	; 0x04
    2c1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c20:	28 e2       	ldi	r18, 0x28	; 40
    2c22:	fc 01       	movw	r30, r24
    2c24:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c26:	8b 81       	ldd	r24, Y+3	; 0x03
    2c28:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2a:	01 97       	sbiw	r24, 0x01	; 1
    2c2c:	9c 83       	std	Y+4, r25	; 0x04
    2c2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2c30:	8b 81       	ldd	r24, Y+3	; 0x03
    2c32:	9c 81       	ldd	r25, Y+4	; 0x04
    2c34:	29 e2       	ldi	r18, 0x29	; 41
    2c36:	fc 01       	movw	r30, r24
    2c38:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3e:	01 97       	sbiw	r24, 0x01	; 1
    2c40:	9c 83       	std	Y+4, r25	; 0x04
    2c42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2c44:	8b 81       	ldd	r24, Y+3	; 0x03
    2c46:	9c 81       	ldd	r25, Y+4	; 0x04
    2c48:	20 e3       	ldi	r18, 0x30	; 48
    2c4a:	fc 01       	movw	r30, r24
    2c4c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c50:	9c 81       	ldd	r25, Y+4	; 0x04
    2c52:	01 97       	sbiw	r24, 0x01	; 1
    2c54:	9c 83       	std	Y+4, r25	; 0x04
    2c56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2c58:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5c:	21 e3       	ldi	r18, 0x31	; 49
    2c5e:	fc 01       	movw	r30, r24
    2c60:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	01 97       	sbiw	r24, 0x01	; 1
    2c68:	9c 83       	std	Y+4, r25	; 0x04
    2c6a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2c70:	28 96       	adiw	r28, 0x08	; 8
    2c72:	0f b6       	in	r0, 0x3f	; 63
    2c74:	f8 94       	cli
    2c76:	de bf       	out	0x3e, r29	; 62
    2c78:	0f be       	out	0x3f, r0	; 63
    2c7a:	cd bf       	out	0x3d, r28	; 61
    2c7c:	df 91       	pop	r29
    2c7e:	cf 91       	pop	r28
    2c80:	08 95       	ret

00002c82 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2c82:	cf 93       	push	r28
    2c84:	df 93       	push	r29
    2c86:	cd b7       	in	r28, 0x3d	; 61
    2c88:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2c8a:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2c8e:	a0 91 9d 06 	lds	r26, 0x069D	; 0x80069d <pxCurrentTCB>
    2c92:	b0 91 9e 06 	lds	r27, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    2c96:	cd 91       	ld	r28, X+
    2c98:	cd bf       	out	0x3d, r28	; 61
    2c9a:	dd 91       	ld	r29, X+
    2c9c:	de bf       	out	0x3e, r29	; 62
    2c9e:	ff 91       	pop	r31
    2ca0:	ef 91       	pop	r30
    2ca2:	df 91       	pop	r29
    2ca4:	cf 91       	pop	r28
    2ca6:	bf 91       	pop	r27
    2ca8:	af 91       	pop	r26
    2caa:	9f 91       	pop	r25
    2cac:	8f 91       	pop	r24
    2cae:	7f 91       	pop	r23
    2cb0:	6f 91       	pop	r22
    2cb2:	5f 91       	pop	r21
    2cb4:	4f 91       	pop	r20
    2cb6:	3f 91       	pop	r19
    2cb8:	2f 91       	pop	r18
    2cba:	1f 91       	pop	r17
    2cbc:	0f 91       	pop	r16
    2cbe:	ff 90       	pop	r15
    2cc0:	ef 90       	pop	r14
    2cc2:	df 90       	pop	r13
    2cc4:	cf 90       	pop	r12
    2cc6:	bf 90       	pop	r11
    2cc8:	af 90       	pop	r10
    2cca:	9f 90       	pop	r9
    2ccc:	8f 90       	pop	r8
    2cce:	7f 90       	pop	r7
    2cd0:	6f 90       	pop	r6
    2cd2:	5f 90       	pop	r5
    2cd4:	4f 90       	pop	r4
    2cd6:	3f 90       	pop	r3
    2cd8:	2f 90       	pop	r2
    2cda:	1f 90       	pop	r1
    2cdc:	0f 90       	pop	r0
    2cde:	0f be       	out	0x3f, r0	; 63
    2ce0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2ce2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2ce4:	81 e0       	ldi	r24, 0x01	; 1
}
    2ce6:	df 91       	pop	r29
    2ce8:	cf 91       	pop	r28
    2cea:	08 95       	ret

00002cec <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2cec:	cf 93       	push	r28
    2cee:	df 93       	push	r29
    2cf0:	cd b7       	in	r28, 0x3d	; 61
    2cf2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2cf4:	00 00       	nop
    2cf6:	df 91       	pop	r29
    2cf8:	cf 91       	pop	r28
    2cfa:	08 95       	ret

00002cfc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2cfc:	0f 92       	push	r0
    2cfe:	0f b6       	in	r0, 0x3f	; 63
    2d00:	f8 94       	cli
    2d02:	0f 92       	push	r0
    2d04:	1f 92       	push	r1
    2d06:	11 24       	eor	r1, r1
    2d08:	2f 92       	push	r2
    2d0a:	3f 92       	push	r3
    2d0c:	4f 92       	push	r4
    2d0e:	5f 92       	push	r5
    2d10:	6f 92       	push	r6
    2d12:	7f 92       	push	r7
    2d14:	8f 92       	push	r8
    2d16:	9f 92       	push	r9
    2d18:	af 92       	push	r10
    2d1a:	bf 92       	push	r11
    2d1c:	cf 92       	push	r12
    2d1e:	df 92       	push	r13
    2d20:	ef 92       	push	r14
    2d22:	ff 92       	push	r15
    2d24:	0f 93       	push	r16
    2d26:	1f 93       	push	r17
    2d28:	2f 93       	push	r18
    2d2a:	3f 93       	push	r19
    2d2c:	4f 93       	push	r20
    2d2e:	5f 93       	push	r21
    2d30:	6f 93       	push	r22
    2d32:	7f 93       	push	r23
    2d34:	8f 93       	push	r24
    2d36:	9f 93       	push	r25
    2d38:	af 93       	push	r26
    2d3a:	bf 93       	push	r27
    2d3c:	cf 93       	push	r28
    2d3e:	df 93       	push	r29
    2d40:	ef 93       	push	r30
    2d42:	ff 93       	push	r31
    2d44:	a0 91 9d 06 	lds	r26, 0x069D	; 0x80069d <pxCurrentTCB>
    2d48:	b0 91 9e 06 	lds	r27, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    2d4c:	0d b6       	in	r0, 0x3d	; 61
    2d4e:	0d 92       	st	X+, r0
    2d50:	0e b6       	in	r0, 0x3e	; 62
    2d52:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2d54:	0e 94 57 26 	call	0x4cae	; 0x4cae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2d58:	a0 91 9d 06 	lds	r26, 0x069D	; 0x80069d <pxCurrentTCB>
    2d5c:	b0 91 9e 06 	lds	r27, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    2d60:	cd 91       	ld	r28, X+
    2d62:	cd bf       	out	0x3d, r28	; 61
    2d64:	dd 91       	ld	r29, X+
    2d66:	de bf       	out	0x3e, r29	; 62
    2d68:	ff 91       	pop	r31
    2d6a:	ef 91       	pop	r30
    2d6c:	df 91       	pop	r29
    2d6e:	cf 91       	pop	r28
    2d70:	bf 91       	pop	r27
    2d72:	af 91       	pop	r26
    2d74:	9f 91       	pop	r25
    2d76:	8f 91       	pop	r24
    2d78:	7f 91       	pop	r23
    2d7a:	6f 91       	pop	r22
    2d7c:	5f 91       	pop	r21
    2d7e:	4f 91       	pop	r20
    2d80:	3f 91       	pop	r19
    2d82:	2f 91       	pop	r18
    2d84:	1f 91       	pop	r17
    2d86:	0f 91       	pop	r16
    2d88:	ff 90       	pop	r15
    2d8a:	ef 90       	pop	r14
    2d8c:	df 90       	pop	r13
    2d8e:	cf 90       	pop	r12
    2d90:	bf 90       	pop	r11
    2d92:	af 90       	pop	r10
    2d94:	9f 90       	pop	r9
    2d96:	8f 90       	pop	r8
    2d98:	7f 90       	pop	r7
    2d9a:	6f 90       	pop	r6
    2d9c:	5f 90       	pop	r5
    2d9e:	4f 90       	pop	r4
    2da0:	3f 90       	pop	r3
    2da2:	2f 90       	pop	r2
    2da4:	1f 90       	pop	r1
    2da6:	0f 90       	pop	r0
    2da8:	0f be       	out	0x3f, r0	; 63
    2daa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2dac:	08 95       	ret
	...

00002db0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2db0:	0f 92       	push	r0
    2db2:	0f b6       	in	r0, 0x3f	; 63
    2db4:	f8 94       	cli
    2db6:	0f 92       	push	r0
    2db8:	1f 92       	push	r1
    2dba:	11 24       	eor	r1, r1
    2dbc:	2f 92       	push	r2
    2dbe:	3f 92       	push	r3
    2dc0:	4f 92       	push	r4
    2dc2:	5f 92       	push	r5
    2dc4:	6f 92       	push	r6
    2dc6:	7f 92       	push	r7
    2dc8:	8f 92       	push	r8
    2dca:	9f 92       	push	r9
    2dcc:	af 92       	push	r10
    2dce:	bf 92       	push	r11
    2dd0:	cf 92       	push	r12
    2dd2:	df 92       	push	r13
    2dd4:	ef 92       	push	r14
    2dd6:	ff 92       	push	r15
    2dd8:	0f 93       	push	r16
    2dda:	1f 93       	push	r17
    2ddc:	2f 93       	push	r18
    2dde:	3f 93       	push	r19
    2de0:	4f 93       	push	r20
    2de2:	5f 93       	push	r21
    2de4:	6f 93       	push	r22
    2de6:	7f 93       	push	r23
    2de8:	8f 93       	push	r24
    2dea:	9f 93       	push	r25
    2dec:	af 93       	push	r26
    2dee:	bf 93       	push	r27
    2df0:	cf 93       	push	r28
    2df2:	df 93       	push	r29
    2df4:	ef 93       	push	r30
    2df6:	ff 93       	push	r31
    2df8:	a0 91 9d 06 	lds	r26, 0x069D	; 0x80069d <pxCurrentTCB>
    2dfc:	b0 91 9e 06 	lds	r27, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    2e00:	0d b6       	in	r0, 0x3d	; 61
    2e02:	0d 92       	st	X+, r0
    2e04:	0e b6       	in	r0, 0x3e	; 62
    2e06:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2e08:	0e 94 6a 25 	call	0x4ad4	; 0x4ad4 <xTaskIncrementTick>
    2e0c:	88 23       	and	r24, r24
    2e0e:	11 f0       	breq	.+4      	; 0x2e14 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2e10:	0e 94 57 26 	call	0x4cae	; 0x4cae <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2e14:	a0 91 9d 06 	lds	r26, 0x069D	; 0x80069d <pxCurrentTCB>
    2e18:	b0 91 9e 06 	lds	r27, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    2e1c:	cd 91       	ld	r28, X+
    2e1e:	cd bf       	out	0x3d, r28	; 61
    2e20:	dd 91       	ld	r29, X+
    2e22:	de bf       	out	0x3e, r29	; 62
    2e24:	ff 91       	pop	r31
    2e26:	ef 91       	pop	r30
    2e28:	df 91       	pop	r29
    2e2a:	cf 91       	pop	r28
    2e2c:	bf 91       	pop	r27
    2e2e:	af 91       	pop	r26
    2e30:	9f 91       	pop	r25
    2e32:	8f 91       	pop	r24
    2e34:	7f 91       	pop	r23
    2e36:	6f 91       	pop	r22
    2e38:	5f 91       	pop	r21
    2e3a:	4f 91       	pop	r20
    2e3c:	3f 91       	pop	r19
    2e3e:	2f 91       	pop	r18
    2e40:	1f 91       	pop	r17
    2e42:	0f 91       	pop	r16
    2e44:	ff 90       	pop	r15
    2e46:	ef 90       	pop	r14
    2e48:	df 90       	pop	r13
    2e4a:	cf 90       	pop	r12
    2e4c:	bf 90       	pop	r11
    2e4e:	af 90       	pop	r10
    2e50:	9f 90       	pop	r9
    2e52:	8f 90       	pop	r8
    2e54:	7f 90       	pop	r7
    2e56:	6f 90       	pop	r6
    2e58:	5f 90       	pop	r5
    2e5a:	4f 90       	pop	r4
    2e5c:	3f 90       	pop	r3
    2e5e:	2f 90       	pop	r2
    2e60:	1f 90       	pop	r1
    2e62:	0f 90       	pop	r0
    2e64:	0f be       	out	0x3f, r0	; 63
    2e66:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e68:	08 95       	ret
	...

00002e6c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2e6c:	cf 93       	push	r28
    2e6e:	df 93       	push	r29
    2e70:	00 d0       	rcall	.+0      	; 0x2e72 <prvSetupTimerInterrupt+0x6>
    2e72:	00 d0       	rcall	.+0      	; 0x2e74 <prvSetupTimerInterrupt+0x8>
    2e74:	00 d0       	rcall	.+0      	; 0x2e76 <prvSetupTimerInterrupt+0xa>
    2e76:	cd b7       	in	r28, 0x3d	; 61
    2e78:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2e7a:	80 e0       	ldi	r24, 0x00	; 0
    2e7c:	95 e3       	ldi	r25, 0x35	; 53
    2e7e:	ac e0       	ldi	r26, 0x0C	; 12
    2e80:	b0 e0       	ldi	r27, 0x00	; 0
    2e82:	89 83       	std	Y+1, r24	; 0x01
    2e84:	9a 83       	std	Y+2, r25	; 0x02
    2e86:	ab 83       	std	Y+3, r26	; 0x03
    2e88:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2e8a:	89 81       	ldd	r24, Y+1	; 0x01
    2e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e8e:	ab 81       	ldd	r26, Y+3	; 0x03
    2e90:	bc 81       	ldd	r27, Y+4	; 0x04
    2e92:	68 94       	set
    2e94:	15 f8       	bld	r1, 5
    2e96:	b6 95       	lsr	r27
    2e98:	a7 95       	ror	r26
    2e9a:	97 95       	ror	r25
    2e9c:	87 95       	ror	r24
    2e9e:	16 94       	lsr	r1
    2ea0:	d1 f7       	brne	.-12     	; 0x2e96 <prvSetupTimerInterrupt+0x2a>
    2ea2:	89 83       	std	Y+1, r24	; 0x01
    2ea4:	9a 83       	std	Y+2, r25	; 0x02
    2ea6:	ab 83       	std	Y+3, r26	; 0x03
    2ea8:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2eaa:	89 81       	ldd	r24, Y+1	; 0x01
    2eac:	9a 81       	ldd	r25, Y+2	; 0x02
    2eae:	ab 81       	ldd	r26, Y+3	; 0x03
    2eb0:	bc 81       	ldd	r27, Y+4	; 0x04
    2eb2:	01 97       	sbiw	r24, 0x01	; 1
    2eb4:	a1 09       	sbc	r26, r1
    2eb6:	b1 09       	sbc	r27, r1
    2eb8:	89 83       	std	Y+1, r24	; 0x01
    2eba:	9a 83       	std	Y+2, r25	; 0x02
    2ebc:	ab 83       	std	Y+3, r26	; 0x03
    2ebe:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2ec0:	89 81       	ldd	r24, Y+1	; 0x01
    2ec2:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    2ec4:	89 81       	ldd	r24, Y+1	; 0x01
    2ec6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec8:	ab 81       	ldd	r26, Y+3	; 0x03
    2eca:	bc 81       	ldd	r27, Y+4	; 0x04
    2ecc:	89 2f       	mov	r24, r25
    2ece:	9a 2f       	mov	r25, r26
    2ed0:	ab 2f       	mov	r26, r27
    2ed2:	bb 27       	eor	r27, r27
    2ed4:	89 83       	std	Y+1, r24	; 0x01
    2ed6:	9a 83       	std	Y+2, r25	; 0x02
    2ed8:	ab 83       	std	Y+3, r26	; 0x03
    2eda:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2edc:	89 81       	ldd	r24, Y+1	; 0x01
    2ede:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    2ee0:	8b e4       	ldi	r24, 0x4B	; 75
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	2e 81       	ldd	r18, Y+6	; 0x06
    2ee6:	fc 01       	movw	r30, r24
    2ee8:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    2eea:	8a e4       	ldi	r24, 0x4A	; 74
    2eec:	90 e0       	ldi	r25, 0x00	; 0
    2eee:	2d 81       	ldd	r18, Y+5	; 0x05
    2ef0:	fc 01       	movw	r30, r24
    2ef2:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2ef4:	8b e0       	ldi	r24, 0x0B	; 11
    2ef6:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    2ef8:	8e e4       	ldi	r24, 0x4E	; 78
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	2d 81       	ldd	r18, Y+5	; 0x05
    2efe:	fc 01       	movw	r30, r24
    2f00:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2f02:	89 e5       	ldi	r24, 0x59	; 89
    2f04:	90 e0       	ldi	r25, 0x00	; 0
    2f06:	fc 01       	movw	r30, r24
    2f08:	80 81       	ld	r24, Z
    2f0a:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2f0c:	8d 81       	ldd	r24, Y+5	; 0x05
    2f0e:	80 61       	ori	r24, 0x10	; 16
    2f10:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK = ucLowByte;
    2f12:	89 e5       	ldi	r24, 0x59	; 89
    2f14:	90 e0       	ldi	r25, 0x00	; 0
    2f16:	2d 81       	ldd	r18, Y+5	; 0x05
    2f18:	fc 01       	movw	r30, r24
    2f1a:	20 83       	st	Z, r18
}
    2f1c:	00 00       	nop
    2f1e:	26 96       	adiw	r28, 0x06	; 6
    2f20:	0f b6       	in	r0, 0x3f	; 63
    2f22:	f8 94       	cli
    2f24:	de bf       	out	0x3e, r29	; 62
    2f26:	0f be       	out	0x3f, r0	; 63
    2f28:	cd bf       	out	0x3d, r28	; 61
    2f2a:	df 91       	pop	r29
    2f2c:	cf 91       	pop	r28
    2f2e:	08 95       	ret

00002f30 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void _VECTOR(7)( void ) __attribute__ ( ( signal, naked ) );
	void _VECTOR(7)( void )
	{
		vPortYieldFromTick();
    2f30:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2f34:	18 95       	reti
	...

00002f38 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2f38:	cf 93       	push	r28
    2f3a:	df 93       	push	r29
    2f3c:	00 d0       	rcall	.+0      	; 0x2f3e <xQueueGenericReset+0x6>
    2f3e:	00 d0       	rcall	.+0      	; 0x2f40 <xQueueGenericReset+0x8>
    2f40:	1f 92       	push	r1
    2f42:	cd b7       	in	r28, 0x3d	; 61
    2f44:	de b7       	in	r29, 0x3e	; 62
    2f46:	9c 83       	std	Y+4, r25	; 0x04
    2f48:	8b 83       	std	Y+3, r24	; 0x03
    2f4a:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f50:	9a 83       	std	Y+2, r25	; 0x02
    2f52:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2f54:	0f b6       	in	r0, 0x3f	; 63
    2f56:	f8 94       	cli
    2f58:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2f5a:	89 81       	ldd	r24, Y+1	; 0x01
    2f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f5e:	fc 01       	movw	r30, r24
    2f60:	80 81       	ld	r24, Z
    2f62:	91 81       	ldd	r25, Z+1	; 0x01
    2f64:	29 81       	ldd	r18, Y+1	; 0x01
    2f66:	3a 81       	ldd	r19, Y+2	; 0x02
    2f68:	f9 01       	movw	r30, r18
    2f6a:	23 8d       	ldd	r18, Z+27	; 0x1b
    2f6c:	42 2f       	mov	r20, r18
    2f6e:	50 e0       	ldi	r21, 0x00	; 0
    2f70:	29 81       	ldd	r18, Y+1	; 0x01
    2f72:	3a 81       	ldd	r19, Y+2	; 0x02
    2f74:	f9 01       	movw	r30, r18
    2f76:	24 8d       	ldd	r18, Z+28	; 0x1c
    2f78:	22 2f       	mov	r18, r18
    2f7a:	30 e0       	ldi	r19, 0x00	; 0
    2f7c:	42 9f       	mul	r20, r18
    2f7e:	b0 01       	movw	r22, r0
    2f80:	43 9f       	mul	r20, r19
    2f82:	70 0d       	add	r23, r0
    2f84:	52 9f       	mul	r21, r18
    2f86:	70 0d       	add	r23, r0
    2f88:	11 24       	eor	r1, r1
    2f8a:	9b 01       	movw	r18, r22
    2f8c:	28 0f       	add	r18, r24
    2f8e:	39 1f       	adc	r19, r25
    2f90:	89 81       	ldd	r24, Y+1	; 0x01
    2f92:	9a 81       	ldd	r25, Y+2	; 0x02
    2f94:	fc 01       	movw	r30, r24
    2f96:	35 83       	std	Z+5, r19	; 0x05
    2f98:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2f9a:	89 81       	ldd	r24, Y+1	; 0x01
    2f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f9e:	fc 01       	movw	r30, r24
    2fa0:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2fa2:	89 81       	ldd	r24, Y+1	; 0x01
    2fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fa6:	fc 01       	movw	r30, r24
    2fa8:	20 81       	ld	r18, Z
    2faa:	31 81       	ldd	r19, Z+1	; 0x01
    2fac:	89 81       	ldd	r24, Y+1	; 0x01
    2fae:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb0:	fc 01       	movw	r30, r24
    2fb2:	33 83       	std	Z+3, r19	; 0x03
    2fb4:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2fb6:	89 81       	ldd	r24, Y+1	; 0x01
    2fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    2fba:	fc 01       	movw	r30, r24
    2fbc:	20 81       	ld	r18, Z
    2fbe:	31 81       	ldd	r19, Z+1	; 0x01
    2fc0:	89 81       	ldd	r24, Y+1	; 0x01
    2fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc4:	fc 01       	movw	r30, r24
    2fc6:	83 8d       	ldd	r24, Z+27	; 0x1b
    2fc8:	88 2f       	mov	r24, r24
    2fca:	90 e0       	ldi	r25, 0x00	; 0
    2fcc:	bc 01       	movw	r22, r24
    2fce:	61 50       	subi	r22, 0x01	; 1
    2fd0:	71 09       	sbc	r23, r1
    2fd2:	89 81       	ldd	r24, Y+1	; 0x01
    2fd4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd6:	fc 01       	movw	r30, r24
    2fd8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fda:	48 2f       	mov	r20, r24
    2fdc:	50 e0       	ldi	r21, 0x00	; 0
    2fde:	64 9f       	mul	r22, r20
    2fe0:	c0 01       	movw	r24, r0
    2fe2:	65 9f       	mul	r22, r21
    2fe4:	90 0d       	add	r25, r0
    2fe6:	74 9f       	mul	r23, r20
    2fe8:	90 0d       	add	r25, r0
    2fea:	11 24       	eor	r1, r1
    2fec:	28 0f       	add	r18, r24
    2fee:	39 1f       	adc	r19, r25
    2ff0:	89 81       	ldd	r24, Y+1	; 0x01
    2ff2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff4:	fc 01       	movw	r30, r24
    2ff6:	37 83       	std	Z+7, r19	; 0x07
    2ff8:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2ffa:	89 81       	ldd	r24, Y+1	; 0x01
    2ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ffe:	2f ef       	ldi	r18, 0xFF	; 255
    3000:	fc 01       	movw	r30, r24
    3002:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    3004:	89 81       	ldd	r24, Y+1	; 0x01
    3006:	9a 81       	ldd	r25, Y+2	; 0x02
    3008:	2f ef       	ldi	r18, 0xFF	; 255
    300a:	fc 01       	movw	r30, r24
    300c:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    300e:	8d 81       	ldd	r24, Y+5	; 0x05
    3010:	88 23       	and	r24, r24
    3012:	81 f4       	brne	.+32     	; 0x3034 <xQueueGenericReset+0xfc>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3014:	89 81       	ldd	r24, Y+1	; 0x01
    3016:	9a 81       	ldd	r25, Y+2	; 0x02
    3018:	fc 01       	movw	r30, r24
    301a:	80 85       	ldd	r24, Z+8	; 0x08
    301c:	88 23       	and	r24, r24
    301e:	a1 f0       	breq	.+40     	; 0x3048 <xQueueGenericReset+0x110>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3020:	89 81       	ldd	r24, Y+1	; 0x01
    3022:	9a 81       	ldd	r25, Y+2	; 0x02
    3024:	08 96       	adiw	r24, 0x08	; 8
    3026:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    302a:	88 23       	and	r24, r24
    302c:	69 f0       	breq	.+26     	; 0x3048 <xQueueGenericReset+0x110>
				{
					queueYIELD_IF_USING_PREEMPTION();
    302e:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
    3032:	0a c0       	rjmp	.+20     	; 0x3048 <xQueueGenericReset+0x110>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3034:	89 81       	ldd	r24, Y+1	; 0x01
    3036:	9a 81       	ldd	r25, Y+2	; 0x02
    3038:	08 96       	adiw	r24, 0x08	; 8
    303a:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    303e:	89 81       	ldd	r24, Y+1	; 0x01
    3040:	9a 81       	ldd	r25, Y+2	; 0x02
    3042:	41 96       	adiw	r24, 0x11	; 17
    3044:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    3048:	0f 90       	pop	r0
    304a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    304c:	81 e0       	ldi	r24, 0x01	; 1
}
    304e:	0f 90       	pop	r0
    3050:	0f 90       	pop	r0
    3052:	0f 90       	pop	r0
    3054:	0f 90       	pop	r0
    3056:	0f 90       	pop	r0
    3058:	df 91       	pop	r29
    305a:	cf 91       	pop	r28
    305c:	08 95       	ret

0000305e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    305e:	0f 93       	push	r16
    3060:	1f 93       	push	r17
    3062:	cf 93       	push	r28
    3064:	df 93       	push	r29
    3066:	cd b7       	in	r28, 0x3d	; 61
    3068:	de b7       	in	r29, 0x3e	; 62
    306a:	29 97       	sbiw	r28, 0x09	; 9
    306c:	0f b6       	in	r0, 0x3f	; 63
    306e:	f8 94       	cli
    3070:	de bf       	out	0x3e, r29	; 62
    3072:	0f be       	out	0x3f, r0	; 63
    3074:	cd bf       	out	0x3d, r28	; 61
    3076:	8f 83       	std	Y+7, r24	; 0x07
    3078:	68 87       	std	Y+8, r22	; 0x08
    307a:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    307c:	88 85       	ldd	r24, Y+8	; 0x08
    307e:	88 23       	and	r24, r24
    3080:	19 f4       	brne	.+6      	; 0x3088 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    3082:	1a 82       	std	Y+2, r1	; 0x02
    3084:	19 82       	std	Y+1, r1	; 0x01
    3086:	0f c0       	rjmp	.+30     	; 0x30a6 <xQueueGenericCreate+0x48>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3088:	8f 81       	ldd	r24, Y+7	; 0x07
    308a:	48 2f       	mov	r20, r24
    308c:	50 e0       	ldi	r21, 0x00	; 0
    308e:	88 85       	ldd	r24, Y+8	; 0x08
    3090:	28 2f       	mov	r18, r24
    3092:	30 e0       	ldi	r19, 0x00	; 0
    3094:	42 9f       	mul	r20, r18
    3096:	c0 01       	movw	r24, r0
    3098:	43 9f       	mul	r20, r19
    309a:	90 0d       	add	r25, r0
    309c:	52 9f       	mul	r21, r18
    309e:	90 0d       	add	r25, r0
    30a0:	11 24       	eor	r1, r1
    30a2:	9a 83       	std	Y+2, r25	; 0x02
    30a4:	89 83       	std	Y+1, r24	; 0x01
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    30a6:	89 81       	ldd	r24, Y+1	; 0x01
    30a8:	9a 81       	ldd	r25, Y+2	; 0x02
    30aa:	4f 96       	adiw	r24, 0x1f	; 31
    30ac:	0e 94 61 12 	call	0x24c2	; 0x24c2 <pvPortMalloc>
    30b0:	9c 83       	std	Y+4, r25	; 0x04
    30b2:	8b 83       	std	Y+3, r24	; 0x03

		if( pxNewQueue != NULL )
    30b4:	8b 81       	ldd	r24, Y+3	; 0x03
    30b6:	9c 81       	ldd	r25, Y+4	; 0x04
    30b8:	89 2b       	or	r24, r25
    30ba:	a1 f0       	breq	.+40     	; 0x30e4 <xQueueGenericCreate+0x86>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    30bc:	8b 81       	ldd	r24, Y+3	; 0x03
    30be:	9c 81       	ldd	r25, Y+4	; 0x04
    30c0:	9e 83       	std	Y+6, r25	; 0x06
    30c2:	8d 83       	std	Y+5, r24	; 0x05
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    30c4:	8d 81       	ldd	r24, Y+5	; 0x05
    30c6:	9e 81       	ldd	r25, Y+6	; 0x06
    30c8:	4f 96       	adiw	r24, 0x1f	; 31
    30ca:	9e 83       	std	Y+6, r25	; 0x06
    30cc:	8d 83       	std	Y+5, r24	; 0x05
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    30ce:	2b 81       	ldd	r18, Y+3	; 0x03
    30d0:	3c 81       	ldd	r19, Y+4	; 0x04
    30d2:	8d 81       	ldd	r24, Y+5	; 0x05
    30d4:	9e 81       	ldd	r25, Y+6	; 0x06
    30d6:	89 01       	movw	r16, r18
    30d8:	29 85       	ldd	r18, Y+9	; 0x09
    30da:	ac 01       	movw	r20, r24
    30dc:	68 85       	ldd	r22, Y+8	; 0x08
    30de:	8f 81       	ldd	r24, Y+7	; 0x07
    30e0:	0e 94 7f 18 	call	0x30fe	; 0x30fe <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    30e4:	8b 81       	ldd	r24, Y+3	; 0x03
    30e6:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    30e8:	29 96       	adiw	r28, 0x09	; 9
    30ea:	0f b6       	in	r0, 0x3f	; 63
    30ec:	f8 94       	cli
    30ee:	de bf       	out	0x3e, r29	; 62
    30f0:	0f be       	out	0x3f, r0	; 63
    30f2:	cd bf       	out	0x3d, r28	; 61
    30f4:	df 91       	pop	r29
    30f6:	cf 91       	pop	r28
    30f8:	1f 91       	pop	r17
    30fa:	0f 91       	pop	r16
    30fc:	08 95       	ret

000030fe <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    30fe:	0f 93       	push	r16
    3100:	1f 93       	push	r17
    3102:	cf 93       	push	r28
    3104:	df 93       	push	r29
    3106:	cd b7       	in	r28, 0x3d	; 61
    3108:	de b7       	in	r29, 0x3e	; 62
    310a:	27 97       	sbiw	r28, 0x07	; 7
    310c:	0f b6       	in	r0, 0x3f	; 63
    310e:	f8 94       	cli
    3110:	de bf       	out	0x3e, r29	; 62
    3112:	0f be       	out	0x3f, r0	; 63
    3114:	cd bf       	out	0x3d, r28	; 61
    3116:	89 83       	std	Y+1, r24	; 0x01
    3118:	6a 83       	std	Y+2, r22	; 0x02
    311a:	5c 83       	std	Y+4, r21	; 0x04
    311c:	4b 83       	std	Y+3, r20	; 0x03
    311e:	2d 83       	std	Y+5, r18	; 0x05
    3120:	1f 83       	std	Y+7, r17	; 0x07
    3122:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    3124:	8a 81       	ldd	r24, Y+2	; 0x02
    3126:	88 23       	and	r24, r24
    3128:	41 f4       	brne	.+16     	; 0x313a <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    312a:	8e 81       	ldd	r24, Y+6	; 0x06
    312c:	9f 81       	ldd	r25, Y+7	; 0x07
    312e:	2e 81       	ldd	r18, Y+6	; 0x06
    3130:	3f 81       	ldd	r19, Y+7	; 0x07
    3132:	fc 01       	movw	r30, r24
    3134:	31 83       	std	Z+1, r19	; 0x01
    3136:	20 83       	st	Z, r18
    3138:	07 c0       	rjmp	.+14     	; 0x3148 <prvInitialiseNewQueue+0x4a>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    313a:	8e 81       	ldd	r24, Y+6	; 0x06
    313c:	9f 81       	ldd	r25, Y+7	; 0x07
    313e:	2b 81       	ldd	r18, Y+3	; 0x03
    3140:	3c 81       	ldd	r19, Y+4	; 0x04
    3142:	fc 01       	movw	r30, r24
    3144:	31 83       	std	Z+1, r19	; 0x01
    3146:	20 83       	st	Z, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    3148:	8e 81       	ldd	r24, Y+6	; 0x06
    314a:	9f 81       	ldd	r25, Y+7	; 0x07
    314c:	29 81       	ldd	r18, Y+1	; 0x01
    314e:	fc 01       	movw	r30, r24
    3150:	23 8f       	std	Z+27, r18	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    3152:	8e 81       	ldd	r24, Y+6	; 0x06
    3154:	9f 81       	ldd	r25, Y+7	; 0x07
    3156:	2a 81       	ldd	r18, Y+2	; 0x02
    3158:	fc 01       	movw	r30, r24
    315a:	24 8f       	std	Z+28, r18	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    315c:	8e 81       	ldd	r24, Y+6	; 0x06
    315e:	9f 81       	ldd	r25, Y+7	; 0x07
    3160:	61 e0       	ldi	r22, 0x01	; 1
    3162:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    3166:	00 00       	nop
    3168:	27 96       	adiw	r28, 0x07	; 7
    316a:	0f b6       	in	r0, 0x3f	; 63
    316c:	f8 94       	cli
    316e:	de bf       	out	0x3e, r29	; 62
    3170:	0f be       	out	0x3f, r0	; 63
    3172:	cd bf       	out	0x3d, r28	; 61
    3174:	df 91       	pop	r29
    3176:	cf 91       	pop	r28
    3178:	1f 91       	pop	r17
    317a:	0f 91       	pop	r16
    317c:	08 95       	ret

0000317e <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    317e:	cf 93       	push	r28
    3180:	df 93       	push	r29
    3182:	00 d0       	rcall	.+0      	; 0x3184 <prvInitialiseMutex+0x6>
    3184:	cd b7       	in	r28, 0x3d	; 61
    3186:	de b7       	in	r29, 0x3e	; 62
    3188:	9a 83       	std	Y+2, r25	; 0x02
    318a:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    318c:	89 81       	ldd	r24, Y+1	; 0x01
    318e:	9a 81       	ldd	r25, Y+2	; 0x02
    3190:	89 2b       	or	r24, r25
    3192:	b9 f0       	breq	.+46     	; 0x31c2 <prvInitialiseMutex+0x44>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    3194:	89 81       	ldd	r24, Y+1	; 0x01
    3196:	9a 81       	ldd	r25, Y+2	; 0x02
    3198:	fc 01       	movw	r30, r24
    319a:	15 82       	std	Z+5, r1	; 0x05
    319c:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    319e:	89 81       	ldd	r24, Y+1	; 0x01
    31a0:	9a 81       	ldd	r25, Y+2	; 0x02
    31a2:	fc 01       	movw	r30, r24
    31a4:	11 82       	std	Z+1, r1	; 0x01
    31a6:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    31a8:	89 81       	ldd	r24, Y+1	; 0x01
    31aa:	9a 81       	ldd	r25, Y+2	; 0x02
    31ac:	fc 01       	movw	r30, r24
    31ae:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    31b0:	89 81       	ldd	r24, Y+1	; 0x01
    31b2:	9a 81       	ldd	r25, Y+2	; 0x02
    31b4:	20 e0       	ldi	r18, 0x00	; 0
    31b6:	40 e0       	ldi	r20, 0x00	; 0
    31b8:	50 e0       	ldi	r21, 0x00	; 0
    31ba:	60 e0       	ldi	r22, 0x00	; 0
    31bc:	70 e0       	ldi	r23, 0x00	; 0
    31be:	0e 94 07 19 	call	0x320e	; 0x320e <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    31c2:	00 00       	nop
    31c4:	0f 90       	pop	r0
    31c6:	0f 90       	pop	r0
    31c8:	df 91       	pop	r29
    31ca:	cf 91       	pop	r28
    31cc:	08 95       	ret

000031ce <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    31ce:	cf 93       	push	r28
    31d0:	df 93       	push	r29
    31d2:	00 d0       	rcall	.+0      	; 0x31d4 <xQueueCreateMutex+0x6>
    31d4:	00 d0       	rcall	.+0      	; 0x31d6 <xQueueCreateMutex+0x8>
    31d6:	1f 92       	push	r1
    31d8:	cd b7       	in	r28, 0x3d	; 61
    31da:	de b7       	in	r29, 0x3e	; 62
    31dc:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    31de:	81 e0       	ldi	r24, 0x01	; 1
    31e0:	89 83       	std	Y+1, r24	; 0x01
    31e2:	1a 82       	std	Y+2, r1	; 0x02

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    31e4:	4d 81       	ldd	r20, Y+5	; 0x05
    31e6:	6a 81       	ldd	r22, Y+2	; 0x02
    31e8:	89 81       	ldd	r24, Y+1	; 0x01
    31ea:	0e 94 2f 18 	call	0x305e	; 0x305e <xQueueGenericCreate>
    31ee:	9c 83       	std	Y+4, r25	; 0x04
    31f0:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    31f2:	8b 81       	ldd	r24, Y+3	; 0x03
    31f4:	9c 81       	ldd	r25, Y+4	; 0x04
    31f6:	0e 94 bf 18 	call	0x317e	; 0x317e <prvInitialiseMutex>

		return xNewQueue;
    31fa:	8b 81       	ldd	r24, Y+3	; 0x03
    31fc:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    31fe:	0f 90       	pop	r0
    3200:	0f 90       	pop	r0
    3202:	0f 90       	pop	r0
    3204:	0f 90       	pop	r0
    3206:	0f 90       	pop	r0
    3208:	df 91       	pop	r29
    320a:	cf 91       	pop	r28
    320c:	08 95       	ret

0000320e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    320e:	cf 93       	push	r28
    3210:	df 93       	push	r29
    3212:	cd b7       	in	r28, 0x3d	; 61
    3214:	de b7       	in	r29, 0x3e	; 62
    3216:	2e 97       	sbiw	r28, 0x0e	; 14
    3218:	0f b6       	in	r0, 0x3f	; 63
    321a:	f8 94       	cli
    321c:	de bf       	out	0x3e, r29	; 62
    321e:	0f be       	out	0x3f, r0	; 63
    3220:	cd bf       	out	0x3d, r28	; 61
    3222:	99 87       	std	Y+9, r25	; 0x09
    3224:	88 87       	std	Y+8, r24	; 0x08
    3226:	7b 87       	std	Y+11, r23	; 0x0b
    3228:	6a 87       	std	Y+10, r22	; 0x0a
    322a:	5d 87       	std	Y+13, r21	; 0x0d
    322c:	4c 87       	std	Y+12, r20	; 0x0c
    322e:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3230:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3232:	88 85       	ldd	r24, Y+8	; 0x08
    3234:	99 85       	ldd	r25, Y+9	; 0x09
    3236:	9b 83       	std	Y+3, r25	; 0x03
    3238:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    323a:	0f b6       	in	r0, 0x3f	; 63
    323c:	f8 94       	cli
    323e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3240:	8a 81       	ldd	r24, Y+2	; 0x02
    3242:	9b 81       	ldd	r25, Y+3	; 0x03
    3244:	fc 01       	movw	r30, r24
    3246:	22 8d       	ldd	r18, Z+26	; 0x1a
    3248:	8a 81       	ldd	r24, Y+2	; 0x02
    324a:	9b 81       	ldd	r25, Y+3	; 0x03
    324c:	fc 01       	movw	r30, r24
    324e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3250:	28 17       	cp	r18, r24
    3252:	18 f0       	brcs	.+6      	; 0x325a <xQueueGenericSend+0x4c>
    3254:	8e 85       	ldd	r24, Y+14	; 0x0e
    3256:	82 30       	cpi	r24, 0x02	; 2
    3258:	11 f5       	brne	.+68     	; 0x329e <xQueueGenericSend+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    325a:	2a 85       	ldd	r18, Y+10	; 0x0a
    325c:	3b 85       	ldd	r19, Y+11	; 0x0b
    325e:	8a 81       	ldd	r24, Y+2	; 0x02
    3260:	9b 81       	ldd	r25, Y+3	; 0x03
    3262:	4e 85       	ldd	r20, Y+14	; 0x0e
    3264:	b9 01       	movw	r22, r18
    3266:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <prvCopyDataToQueue>
    326a:	8c 83       	std	Y+4, r24	; 0x04

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    326c:	8a 81       	ldd	r24, Y+2	; 0x02
    326e:	9b 81       	ldd	r25, Y+3	; 0x03
    3270:	fc 01       	movw	r30, r24
    3272:	81 89       	ldd	r24, Z+17	; 0x11
    3274:	88 23       	and	r24, r24
    3276:	51 f0       	breq	.+20     	; 0x328c <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3278:	8a 81       	ldd	r24, Y+2	; 0x02
    327a:	9b 81       	ldd	r25, Y+3	; 0x03
    327c:	41 96       	adiw	r24, 0x11	; 17
    327e:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    3282:	88 23       	and	r24, r24
    3284:	41 f0       	breq	.+16     	; 0x3296 <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    3286:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
    328a:	05 c0       	rjmp	.+10     	; 0x3296 <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    328c:	8c 81       	ldd	r24, Y+4	; 0x04
    328e:	88 23       	and	r24, r24
    3290:	11 f0       	breq	.+4      	; 0x3296 <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3292:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3296:	0f 90       	pop	r0
    3298:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	60 c0       	rjmp	.+192    	; 0x335e <xQueueGenericSend+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    329e:	8c 85       	ldd	r24, Y+12	; 0x0c
    32a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    32a2:	89 2b       	or	r24, r25
    32a4:	21 f4       	brne	.+8      	; 0x32ae <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    32a6:	0f 90       	pop	r0
    32a8:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    32aa:	80 e0       	ldi	r24, 0x00	; 0
    32ac:	58 c0       	rjmp	.+176    	; 0x335e <xQueueGenericSend+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    32ae:	89 81       	ldd	r24, Y+1	; 0x01
    32b0:	88 23       	and	r24, r24
    32b2:	31 f4       	brne	.+12     	; 0x32c0 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    32b4:	ce 01       	movw	r24, r28
    32b6:	05 96       	adiw	r24, 0x05	; 5
    32b8:	0e 94 12 28 	call	0x5024	; 0x5024 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    32bc:	81 e0       	ldi	r24, 0x01	; 1
    32be:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    32c0:	0f 90       	pop	r0
    32c2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    32c4:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    32c8:	0f b6       	in	r0, 0x3f	; 63
    32ca:	f8 94       	cli
    32cc:	0f 92       	push	r0
    32ce:	8a 81       	ldd	r24, Y+2	; 0x02
    32d0:	9b 81       	ldd	r25, Y+3	; 0x03
    32d2:	fc 01       	movw	r30, r24
    32d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    32d6:	8f 3f       	cpi	r24, 0xFF	; 255
    32d8:	21 f4       	brne	.+8      	; 0x32e2 <xQueueGenericSend+0xd4>
    32da:	8a 81       	ldd	r24, Y+2	; 0x02
    32dc:	9b 81       	ldd	r25, Y+3	; 0x03
    32de:	fc 01       	movw	r30, r24
    32e0:	15 8e       	std	Z+29, r1	; 0x1d
    32e2:	8a 81       	ldd	r24, Y+2	; 0x02
    32e4:	9b 81       	ldd	r25, Y+3	; 0x03
    32e6:	fc 01       	movw	r30, r24
    32e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    32ea:	8f 3f       	cpi	r24, 0xFF	; 255
    32ec:	21 f4       	brne	.+8      	; 0x32f6 <xQueueGenericSend+0xe8>
    32ee:	8a 81       	ldd	r24, Y+2	; 0x02
    32f0:	9b 81       	ldd	r25, Y+3	; 0x03
    32f2:	fc 01       	movw	r30, r24
    32f4:	16 8e       	std	Z+30, r1	; 0x1e
    32f6:	0f 90       	pop	r0
    32f8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    32fa:	9e 01       	movw	r18, r28
    32fc:	24 5f       	subi	r18, 0xF4	; 244
    32fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3300:	ce 01       	movw	r24, r28
    3302:	05 96       	adiw	r24, 0x05	; 5
    3304:	b9 01       	movw	r22, r18
    3306:	0e 94 2e 28 	call	0x505c	; 0x505c <xTaskCheckForTimeOut>
    330a:	88 23       	and	r24, r24
    330c:	09 f5       	brne	.+66     	; 0x3350 <xQueueGenericSend+0x142>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    330e:	8a 81       	ldd	r24, Y+2	; 0x02
    3310:	9b 81       	ldd	r25, Y+3	; 0x03
    3312:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <prvIsQueueFull>
    3316:	88 23       	and	r24, r24
    3318:	a1 f0       	breq	.+40     	; 0x3342 <xQueueGenericSend+0x134>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    331a:	2c 85       	ldd	r18, Y+12	; 0x0c
    331c:	3d 85       	ldd	r19, Y+13	; 0x0d
    331e:	8a 81       	ldd	r24, Y+2	; 0x02
    3320:	9b 81       	ldd	r25, Y+3	; 0x03
    3322:	08 96       	adiw	r24, 0x08	; 8
    3324:	b9 01       	movw	r22, r18
    3326:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    332a:	8a 81       	ldd	r24, Y+2	; 0x02
    332c:	9b 81       	ldd	r25, Y+3	; 0x03
    332e:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3332:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    3336:	88 23       	and	r24, r24
    3338:	09 f0       	breq	.+2      	; 0x333c <xQueueGenericSend+0x12e>
    333a:	7f cf       	rjmp	.-258    	; 0x323a <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    333c:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
    3340:	7c cf       	rjmp	.-264    	; 0x323a <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3342:	8a 81       	ldd	r24, Y+2	; 0x02
    3344:	9b 81       	ldd	r25, Y+3	; 0x03
    3346:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    334a:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    334e:	75 cf       	rjmp	.-278    	; 0x323a <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3350:	8a 81       	ldd	r24, Y+2	; 0x02
    3352:	9b 81       	ldd	r25, Y+3	; 0x03
    3354:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3358:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    335c:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    335e:	2e 96       	adiw	r28, 0x0e	; 14
    3360:	0f b6       	in	r0, 0x3f	; 63
    3362:	f8 94       	cli
    3364:	de bf       	out	0x3e, r29	; 62
    3366:	0f be       	out	0x3f, r0	; 63
    3368:	cd bf       	out	0x3d, r28	; 61
    336a:	df 91       	pop	r29
    336c:	cf 91       	pop	r28
    336e:	08 95       	ret

00003370 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3370:	cf 93       	push	r28
    3372:	df 93       	push	r29
    3374:	cd b7       	in	r28, 0x3d	; 61
    3376:	de b7       	in	r29, 0x3e	; 62
    3378:	2c 97       	sbiw	r28, 0x0c	; 12
    337a:	0f b6       	in	r0, 0x3f	; 63
    337c:	f8 94       	cli
    337e:	de bf       	out	0x3e, r29	; 62
    3380:	0f be       	out	0x3f, r0	; 63
    3382:	cd bf       	out	0x3d, r28	; 61
    3384:	9f 83       	std	Y+7, r25	; 0x07
    3386:	8e 83       	std	Y+6, r24	; 0x06
    3388:	79 87       	std	Y+9, r23	; 0x09
    338a:	68 87       	std	Y+8, r22	; 0x08
    338c:	5b 87       	std	Y+11, r21	; 0x0b
    338e:	4a 87       	std	Y+10, r20	; 0x0a
    3390:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3392:	8e 81       	ldd	r24, Y+6	; 0x06
    3394:	9f 81       	ldd	r25, Y+7	; 0x07
    3396:	9b 83       	std	Y+3, r25	; 0x03
    3398:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    339a:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    339c:	8a 81       	ldd	r24, Y+2	; 0x02
    339e:	9b 81       	ldd	r25, Y+3	; 0x03
    33a0:	fc 01       	movw	r30, r24
    33a2:	22 8d       	ldd	r18, Z+26	; 0x1a
    33a4:	8a 81       	ldd	r24, Y+2	; 0x02
    33a6:	9b 81       	ldd	r25, Y+3	; 0x03
    33a8:	fc 01       	movw	r30, r24
    33aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    33ac:	28 17       	cp	r18, r24
    33ae:	18 f0       	brcs	.+6      	; 0x33b6 <xQueueGenericSendFromISR+0x46>
    33b0:	8c 85       	ldd	r24, Y+12	; 0x0c
    33b2:	82 30       	cpi	r24, 0x02	; 2
    33b4:	89 f5       	brne	.+98     	; 0x3418 <xQueueGenericSendFromISR+0xa8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    33b6:	8a 81       	ldd	r24, Y+2	; 0x02
    33b8:	9b 81       	ldd	r25, Y+3	; 0x03
    33ba:	fc 01       	movw	r30, r24
    33bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    33be:	8d 83       	std	Y+5, r24	; 0x05
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    33c0:	28 85       	ldd	r18, Y+8	; 0x08
    33c2:	39 85       	ldd	r19, Y+9	; 0x09
    33c4:	8a 81       	ldd	r24, Y+2	; 0x02
    33c6:	9b 81       	ldd	r25, Y+3	; 0x03
    33c8:	4c 85       	ldd	r20, Y+12	; 0x0c
    33ca:	b9 01       	movw	r22, r18
    33cc:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    33d0:	8d 81       	ldd	r24, Y+5	; 0x05
    33d2:	8f 3f       	cpi	r24, 0xFF	; 255
    33d4:	b9 f4       	brne	.+46     	; 0x3404 <xQueueGenericSendFromISR+0x94>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    33d6:	8a 81       	ldd	r24, Y+2	; 0x02
    33d8:	9b 81       	ldd	r25, Y+3	; 0x03
    33da:	fc 01       	movw	r30, r24
    33dc:	81 89       	ldd	r24, Z+17	; 0x11
    33de:	88 23       	and	r24, r24
    33e0:	c1 f0       	breq	.+48     	; 0x3412 <xQueueGenericSendFromISR+0xa2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    33e2:	8a 81       	ldd	r24, Y+2	; 0x02
    33e4:	9b 81       	ldd	r25, Y+3	; 0x03
    33e6:	41 96       	adiw	r24, 0x11	; 17
    33e8:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    33ec:	88 23       	and	r24, r24
    33ee:	89 f0       	breq	.+34     	; 0x3412 <xQueueGenericSendFromISR+0xa2>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    33f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    33f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    33f4:	89 2b       	or	r24, r25
    33f6:	69 f0       	breq	.+26     	; 0x3412 <xQueueGenericSendFromISR+0xa2>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    33f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    33fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    33fc:	21 e0       	ldi	r18, 0x01	; 1
    33fe:	fc 01       	movw	r30, r24
    3400:	20 83       	st	Z, r18
    3402:	07 c0       	rjmp	.+14     	; 0x3412 <xQueueGenericSendFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3404:	8d 81       	ldd	r24, Y+5	; 0x05
    3406:	8f 5f       	subi	r24, 0xFF	; 255
    3408:	28 2f       	mov	r18, r24
    340a:	8a 81       	ldd	r24, Y+2	; 0x02
    340c:	9b 81       	ldd	r25, Y+3	; 0x03
    340e:	fc 01       	movw	r30, r24
    3410:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    3412:	81 e0       	ldi	r24, 0x01	; 1
    3414:	89 83       	std	Y+1, r24	; 0x01
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
    3416:	01 c0       	rjmp	.+2      	; 0x341a <xQueueGenericSendFromISR+0xaa>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3418:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    341a:	89 81       	ldd	r24, Y+1	; 0x01
}
    341c:	2c 96       	adiw	r28, 0x0c	; 12
    341e:	0f b6       	in	r0, 0x3f	; 63
    3420:	f8 94       	cli
    3422:	de bf       	out	0x3e, r29	; 62
    3424:	0f be       	out	0x3f, r0	; 63
    3426:	cd bf       	out	0x3d, r28	; 61
    3428:	df 91       	pop	r29
    342a:	cf 91       	pop	r28
    342c:	08 95       	ret

0000342e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    342e:	cf 93       	push	r28
    3430:	df 93       	push	r29
    3432:	cd b7       	in	r28, 0x3d	; 61
    3434:	de b7       	in	r29, 0x3e	; 62
    3436:	2a 97       	sbiw	r28, 0x0a	; 10
    3438:	0f b6       	in	r0, 0x3f	; 63
    343a:	f8 94       	cli
    343c:	de bf       	out	0x3e, r29	; 62
    343e:	0f be       	out	0x3f, r0	; 63
    3440:	cd bf       	out	0x3d, r28	; 61
    3442:	98 87       	std	Y+8, r25	; 0x08
    3444:	8f 83       	std	Y+7, r24	; 0x07
    3446:	7a 87       	std	Y+10, r23	; 0x0a
    3448:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    344a:	8f 81       	ldd	r24, Y+7	; 0x07
    344c:	98 85       	ldd	r25, Y+8	; 0x08
    344e:	9b 83       	std	Y+3, r25	; 0x03
    3450:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3452:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3454:	8a 81       	ldd	r24, Y+2	; 0x02
    3456:	9b 81       	ldd	r25, Y+3	; 0x03
    3458:	fc 01       	movw	r30, r24
    345a:	82 8d       	ldd	r24, Z+26	; 0x1a
    345c:	8d 83       	std	Y+5, r24	; 0x05

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    345e:	8a 81       	ldd	r24, Y+2	; 0x02
    3460:	9b 81       	ldd	r25, Y+3	; 0x03
    3462:	fc 01       	movw	r30, r24
    3464:	93 8d       	ldd	r25, Z+27	; 0x1b
    3466:	8d 81       	ldd	r24, Y+5	; 0x05
    3468:	89 17       	cp	r24, r25
    346a:	80 f5       	brcc	.+96     	; 0x34cc <xQueueGiveFromISR+0x9e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    346c:	8a 81       	ldd	r24, Y+2	; 0x02
    346e:	9b 81       	ldd	r25, Y+3	; 0x03
    3470:	fc 01       	movw	r30, r24
    3472:	86 8d       	ldd	r24, Z+30	; 0x1e
    3474:	8e 83       	std	Y+6, r24	; 0x06
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3476:	8d 81       	ldd	r24, Y+5	; 0x05
    3478:	21 e0       	ldi	r18, 0x01	; 1
    347a:	28 0f       	add	r18, r24
    347c:	8a 81       	ldd	r24, Y+2	; 0x02
    347e:	9b 81       	ldd	r25, Y+3	; 0x03
    3480:	fc 01       	movw	r30, r24
    3482:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3484:	8e 81       	ldd	r24, Y+6	; 0x06
    3486:	8f 3f       	cpi	r24, 0xFF	; 255
    3488:	b9 f4       	brne	.+46     	; 0x34b8 <xQueueGiveFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    348a:	8a 81       	ldd	r24, Y+2	; 0x02
    348c:	9b 81       	ldd	r25, Y+3	; 0x03
    348e:	fc 01       	movw	r30, r24
    3490:	81 89       	ldd	r24, Z+17	; 0x11
    3492:	88 23       	and	r24, r24
    3494:	c1 f0       	breq	.+48     	; 0x34c6 <xQueueGiveFromISR+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3496:	8a 81       	ldd	r24, Y+2	; 0x02
    3498:	9b 81       	ldd	r25, Y+3	; 0x03
    349a:	41 96       	adiw	r24, 0x11	; 17
    349c:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    34a0:	88 23       	and	r24, r24
    34a2:	89 f0       	breq	.+34     	; 0x34c6 <xQueueGiveFromISR+0x98>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    34a4:	89 85       	ldd	r24, Y+9	; 0x09
    34a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    34a8:	89 2b       	or	r24, r25
    34aa:	69 f0       	breq	.+26     	; 0x34c6 <xQueueGiveFromISR+0x98>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    34ac:	89 85       	ldd	r24, Y+9	; 0x09
    34ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    34b0:	21 e0       	ldi	r18, 0x01	; 1
    34b2:	fc 01       	movw	r30, r24
    34b4:	20 83       	st	Z, r18
    34b6:	07 c0       	rjmp	.+14     	; 0x34c6 <xQueueGiveFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    34b8:	8e 81       	ldd	r24, Y+6	; 0x06
    34ba:	8f 5f       	subi	r24, 0xFF	; 255
    34bc:	28 2f       	mov	r18, r24
    34be:	8a 81       	ldd	r24, Y+2	; 0x02
    34c0:	9b 81       	ldd	r25, Y+3	; 0x03
    34c2:	fc 01       	movw	r30, r24
    34c4:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    34c6:	81 e0       	ldi	r24, 0x01	; 1
    34c8:	89 83       	std	Y+1, r24	; 0x01
    34ca:	01 c0       	rjmp	.+2      	; 0x34ce <xQueueGiveFromISR+0xa0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    34cc:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    34ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    34d0:	2a 96       	adiw	r28, 0x0a	; 10
    34d2:	0f b6       	in	r0, 0x3f	; 63
    34d4:	f8 94       	cli
    34d6:	de bf       	out	0x3e, r29	; 62
    34d8:	0f be       	out	0x3f, r0	; 63
    34da:	cd bf       	out	0x3d, r28	; 61
    34dc:	df 91       	pop	r29
    34de:	cf 91       	pop	r28
    34e0:	08 95       	ret

000034e2 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    34e2:	cf 93       	push	r28
    34e4:	df 93       	push	r29
    34e6:	cd b7       	in	r28, 0x3d	; 61
    34e8:	de b7       	in	r29, 0x3e	; 62
    34ea:	2d 97       	sbiw	r28, 0x0d	; 13
    34ec:	0f b6       	in	r0, 0x3f	; 63
    34ee:	f8 94       	cli
    34f0:	de bf       	out	0x3e, r29	; 62
    34f2:	0f be       	out	0x3f, r0	; 63
    34f4:	cd bf       	out	0x3d, r28	; 61
    34f6:	99 87       	std	Y+9, r25	; 0x09
    34f8:	88 87       	std	Y+8, r24	; 0x08
    34fa:	7b 87       	std	Y+11, r23	; 0x0b
    34fc:	6a 87       	std	Y+10, r22	; 0x0a
    34fe:	5d 87       	std	Y+13, r21	; 0x0d
    3500:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3502:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3504:	88 85       	ldd	r24, Y+8	; 0x08
    3506:	99 85       	ldd	r25, Y+9	; 0x09
    3508:	9b 83       	std	Y+3, r25	; 0x03
    350a:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    350c:	0f b6       	in	r0, 0x3f	; 63
    350e:	f8 94       	cli
    3510:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3512:	8a 81       	ldd	r24, Y+2	; 0x02
    3514:	9b 81       	ldd	r25, Y+3	; 0x03
    3516:	fc 01       	movw	r30, r24
    3518:	82 8d       	ldd	r24, Z+26	; 0x1a
    351a:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    351c:	8c 81       	ldd	r24, Y+4	; 0x04
    351e:	88 23       	and	r24, r24
    3520:	09 f1       	breq	.+66     	; 0x3564 <xQueueReceive+0x82>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3522:	2a 85       	ldd	r18, Y+10	; 0x0a
    3524:	3b 85       	ldd	r19, Y+11	; 0x0b
    3526:	8a 81       	ldd	r24, Y+2	; 0x02
    3528:	9b 81       	ldd	r25, Y+3	; 0x03
    352a:	b9 01       	movw	r22, r18
    352c:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3530:	8c 81       	ldd	r24, Y+4	; 0x04
    3532:	2f ef       	ldi	r18, 0xFF	; 255
    3534:	28 0f       	add	r18, r24
    3536:	8a 81       	ldd	r24, Y+2	; 0x02
    3538:	9b 81       	ldd	r25, Y+3	; 0x03
    353a:	fc 01       	movw	r30, r24
    353c:	22 8f       	std	Z+26, r18	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    353e:	8a 81       	ldd	r24, Y+2	; 0x02
    3540:	9b 81       	ldd	r25, Y+3	; 0x03
    3542:	fc 01       	movw	r30, r24
    3544:	80 85       	ldd	r24, Z+8	; 0x08
    3546:	88 23       	and	r24, r24
    3548:	49 f0       	breq	.+18     	; 0x355c <xQueueReceive+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    354a:	8a 81       	ldd	r24, Y+2	; 0x02
    354c:	9b 81       	ldd	r25, Y+3	; 0x03
    354e:	08 96       	adiw	r24, 0x08	; 8
    3550:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    3554:	88 23       	and	r24, r24
    3556:	11 f0       	breq	.+4      	; 0x355c <xQueueReceive+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3558:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    355c:	0f 90       	pop	r0
    355e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3560:	81 e0       	ldi	r24, 0x01	; 1
    3562:	67 c0       	rjmp	.+206    	; 0x3632 <xQueueReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3564:	8c 85       	ldd	r24, Y+12	; 0x0c
    3566:	9d 85       	ldd	r25, Y+13	; 0x0d
    3568:	89 2b       	or	r24, r25
    356a:	21 f4       	brne	.+8      	; 0x3574 <xQueueReceive+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    356c:	0f 90       	pop	r0
    356e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3570:	80 e0       	ldi	r24, 0x00	; 0
    3572:	5f c0       	rjmp	.+190    	; 0x3632 <xQueueReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    3574:	89 81       	ldd	r24, Y+1	; 0x01
    3576:	88 23       	and	r24, r24
    3578:	31 f4       	brne	.+12     	; 0x3586 <xQueueReceive+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    357a:	ce 01       	movw	r24, r28
    357c:	05 96       	adiw	r24, 0x05	; 5
    357e:	0e 94 12 28 	call	0x5024	; 0x5024 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3582:	81 e0       	ldi	r24, 0x01	; 1
    3584:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3586:	0f 90       	pop	r0
    3588:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    358a:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    358e:	0f b6       	in	r0, 0x3f	; 63
    3590:	f8 94       	cli
    3592:	0f 92       	push	r0
    3594:	8a 81       	ldd	r24, Y+2	; 0x02
    3596:	9b 81       	ldd	r25, Y+3	; 0x03
    3598:	fc 01       	movw	r30, r24
    359a:	85 8d       	ldd	r24, Z+29	; 0x1d
    359c:	8f 3f       	cpi	r24, 0xFF	; 255
    359e:	21 f4       	brne	.+8      	; 0x35a8 <xQueueReceive+0xc6>
    35a0:	8a 81       	ldd	r24, Y+2	; 0x02
    35a2:	9b 81       	ldd	r25, Y+3	; 0x03
    35a4:	fc 01       	movw	r30, r24
    35a6:	15 8e       	std	Z+29, r1	; 0x1d
    35a8:	8a 81       	ldd	r24, Y+2	; 0x02
    35aa:	9b 81       	ldd	r25, Y+3	; 0x03
    35ac:	fc 01       	movw	r30, r24
    35ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    35b0:	8f 3f       	cpi	r24, 0xFF	; 255
    35b2:	21 f4       	brne	.+8      	; 0x35bc <xQueueReceive+0xda>
    35b4:	8a 81       	ldd	r24, Y+2	; 0x02
    35b6:	9b 81       	ldd	r25, Y+3	; 0x03
    35b8:	fc 01       	movw	r30, r24
    35ba:	16 8e       	std	Z+30, r1	; 0x1e
    35bc:	0f 90       	pop	r0
    35be:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    35c0:	9e 01       	movw	r18, r28
    35c2:	24 5f       	subi	r18, 0xF4	; 244
    35c4:	3f 4f       	sbci	r19, 0xFF	; 255
    35c6:	ce 01       	movw	r24, r28
    35c8:	05 96       	adiw	r24, 0x05	; 5
    35ca:	b9 01       	movw	r22, r18
    35cc:	0e 94 2e 28 	call	0x505c	; 0x505c <xTaskCheckForTimeOut>
    35d0:	88 23       	and	r24, r24
    35d2:	09 f5       	brne	.+66     	; 0x3616 <xQueueReceive+0x134>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    35d4:	8a 81       	ldd	r24, Y+2	; 0x02
    35d6:	9b 81       	ldd	r25, Y+3	; 0x03
    35d8:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <prvIsQueueEmpty>
    35dc:	88 23       	and	r24, r24
    35de:	a1 f0       	breq	.+40     	; 0x3608 <xQueueReceive+0x126>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    35e0:	2c 85       	ldd	r18, Y+12	; 0x0c
    35e2:	3d 85       	ldd	r19, Y+13	; 0x0d
    35e4:	8a 81       	ldd	r24, Y+2	; 0x02
    35e6:	9b 81       	ldd	r25, Y+3	; 0x03
    35e8:	41 96       	adiw	r24, 0x11	; 17
    35ea:	b9 01       	movw	r22, r18
    35ec:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    35f0:	8a 81       	ldd	r24, Y+2	; 0x02
    35f2:	9b 81       	ldd	r25, Y+3	; 0x03
    35f4:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    35f8:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    35fc:	88 23       	and	r24, r24
    35fe:	09 f0       	breq	.+2      	; 0x3602 <xQueueReceive+0x120>
    3600:	85 cf       	rjmp	.-246    	; 0x350c <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    3602:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
    3606:	82 cf       	rjmp	.-252    	; 0x350c <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    3608:	8a 81       	ldd	r24, Y+2	; 0x02
    360a:	9b 81       	ldd	r25, Y+3	; 0x03
    360c:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3610:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    3614:	7b cf       	rjmp	.-266    	; 0x350c <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    3616:	8a 81       	ldd	r24, Y+2	; 0x02
    3618:	9b 81       	ldd	r25, Y+3	; 0x03
    361a:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    361e:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3622:	8a 81       	ldd	r24, Y+2	; 0x02
    3624:	9b 81       	ldd	r25, Y+3	; 0x03
    3626:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <prvIsQueueEmpty>
    362a:	88 23       	and	r24, r24
    362c:	09 f4       	brne	.+2      	; 0x3630 <xQueueReceive+0x14e>
    362e:	6e cf       	rjmp	.-292    	; 0x350c <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3630:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3632:	2d 96       	adiw	r28, 0x0d	; 13
    3634:	0f b6       	in	r0, 0x3f	; 63
    3636:	f8 94       	cli
    3638:	de bf       	out	0x3e, r29	; 62
    363a:	0f be       	out	0x3f, r0	; 63
    363c:	cd bf       	out	0x3d, r28	; 61
    363e:	df 91       	pop	r29
    3640:	cf 91       	pop	r28
    3642:	08 95       	ret

00003644 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    3644:	cf 93       	push	r28
    3646:	df 93       	push	r29
    3648:	cd b7       	in	r28, 0x3d	; 61
    364a:	de b7       	in	r29, 0x3e	; 62
    364c:	2d 97       	sbiw	r28, 0x0d	; 13
    364e:	0f b6       	in	r0, 0x3f	; 63
    3650:	f8 94       	cli
    3652:	de bf       	out	0x3e, r29	; 62
    3654:	0f be       	out	0x3f, r0	; 63
    3656:	cd bf       	out	0x3d, r28	; 61
    3658:	9b 87       	std	Y+11, r25	; 0x0b
    365a:	8a 87       	std	Y+10, r24	; 0x0a
    365c:	7d 87       	std	Y+13, r23	; 0x0d
    365e:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3660:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3662:	8a 85       	ldd	r24, Y+10	; 0x0a
    3664:	9b 85       	ldd	r25, Y+11	; 0x0b
    3666:	9c 83       	std	Y+4, r25	; 0x04
    3668:	8b 83       	std	Y+3, r24	; 0x03

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    366a:	1a 82       	std	Y+2, r1	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    366c:	0f b6       	in	r0, 0x3f	; 63
    366e:	f8 94       	cli
    3670:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3672:	8b 81       	ldd	r24, Y+3	; 0x03
    3674:	9c 81       	ldd	r25, Y+4	; 0x04
    3676:	fc 01       	movw	r30, r24
    3678:	82 8d       	ldd	r24, Z+26	; 0x1a
    367a:	8d 83       	std	Y+5, r24	; 0x05

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    367c:	8d 81       	ldd	r24, Y+5	; 0x05
    367e:	88 23       	and	r24, r24
    3680:	49 f1       	breq	.+82     	; 0x36d4 <xQueueSemaphoreTake+0x90>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3682:	8d 81       	ldd	r24, Y+5	; 0x05
    3684:	2f ef       	ldi	r18, 0xFF	; 255
    3686:	28 0f       	add	r18, r24
    3688:	8b 81       	ldd	r24, Y+3	; 0x03
    368a:	9c 81       	ldd	r25, Y+4	; 0x04
    368c:	fc 01       	movw	r30, r24
    368e:	22 8f       	std	Z+26, r18	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3690:	8b 81       	ldd	r24, Y+3	; 0x03
    3692:	9c 81       	ldd	r25, Y+4	; 0x04
    3694:	fc 01       	movw	r30, r24
    3696:	80 81       	ld	r24, Z
    3698:	91 81       	ldd	r25, Z+1	; 0x01
    369a:	89 2b       	or	r24, r25
    369c:	41 f4       	brne	.+16     	; 0x36ae <xQueueSemaphoreTake+0x6a>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    369e:	0e 94 7b 2b 	call	0x56f6	; 0x56f6 <pvTaskIncrementMutexHeldCount>
    36a2:	9c 01       	movw	r18, r24
    36a4:	8b 81       	ldd	r24, Y+3	; 0x03
    36a6:	9c 81       	ldd	r25, Y+4	; 0x04
    36a8:	fc 01       	movw	r30, r24
    36aa:	35 83       	std	Z+5, r19	; 0x05
    36ac:	24 83       	std	Z+4, r18	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    36ae:	8b 81       	ldd	r24, Y+3	; 0x03
    36b0:	9c 81       	ldd	r25, Y+4	; 0x04
    36b2:	fc 01       	movw	r30, r24
    36b4:	80 85       	ldd	r24, Z+8	; 0x08
    36b6:	88 23       	and	r24, r24
    36b8:	49 f0       	breq	.+18     	; 0x36cc <xQueueSemaphoreTake+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    36ba:	8b 81       	ldd	r24, Y+3	; 0x03
    36bc:	9c 81       	ldd	r25, Y+4	; 0x04
    36be:	08 96       	adiw	r24, 0x08	; 8
    36c0:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    36c4:	88 23       	and	r24, r24
    36c6:	11 f0       	breq	.+4      	; 0x36cc <xQueueSemaphoreTake+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
    36c8:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    36cc:	0f 90       	pop	r0
    36ce:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    36d0:	81 e0       	ldi	r24, 0x01	; 1
    36d2:	90 c0       	rjmp	.+288    	; 0x37f4 <xQueueSemaphoreTake+0x1b0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    36d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    36d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    36d8:	89 2b       	or	r24, r25
    36da:	21 f4       	brne	.+8      	; 0x36e4 <xQueueSemaphoreTake+0xa0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    36dc:	0f 90       	pop	r0
    36de:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    36e0:	80 e0       	ldi	r24, 0x00	; 0
    36e2:	88 c0       	rjmp	.+272    	; 0x37f4 <xQueueSemaphoreTake+0x1b0>
				}
				else if( xEntryTimeSet == pdFALSE )
    36e4:	89 81       	ldd	r24, Y+1	; 0x01
    36e6:	88 23       	and	r24, r24
    36e8:	31 f4       	brne	.+12     	; 0x36f6 <xQueueSemaphoreTake+0xb2>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    36ea:	ce 01       	movw	r24, r28
    36ec:	07 96       	adiw	r24, 0x07	; 7
    36ee:	0e 94 12 28 	call	0x5024	; 0x5024 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    36f2:	81 e0       	ldi	r24, 0x01	; 1
    36f4:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    36f6:	0f 90       	pop	r0
    36f8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    36fa:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    36fe:	0f b6       	in	r0, 0x3f	; 63
    3700:	f8 94       	cli
    3702:	0f 92       	push	r0
    3704:	8b 81       	ldd	r24, Y+3	; 0x03
    3706:	9c 81       	ldd	r25, Y+4	; 0x04
    3708:	fc 01       	movw	r30, r24
    370a:	85 8d       	ldd	r24, Z+29	; 0x1d
    370c:	8f 3f       	cpi	r24, 0xFF	; 255
    370e:	21 f4       	brne	.+8      	; 0x3718 <xQueueSemaphoreTake+0xd4>
    3710:	8b 81       	ldd	r24, Y+3	; 0x03
    3712:	9c 81       	ldd	r25, Y+4	; 0x04
    3714:	fc 01       	movw	r30, r24
    3716:	15 8e       	std	Z+29, r1	; 0x1d
    3718:	8b 81       	ldd	r24, Y+3	; 0x03
    371a:	9c 81       	ldd	r25, Y+4	; 0x04
    371c:	fc 01       	movw	r30, r24
    371e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3720:	8f 3f       	cpi	r24, 0xFF	; 255
    3722:	21 f4       	brne	.+8      	; 0x372c <xQueueSemaphoreTake+0xe8>
    3724:	8b 81       	ldd	r24, Y+3	; 0x03
    3726:	9c 81       	ldd	r25, Y+4	; 0x04
    3728:	fc 01       	movw	r30, r24
    372a:	16 8e       	std	Z+30, r1	; 0x1e
    372c:	0f 90       	pop	r0
    372e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3730:	9e 01       	movw	r18, r28
    3732:	24 5f       	subi	r18, 0xF4	; 244
    3734:	3f 4f       	sbci	r19, 0xFF	; 255
    3736:	ce 01       	movw	r24, r28
    3738:	07 96       	adiw	r24, 0x07	; 7
    373a:	b9 01       	movw	r22, r18
    373c:	0e 94 2e 28 	call	0x505c	; 0x505c <xTaskCheckForTimeOut>
    3740:	88 23       	and	r24, r24
    3742:	a9 f5       	brne	.+106    	; 0x37ae <xQueueSemaphoreTake+0x16a>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3744:	8b 81       	ldd	r24, Y+3	; 0x03
    3746:	9c 81       	ldd	r25, Y+4	; 0x04
    3748:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <prvIsQueueEmpty>
    374c:	88 23       	and	r24, r24
    374e:	41 f1       	breq	.+80     	; 0x37a0 <xQueueSemaphoreTake+0x15c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3750:	8b 81       	ldd	r24, Y+3	; 0x03
    3752:	9c 81       	ldd	r25, Y+4	; 0x04
    3754:	fc 01       	movw	r30, r24
    3756:	80 81       	ld	r24, Z
    3758:	91 81       	ldd	r25, Z+1	; 0x01
    375a:	89 2b       	or	r24, r25
    375c:	69 f4       	brne	.+26     	; 0x3778 <xQueueSemaphoreTake+0x134>
					{
						taskENTER_CRITICAL();
    375e:	0f b6       	in	r0, 0x3f	; 63
    3760:	f8 94       	cli
    3762:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    3764:	8b 81       	ldd	r24, Y+3	; 0x03
    3766:	9c 81       	ldd	r25, Y+4	; 0x04
    3768:	fc 01       	movw	r30, r24
    376a:	84 81       	ldd	r24, Z+4	; 0x04
    376c:	95 81       	ldd	r25, Z+5	; 0x05
    376e:	0e 94 88 29 	call	0x5310	; 0x5310 <xTaskPriorityInherit>
    3772:	8a 83       	std	Y+2, r24	; 0x02
						}
						taskEXIT_CRITICAL();
    3774:	0f 90       	pop	r0
    3776:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3778:	2c 85       	ldd	r18, Y+12	; 0x0c
    377a:	3d 85       	ldd	r19, Y+13	; 0x0d
    377c:	8b 81       	ldd	r24, Y+3	; 0x03
    377e:	9c 81       	ldd	r25, Y+4	; 0x04
    3780:	41 96       	adiw	r24, 0x11	; 17
    3782:	b9 01       	movw	r22, r18
    3784:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3788:	8b 81       	ldd	r24, Y+3	; 0x03
    378a:	9c 81       	ldd	r25, Y+4	; 0x04
    378c:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3790:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    3794:	88 23       	and	r24, r24
    3796:	09 f0       	breq	.+2      	; 0x379a <xQueueSemaphoreTake+0x156>
    3798:	69 cf       	rjmp	.-302    	; 0x366c <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    379a:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
    379e:	66 cf       	rjmp	.-308    	; 0x366c <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    37a0:	8b 81       	ldd	r24, Y+3	; 0x03
    37a2:	9c 81       	ldd	r25, Y+4	; 0x04
    37a4:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    37a8:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    37ac:	5f cf       	rjmp	.-322    	; 0x366c <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    37ae:	8b 81       	ldd	r24, Y+3	; 0x03
    37b0:	9c 81       	ldd	r25, Y+4	; 0x04
    37b2:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    37b6:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37ba:	8b 81       	ldd	r24, Y+3	; 0x03
    37bc:	9c 81       	ldd	r25, Y+4	; 0x04
    37be:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <prvIsQueueEmpty>
    37c2:	88 23       	and	r24, r24
    37c4:	09 f4       	brne	.+2      	; 0x37c8 <xQueueSemaphoreTake+0x184>
    37c6:	52 cf       	rjmp	.-348    	; 0x366c <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    37c8:	8a 81       	ldd	r24, Y+2	; 0x02
    37ca:	88 23       	and	r24, r24
    37cc:	91 f0       	breq	.+36     	; 0x37f2 <xQueueSemaphoreTake+0x1ae>
					{
						taskENTER_CRITICAL();
    37ce:	0f b6       	in	r0, 0x3f	; 63
    37d0:	f8 94       	cli
    37d2:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    37d4:	8b 81       	ldd	r24, Y+3	; 0x03
    37d6:	9c 81       	ldd	r25, Y+4	; 0x04
    37d8:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <prvGetDisinheritPriorityAfterTimeout>
    37dc:	8e 83       	std	Y+6, r24	; 0x06
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    37de:	8b 81       	ldd	r24, Y+3	; 0x03
    37e0:	9c 81       	ldd	r25, Y+4	; 0x04
    37e2:	fc 01       	movw	r30, r24
    37e4:	84 81       	ldd	r24, Z+4	; 0x04
    37e6:	95 81       	ldd	r25, Z+5	; 0x05
    37e8:	6e 81       	ldd	r22, Y+6	; 0x06
    37ea:	0e 94 b1 2a 	call	0x5562	; 0x5562 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    37ee:	0f 90       	pop	r0
    37f0:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    37f2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    37f4:	2d 96       	adiw	r28, 0x0d	; 13
    37f6:	0f b6       	in	r0, 0x3f	; 63
    37f8:	f8 94       	cli
    37fa:	de bf       	out	0x3e, r29	; 62
    37fc:	0f be       	out	0x3f, r0	; 63
    37fe:	cd bf       	out	0x3d, r28	; 61
    3800:	df 91       	pop	r29
    3802:	cf 91       	pop	r28
    3804:	08 95       	ret

00003806 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3806:	cf 93       	push	r28
    3808:	df 93       	push	r29
    380a:	cd b7       	in	r28, 0x3d	; 61
    380c:	de b7       	in	r29, 0x3e	; 62
    380e:	2f 97       	sbiw	r28, 0x0f	; 15
    3810:	0f b6       	in	r0, 0x3f	; 63
    3812:	f8 94       	cli
    3814:	de bf       	out	0x3e, r29	; 62
    3816:	0f be       	out	0x3f, r0	; 63
    3818:	cd bf       	out	0x3d, r28	; 61
    381a:	9b 87       	std	Y+11, r25	; 0x0b
    381c:	8a 87       	std	Y+10, r24	; 0x0a
    381e:	7d 87       	std	Y+13, r23	; 0x0d
    3820:	6c 87       	std	Y+12, r22	; 0x0c
    3822:	5f 87       	std	Y+15, r21	; 0x0f
    3824:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    3826:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3828:	8a 85       	ldd	r24, Y+10	; 0x0a
    382a:	9b 85       	ldd	r25, Y+11	; 0x0b
    382c:	9b 83       	std	Y+3, r25	; 0x03
    382e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3830:	0f b6       	in	r0, 0x3f	; 63
    3832:	f8 94       	cli
    3834:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3836:	8a 81       	ldd	r24, Y+2	; 0x02
    3838:	9b 81       	ldd	r25, Y+3	; 0x03
    383a:	fc 01       	movw	r30, r24
    383c:	82 8d       	ldd	r24, Z+26	; 0x1a
    383e:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3840:	8c 81       	ldd	r24, Y+4	; 0x04
    3842:	88 23       	and	r24, r24
    3844:	41 f1       	breq	.+80     	; 0x3896 <xQueuePeek+0x90>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3846:	8a 81       	ldd	r24, Y+2	; 0x02
    3848:	9b 81       	ldd	r25, Y+3	; 0x03
    384a:	fc 01       	movw	r30, r24
    384c:	86 81       	ldd	r24, Z+6	; 0x06
    384e:	97 81       	ldd	r25, Z+7	; 0x07
    3850:	9e 83       	std	Y+6, r25	; 0x06
    3852:	8d 83       	std	Y+5, r24	; 0x05

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3854:	2c 85       	ldd	r18, Y+12	; 0x0c
    3856:	3d 85       	ldd	r19, Y+13	; 0x0d
    3858:	8a 81       	ldd	r24, Y+2	; 0x02
    385a:	9b 81       	ldd	r25, Y+3	; 0x03
    385c:	b9 01       	movw	r22, r18
    385e:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3862:	8a 81       	ldd	r24, Y+2	; 0x02
    3864:	9b 81       	ldd	r25, Y+3	; 0x03
    3866:	2d 81       	ldd	r18, Y+5	; 0x05
    3868:	3e 81       	ldd	r19, Y+6	; 0x06
    386a:	fc 01       	movw	r30, r24
    386c:	37 83       	std	Z+7, r19	; 0x07
    386e:	26 83       	std	Z+6, r18	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3870:	8a 81       	ldd	r24, Y+2	; 0x02
    3872:	9b 81       	ldd	r25, Y+3	; 0x03
    3874:	fc 01       	movw	r30, r24
    3876:	81 89       	ldd	r24, Z+17	; 0x11
    3878:	88 23       	and	r24, r24
    387a:	49 f0       	breq	.+18     	; 0x388e <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    387c:	8a 81       	ldd	r24, Y+2	; 0x02
    387e:	9b 81       	ldd	r25, Y+3	; 0x03
    3880:	41 96       	adiw	r24, 0x11	; 17
    3882:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    3886:	88 23       	and	r24, r24
    3888:	11 f0       	breq	.+4      	; 0x388e <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    388a:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    388e:	0f 90       	pop	r0
    3890:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	67 c0       	rjmp	.+206    	; 0x3964 <xQueuePeek+0x15e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3896:	8e 85       	ldd	r24, Y+14	; 0x0e
    3898:	9f 85       	ldd	r25, Y+15	; 0x0f
    389a:	89 2b       	or	r24, r25
    389c:	21 f4       	brne	.+8      	; 0x38a6 <xQueuePeek+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    389e:	0f 90       	pop	r0
    38a0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    38a2:	80 e0       	ldi	r24, 0x00	; 0
    38a4:	5f c0       	rjmp	.+190    	; 0x3964 <xQueuePeek+0x15e>
				}
				else if( xEntryTimeSet == pdFALSE )
    38a6:	89 81       	ldd	r24, Y+1	; 0x01
    38a8:	88 23       	and	r24, r24
    38aa:	31 f4       	brne	.+12     	; 0x38b8 <xQueuePeek+0xb2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    38ac:	ce 01       	movw	r24, r28
    38ae:	07 96       	adiw	r24, 0x07	; 7
    38b0:	0e 94 12 28 	call	0x5024	; 0x5024 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    38b4:	81 e0       	ldi	r24, 0x01	; 1
    38b6:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    38b8:	0f 90       	pop	r0
    38ba:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    38bc:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    38c0:	0f b6       	in	r0, 0x3f	; 63
    38c2:	f8 94       	cli
    38c4:	0f 92       	push	r0
    38c6:	8a 81       	ldd	r24, Y+2	; 0x02
    38c8:	9b 81       	ldd	r25, Y+3	; 0x03
    38ca:	fc 01       	movw	r30, r24
    38cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    38ce:	8f 3f       	cpi	r24, 0xFF	; 255
    38d0:	21 f4       	brne	.+8      	; 0x38da <xQueuePeek+0xd4>
    38d2:	8a 81       	ldd	r24, Y+2	; 0x02
    38d4:	9b 81       	ldd	r25, Y+3	; 0x03
    38d6:	fc 01       	movw	r30, r24
    38d8:	15 8e       	std	Z+29, r1	; 0x1d
    38da:	8a 81       	ldd	r24, Y+2	; 0x02
    38dc:	9b 81       	ldd	r25, Y+3	; 0x03
    38de:	fc 01       	movw	r30, r24
    38e0:	86 8d       	ldd	r24, Z+30	; 0x1e
    38e2:	8f 3f       	cpi	r24, 0xFF	; 255
    38e4:	21 f4       	brne	.+8      	; 0x38ee <xQueuePeek+0xe8>
    38e6:	8a 81       	ldd	r24, Y+2	; 0x02
    38e8:	9b 81       	ldd	r25, Y+3	; 0x03
    38ea:	fc 01       	movw	r30, r24
    38ec:	16 8e       	std	Z+30, r1	; 0x1e
    38ee:	0f 90       	pop	r0
    38f0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    38f2:	9e 01       	movw	r18, r28
    38f4:	22 5f       	subi	r18, 0xF2	; 242
    38f6:	3f 4f       	sbci	r19, 0xFF	; 255
    38f8:	ce 01       	movw	r24, r28
    38fa:	07 96       	adiw	r24, 0x07	; 7
    38fc:	b9 01       	movw	r22, r18
    38fe:	0e 94 2e 28 	call	0x505c	; 0x505c <xTaskCheckForTimeOut>
    3902:	88 23       	and	r24, r24
    3904:	09 f5       	brne	.+66     	; 0x3948 <xQueuePeek+0x142>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3906:	8a 81       	ldd	r24, Y+2	; 0x02
    3908:	9b 81       	ldd	r25, Y+3	; 0x03
    390a:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <prvIsQueueEmpty>
    390e:	88 23       	and	r24, r24
    3910:	a1 f0       	breq	.+40     	; 0x393a <xQueuePeek+0x134>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3912:	2e 85       	ldd	r18, Y+14	; 0x0e
    3914:	3f 85       	ldd	r19, Y+15	; 0x0f
    3916:	8a 81       	ldd	r24, Y+2	; 0x02
    3918:	9b 81       	ldd	r25, Y+3	; 0x03
    391a:	41 96       	adiw	r24, 0x11	; 17
    391c:	b9 01       	movw	r22, r18
    391e:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3922:	8a 81       	ldd	r24, Y+2	; 0x02
    3924:	9b 81       	ldd	r25, Y+3	; 0x03
    3926:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    392a:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    392e:	88 23       	and	r24, r24
    3930:	09 f0       	breq	.+2      	; 0x3934 <xQueuePeek+0x12e>
    3932:	7e cf       	rjmp	.-260    	; 0x3830 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    3934:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
    3938:	7b cf       	rjmp	.-266    	; 0x3830 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    393a:	8a 81       	ldd	r24, Y+2	; 0x02
    393c:	9b 81       	ldd	r25, Y+3	; 0x03
    393e:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3942:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    3946:	74 cf       	rjmp	.-280    	; 0x3830 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    3948:	8a 81       	ldd	r24, Y+2	; 0x02
    394a:	9b 81       	ldd	r25, Y+3	; 0x03
    394c:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3950:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3954:	8a 81       	ldd	r24, Y+2	; 0x02
    3956:	9b 81       	ldd	r25, Y+3	; 0x03
    3958:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <prvIsQueueEmpty>
    395c:	88 23       	and	r24, r24
    395e:	09 f4       	brne	.+2      	; 0x3962 <xQueuePeek+0x15c>
    3960:	67 cf       	rjmp	.-306    	; 0x3830 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3962:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3964:	2f 96       	adiw	r28, 0x0f	; 15
    3966:	0f b6       	in	r0, 0x3f	; 63
    3968:	f8 94       	cli
    396a:	de bf       	out	0x3e, r29	; 62
    396c:	0f be       	out	0x3f, r0	; 63
    396e:	cd bf       	out	0x3d, r28	; 61
    3970:	df 91       	pop	r29
    3972:	cf 91       	pop	r28
    3974:	08 95       	ret

00003976 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3976:	cf 93       	push	r28
    3978:	df 93       	push	r29
    397a:	cd b7       	in	r28, 0x3d	; 61
    397c:	de b7       	in	r29, 0x3e	; 62
    397e:	2c 97       	sbiw	r28, 0x0c	; 12
    3980:	0f b6       	in	r0, 0x3f	; 63
    3982:	f8 94       	cli
    3984:	de bf       	out	0x3e, r29	; 62
    3986:	0f be       	out	0x3f, r0	; 63
    3988:	cd bf       	out	0x3d, r28	; 61
    398a:	98 87       	std	Y+8, r25	; 0x08
    398c:	8f 83       	std	Y+7, r24	; 0x07
    398e:	7a 87       	std	Y+10, r23	; 0x0a
    3990:	69 87       	std	Y+9, r22	; 0x09
    3992:	5c 87       	std	Y+12, r21	; 0x0c
    3994:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3996:	8f 81       	ldd	r24, Y+7	; 0x07
    3998:	98 85       	ldd	r25, Y+8	; 0x08
    399a:	9b 83       	std	Y+3, r25	; 0x03
    399c:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    399e:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    39a0:	8a 81       	ldd	r24, Y+2	; 0x02
    39a2:	9b 81       	ldd	r25, Y+3	; 0x03
    39a4:	fc 01       	movw	r30, r24
    39a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    39a8:	8d 83       	std	Y+5, r24	; 0x05

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    39aa:	8d 81       	ldd	r24, Y+5	; 0x05
    39ac:	88 23       	and	r24, r24
    39ae:	b9 f1       	breq	.+110    	; 0x3a1e <xQueueReceiveFromISR+0xa8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    39b0:	8a 81       	ldd	r24, Y+2	; 0x02
    39b2:	9b 81       	ldd	r25, Y+3	; 0x03
    39b4:	fc 01       	movw	r30, r24
    39b6:	85 8d       	ldd	r24, Z+29	; 0x1d
    39b8:	8e 83       	std	Y+6, r24	; 0x06

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    39ba:	29 85       	ldd	r18, Y+9	; 0x09
    39bc:	3a 85       	ldd	r19, Y+10	; 0x0a
    39be:	8a 81       	ldd	r24, Y+2	; 0x02
    39c0:	9b 81       	ldd	r25, Y+3	; 0x03
    39c2:	b9 01       	movw	r22, r18
    39c4:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    39c8:	8d 81       	ldd	r24, Y+5	; 0x05
    39ca:	2f ef       	ldi	r18, 0xFF	; 255
    39cc:	28 0f       	add	r18, r24
    39ce:	8a 81       	ldd	r24, Y+2	; 0x02
    39d0:	9b 81       	ldd	r25, Y+3	; 0x03
    39d2:	fc 01       	movw	r30, r24
    39d4:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    39d6:	8e 81       	ldd	r24, Y+6	; 0x06
    39d8:	8f 3f       	cpi	r24, 0xFF	; 255
    39da:	b9 f4       	brne	.+46     	; 0x3a0a <xQueueReceiveFromISR+0x94>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39dc:	8a 81       	ldd	r24, Y+2	; 0x02
    39de:	9b 81       	ldd	r25, Y+3	; 0x03
    39e0:	fc 01       	movw	r30, r24
    39e2:	80 85       	ldd	r24, Z+8	; 0x08
    39e4:	88 23       	and	r24, r24
    39e6:	c1 f0       	breq	.+48     	; 0x3a18 <xQueueReceiveFromISR+0xa2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    39e8:	8a 81       	ldd	r24, Y+2	; 0x02
    39ea:	9b 81       	ldd	r25, Y+3	; 0x03
    39ec:	08 96       	adiw	r24, 0x08	; 8
    39ee:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    39f2:	88 23       	and	r24, r24
    39f4:	89 f0       	breq	.+34     	; 0x3a18 <xQueueReceiveFromISR+0xa2>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    39f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    39f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    39fa:	89 2b       	or	r24, r25
    39fc:	69 f0       	breq	.+26     	; 0x3a18 <xQueueReceiveFromISR+0xa2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    39fe:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a00:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a02:	21 e0       	ldi	r18, 0x01	; 1
    3a04:	fc 01       	movw	r30, r24
    3a06:	20 83       	st	Z, r18
    3a08:	07 c0       	rjmp	.+14     	; 0x3a18 <xQueueReceiveFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3a0a:	8e 81       	ldd	r24, Y+6	; 0x06
    3a0c:	8f 5f       	subi	r24, 0xFF	; 255
    3a0e:	28 2f       	mov	r18, r24
    3a10:	8a 81       	ldd	r24, Y+2	; 0x02
    3a12:	9b 81       	ldd	r25, Y+3	; 0x03
    3a14:	fc 01       	movw	r30, r24
    3a16:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3a18:	81 e0       	ldi	r24, 0x01	; 1
    3a1a:	89 83       	std	Y+1, r24	; 0x01
    3a1c:	01 c0       	rjmp	.+2      	; 0x3a20 <xQueueReceiveFromISR+0xaa>
		}
		else
		{
			xReturn = pdFAIL;
    3a1e:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3a20:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a22:	2c 96       	adiw	r28, 0x0c	; 12
    3a24:	0f b6       	in	r0, 0x3f	; 63
    3a26:	f8 94       	cli
    3a28:	de bf       	out	0x3e, r29	; 62
    3a2a:	0f be       	out	0x3f, r0	; 63
    3a2c:	cd bf       	out	0x3d, r28	; 61
    3a2e:	df 91       	pop	r29
    3a30:	cf 91       	pop	r28
    3a32:	08 95       	ret

00003a34 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3a34:	cf 93       	push	r28
    3a36:	df 93       	push	r29
    3a38:	cd b7       	in	r28, 0x3d	; 61
    3a3a:	de b7       	in	r29, 0x3e	; 62
    3a3c:	2a 97       	sbiw	r28, 0x0a	; 10
    3a3e:	0f b6       	in	r0, 0x3f	; 63
    3a40:	f8 94       	cli
    3a42:	de bf       	out	0x3e, r29	; 62
    3a44:	0f be       	out	0x3f, r0	; 63
    3a46:	cd bf       	out	0x3d, r28	; 61
    3a48:	98 87       	std	Y+8, r25	; 0x08
    3a4a:	8f 83       	std	Y+7, r24	; 0x07
    3a4c:	7a 87       	std	Y+10, r23	; 0x0a
    3a4e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3a50:	8f 81       	ldd	r24, Y+7	; 0x07
    3a52:	98 85       	ldd	r25, Y+8	; 0x08
    3a54:	9b 83       	std	Y+3, r25	; 0x03
    3a56:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3a58:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5e:	fc 01       	movw	r30, r24
    3a60:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a62:	88 23       	and	r24, r24
    3a64:	c1 f0       	breq	.+48     	; 0x3a96 <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3a66:	8a 81       	ldd	r24, Y+2	; 0x02
    3a68:	9b 81       	ldd	r25, Y+3	; 0x03
    3a6a:	fc 01       	movw	r30, r24
    3a6c:	86 81       	ldd	r24, Z+6	; 0x06
    3a6e:	97 81       	ldd	r25, Z+7	; 0x07
    3a70:	9e 83       	std	Y+6, r25	; 0x06
    3a72:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a74:	29 85       	ldd	r18, Y+9	; 0x09
    3a76:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a78:	8a 81       	ldd	r24, Y+2	; 0x02
    3a7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a7c:	b9 01       	movw	r22, r18
    3a7e:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3a82:	8a 81       	ldd	r24, Y+2	; 0x02
    3a84:	9b 81       	ldd	r25, Y+3	; 0x03
    3a86:	2d 81       	ldd	r18, Y+5	; 0x05
    3a88:	3e 81       	ldd	r19, Y+6	; 0x06
    3a8a:	fc 01       	movw	r30, r24
    3a8c:	37 83       	std	Z+7, r19	; 0x07
    3a8e:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3a90:	81 e0       	ldi	r24, 0x01	; 1
    3a92:	89 83       	std	Y+1, r24	; 0x01
    3a94:	01 c0       	rjmp	.+2      	; 0x3a98 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    3a96:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3a98:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a9a:	2a 96       	adiw	r28, 0x0a	; 10
    3a9c:	0f b6       	in	r0, 0x3f	; 63
    3a9e:	f8 94       	cli
    3aa0:	de bf       	out	0x3e, r29	; 62
    3aa2:	0f be       	out	0x3f, r0	; 63
    3aa4:	cd bf       	out	0x3d, r28	; 61
    3aa6:	df 91       	pop	r29
    3aa8:	cf 91       	pop	r28
    3aaa:	08 95       	ret

00003aac <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3aac:	cf 93       	push	r28
    3aae:	df 93       	push	r29
    3ab0:	00 d0       	rcall	.+0      	; 0x3ab2 <uxQueueMessagesWaiting+0x6>
    3ab2:	1f 92       	push	r1
    3ab4:	cd b7       	in	r28, 0x3d	; 61
    3ab6:	de b7       	in	r29, 0x3e	; 62
    3ab8:	9b 83       	std	Y+3, r25	; 0x03
    3aba:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3abc:	0f b6       	in	r0, 0x3f	; 63
    3abe:	f8 94       	cli
    3ac0:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ac4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ac6:	fc 01       	movw	r30, r24
    3ac8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3aca:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3acc:	0f 90       	pop	r0
    3ace:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3ad0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3ad2:	0f 90       	pop	r0
    3ad4:	0f 90       	pop	r0
    3ad6:	0f 90       	pop	r0
    3ad8:	df 91       	pop	r29
    3ada:	cf 91       	pop	r28
    3adc:	08 95       	ret

00003ade <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3ade:	cf 93       	push	r28
    3ae0:	df 93       	push	r29
    3ae2:	00 d0       	rcall	.+0      	; 0x3ae4 <uxQueueSpacesAvailable+0x6>
    3ae4:	00 d0       	rcall	.+0      	; 0x3ae6 <uxQueueSpacesAvailable+0x8>
    3ae6:	1f 92       	push	r1
    3ae8:	cd b7       	in	r28, 0x3d	; 61
    3aea:	de b7       	in	r29, 0x3e	; 62
    3aec:	9d 83       	std	Y+5, r25	; 0x05
    3aee:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3af0:	8c 81       	ldd	r24, Y+4	; 0x04
    3af2:	9d 81       	ldd	r25, Y+5	; 0x05
    3af4:	9a 83       	std	Y+2, r25	; 0x02
    3af6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3af8:	0f b6       	in	r0, 0x3f	; 63
    3afa:	f8 94       	cli
    3afc:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3afe:	89 81       	ldd	r24, Y+1	; 0x01
    3b00:	9a 81       	ldd	r25, Y+2	; 0x02
    3b02:	fc 01       	movw	r30, r24
    3b04:	23 8d       	ldd	r18, Z+27	; 0x1b
    3b06:	89 81       	ldd	r24, Y+1	; 0x01
    3b08:	9a 81       	ldd	r25, Y+2	; 0x02
    3b0a:	fc 01       	movw	r30, r24
    3b0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b0e:	f2 2f       	mov	r31, r18
    3b10:	f8 1b       	sub	r31, r24
    3b12:	8f 2f       	mov	r24, r31
    3b14:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3b16:	0f 90       	pop	r0
    3b18:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3b1a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b1c:	0f 90       	pop	r0
    3b1e:	0f 90       	pop	r0
    3b20:	0f 90       	pop	r0
    3b22:	0f 90       	pop	r0
    3b24:	0f 90       	pop	r0
    3b26:	df 91       	pop	r29
    3b28:	cf 91       	pop	r28
    3b2a:	08 95       	ret

00003b2c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3b2c:	cf 93       	push	r28
    3b2e:	df 93       	push	r29
    3b30:	00 d0       	rcall	.+0      	; 0x3b32 <uxQueueMessagesWaitingFromISR+0x6>
    3b32:	00 d0       	rcall	.+0      	; 0x3b34 <uxQueueMessagesWaitingFromISR+0x8>
    3b34:	1f 92       	push	r1
    3b36:	cd b7       	in	r28, 0x3d	; 61
    3b38:	de b7       	in	r29, 0x3e	; 62
    3b3a:	9d 83       	std	Y+5, r25	; 0x05
    3b3c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3b3e:	8c 81       	ldd	r24, Y+4	; 0x04
    3b40:	9d 81       	ldd	r25, Y+5	; 0x05
    3b42:	9a 83       	std	Y+2, r25	; 0x02
    3b44:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3b46:	89 81       	ldd	r24, Y+1	; 0x01
    3b48:	9a 81       	ldd	r25, Y+2	; 0x02
    3b4a:	fc 01       	movw	r30, r24
    3b4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b4e:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3b50:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b52:	0f 90       	pop	r0
    3b54:	0f 90       	pop	r0
    3b56:	0f 90       	pop	r0
    3b58:	0f 90       	pop	r0
    3b5a:	0f 90       	pop	r0
    3b5c:	df 91       	pop	r29
    3b5e:	cf 91       	pop	r28
    3b60:	08 95       	ret

00003b62 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	00 d0       	rcall	.+0      	; 0x3b68 <vQueueDelete+0x6>
    3b68:	00 d0       	rcall	.+0      	; 0x3b6a <vQueueDelete+0x8>
    3b6a:	cd b7       	in	r28, 0x3d	; 61
    3b6c:	de b7       	in	r29, 0x3e	; 62
    3b6e:	9c 83       	std	Y+4, r25	; 0x04
    3b70:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3b72:	8b 81       	ldd	r24, Y+3	; 0x03
    3b74:	9c 81       	ldd	r25, Y+4	; 0x04
    3b76:	9a 83       	std	Y+2, r25	; 0x02
    3b78:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3b7a:	89 81       	ldd	r24, Y+1	; 0x01
    3b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b7e:	0e 94 b6 12 	call	0x256c	; 0x256c <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3b82:	00 00       	nop
    3b84:	0f 90       	pop	r0
    3b86:	0f 90       	pop	r0
    3b88:	0f 90       	pop	r0
    3b8a:	0f 90       	pop	r0
    3b8c:	df 91       	pop	r29
    3b8e:	cf 91       	pop	r28
    3b90:	08 95       	ret

00003b92 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    3b92:	cf 93       	push	r28
    3b94:	df 93       	push	r29
    3b96:	00 d0       	rcall	.+0      	; 0x3b98 <prvGetDisinheritPriorityAfterTimeout+0x6>
    3b98:	1f 92       	push	r1
    3b9a:	cd b7       	in	r28, 0x3d	; 61
    3b9c:	de b7       	in	r29, 0x3e	; 62
    3b9e:	9b 83       	std	Y+3, r25	; 0x03
    3ba0:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    3ba2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ba4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ba6:	fc 01       	movw	r30, r24
    3ba8:	81 89       	ldd	r24, Z+17	; 0x11
    3baa:	88 23       	and	r24, r24
    3bac:	69 f0       	breq	.+26     	; 0x3bc8 <prvGetDisinheritPriorityAfterTimeout+0x36>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    3bae:	8a 81       	ldd	r24, Y+2	; 0x02
    3bb0:	9b 81       	ldd	r25, Y+3	; 0x03
    3bb2:	fc 01       	movw	r30, r24
    3bb4:	86 89       	ldd	r24, Z+22	; 0x16
    3bb6:	97 89       	ldd	r25, Z+23	; 0x17
    3bb8:	fc 01       	movw	r30, r24
    3bba:	80 81       	ld	r24, Z
    3bbc:	91 81       	ldd	r25, Z+1	; 0x01
    3bbe:	98 2f       	mov	r25, r24
    3bc0:	85 e0       	ldi	r24, 0x05	; 5
    3bc2:	89 1b       	sub	r24, r25
    3bc4:	89 83       	std	Y+1, r24	; 0x01
    3bc6:	01 c0       	rjmp	.+2      	; 0x3bca <prvGetDisinheritPriorityAfterTimeout+0x38>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    3bc8:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    3bca:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3bcc:	0f 90       	pop	r0
    3bce:	0f 90       	pop	r0
    3bd0:	0f 90       	pop	r0
    3bd2:	df 91       	pop	r29
    3bd4:	cf 91       	pop	r28
    3bd6:	08 95       	ret

00003bd8 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3bd8:	cf 93       	push	r28
    3bda:	df 93       	push	r29
    3bdc:	cd b7       	in	r28, 0x3d	; 61
    3bde:	de b7       	in	r29, 0x3e	; 62
    3be0:	27 97       	sbiw	r28, 0x07	; 7
    3be2:	0f b6       	in	r0, 0x3f	; 63
    3be4:	f8 94       	cli
    3be6:	de bf       	out	0x3e, r29	; 62
    3be8:	0f be       	out	0x3f, r0	; 63
    3bea:	cd bf       	out	0x3d, r28	; 61
    3bec:	9c 83       	std	Y+4, r25	; 0x04
    3bee:	8b 83       	std	Y+3, r24	; 0x03
    3bf0:	7e 83       	std	Y+6, r23	; 0x06
    3bf2:	6d 83       	std	Y+5, r22	; 0x05
    3bf4:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3bf6:	19 82       	std	Y+1, r1	; 0x01
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    3bfc:	fc 01       	movw	r30, r24
    3bfe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c00:	8a 83       	std	Y+2, r24	; 0x02

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3c02:	8b 81       	ldd	r24, Y+3	; 0x03
    3c04:	9c 81       	ldd	r25, Y+4	; 0x04
    3c06:	fc 01       	movw	r30, r24
    3c08:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c0a:	88 23       	and	r24, r24
    3c0c:	b1 f4       	brne	.+44     	; 0x3c3a <prvCopyDataToQueue+0x62>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c10:	9c 81       	ldd	r25, Y+4	; 0x04
    3c12:	fc 01       	movw	r30, r24
    3c14:	80 81       	ld	r24, Z
    3c16:	91 81       	ldd	r25, Z+1	; 0x01
    3c18:	89 2b       	or	r24, r25
    3c1a:	09 f0       	breq	.+2      	; 0x3c1e <prvCopyDataToQueue+0x46>
    3c1c:	9c c0       	rjmp	.+312    	; 0x3d56 <prvCopyDataToQueue+0x17e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    3c1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c20:	9c 81       	ldd	r25, Y+4	; 0x04
    3c22:	fc 01       	movw	r30, r24
    3c24:	84 81       	ldd	r24, Z+4	; 0x04
    3c26:	95 81       	ldd	r25, Z+5	; 0x05
    3c28:	0e 94 34 2a 	call	0x5468	; 0x5468 <xTaskPriorityDisinherit>
    3c2c:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    3c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c30:	9c 81       	ldd	r25, Y+4	; 0x04
    3c32:	fc 01       	movw	r30, r24
    3c34:	15 82       	std	Z+5, r1	; 0x05
    3c36:	14 82       	std	Z+4, r1	; 0x04
    3c38:	8e c0       	rjmp	.+284    	; 0x3d56 <prvCopyDataToQueue+0x17e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3c3a:	8f 81       	ldd	r24, Y+7	; 0x07
    3c3c:	88 23       	and	r24, r24
    3c3e:	d9 f5       	brne	.+118    	; 0x3cb6 <prvCopyDataToQueue+0xde>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3c40:	8b 81       	ldd	r24, Y+3	; 0x03
    3c42:	9c 81       	ldd	r25, Y+4	; 0x04
    3c44:	fc 01       	movw	r30, r24
    3c46:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c48:	48 2f       	mov	r20, r24
    3c4a:	50 e0       	ldi	r21, 0x00	; 0
    3c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c50:	fc 01       	movw	r30, r24
    3c52:	82 81       	ldd	r24, Z+2	; 0x02
    3c54:	93 81       	ldd	r25, Z+3	; 0x03
    3c56:	2d 81       	ldd	r18, Y+5	; 0x05
    3c58:	3e 81       	ldd	r19, Y+6	; 0x06
    3c5a:	b9 01       	movw	r22, r18
    3c5c:	0e 94 d6 31 	call	0x63ac	; 0x63ac <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3c60:	8b 81       	ldd	r24, Y+3	; 0x03
    3c62:	9c 81       	ldd	r25, Y+4	; 0x04
    3c64:	fc 01       	movw	r30, r24
    3c66:	22 81       	ldd	r18, Z+2	; 0x02
    3c68:	33 81       	ldd	r19, Z+3	; 0x03
    3c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c6c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c6e:	fc 01       	movw	r30, r24
    3c70:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c72:	88 2f       	mov	r24, r24
    3c74:	90 e0       	ldi	r25, 0x00	; 0
    3c76:	28 0f       	add	r18, r24
    3c78:	39 1f       	adc	r19, r25
    3c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c7c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c7e:	fc 01       	movw	r30, r24
    3c80:	33 83       	std	Z+3, r19	; 0x03
    3c82:	22 83       	std	Z+2, r18	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3c84:	8b 81       	ldd	r24, Y+3	; 0x03
    3c86:	9c 81       	ldd	r25, Y+4	; 0x04
    3c88:	fc 01       	movw	r30, r24
    3c8a:	22 81       	ldd	r18, Z+2	; 0x02
    3c8c:	33 81       	ldd	r19, Z+3	; 0x03
    3c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c90:	9c 81       	ldd	r25, Y+4	; 0x04
    3c92:	fc 01       	movw	r30, r24
    3c94:	84 81       	ldd	r24, Z+4	; 0x04
    3c96:	95 81       	ldd	r25, Z+5	; 0x05
    3c98:	28 17       	cp	r18, r24
    3c9a:	39 07       	cpc	r19, r25
    3c9c:	08 f4       	brcc	.+2      	; 0x3ca0 <prvCopyDataToQueue+0xc8>
    3c9e:	5b c0       	rjmp	.+182    	; 0x3d56 <prvCopyDataToQueue+0x17e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ca4:	fc 01       	movw	r30, r24
    3ca6:	20 81       	ld	r18, Z
    3ca8:	31 81       	ldd	r19, Z+1	; 0x01
    3caa:	8b 81       	ldd	r24, Y+3	; 0x03
    3cac:	9c 81       	ldd	r25, Y+4	; 0x04
    3cae:	fc 01       	movw	r30, r24
    3cb0:	33 83       	std	Z+3, r19	; 0x03
    3cb2:	22 83       	std	Z+2, r18	; 0x02
    3cb4:	50 c0       	rjmp	.+160    	; 0x3d56 <prvCopyDataToQueue+0x17e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cba:	fc 01       	movw	r30, r24
    3cbc:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cbe:	48 2f       	mov	r20, r24
    3cc0:	50 e0       	ldi	r21, 0x00	; 0
    3cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc6:	fc 01       	movw	r30, r24
    3cc8:	86 81       	ldd	r24, Z+6	; 0x06
    3cca:	97 81       	ldd	r25, Z+7	; 0x07
    3ccc:	2d 81       	ldd	r18, Y+5	; 0x05
    3cce:	3e 81       	ldd	r19, Y+6	; 0x06
    3cd0:	b9 01       	movw	r22, r18
    3cd2:	0e 94 d6 31 	call	0x63ac	; 0x63ac <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cda:	fc 01       	movw	r30, r24
    3cdc:	26 81       	ldd	r18, Z+6	; 0x06
    3cde:	37 81       	ldd	r19, Z+7	; 0x07
    3ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce4:	fc 01       	movw	r30, r24
    3ce6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ce8:	88 2f       	mov	r24, r24
    3cea:	90 e0       	ldi	r25, 0x00	; 0
    3cec:	91 95       	neg	r25
    3cee:	81 95       	neg	r24
    3cf0:	91 09       	sbc	r25, r1
    3cf2:	28 0f       	add	r18, r24
    3cf4:	39 1f       	adc	r19, r25
    3cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cfa:	fc 01       	movw	r30, r24
    3cfc:	37 83       	std	Z+7, r19	; 0x07
    3cfe:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d00:	8b 81       	ldd	r24, Y+3	; 0x03
    3d02:	9c 81       	ldd	r25, Y+4	; 0x04
    3d04:	fc 01       	movw	r30, r24
    3d06:	26 81       	ldd	r18, Z+6	; 0x06
    3d08:	37 81       	ldd	r19, Z+7	; 0x07
    3d0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d0e:	fc 01       	movw	r30, r24
    3d10:	80 81       	ld	r24, Z
    3d12:	91 81       	ldd	r25, Z+1	; 0x01
    3d14:	28 17       	cp	r18, r24
    3d16:	39 07       	cpc	r19, r25
    3d18:	a8 f4       	brcc	.+42     	; 0x3d44 <prvCopyDataToQueue+0x16c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d1e:	fc 01       	movw	r30, r24
    3d20:	24 81       	ldd	r18, Z+4	; 0x04
    3d22:	35 81       	ldd	r19, Z+5	; 0x05
    3d24:	8b 81       	ldd	r24, Y+3	; 0x03
    3d26:	9c 81       	ldd	r25, Y+4	; 0x04
    3d28:	fc 01       	movw	r30, r24
    3d2a:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d2c:	88 2f       	mov	r24, r24
    3d2e:	90 e0       	ldi	r25, 0x00	; 0
    3d30:	91 95       	neg	r25
    3d32:	81 95       	neg	r24
    3d34:	91 09       	sbc	r25, r1
    3d36:	28 0f       	add	r18, r24
    3d38:	39 1f       	adc	r19, r25
    3d3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d3c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d3e:	fc 01       	movw	r30, r24
    3d40:	37 83       	std	Z+7, r19	; 0x07
    3d42:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3d44:	8f 81       	ldd	r24, Y+7	; 0x07
    3d46:	82 30       	cpi	r24, 0x02	; 2
    3d48:	31 f4       	brne	.+12     	; 0x3d56 <prvCopyDataToQueue+0x17e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3d4a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d4c:	88 23       	and	r24, r24
    3d4e:	19 f0       	breq	.+6      	; 0x3d56 <prvCopyDataToQueue+0x17e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3d50:	8a 81       	ldd	r24, Y+2	; 0x02
    3d52:	81 50       	subi	r24, 0x01	; 1
    3d54:	8a 83       	std	Y+2, r24	; 0x02
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3d56:	8a 81       	ldd	r24, Y+2	; 0x02
    3d58:	21 e0       	ldi	r18, 0x01	; 1
    3d5a:	28 0f       	add	r18, r24
    3d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d60:	fc 01       	movw	r30, r24
    3d62:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3d64:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d66:	27 96       	adiw	r28, 0x07	; 7
    3d68:	0f b6       	in	r0, 0x3f	; 63
    3d6a:	f8 94       	cli
    3d6c:	de bf       	out	0x3e, r29	; 62
    3d6e:	0f be       	out	0x3f, r0	; 63
    3d70:	cd bf       	out	0x3d, r28	; 61
    3d72:	df 91       	pop	r29
    3d74:	cf 91       	pop	r28
    3d76:	08 95       	ret

00003d78 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3d78:	cf 93       	push	r28
    3d7a:	df 93       	push	r29
    3d7c:	00 d0       	rcall	.+0      	; 0x3d7e <prvCopyDataFromQueue+0x6>
    3d7e:	00 d0       	rcall	.+0      	; 0x3d80 <prvCopyDataFromQueue+0x8>
    3d80:	cd b7       	in	r28, 0x3d	; 61
    3d82:	de b7       	in	r29, 0x3e	; 62
    3d84:	9a 83       	std	Y+2, r25	; 0x02
    3d86:	89 83       	std	Y+1, r24	; 0x01
    3d88:	7c 83       	std	Y+4, r23	; 0x04
    3d8a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3d8c:	89 81       	ldd	r24, Y+1	; 0x01
    3d8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d90:	fc 01       	movw	r30, r24
    3d92:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d94:	88 23       	and	r24, r24
    3d96:	c9 f1       	breq	.+114    	; 0x3e0a <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3d98:	89 81       	ldd	r24, Y+1	; 0x01
    3d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9c:	fc 01       	movw	r30, r24
    3d9e:	26 81       	ldd	r18, Z+6	; 0x06
    3da0:	37 81       	ldd	r19, Z+7	; 0x07
    3da2:	89 81       	ldd	r24, Y+1	; 0x01
    3da4:	9a 81       	ldd	r25, Y+2	; 0x02
    3da6:	fc 01       	movw	r30, r24
    3da8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3daa:	88 2f       	mov	r24, r24
    3dac:	90 e0       	ldi	r25, 0x00	; 0
    3dae:	28 0f       	add	r18, r24
    3db0:	39 1f       	adc	r19, r25
    3db2:	89 81       	ldd	r24, Y+1	; 0x01
    3db4:	9a 81       	ldd	r25, Y+2	; 0x02
    3db6:	fc 01       	movw	r30, r24
    3db8:	37 83       	std	Z+7, r19	; 0x07
    3dba:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3dbc:	89 81       	ldd	r24, Y+1	; 0x01
    3dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc0:	fc 01       	movw	r30, r24
    3dc2:	26 81       	ldd	r18, Z+6	; 0x06
    3dc4:	37 81       	ldd	r19, Z+7	; 0x07
    3dc6:	89 81       	ldd	r24, Y+1	; 0x01
    3dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dca:	fc 01       	movw	r30, r24
    3dcc:	84 81       	ldd	r24, Z+4	; 0x04
    3dce:	95 81       	ldd	r25, Z+5	; 0x05
    3dd0:	28 17       	cp	r18, r24
    3dd2:	39 07       	cpc	r19, r25
    3dd4:	50 f0       	brcs	.+20     	; 0x3dea <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3dd6:	89 81       	ldd	r24, Y+1	; 0x01
    3dd8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dda:	fc 01       	movw	r30, r24
    3ddc:	20 81       	ld	r18, Z
    3dde:	31 81       	ldd	r19, Z+1	; 0x01
    3de0:	89 81       	ldd	r24, Y+1	; 0x01
    3de2:	9a 81       	ldd	r25, Y+2	; 0x02
    3de4:	fc 01       	movw	r30, r24
    3de6:	37 83       	std	Z+7, r19	; 0x07
    3de8:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3dea:	89 81       	ldd	r24, Y+1	; 0x01
    3dec:	9a 81       	ldd	r25, Y+2	; 0x02
    3dee:	fc 01       	movw	r30, r24
    3df0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3df2:	48 2f       	mov	r20, r24
    3df4:	50 e0       	ldi	r21, 0x00	; 0
    3df6:	89 81       	ldd	r24, Y+1	; 0x01
    3df8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dfa:	fc 01       	movw	r30, r24
    3dfc:	26 81       	ldd	r18, Z+6	; 0x06
    3dfe:	37 81       	ldd	r19, Z+7	; 0x07
    3e00:	8b 81       	ldd	r24, Y+3	; 0x03
    3e02:	9c 81       	ldd	r25, Y+4	; 0x04
    3e04:	b9 01       	movw	r22, r18
    3e06:	0e 94 d6 31 	call	0x63ac	; 0x63ac <memcpy>
	}
}
    3e0a:	00 00       	nop
    3e0c:	0f 90       	pop	r0
    3e0e:	0f 90       	pop	r0
    3e10:	0f 90       	pop	r0
    3e12:	0f 90       	pop	r0
    3e14:	df 91       	pop	r29
    3e16:	cf 91       	pop	r28
    3e18:	08 95       	ret

00003e1a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3e1a:	cf 93       	push	r28
    3e1c:	df 93       	push	r29
    3e1e:	00 d0       	rcall	.+0      	; 0x3e20 <prvUnlockQueue+0x6>
    3e20:	00 d0       	rcall	.+0      	; 0x3e22 <prvUnlockQueue+0x8>
    3e22:	cd b7       	in	r28, 0x3d	; 61
    3e24:	de b7       	in	r29, 0x3e	; 62
    3e26:	9c 83       	std	Y+4, r25	; 0x04
    3e28:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3e2a:	0f b6       	in	r0, 0x3f	; 63
    3e2c:	f8 94       	cli
    3e2e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3e30:	8b 81       	ldd	r24, Y+3	; 0x03
    3e32:	9c 81       	ldd	r25, Y+4	; 0x04
    3e34:	fc 01       	movw	r30, r24
    3e36:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e38:	89 83       	std	Y+1, r24	; 0x01

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3e3a:	12 c0       	rjmp	.+36     	; 0x3e60 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e40:	fc 01       	movw	r30, r24
    3e42:	81 89       	ldd	r24, Z+17	; 0x11
    3e44:	88 23       	and	r24, r24
    3e46:	81 f0       	breq	.+32     	; 0x3e68 <prvUnlockQueue+0x4e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3e48:	8b 81       	ldd	r24, Y+3	; 0x03
    3e4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e4c:	41 96       	adiw	r24, 0x11	; 17
    3e4e:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    3e52:	88 23       	and	r24, r24
    3e54:	11 f0       	breq	.+4      	; 0x3e5a <prvUnlockQueue+0x40>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3e56:	0e 94 a1 28 	call	0x5142	; 0x5142 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3e5a:	89 81       	ldd	r24, Y+1	; 0x01
    3e5c:	81 50       	subi	r24, 0x01	; 1
    3e5e:	89 83       	std	Y+1, r24	; 0x01
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3e60:	89 81       	ldd	r24, Y+1	; 0x01
    3e62:	18 16       	cp	r1, r24
    3e64:	5c f3       	brlt	.-42     	; 0x3e3c <prvUnlockQueue+0x22>
    3e66:	01 c0       	rjmp	.+2      	; 0x3e6a <prvUnlockQueue+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3e68:	00 00       	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e6c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e6e:	2f ef       	ldi	r18, 0xFF	; 255
    3e70:	fc 01       	movw	r30, r24
    3e72:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3e74:	0f 90       	pop	r0
    3e76:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3e78:	0f b6       	in	r0, 0x3f	; 63
    3e7a:	f8 94       	cli
    3e7c:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e80:	9c 81       	ldd	r25, Y+4	; 0x04
    3e82:	fc 01       	movw	r30, r24
    3e84:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e86:	8a 83       	std	Y+2, r24	; 0x02

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3e88:	12 c0       	rjmp	.+36     	; 0x3eae <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e8e:	fc 01       	movw	r30, r24
    3e90:	80 85       	ldd	r24, Z+8	; 0x08
    3e92:	88 23       	and	r24, r24
    3e94:	81 f0       	breq	.+32     	; 0x3eb6 <prvUnlockQueue+0x9c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e96:	8b 81       	ldd	r24, Y+3	; 0x03
    3e98:	9c 81       	ldd	r25, Y+4	; 0x04
    3e9a:	08 96       	adiw	r24, 0x08	; 8
    3e9c:	0e 94 20 27 	call	0x4e40	; 0x4e40 <xTaskRemoveFromEventList>
    3ea0:	88 23       	and	r24, r24
    3ea2:	11 f0       	breq	.+4      	; 0x3ea8 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    3ea4:	0e 94 a1 28 	call	0x5142	; 0x5142 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eaa:	81 50       	subi	r24, 0x01	; 1
    3eac:	8a 83       	std	Y+2, r24	; 0x02
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3eae:	8a 81       	ldd	r24, Y+2	; 0x02
    3eb0:	18 16       	cp	r1, r24
    3eb2:	5c f3       	brlt	.-42     	; 0x3e8a <prvUnlockQueue+0x70>
    3eb4:	01 c0       	rjmp	.+2      	; 0x3eb8 <prvUnlockQueue+0x9e>

				--cRxLock;
			}
			else
			{
				break;
    3eb6:	00 00       	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3eba:	9c 81       	ldd	r25, Y+4	; 0x04
    3ebc:	2f ef       	ldi	r18, 0xFF	; 255
    3ebe:	fc 01       	movw	r30, r24
    3ec0:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    3ec2:	0f 90       	pop	r0
    3ec4:	0f be       	out	0x3f, r0	; 63
}
    3ec6:	00 00       	nop
    3ec8:	0f 90       	pop	r0
    3eca:	0f 90       	pop	r0
    3ecc:	0f 90       	pop	r0
    3ece:	0f 90       	pop	r0
    3ed0:	df 91       	pop	r29
    3ed2:	cf 91       	pop	r28
    3ed4:	08 95       	ret

00003ed6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3ed6:	cf 93       	push	r28
    3ed8:	df 93       	push	r29
    3eda:	00 d0       	rcall	.+0      	; 0x3edc <prvIsQueueEmpty+0x6>
    3edc:	1f 92       	push	r1
    3ede:	cd b7       	in	r28, 0x3d	; 61
    3ee0:	de b7       	in	r29, 0x3e	; 62
    3ee2:	9b 83       	std	Y+3, r25	; 0x03
    3ee4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3ee6:	0f b6       	in	r0, 0x3f	; 63
    3ee8:	f8 94       	cli
    3eea:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3eec:	8a 81       	ldd	r24, Y+2	; 0x02
    3eee:	9b 81       	ldd	r25, Y+3	; 0x03
    3ef0:	fc 01       	movw	r30, r24
    3ef2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ef4:	88 23       	and	r24, r24
    3ef6:	19 f4       	brne	.+6      	; 0x3efe <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    3ef8:	81 e0       	ldi	r24, 0x01	; 1
    3efa:	89 83       	std	Y+1, r24	; 0x01
    3efc:	01 c0       	rjmp	.+2      	; 0x3f00 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    3efe:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3f00:	0f 90       	pop	r0
    3f02:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f04:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f06:	0f 90       	pop	r0
    3f08:	0f 90       	pop	r0
    3f0a:	0f 90       	pop	r0
    3f0c:	df 91       	pop	r29
    3f0e:	cf 91       	pop	r28
    3f10:	08 95       	ret

00003f12 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3f12:	cf 93       	push	r28
    3f14:	df 93       	push	r29
    3f16:	00 d0       	rcall	.+0      	; 0x3f18 <xQueueIsQueueEmptyFromISR+0x6>
    3f18:	00 d0       	rcall	.+0      	; 0x3f1a <xQueueIsQueueEmptyFromISR+0x8>
    3f1a:	1f 92       	push	r1
    3f1c:	cd b7       	in	r28, 0x3d	; 61
    3f1e:	de b7       	in	r29, 0x3e	; 62
    3f20:	9d 83       	std	Y+5, r25	; 0x05
    3f22:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3f24:	8c 81       	ldd	r24, Y+4	; 0x04
    3f26:	9d 81       	ldd	r25, Y+5	; 0x05
    3f28:	9b 83       	std	Y+3, r25	; 0x03
    3f2a:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3f2c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f2e:	9b 81       	ldd	r25, Y+3	; 0x03
    3f30:	fc 01       	movw	r30, r24
    3f32:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f34:	88 23       	and	r24, r24
    3f36:	19 f4       	brne	.+6      	; 0x3f3e <xQueueIsQueueEmptyFromISR+0x2c>
	{
		xReturn = pdTRUE;
    3f38:	81 e0       	ldi	r24, 0x01	; 1
    3f3a:	89 83       	std	Y+1, r24	; 0x01
    3f3c:	01 c0       	rjmp	.+2      	; 0x3f40 <xQueueIsQueueEmptyFromISR+0x2e>
	}
	else
	{
		xReturn = pdFALSE;
    3f3e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3f40:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3f42:	0f 90       	pop	r0
    3f44:	0f 90       	pop	r0
    3f46:	0f 90       	pop	r0
    3f48:	0f 90       	pop	r0
    3f4a:	0f 90       	pop	r0
    3f4c:	df 91       	pop	r29
    3f4e:	cf 91       	pop	r28
    3f50:	08 95       	ret

00003f52 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3f52:	cf 93       	push	r28
    3f54:	df 93       	push	r29
    3f56:	00 d0       	rcall	.+0      	; 0x3f58 <prvIsQueueFull+0x6>
    3f58:	1f 92       	push	r1
    3f5a:	cd b7       	in	r28, 0x3d	; 61
    3f5c:	de b7       	in	r29, 0x3e	; 62
    3f5e:	9b 83       	std	Y+3, r25	; 0x03
    3f60:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3f62:	0f b6       	in	r0, 0x3f	; 63
    3f64:	f8 94       	cli
    3f66:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3f68:	8a 81       	ldd	r24, Y+2	; 0x02
    3f6a:	9b 81       	ldd	r25, Y+3	; 0x03
    3f6c:	fc 01       	movw	r30, r24
    3f6e:	22 8d       	ldd	r18, Z+26	; 0x1a
    3f70:	8a 81       	ldd	r24, Y+2	; 0x02
    3f72:	9b 81       	ldd	r25, Y+3	; 0x03
    3f74:	fc 01       	movw	r30, r24
    3f76:	83 8d       	ldd	r24, Z+27	; 0x1b
    3f78:	28 17       	cp	r18, r24
    3f7a:	19 f4       	brne	.+6      	; 0x3f82 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    3f7c:	81 e0       	ldi	r24, 0x01	; 1
    3f7e:	89 83       	std	Y+1, r24	; 0x01
    3f80:	01 c0       	rjmp	.+2      	; 0x3f84 <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    3f82:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3f84:	0f 90       	pop	r0
    3f86:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f88:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f8a:	0f 90       	pop	r0
    3f8c:	0f 90       	pop	r0
    3f8e:	0f 90       	pop	r0
    3f90:	df 91       	pop	r29
    3f92:	cf 91       	pop	r28
    3f94:	08 95       	ret

00003f96 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3f96:	cf 93       	push	r28
    3f98:	df 93       	push	r29
    3f9a:	00 d0       	rcall	.+0      	; 0x3f9c <xQueueIsQueueFullFromISR+0x6>
    3f9c:	00 d0       	rcall	.+0      	; 0x3f9e <xQueueIsQueueFullFromISR+0x8>
    3f9e:	1f 92       	push	r1
    3fa0:	cd b7       	in	r28, 0x3d	; 61
    3fa2:	de b7       	in	r29, 0x3e	; 62
    3fa4:	9d 83       	std	Y+5, r25	; 0x05
    3fa6:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3fa8:	8c 81       	ldd	r24, Y+4	; 0x04
    3faa:	9d 81       	ldd	r25, Y+5	; 0x05
    3fac:	9b 83       	std	Y+3, r25	; 0x03
    3fae:	8a 83       	std	Y+2, r24	; 0x02

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb2:	9b 81       	ldd	r25, Y+3	; 0x03
    3fb4:	fc 01       	movw	r30, r24
    3fb6:	22 8d       	ldd	r18, Z+26	; 0x1a
    3fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    3fba:	9b 81       	ldd	r25, Y+3	; 0x03
    3fbc:	fc 01       	movw	r30, r24
    3fbe:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fc0:	28 17       	cp	r18, r24
    3fc2:	19 f4       	brne	.+6      	; 0x3fca <xQueueIsQueueFullFromISR+0x34>
	{
		xReturn = pdTRUE;
    3fc4:	81 e0       	ldi	r24, 0x01	; 1
    3fc6:	89 83       	std	Y+1, r24	; 0x01
    3fc8:	01 c0       	rjmp	.+2      	; 0x3fcc <xQueueIsQueueFullFromISR+0x36>
	}
	else
	{
		xReturn = pdFALSE;
    3fca:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3fcc:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3fce:	0f 90       	pop	r0
    3fd0:	0f 90       	pop	r0
    3fd2:	0f 90       	pop	r0
    3fd4:	0f 90       	pop	r0
    3fd6:	0f 90       	pop	r0
    3fd8:	df 91       	pop	r29
    3fda:	cf 91       	pop	r28
    3fdc:	08 95       	ret

00003fde <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3fde:	8f 92       	push	r8
    3fe0:	9f 92       	push	r9
    3fe2:	af 92       	push	r10
    3fe4:	bf 92       	push	r11
    3fe6:	cf 92       	push	r12
    3fe8:	df 92       	push	r13
    3fea:	ef 92       	push	r14
    3fec:	ff 92       	push	r15
    3fee:	0f 93       	push	r16
    3ff0:	1f 93       	push	r17
    3ff2:	cf 93       	push	r28
    3ff4:	df 93       	push	r29
    3ff6:	cd b7       	in	r28, 0x3d	; 61
    3ff8:	de b7       	in	r29, 0x3e	; 62
    3ffa:	60 97       	sbiw	r28, 0x10	; 16
    3ffc:	0f b6       	in	r0, 0x3f	; 63
    3ffe:	f8 94       	cli
    4000:	de bf       	out	0x3e, r29	; 62
    4002:	0f be       	out	0x3f, r0	; 63
    4004:	cd bf       	out	0x3d, r28	; 61
    4006:	9f 83       	std	Y+7, r25	; 0x07
    4008:	8e 83       	std	Y+6, r24	; 0x06
    400a:	79 87       	std	Y+9, r23	; 0x09
    400c:	68 87       	std	Y+8, r22	; 0x08
    400e:	5b 87       	std	Y+11, r21	; 0x0b
    4010:	4a 87       	std	Y+10, r20	; 0x0a
    4012:	3d 87       	std	Y+13, r19	; 0x0d
    4014:	2c 87       	std	Y+12, r18	; 0x0c
    4016:	0e 87       	std	Y+14, r16	; 0x0e
    4018:	f8 8a       	std	Y+16, r15	; 0x10
    401a:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    401c:	8a 85       	ldd	r24, Y+10	; 0x0a
    401e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4020:	0e 94 61 12 	call	0x24c2	; 0x24c2 <pvPortMalloc>
    4024:	9d 83       	std	Y+5, r25	; 0x05
    4026:	8c 83       	std	Y+4, r24	; 0x04

			if( pxStack != NULL )
    4028:	8c 81       	ldd	r24, Y+4	; 0x04
    402a:	9d 81       	ldd	r25, Y+5	; 0x05
    402c:	89 2b       	or	r24, r25
    402e:	b9 f0       	breq	.+46     	; 0x405e <xTaskCreate+0x80>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4030:	88 e2       	ldi	r24, 0x28	; 40
    4032:	90 e0       	ldi	r25, 0x00	; 0
    4034:	0e 94 61 12 	call	0x24c2	; 0x24c2 <pvPortMalloc>
    4038:	9a 83       	std	Y+2, r25	; 0x02
    403a:	89 83       	std	Y+1, r24	; 0x01

				if( pxNewTCB != NULL )
    403c:	89 81       	ldd	r24, Y+1	; 0x01
    403e:	9a 81       	ldd	r25, Y+2	; 0x02
    4040:	89 2b       	or	r24, r25
    4042:	41 f0       	breq	.+16     	; 0x4054 <xTaskCreate+0x76>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4044:	89 81       	ldd	r24, Y+1	; 0x01
    4046:	9a 81       	ldd	r25, Y+2	; 0x02
    4048:	2c 81       	ldd	r18, Y+4	; 0x04
    404a:	3d 81       	ldd	r19, Y+5	; 0x05
    404c:	fc 01       	movw	r30, r24
    404e:	30 8f       	std	Z+24, r19	; 0x18
    4050:	27 8b       	std	Z+23, r18	; 0x17
    4052:	07 c0       	rjmp	.+14     	; 0x4062 <xTaskCreate+0x84>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    4054:	8c 81       	ldd	r24, Y+4	; 0x04
    4056:	9d 81       	ldd	r25, Y+5	; 0x05
    4058:	0e 94 b6 12 	call	0x256c	; 0x256c <vPortFree>
    405c:	02 c0       	rjmp	.+4      	; 0x4062 <xTaskCreate+0x84>
				}
			}
			else
			{
				pxNewTCB = NULL;
    405e:	1a 82       	std	Y+2, r1	; 0x02
    4060:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4062:	89 81       	ldd	r24, Y+1	; 0x01
    4064:	9a 81       	ldd	r25, Y+2	; 0x02
    4066:	89 2b       	or	r24, r25
    4068:	09 f1       	breq	.+66     	; 0x40ac <xTaskCreate+0xce>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    406a:	8a 85       	ldd	r24, Y+10	; 0x0a
    406c:	9b 85       	ldd	r25, Y+11	; 0x0b
    406e:	cc 01       	movw	r24, r24
    4070:	a0 e0       	ldi	r26, 0x00	; 0
    4072:	b0 e0       	ldi	r27, 0x00	; 0
    4074:	09 81       	ldd	r16, Y+1	; 0x01
    4076:	1a 81       	ldd	r17, Y+2	; 0x02
    4078:	4f 85       	ldd	r20, Y+15	; 0x0f
    407a:	58 89       	ldd	r21, Y+16	; 0x10
    407c:	2c 85       	ldd	r18, Y+12	; 0x0c
    407e:	3d 85       	ldd	r19, Y+13	; 0x0d
    4080:	68 85       	ldd	r22, Y+8	; 0x08
    4082:	79 85       	ldd	r23, Y+9	; 0x09
    4084:	ee 81       	ldd	r30, Y+6	; 0x06
    4086:	ff 81       	ldd	r31, Y+7	; 0x07
    4088:	81 2c       	mov	r8, r1
    408a:	91 2c       	mov	r9, r1
    408c:	58 01       	movw	r10, r16
    408e:	6a 01       	movw	r12, r20
    4090:	ee 84       	ldd	r14, Y+14	; 0x0e
    4092:	89 01       	movw	r16, r18
    4094:	9c 01       	movw	r18, r24
    4096:	ad 01       	movw	r20, r26
    4098:	cf 01       	movw	r24, r30
    409a:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    409e:	89 81       	ldd	r24, Y+1	; 0x01
    40a0:	9a 81       	ldd	r25, Y+2	; 0x02
    40a2:	0e 94 40 21 	call	0x4280	; 0x4280 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    40a6:	81 e0       	ldi	r24, 0x01	; 1
    40a8:	8b 83       	std	Y+3, r24	; 0x03
    40aa:	02 c0       	rjmp	.+4      	; 0x40b0 <xTaskCreate+0xd2>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    40ac:	8f ef       	ldi	r24, 0xFF	; 255
    40ae:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    40b0:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    40b2:	60 96       	adiw	r28, 0x10	; 16
    40b4:	0f b6       	in	r0, 0x3f	; 63
    40b6:	f8 94       	cli
    40b8:	de bf       	out	0x3e, r29	; 62
    40ba:	0f be       	out	0x3f, r0	; 63
    40bc:	cd bf       	out	0x3d, r28	; 61
    40be:	df 91       	pop	r29
    40c0:	cf 91       	pop	r28
    40c2:	1f 91       	pop	r17
    40c4:	0f 91       	pop	r16
    40c6:	ff 90       	pop	r15
    40c8:	ef 90       	pop	r14
    40ca:	df 90       	pop	r13
    40cc:	cf 90       	pop	r12
    40ce:	bf 90       	pop	r11
    40d0:	af 90       	pop	r10
    40d2:	9f 90       	pop	r9
    40d4:	8f 90       	pop	r8
    40d6:	08 95       	ret

000040d8 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    40d8:	8f 92       	push	r8
    40da:	9f 92       	push	r9
    40dc:	af 92       	push	r10
    40de:	bf 92       	push	r11
    40e0:	cf 92       	push	r12
    40e2:	df 92       	push	r13
    40e4:	ef 92       	push	r14
    40e6:	0f 93       	push	r16
    40e8:	1f 93       	push	r17
    40ea:	cf 93       	push	r28
    40ec:	df 93       	push	r29
    40ee:	cd b7       	in	r28, 0x3d	; 61
    40f0:	de b7       	in	r29, 0x3e	; 62
    40f2:	64 97       	sbiw	r28, 0x14	; 20
    40f4:	0f b6       	in	r0, 0x3f	; 63
    40f6:	f8 94       	cli
    40f8:	de bf       	out	0x3e, r29	; 62
    40fa:	0f be       	out	0x3f, r0	; 63
    40fc:	cd bf       	out	0x3d, r28	; 61
    40fe:	9d 83       	std	Y+5, r25	; 0x05
    4100:	8c 83       	std	Y+4, r24	; 0x04
    4102:	7f 83       	std	Y+7, r23	; 0x07
    4104:	6e 83       	std	Y+6, r22	; 0x06
    4106:	28 87       	std	Y+8, r18	; 0x08
    4108:	39 87       	std	Y+9, r19	; 0x09
    410a:	4a 87       	std	Y+10, r20	; 0x0a
    410c:	5b 87       	std	Y+11, r21	; 0x0b
    410e:	1d 87       	std	Y+13, r17	; 0x0d
    4110:	0c 87       	std	Y+12, r16	; 0x0c
    4112:	ee 86       	std	Y+14, r14	; 0x0e
    4114:	d8 8a       	std	Y+16, r13	; 0x10
    4116:	cf 86       	std	Y+15, r12	; 0x0f
    4118:	ba 8a       	std	Y+18, r11	; 0x12
    411a:	a9 8a       	std	Y+17, r10	; 0x11
    411c:	9c 8a       	std	Y+20, r9	; 0x14
    411e:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4120:	89 89       	ldd	r24, Y+17	; 0x11
    4122:	9a 89       	ldd	r25, Y+18	; 0x12
    4124:	fc 01       	movw	r30, r24
    4126:	27 89       	ldd	r18, Z+23	; 0x17
    4128:	30 8d       	ldd	r19, Z+24	; 0x18
    412a:	88 85       	ldd	r24, Y+8	; 0x08
    412c:	99 85       	ldd	r25, Y+9	; 0x09
    412e:	01 97       	sbiw	r24, 0x01	; 1
    4130:	82 0f       	add	r24, r18
    4132:	93 1f       	adc	r25, r19
    4134:	9b 83       	std	Y+3, r25	; 0x03
    4136:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4138:	8e 81       	ldd	r24, Y+6	; 0x06
    413a:	9f 81       	ldd	r25, Y+7	; 0x07
    413c:	89 2b       	or	r24, r25
    413e:	69 f1       	breq	.+90     	; 0x419a <prvInitialiseNewTask+0xc2>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4140:	19 82       	std	Y+1, r1	; 0x01
    4142:	21 c0       	rjmp	.+66     	; 0x4186 <prvInitialiseNewTask+0xae>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4144:	89 81       	ldd	r24, Y+1	; 0x01
    4146:	88 2f       	mov	r24, r24
    4148:	90 e0       	ldi	r25, 0x00	; 0
    414a:	29 81       	ldd	r18, Y+1	; 0x01
    414c:	22 2f       	mov	r18, r18
    414e:	30 e0       	ldi	r19, 0x00	; 0
    4150:	4e 81       	ldd	r20, Y+6	; 0x06
    4152:	5f 81       	ldd	r21, Y+7	; 0x07
    4154:	24 0f       	add	r18, r20
    4156:	35 1f       	adc	r19, r21
    4158:	f9 01       	movw	r30, r18
    415a:	40 81       	ld	r20, Z
    415c:	29 89       	ldd	r18, Y+17	; 0x11
    415e:	3a 89       	ldd	r19, Y+18	; 0x12
    4160:	82 0f       	add	r24, r18
    4162:	93 1f       	adc	r25, r19
    4164:	49 96       	adiw	r24, 0x19	; 25
    4166:	fc 01       	movw	r30, r24
    4168:	40 83       	st	Z, r20

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    416a:	89 81       	ldd	r24, Y+1	; 0x01
    416c:	88 2f       	mov	r24, r24
    416e:	90 e0       	ldi	r25, 0x00	; 0
    4170:	2e 81       	ldd	r18, Y+6	; 0x06
    4172:	3f 81       	ldd	r19, Y+7	; 0x07
    4174:	82 0f       	add	r24, r18
    4176:	93 1f       	adc	r25, r19
    4178:	fc 01       	movw	r30, r24
    417a:	80 81       	ld	r24, Z
    417c:	88 23       	and	r24, r24
    417e:	39 f0       	breq	.+14     	; 0x418e <prvInitialiseNewTask+0xb6>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4180:	89 81       	ldd	r24, Y+1	; 0x01
    4182:	8f 5f       	subi	r24, 0xFF	; 255
    4184:	89 83       	std	Y+1, r24	; 0x01
    4186:	89 81       	ldd	r24, Y+1	; 0x01
    4188:	88 30       	cpi	r24, 0x08	; 8
    418a:	e0 f2       	brcs	.-72     	; 0x4144 <prvInitialiseNewTask+0x6c>
    418c:	01 c0       	rjmp	.+2      	; 0x4190 <prvInitialiseNewTask+0xb8>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
    418e:	00 00       	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4190:	89 89       	ldd	r24, Y+17	; 0x11
    4192:	9a 89       	ldd	r25, Y+18	; 0x12
    4194:	fc 01       	movw	r30, r24
    4196:	10 a2       	std	Z+32, r1	; 0x20
    4198:	04 c0       	rjmp	.+8      	; 0x41a2 <prvInitialiseNewTask+0xca>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    419a:	89 89       	ldd	r24, Y+17	; 0x11
    419c:	9a 89       	ldd	r25, Y+18	; 0x12
    419e:	fc 01       	movw	r30, r24
    41a0:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    41a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    41a4:	85 30       	cpi	r24, 0x05	; 5
    41a6:	10 f0       	brcs	.+4      	; 0x41ac <prvInitialiseNewTask+0xd4>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    41a8:	84 e0       	ldi	r24, 0x04	; 4
    41aa:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    41ac:	89 89       	ldd	r24, Y+17	; 0x11
    41ae:	9a 89       	ldd	r25, Y+18	; 0x12
    41b0:	2e 85       	ldd	r18, Y+14	; 0x0e
    41b2:	fc 01       	movw	r30, r24
    41b4:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    41b6:	89 89       	ldd	r24, Y+17	; 0x11
    41b8:	9a 89       	ldd	r25, Y+18	; 0x12
    41ba:	2e 85       	ldd	r18, Y+14	; 0x0e
    41bc:	fc 01       	movw	r30, r24
    41be:	21 a3       	std	Z+33, r18	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    41c0:	89 89       	ldd	r24, Y+17	; 0x11
    41c2:	9a 89       	ldd	r25, Y+18	; 0x12
    41c4:	fc 01       	movw	r30, r24
    41c6:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    41c8:	89 89       	ldd	r24, Y+17	; 0x11
    41ca:	9a 89       	ldd	r25, Y+18	; 0x12
    41cc:	02 96       	adiw	r24, 0x02	; 2
    41ce:	0e 94 16 13 	call	0x262c	; 0x262c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    41d2:	89 89       	ldd	r24, Y+17	; 0x11
    41d4:	9a 89       	ldd	r25, Y+18	; 0x12
    41d6:	0c 96       	adiw	r24, 0x0c	; 12
    41d8:	0e 94 16 13 	call	0x262c	; 0x262c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    41dc:	89 89       	ldd	r24, Y+17	; 0x11
    41de:	9a 89       	ldd	r25, Y+18	; 0x12
    41e0:	29 89       	ldd	r18, Y+17	; 0x11
    41e2:	3a 89       	ldd	r19, Y+18	; 0x12
    41e4:	fc 01       	movw	r30, r24
    41e6:	31 87       	std	Z+9, r19	; 0x09
    41e8:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    41ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    41ec:	88 2f       	mov	r24, r24
    41ee:	90 e0       	ldi	r25, 0x00	; 0
    41f0:	25 e0       	ldi	r18, 0x05	; 5
    41f2:	30 e0       	ldi	r19, 0x00	; 0
    41f4:	28 1b       	sub	r18, r24
    41f6:	39 0b       	sbc	r19, r25
    41f8:	89 89       	ldd	r24, Y+17	; 0x11
    41fa:	9a 89       	ldd	r25, Y+18	; 0x12
    41fc:	fc 01       	movw	r30, r24
    41fe:	35 87       	std	Z+13, r19	; 0x0d
    4200:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4202:	89 89       	ldd	r24, Y+17	; 0x11
    4204:	9a 89       	ldd	r25, Y+18	; 0x12
    4206:	29 89       	ldd	r18, Y+17	; 0x11
    4208:	3a 89       	ldd	r19, Y+18	; 0x12
    420a:	fc 01       	movw	r30, r24
    420c:	33 8b       	std	Z+19, r19	; 0x13
    420e:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4210:	89 89       	ldd	r24, Y+17	; 0x11
    4212:	9a 89       	ldd	r25, Y+18	; 0x12
    4214:	fc 01       	movw	r30, r24
    4216:	13 a2       	std	Z+35, r1	; 0x23
    4218:	14 a2       	std	Z+36, r1	; 0x24
    421a:	15 a2       	std	Z+37, r1	; 0x25
    421c:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    421e:	89 89       	ldd	r24, Y+17	; 0x11
    4220:	9a 89       	ldd	r25, Y+18	; 0x12
    4222:	fc 01       	movw	r30, r24
    4224:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4226:	4c 85       	ldd	r20, Y+12	; 0x0c
    4228:	5d 85       	ldd	r21, Y+13	; 0x0d
    422a:	2c 81       	ldd	r18, Y+4	; 0x04
    422c:	3d 81       	ldd	r19, Y+5	; 0x05
    422e:	8a 81       	ldd	r24, Y+2	; 0x02
    4230:	9b 81       	ldd	r25, Y+3	; 0x03
    4232:	b9 01       	movw	r22, r18
    4234:	0e 94 98 14 	call	0x2930	; 0x2930 <pxPortInitialiseStack>
    4238:	9c 01       	movw	r18, r24
    423a:	89 89       	ldd	r24, Y+17	; 0x11
    423c:	9a 89       	ldd	r25, Y+18	; 0x12
    423e:	fc 01       	movw	r30, r24
    4240:	31 83       	std	Z+1, r19	; 0x01
    4242:	20 83       	st	Z, r18
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4244:	8f 85       	ldd	r24, Y+15	; 0x0f
    4246:	98 89       	ldd	r25, Y+16	; 0x10
    4248:	89 2b       	or	r24, r25
    424a:	39 f0       	breq	.+14     	; 0x425a <prvInitialiseNewTask+0x182>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    424c:	8f 85       	ldd	r24, Y+15	; 0x0f
    424e:	98 89       	ldd	r25, Y+16	; 0x10
    4250:	29 89       	ldd	r18, Y+17	; 0x11
    4252:	3a 89       	ldd	r19, Y+18	; 0x12
    4254:	fc 01       	movw	r30, r24
    4256:	31 83       	std	Z+1, r19	; 0x01
    4258:	20 83       	st	Z, r18
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    425a:	00 00       	nop
    425c:	64 96       	adiw	r28, 0x14	; 20
    425e:	0f b6       	in	r0, 0x3f	; 63
    4260:	f8 94       	cli
    4262:	de bf       	out	0x3e, r29	; 62
    4264:	0f be       	out	0x3f, r0	; 63
    4266:	cd bf       	out	0x3d, r28	; 61
    4268:	df 91       	pop	r29
    426a:	cf 91       	pop	r28
    426c:	1f 91       	pop	r17
    426e:	0f 91       	pop	r16
    4270:	ef 90       	pop	r14
    4272:	df 90       	pop	r13
    4274:	cf 90       	pop	r12
    4276:	bf 90       	pop	r11
    4278:	af 90       	pop	r10
    427a:	9f 90       	pop	r9
    427c:	8f 90       	pop	r8
    427e:	08 95       	ret

00004280 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4280:	cf 93       	push	r28
    4282:	df 93       	push	r29
    4284:	00 d0       	rcall	.+0      	; 0x4286 <prvAddNewTaskToReadyList+0x6>
    4286:	cd b7       	in	r28, 0x3d	; 61
    4288:	de b7       	in	r29, 0x3e	; 62
    428a:	9a 83       	std	Y+2, r25	; 0x02
    428c:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    428e:	0f b6       	in	r0, 0x3f	; 63
    4290:	f8 94       	cli
    4292:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4294:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxCurrentNumberOfTasks>
    4298:	8f 5f       	subi	r24, 0xFF	; 255
    429a:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    429e:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    42a2:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    42a6:	89 2b       	or	r24, r25
    42a8:	69 f4       	brne	.+26     	; 0x42c4 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    42aa:	89 81       	ldd	r24, Y+1	; 0x01
    42ac:	9a 81       	ldd	r25, Y+2	; 0x02
    42ae:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <pxCurrentTCB+0x1>
    42b2:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    42b6:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxCurrentNumberOfTasks>
    42ba:	81 30       	cpi	r24, 0x01	; 1
    42bc:	c9 f4       	brne	.+50     	; 0x42f0 <prvAddNewTaskToReadyList+0x70>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    42be:	0e 94 bc 28 	call	0x5178	; 0x5178 <prvInitialiseTaskLists>
    42c2:	16 c0       	rjmp	.+44     	; 0x42f0 <prvAddNewTaskToReadyList+0x70>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    42c4:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <xSchedulerRunning>
    42c8:	88 23       	and	r24, r24
    42ca:	91 f4       	brne	.+36     	; 0x42f0 <prvAddNewTaskToReadyList+0x70>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    42cc:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    42d0:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    42d4:	fc 01       	movw	r30, r24
    42d6:	26 89       	ldd	r18, Z+22	; 0x16
    42d8:	89 81       	ldd	r24, Y+1	; 0x01
    42da:	9a 81       	ldd	r25, Y+2	; 0x02
    42dc:	fc 01       	movw	r30, r24
    42de:	86 89       	ldd	r24, Z+22	; 0x16
    42e0:	82 17       	cp	r24, r18
    42e2:	30 f0       	brcs	.+12     	; 0x42f0 <prvAddNewTaskToReadyList+0x70>
				{
					pxCurrentTCB = pxNewTCB;
    42e4:	89 81       	ldd	r24, Y+1	; 0x01
    42e6:	9a 81       	ldd	r25, Y+2	; 0x02
    42e8:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <pxCurrentTCB+0x1>
    42ec:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    42f0:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxTaskNumber>
    42f4:	8f 5f       	subi	r24, 0xFF	; 255
    42f6:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    42fa:	89 81       	ldd	r24, Y+1	; 0x01
    42fc:	9a 81       	ldd	r25, Y+2	; 0x02
    42fe:	fc 01       	movw	r30, r24
    4300:	96 89       	ldd	r25, Z+22	; 0x16
    4302:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    4306:	89 17       	cp	r24, r25
    4308:	30 f4       	brcc	.+12     	; 0x4316 <prvAddNewTaskToReadyList+0x96>
    430a:	89 81       	ldd	r24, Y+1	; 0x01
    430c:	9a 81       	ldd	r25, Y+2	; 0x02
    430e:	fc 01       	movw	r30, r24
    4310:	86 89       	ldd	r24, Z+22	; 0x16
    4312:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    4316:	89 81       	ldd	r24, Y+1	; 0x01
    4318:	9a 81       	ldd	r25, Y+2	; 0x02
    431a:	ac 01       	movw	r20, r24
    431c:	4e 5f       	subi	r20, 0xFE	; 254
    431e:	5f 4f       	sbci	r21, 0xFF	; 255
    4320:	89 81       	ldd	r24, Y+1	; 0x01
    4322:	9a 81       	ldd	r25, Y+2	; 0x02
    4324:	fc 01       	movw	r30, r24
    4326:	86 89       	ldd	r24, Z+22	; 0x16
    4328:	28 2f       	mov	r18, r24
    432a:	30 e0       	ldi	r19, 0x00	; 0
    432c:	c9 01       	movw	r24, r18
    432e:	88 0f       	add	r24, r24
    4330:	99 1f       	adc	r25, r25
    4332:	88 0f       	add	r24, r24
    4334:	99 1f       	adc	r25, r25
    4336:	88 0f       	add	r24, r24
    4338:	99 1f       	adc	r25, r25
    433a:	82 0f       	add	r24, r18
    433c:	93 1f       	adc	r25, r19
    433e:	81 56       	subi	r24, 0x61	; 97
    4340:	99 4f       	sbci	r25, 0xF9	; 249
    4342:	ba 01       	movw	r22, r20
    4344:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4348:	0f 90       	pop	r0
    434a:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    434c:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <xSchedulerRunning>
    4350:	88 23       	and	r24, r24
    4352:	71 f0       	breq	.+28     	; 0x4370 <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4354:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4358:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    435c:	fc 01       	movw	r30, r24
    435e:	26 89       	ldd	r18, Z+22	; 0x16
    4360:	89 81       	ldd	r24, Y+1	; 0x01
    4362:	9a 81       	ldd	r25, Y+2	; 0x02
    4364:	fc 01       	movw	r30, r24
    4366:	86 89       	ldd	r24, Z+22	; 0x16
    4368:	28 17       	cp	r18, r24
    436a:	10 f4       	brcc	.+4      	; 0x4370 <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    436c:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4370:	00 00       	nop
    4372:	0f 90       	pop	r0
    4374:	0f 90       	pop	r0
    4376:	df 91       	pop	r29
    4378:	cf 91       	pop	r28
    437a:	08 95       	ret

0000437c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    437c:	cf 93       	push	r28
    437e:	df 93       	push	r29
    4380:	00 d0       	rcall	.+0      	; 0x4382 <vTaskDelete+0x6>
    4382:	00 d0       	rcall	.+0      	; 0x4384 <vTaskDelete+0x8>
    4384:	cd b7       	in	r28, 0x3d	; 61
    4386:	de b7       	in	r29, 0x3e	; 62
    4388:	9c 83       	std	Y+4, r25	; 0x04
    438a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    438c:	0f b6       	in	r0, 0x3f	; 63
    438e:	f8 94       	cli
    4390:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4392:	8b 81       	ldd	r24, Y+3	; 0x03
    4394:	9c 81       	ldd	r25, Y+4	; 0x04
    4396:	89 2b       	or	r24, r25
    4398:	29 f4       	brne	.+10     	; 0x43a4 <vTaskDelete+0x28>
    439a:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    439e:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    43a2:	02 c0       	rjmp	.+4      	; 0x43a8 <vTaskDelete+0x2c>
    43a4:	8b 81       	ldd	r24, Y+3	; 0x03
    43a6:	9c 81       	ldd	r25, Y+4	; 0x04
    43a8:	9a 83       	std	Y+2, r25	; 0x02
    43aa:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    43ac:	89 81       	ldd	r24, Y+1	; 0x01
    43ae:	9a 81       	ldd	r25, Y+2	; 0x02
    43b0:	02 96       	adiw	r24, 0x02	; 2
    43b2:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    43b6:	89 81       	ldd	r24, Y+1	; 0x01
    43b8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ba:	fc 01       	movw	r30, r24
    43bc:	84 89       	ldd	r24, Z+20	; 0x14
    43be:	95 89       	ldd	r25, Z+21	; 0x15
    43c0:	89 2b       	or	r24, r25
    43c2:	29 f0       	breq	.+10     	; 0x43ce <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    43c4:	89 81       	ldd	r24, Y+1	; 0x01
    43c6:	9a 81       	ldd	r25, Y+2	; 0x02
    43c8:	0c 96       	adiw	r24, 0x0c	; 12
    43ca:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    43ce:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxTaskNumber>
    43d2:	8f 5f       	subi	r24, 0xFF	; 255
    43d4:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    43d8:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    43dc:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    43e0:	29 81       	ldd	r18, Y+1	; 0x01
    43e2:	3a 81       	ldd	r19, Y+2	; 0x02
    43e4:	28 17       	cp	r18, r24
    43e6:	39 07       	cpc	r19, r25
    43e8:	71 f4       	brne	.+28     	; 0x4406 <vTaskDelete+0x8a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    43ea:	89 81       	ldd	r24, Y+1	; 0x01
    43ec:	9a 81       	ldd	r25, Y+2	; 0x02
    43ee:	02 96       	adiw	r24, 0x02	; 2
    43f0:	bc 01       	movw	r22, r24
    43f2:	8b ee       	ldi	r24, 0xEB	; 235
    43f4:	96 e0       	ldi	r25, 0x06	; 6
    43f6:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    43fa:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <uxDeletedTasksWaitingCleanUp>
    43fe:	8f 5f       	subi	r24, 0xFF	; 255
    4400:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <uxDeletedTasksWaitingCleanUp>
    4404:	0b c0       	rjmp	.+22     	; 0x441c <vTaskDelete+0xa0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4406:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxCurrentNumberOfTasks>
    440a:	81 50       	subi	r24, 0x01	; 1
    440c:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <uxCurrentNumberOfTasks>
				prvDeleteTCB( pxTCB );
    4410:	89 81       	ldd	r24, Y+1	; 0x01
    4412:	9a 81       	ldd	r25, Y+2	; 0x02
    4414:	0e 94 2f 29 	call	0x525e	; 0x525e <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4418:	0e 94 47 29 	call	0x528e	; 0x528e <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    441c:	0f 90       	pop	r0
    441e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4420:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <xSchedulerRunning>
    4424:	88 23       	and	r24, r24
    4426:	59 f0       	breq	.+22     	; 0x443e <vTaskDelete+0xc2>
		{
			if( pxTCB == pxCurrentTCB )
    4428:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    442c:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4430:	29 81       	ldd	r18, Y+1	; 0x01
    4432:	3a 81       	ldd	r19, Y+2	; 0x02
    4434:	28 17       	cp	r18, r24
    4436:	39 07       	cpc	r19, r25
    4438:	11 f4       	brne	.+4      	; 0x443e <vTaskDelete+0xc2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    443a:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    443e:	00 00       	nop
    4440:	0f 90       	pop	r0
    4442:	0f 90       	pop	r0
    4444:	0f 90       	pop	r0
    4446:	0f 90       	pop	r0
    4448:	df 91       	pop	r29
    444a:	cf 91       	pop	r28
    444c:	08 95       	ret

0000444e <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    444e:	cf 93       	push	r28
    4450:	df 93       	push	r29
    4452:	cd b7       	in	r28, 0x3d	; 61
    4454:	de b7       	in	r29, 0x3e	; 62
    4456:	2a 97       	sbiw	r28, 0x0a	; 10
    4458:	0f b6       	in	r0, 0x3f	; 63
    445a:	f8 94       	cli
    445c:	de bf       	out	0x3e, r29	; 62
    445e:	0f be       	out	0x3f, r0	; 63
    4460:	cd bf       	out	0x3d, r28	; 61
    4462:	98 87       	std	Y+8, r25	; 0x08
    4464:	8f 83       	std	Y+7, r24	; 0x07
    4466:	7a 87       	std	Y+10, r23	; 0x0a
    4468:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    446a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    446c:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    4470:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xTickCount>
    4474:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xTickCount+0x1>
    4478:	9b 83       	std	Y+3, r25	; 0x03
    447a:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    447c:	8f 81       	ldd	r24, Y+7	; 0x07
    447e:	98 85       	ldd	r25, Y+8	; 0x08
    4480:	fc 01       	movw	r30, r24
    4482:	20 81       	ld	r18, Z
    4484:	31 81       	ldd	r19, Z+1	; 0x01
    4486:	89 85       	ldd	r24, Y+9	; 0x09
    4488:	9a 85       	ldd	r25, Y+10	; 0x0a
    448a:	82 0f       	add	r24, r18
    448c:	93 1f       	adc	r25, r19
    448e:	9d 83       	std	Y+5, r25	; 0x05
    4490:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    4492:	8f 81       	ldd	r24, Y+7	; 0x07
    4494:	98 85       	ldd	r25, Y+8	; 0x08
    4496:	fc 01       	movw	r30, r24
    4498:	20 81       	ld	r18, Z
    449a:	31 81       	ldd	r19, Z+1	; 0x01
    449c:	8a 81       	ldd	r24, Y+2	; 0x02
    449e:	9b 81       	ldd	r25, Y+3	; 0x03
    44a0:	82 17       	cp	r24, r18
    44a2:	93 07       	cpc	r25, r19
    44a4:	a0 f4       	brcc	.+40     	; 0x44ce <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    44a6:	8f 81       	ldd	r24, Y+7	; 0x07
    44a8:	98 85       	ldd	r25, Y+8	; 0x08
    44aa:	fc 01       	movw	r30, r24
    44ac:	20 81       	ld	r18, Z
    44ae:	31 81       	ldd	r19, Z+1	; 0x01
    44b0:	8c 81       	ldd	r24, Y+4	; 0x04
    44b2:	9d 81       	ldd	r25, Y+5	; 0x05
    44b4:	82 17       	cp	r24, r18
    44b6:	93 07       	cpc	r25, r19
    44b8:	e8 f4       	brcc	.+58     	; 0x44f4 <vTaskDelayUntil+0xa6>
    44ba:	2c 81       	ldd	r18, Y+4	; 0x04
    44bc:	3d 81       	ldd	r19, Y+5	; 0x05
    44be:	8a 81       	ldd	r24, Y+2	; 0x02
    44c0:	9b 81       	ldd	r25, Y+3	; 0x03
    44c2:	82 17       	cp	r24, r18
    44c4:	93 07       	cpc	r25, r19
    44c6:	b0 f4       	brcc	.+44     	; 0x44f4 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    44c8:	81 e0       	ldi	r24, 0x01	; 1
    44ca:	89 83       	std	Y+1, r24	; 0x01
    44cc:	13 c0       	rjmp	.+38     	; 0x44f4 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    44ce:	8f 81       	ldd	r24, Y+7	; 0x07
    44d0:	98 85       	ldd	r25, Y+8	; 0x08
    44d2:	fc 01       	movw	r30, r24
    44d4:	20 81       	ld	r18, Z
    44d6:	31 81       	ldd	r19, Z+1	; 0x01
    44d8:	8c 81       	ldd	r24, Y+4	; 0x04
    44da:	9d 81       	ldd	r25, Y+5	; 0x05
    44dc:	82 17       	cp	r24, r18
    44de:	93 07       	cpc	r25, r19
    44e0:	38 f0       	brcs	.+14     	; 0x44f0 <vTaskDelayUntil+0xa2>
    44e2:	2c 81       	ldd	r18, Y+4	; 0x04
    44e4:	3d 81       	ldd	r19, Y+5	; 0x05
    44e6:	8a 81       	ldd	r24, Y+2	; 0x02
    44e8:	9b 81       	ldd	r25, Y+3	; 0x03
    44ea:	82 17       	cp	r24, r18
    44ec:	93 07       	cpc	r25, r19
    44ee:	10 f4       	brcc	.+4      	; 0x44f4 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    44f0:	81 e0       	ldi	r24, 0x01	; 1
    44f2:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    44f4:	8f 81       	ldd	r24, Y+7	; 0x07
    44f6:	98 85       	ldd	r25, Y+8	; 0x08
    44f8:	2c 81       	ldd	r18, Y+4	; 0x04
    44fa:	3d 81       	ldd	r19, Y+5	; 0x05
    44fc:	fc 01       	movw	r30, r24
    44fe:	31 83       	std	Z+1, r19	; 0x01
    4500:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    4502:	89 81       	ldd	r24, Y+1	; 0x01
    4504:	88 23       	and	r24, r24
    4506:	59 f0       	breq	.+22     	; 0x451e <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    4508:	2c 81       	ldd	r18, Y+4	; 0x04
    450a:	3d 81       	ldd	r19, Y+5	; 0x05
    450c:	8a 81       	ldd	r24, Y+2	; 0x02
    450e:	9b 81       	ldd	r25, Y+3	; 0x03
    4510:	a9 01       	movw	r20, r18
    4512:	48 1b       	sub	r20, r24
    4514:	59 0b       	sbc	r21, r25
    4516:	ca 01       	movw	r24, r20
    4518:	60 e0       	ldi	r22, 0x00	; 0
    451a:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    451e:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    4522:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4524:	8e 81       	ldd	r24, Y+6	; 0x06
    4526:	88 23       	and	r24, r24
    4528:	11 f4       	brne	.+4      	; 0x452e <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    452a:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    452e:	00 00       	nop
    4530:	2a 96       	adiw	r28, 0x0a	; 10
    4532:	0f b6       	in	r0, 0x3f	; 63
    4534:	f8 94       	cli
    4536:	de bf       	out	0x3e, r29	; 62
    4538:	0f be       	out	0x3f, r0	; 63
    453a:	cd bf       	out	0x3d, r28	; 61
    453c:	df 91       	pop	r29
    453e:	cf 91       	pop	r28
    4540:	08 95       	ret

00004542 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4542:	cf 93       	push	r28
    4544:	df 93       	push	r29
    4546:	00 d0       	rcall	.+0      	; 0x4548 <vTaskDelay+0x6>
    4548:	1f 92       	push	r1
    454a:	cd b7       	in	r28, 0x3d	; 61
    454c:	de b7       	in	r29, 0x3e	; 62
    454e:	9b 83       	std	Y+3, r25	; 0x03
    4550:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4552:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4554:	8a 81       	ldd	r24, Y+2	; 0x02
    4556:	9b 81       	ldd	r25, Y+3	; 0x03
    4558:	89 2b       	or	r24, r25
    455a:	51 f0       	breq	.+20     	; 0x4570 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    455c:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4560:	8a 81       	ldd	r24, Y+2	; 0x02
    4562:	9b 81       	ldd	r25, Y+3	; 0x03
    4564:	60 e0       	ldi	r22, 0x00	; 0
    4566:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    456a:	0e 94 7f 24 	call	0x48fe	; 0x48fe <xTaskResumeAll>
    456e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4570:	89 81       	ldd	r24, Y+1	; 0x01
    4572:	88 23       	and	r24, r24
    4574:	11 f4       	brne	.+4      	; 0x457a <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    4576:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    457a:	00 00       	nop
    457c:	0f 90       	pop	r0
    457e:	0f 90       	pop	r0
    4580:	0f 90       	pop	r0
    4582:	df 91       	pop	r29
    4584:	cf 91       	pop	r28
    4586:	08 95       	ret

00004588 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    4588:	cf 93       	push	r28
    458a:	df 93       	push	r29
    458c:	00 d0       	rcall	.+0      	; 0x458e <vTaskSuspend+0x6>
    458e:	00 d0       	rcall	.+0      	; 0x4590 <vTaskSuspend+0x8>
    4590:	cd b7       	in	r28, 0x3d	; 61
    4592:	de b7       	in	r29, 0x3e	; 62
    4594:	9c 83       	std	Y+4, r25	; 0x04
    4596:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4598:	0f b6       	in	r0, 0x3f	; 63
    459a:	f8 94       	cli
    459c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    459e:	8b 81       	ldd	r24, Y+3	; 0x03
    45a0:	9c 81       	ldd	r25, Y+4	; 0x04
    45a2:	89 2b       	or	r24, r25
    45a4:	29 f4       	brne	.+10     	; 0x45b0 <vTaskSuspend+0x28>
    45a6:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    45aa:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    45ae:	02 c0       	rjmp	.+4      	; 0x45b4 <vTaskSuspend+0x2c>
    45b0:	8b 81       	ldd	r24, Y+3	; 0x03
    45b2:	9c 81       	ldd	r25, Y+4	; 0x04
    45b4:	9a 83       	std	Y+2, r25	; 0x02
    45b6:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    45b8:	89 81       	ldd	r24, Y+1	; 0x01
    45ba:	9a 81       	ldd	r25, Y+2	; 0x02
    45bc:	02 96       	adiw	r24, 0x02	; 2
    45be:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    45c2:	89 81       	ldd	r24, Y+1	; 0x01
    45c4:	9a 81       	ldd	r25, Y+2	; 0x02
    45c6:	fc 01       	movw	r30, r24
    45c8:	84 89       	ldd	r24, Z+20	; 0x14
    45ca:	95 89       	ldd	r25, Z+21	; 0x15
    45cc:	89 2b       	or	r24, r25
    45ce:	29 f0       	breq	.+10     	; 0x45da <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    45d0:	89 81       	ldd	r24, Y+1	; 0x01
    45d2:	9a 81       	ldd	r25, Y+2	; 0x02
    45d4:	0c 96       	adiw	r24, 0x0c	; 12
    45d6:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    45da:	89 81       	ldd	r24, Y+1	; 0x01
    45dc:	9a 81       	ldd	r25, Y+2	; 0x02
    45de:	02 96       	adiw	r24, 0x02	; 2
    45e0:	bc 01       	movw	r22, r24
    45e2:	85 ef       	ldi	r24, 0xF5	; 245
    45e4:	96 e0       	ldi	r25, 0x06	; 6
    45e6:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    45ea:	89 81       	ldd	r24, Y+1	; 0x01
    45ec:	9a 81       	ldd	r25, Y+2	; 0x02
    45ee:	fc 01       	movw	r30, r24
    45f0:	87 a1       	ldd	r24, Z+39	; 0x27
    45f2:	81 30       	cpi	r24, 0x01	; 1
    45f4:	21 f4       	brne	.+8      	; 0x45fe <vTaskSuspend+0x76>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    45f6:	89 81       	ldd	r24, Y+1	; 0x01
    45f8:	9a 81       	ldd	r25, Y+2	; 0x02
    45fa:	fc 01       	movw	r30, r24
    45fc:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    45fe:	0f 90       	pop	r0
    4600:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    4602:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <xSchedulerRunning>
    4606:	88 23       	and	r24, r24
    4608:	39 f0       	breq	.+14     	; 0x4618 <vTaskSuspend+0x90>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    460a:	0f b6       	in	r0, 0x3f	; 63
    460c:	f8 94       	cli
    460e:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    4610:	0e 94 47 29 	call	0x528e	; 0x528e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    4614:	0f 90       	pop	r0
    4616:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    4618:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    461c:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4620:	29 81       	ldd	r18, Y+1	; 0x01
    4622:	3a 81       	ldd	r19, Y+2	; 0x02
    4624:	28 17       	cp	r18, r24
    4626:	39 07       	cpc	r19, r25
    4628:	a1 f4       	brne	.+40     	; 0x4652 <vTaskSuspend+0xca>
		{
			if( xSchedulerRunning != pdFALSE )
    462a:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <xSchedulerRunning>
    462e:	88 23       	and	r24, r24
    4630:	19 f0       	breq	.+6      	; 0x4638 <vTaskSuspend+0xb0>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4632:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4636:	0d c0       	rjmp	.+26     	; 0x4652 <vTaskSuspend+0xca>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    4638:	90 91 f5 06 	lds	r25, 0x06F5	; 0x8006f5 <xSuspendedTaskList>
    463c:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxCurrentNumberOfTasks>
    4640:	98 17       	cp	r25, r24
    4642:	29 f4       	brne	.+10     	; 0x464e <vTaskSuspend+0xc6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    4644:	10 92 9e 06 	sts	0x069E, r1	; 0x80069e <pxCurrentTCB+0x1>
    4648:	10 92 9d 06 	sts	0x069D, r1	; 0x80069d <pxCurrentTCB>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    464c:	02 c0       	rjmp	.+4      	; 0x4652 <vTaskSuspend+0xca>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
    464e:	0e 94 57 26 	call	0x4cae	; 0x4cae <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4652:	00 00       	nop
    4654:	0f 90       	pop	r0
    4656:	0f 90       	pop	r0
    4658:	0f 90       	pop	r0
    465a:	0f 90       	pop	r0
    465c:	df 91       	pop	r29
    465e:	cf 91       	pop	r28
    4660:	08 95       	ret

00004662 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4662:	cf 93       	push	r28
    4664:	df 93       	push	r29
    4666:	00 d0       	rcall	.+0      	; 0x4668 <prvTaskIsTaskSuspended+0x6>
    4668:	00 d0       	rcall	.+0      	; 0x466a <prvTaskIsTaskSuspended+0x8>
    466a:	1f 92       	push	r1
    466c:	cd b7       	in	r28, 0x3d	; 61
    466e:	de b7       	in	r29, 0x3e	; 62
    4670:	9d 83       	std	Y+5, r25	; 0x05
    4672:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    4674:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = xTask;
    4676:	8c 81       	ldd	r24, Y+4	; 0x04
    4678:	9d 81       	ldd	r25, Y+5	; 0x05
    467a:	9b 83       	std	Y+3, r25	; 0x03
    467c:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    467e:	8a 81       	ldd	r24, Y+2	; 0x02
    4680:	9b 81       	ldd	r25, Y+3	; 0x03
    4682:	fc 01       	movw	r30, r24
    4684:	82 85       	ldd	r24, Z+10	; 0x0a
    4686:	93 85       	ldd	r25, Z+11	; 0x0b
    4688:	85 5f       	subi	r24, 0xF5	; 245
    468a:	96 40       	sbci	r25, 0x06	; 6
    468c:	89 f4       	brne	.+34     	; 0x46b0 <prvTaskIsTaskSuspended+0x4e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    468e:	8a 81       	ldd	r24, Y+2	; 0x02
    4690:	9b 81       	ldd	r25, Y+3	; 0x03
    4692:	fc 01       	movw	r30, r24
    4694:	84 89       	ldd	r24, Z+20	; 0x14
    4696:	95 89       	ldd	r25, Z+21	; 0x15
    4698:	82 5e       	subi	r24, 0xE2	; 226
    469a:	96 40       	sbci	r25, 0x06	; 6
    469c:	49 f0       	breq	.+18     	; 0x46b0 <prvTaskIsTaskSuspended+0x4e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    469e:	8a 81       	ldd	r24, Y+2	; 0x02
    46a0:	9b 81       	ldd	r25, Y+3	; 0x03
    46a2:	fc 01       	movw	r30, r24
    46a4:	84 89       	ldd	r24, Z+20	; 0x14
    46a6:	95 89       	ldd	r25, Z+21	; 0x15
    46a8:	89 2b       	or	r24, r25
    46aa:	11 f4       	brne	.+4      	; 0x46b0 <prvTaskIsTaskSuspended+0x4e>
				{
					xReturn = pdTRUE;
    46ac:	81 e0       	ldi	r24, 0x01	; 1
    46ae:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    46b0:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    46b2:	0f 90       	pop	r0
    46b4:	0f 90       	pop	r0
    46b6:	0f 90       	pop	r0
    46b8:	0f 90       	pop	r0
    46ba:	0f 90       	pop	r0
    46bc:	df 91       	pop	r29
    46be:	cf 91       	pop	r28
    46c0:	08 95       	ret

000046c2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    46c2:	cf 93       	push	r28
    46c4:	df 93       	push	r29
    46c6:	00 d0       	rcall	.+0      	; 0x46c8 <vTaskResume+0x6>
    46c8:	00 d0       	rcall	.+0      	; 0x46ca <vTaskResume+0x8>
    46ca:	cd b7       	in	r28, 0x3d	; 61
    46cc:	de b7       	in	r29, 0x3e	; 62
    46ce:	9c 83       	std	Y+4, r25	; 0x04
    46d0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    46d2:	8b 81       	ldd	r24, Y+3	; 0x03
    46d4:	9c 81       	ldd	r25, Y+4	; 0x04
    46d6:	9a 83       	std	Y+2, r25	; 0x02
    46d8:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    46da:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    46de:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    46e2:	29 81       	ldd	r18, Y+1	; 0x01
    46e4:	3a 81       	ldd	r19, Y+2	; 0x02
    46e6:	28 17       	cp	r18, r24
    46e8:	39 07       	cpc	r19, r25
    46ea:	09 f4       	brne	.+2      	; 0x46ee <vTaskResume+0x2c>
    46ec:	4a c0       	rjmp	.+148    	; 0x4782 <vTaskResume+0xc0>
    46ee:	89 81       	ldd	r24, Y+1	; 0x01
    46f0:	9a 81       	ldd	r25, Y+2	; 0x02
    46f2:	89 2b       	or	r24, r25
    46f4:	09 f4       	brne	.+2      	; 0x46f8 <vTaskResume+0x36>
    46f6:	45 c0       	rjmp	.+138    	; 0x4782 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    46f8:	0f b6       	in	r0, 0x3f	; 63
    46fa:	f8 94       	cli
    46fc:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    46fe:	89 81       	ldd	r24, Y+1	; 0x01
    4700:	9a 81       	ldd	r25, Y+2	; 0x02
    4702:	0e 94 31 23 	call	0x4662	; 0x4662 <prvTaskIsTaskSuspended>
    4706:	88 23       	and	r24, r24
    4708:	d1 f1       	breq	.+116    	; 0x477e <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    470a:	89 81       	ldd	r24, Y+1	; 0x01
    470c:	9a 81       	ldd	r25, Y+2	; 0x02
    470e:	02 96       	adiw	r24, 0x02	; 2
    4710:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4714:	89 81       	ldd	r24, Y+1	; 0x01
    4716:	9a 81       	ldd	r25, Y+2	; 0x02
    4718:	fc 01       	movw	r30, r24
    471a:	96 89       	ldd	r25, Z+22	; 0x16
    471c:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    4720:	89 17       	cp	r24, r25
    4722:	30 f4       	brcc	.+12     	; 0x4730 <vTaskResume+0x6e>
    4724:	89 81       	ldd	r24, Y+1	; 0x01
    4726:	9a 81       	ldd	r25, Y+2	; 0x02
    4728:	fc 01       	movw	r30, r24
    472a:	86 89       	ldd	r24, Z+22	; 0x16
    472c:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    4730:	89 81       	ldd	r24, Y+1	; 0x01
    4732:	9a 81       	ldd	r25, Y+2	; 0x02
    4734:	ac 01       	movw	r20, r24
    4736:	4e 5f       	subi	r20, 0xFE	; 254
    4738:	5f 4f       	sbci	r21, 0xFF	; 255
    473a:	89 81       	ldd	r24, Y+1	; 0x01
    473c:	9a 81       	ldd	r25, Y+2	; 0x02
    473e:	fc 01       	movw	r30, r24
    4740:	86 89       	ldd	r24, Z+22	; 0x16
    4742:	28 2f       	mov	r18, r24
    4744:	30 e0       	ldi	r19, 0x00	; 0
    4746:	c9 01       	movw	r24, r18
    4748:	88 0f       	add	r24, r24
    474a:	99 1f       	adc	r25, r25
    474c:	88 0f       	add	r24, r24
    474e:	99 1f       	adc	r25, r25
    4750:	88 0f       	add	r24, r24
    4752:	99 1f       	adc	r25, r25
    4754:	82 0f       	add	r24, r18
    4756:	93 1f       	adc	r25, r19
    4758:	81 56       	subi	r24, 0x61	; 97
    475a:	99 4f       	sbci	r25, 0xF9	; 249
    475c:	ba 01       	movw	r22, r20
    475e:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4762:	89 81       	ldd	r24, Y+1	; 0x01
    4764:	9a 81       	ldd	r25, Y+2	; 0x02
    4766:	fc 01       	movw	r30, r24
    4768:	26 89       	ldd	r18, Z+22	; 0x16
    476a:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    476e:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4772:	fc 01       	movw	r30, r24
    4774:	86 89       	ldd	r24, Z+22	; 0x16
    4776:	28 17       	cp	r18, r24
    4778:	10 f0       	brcs	.+4      	; 0x477e <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    477a:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    477e:	0f 90       	pop	r0
    4780:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4782:	00 00       	nop
    4784:	0f 90       	pop	r0
    4786:	0f 90       	pop	r0
    4788:	0f 90       	pop	r0
    478a:	0f 90       	pop	r0
    478c:	df 91       	pop	r29
    478e:	cf 91       	pop	r28
    4790:	08 95       	ret

00004792 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4792:	cf 93       	push	r28
    4794:	df 93       	push	r29
    4796:	00 d0       	rcall	.+0      	; 0x4798 <xTaskResumeFromISR+0x6>
    4798:	00 d0       	rcall	.+0      	; 0x479a <xTaskResumeFromISR+0x8>
    479a:	00 d0       	rcall	.+0      	; 0x479c <xTaskResumeFromISR+0xa>
    479c:	cd b7       	in	r28, 0x3d	; 61
    479e:	de b7       	in	r29, 0x3e	; 62
    47a0:	9e 83       	std	Y+6, r25	; 0x06
    47a2:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    47a4:	19 82       	std	Y+1, r1	; 0x01
	TCB_t * const pxTCB = xTaskToResume;
    47a6:	8d 81       	ldd	r24, Y+5	; 0x05
    47a8:	9e 81       	ldd	r25, Y+6	; 0x06
    47aa:	9b 83       	std	Y+3, r25	; 0x03
    47ac:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    47ae:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    47b0:	8a 81       	ldd	r24, Y+2	; 0x02
    47b2:	9b 81       	ldd	r25, Y+3	; 0x03
    47b4:	0e 94 31 23 	call	0x4662	; 0x4662 <prvTaskIsTaskSuspended>
    47b8:	88 23       	and	r24, r24
    47ba:	09 f4       	brne	.+2      	; 0x47be <xTaskResumeFromISR+0x2c>
    47bc:	47 c0       	rjmp	.+142    	; 0x484c <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    47be:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    47c2:	88 23       	and	r24, r24
    47c4:	d9 f5       	brne	.+118    	; 0x483c <xTaskResumeFromISR+0xaa>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    47c6:	8a 81       	ldd	r24, Y+2	; 0x02
    47c8:	9b 81       	ldd	r25, Y+3	; 0x03
    47ca:	fc 01       	movw	r30, r24
    47cc:	26 89       	ldd	r18, Z+22	; 0x16
    47ce:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    47d2:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    47d6:	fc 01       	movw	r30, r24
    47d8:	86 89       	ldd	r24, Z+22	; 0x16
    47da:	28 17       	cp	r18, r24
    47dc:	10 f0       	brcs	.+4      	; 0x47e2 <xTaskResumeFromISR+0x50>
					{
						xYieldRequired = pdTRUE;
    47de:	81 e0       	ldi	r24, 0x01	; 1
    47e0:	89 83       	std	Y+1, r24	; 0x01
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    47e2:	8a 81       	ldd	r24, Y+2	; 0x02
    47e4:	9b 81       	ldd	r25, Y+3	; 0x03
    47e6:	02 96       	adiw	r24, 0x02	; 2
    47e8:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    47ec:	8a 81       	ldd	r24, Y+2	; 0x02
    47ee:	9b 81       	ldd	r25, Y+3	; 0x03
    47f0:	fc 01       	movw	r30, r24
    47f2:	96 89       	ldd	r25, Z+22	; 0x16
    47f4:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    47f8:	89 17       	cp	r24, r25
    47fa:	30 f4       	brcc	.+12     	; 0x4808 <xTaskResumeFromISR+0x76>
    47fc:	8a 81       	ldd	r24, Y+2	; 0x02
    47fe:	9b 81       	ldd	r25, Y+3	; 0x03
    4800:	fc 01       	movw	r30, r24
    4802:	86 89       	ldd	r24, Z+22	; 0x16
    4804:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    4808:	8a 81       	ldd	r24, Y+2	; 0x02
    480a:	9b 81       	ldd	r25, Y+3	; 0x03
    480c:	ac 01       	movw	r20, r24
    480e:	4e 5f       	subi	r20, 0xFE	; 254
    4810:	5f 4f       	sbci	r21, 0xFF	; 255
    4812:	8a 81       	ldd	r24, Y+2	; 0x02
    4814:	9b 81       	ldd	r25, Y+3	; 0x03
    4816:	fc 01       	movw	r30, r24
    4818:	86 89       	ldd	r24, Z+22	; 0x16
    481a:	28 2f       	mov	r18, r24
    481c:	30 e0       	ldi	r19, 0x00	; 0
    481e:	c9 01       	movw	r24, r18
    4820:	88 0f       	add	r24, r24
    4822:	99 1f       	adc	r25, r25
    4824:	88 0f       	add	r24, r24
    4826:	99 1f       	adc	r25, r25
    4828:	88 0f       	add	r24, r24
    482a:	99 1f       	adc	r25, r25
    482c:	82 0f       	add	r24, r18
    482e:	93 1f       	adc	r25, r19
    4830:	81 56       	subi	r24, 0x61	; 97
    4832:	99 4f       	sbci	r25, 0xF9	; 249
    4834:	ba 01       	movw	r22, r20
    4836:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
    483a:	08 c0       	rjmp	.+16     	; 0x484c <xTaskResumeFromISR+0xba>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    483c:	8a 81       	ldd	r24, Y+2	; 0x02
    483e:	9b 81       	ldd	r25, Y+3	; 0x03
    4840:	0c 96       	adiw	r24, 0x0c	; 12
    4842:	bc 01       	movw	r22, r24
    4844:	82 ee       	ldi	r24, 0xE2	; 226
    4846:	96 e0       	ldi	r25, 0x06	; 6
    4848:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    484c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    484e:	26 96       	adiw	r28, 0x06	; 6
    4850:	0f b6       	in	r0, 0x3f	; 63
    4852:	f8 94       	cli
    4854:	de bf       	out	0x3e, r29	; 62
    4856:	0f be       	out	0x3f, r0	; 63
    4858:	cd bf       	out	0x3d, r28	; 61
    485a:	df 91       	pop	r29
    485c:	cf 91       	pop	r28
    485e:	08 95       	ret

00004860 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4860:	ef 92       	push	r14
    4862:	ff 92       	push	r15
    4864:	0f 93       	push	r16
    4866:	cf 93       	push	r28
    4868:	df 93       	push	r29
    486a:	1f 92       	push	r1
    486c:	cd b7       	in	r28, 0x3d	; 61
    486e:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4870:	0f 2e       	mov	r0, r31
    4872:	f9 e0       	ldi	r31, 0x09	; 9
    4874:	ef 2e       	mov	r14, r31
    4876:	f7 e0       	ldi	r31, 0x07	; 7
    4878:	ff 2e       	mov	r15, r31
    487a:	f0 2d       	mov	r31, r0
    487c:	00 e0       	ldi	r16, 0x00	; 0
    487e:	20 e0       	ldi	r18, 0x00	; 0
    4880:	30 e0       	ldi	r19, 0x00	; 0
    4882:	45 e5       	ldi	r20, 0x55	; 85
    4884:	50 e0       	ldi	r21, 0x00	; 0
    4886:	63 eb       	ldi	r22, 0xB3	; 179
    4888:	70 e0       	ldi	r23, 0x00	; 0
    488a:	8c ea       	ldi	r24, 0xAC	; 172
    488c:	98 e2       	ldi	r25, 0x28	; 40
    488e:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <xTaskCreate>
    4892:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4894:	89 81       	ldd	r24, Y+1	; 0x01
    4896:	81 30       	cpi	r24, 0x01	; 1
    4898:	81 f4       	brne	.+32     	; 0x48ba <vTaskStartScheduler+0x5a>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    489a:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    489c:	8f ef       	ldi	r24, 0xFF	; 255
    489e:	9f ef       	ldi	r25, 0xFF	; 255
    48a0:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <xNextTaskUnblockTime+0x1>
    48a4:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    48a8:	81 e0       	ldi	r24, 0x01	; 1
    48aa:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    48ae:	10 92 00 07 	sts	0x0700, r1	; 0x800700 <xTickCount+0x1>
    48b2:	10 92 ff 06 	sts	0x06FF, r1	; 0x8006ff <xTickCount>

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    48b6:	0e 94 41 16 	call	0x2c82	; 0x2c82 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    48ba:	00 00       	nop
    48bc:	0f 90       	pop	r0
    48be:	df 91       	pop	r29
    48c0:	cf 91       	pop	r28
    48c2:	0f 91       	pop	r16
    48c4:	ff 90       	pop	r15
    48c6:	ef 90       	pop	r14
    48c8:	08 95       	ret

000048ca <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    48ca:	cf 93       	push	r28
    48cc:	df 93       	push	r29
    48ce:	cd b7       	in	r28, 0x3d	; 61
    48d0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    48d2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    48d4:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <xSchedulerRunning>
	vPortEndScheduler();
    48d8:	0e 94 76 16 	call	0x2cec	; 0x2cec <vPortEndScheduler>
}
    48dc:	00 00       	nop
    48de:	df 91       	pop	r29
    48e0:	cf 91       	pop	r28
    48e2:	08 95       	ret

000048e4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    48e4:	cf 93       	push	r28
    48e6:	df 93       	push	r29
    48e8:	cd b7       	in	r28, 0x3d	; 61
    48ea:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    48ec:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    48f0:	8f 5f       	subi	r24, 0xFF	; 255
    48f2:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxSchedulerSuspended>
	portMEMORY_BARRIER();
}
    48f6:	00 00       	nop
    48f8:	df 91       	pop	r29
    48fa:	cf 91       	pop	r28
    48fc:	08 95       	ret

000048fe <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    48fe:	cf 93       	push	r28
    4900:	df 93       	push	r29
    4902:	00 d0       	rcall	.+0      	; 0x4904 <xTaskResumeAll+0x6>
    4904:	00 d0       	rcall	.+0      	; 0x4906 <xTaskResumeAll+0x8>
    4906:	cd b7       	in	r28, 0x3d	; 61
    4908:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    490a:	1a 82       	std	Y+2, r1	; 0x02
    490c:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xAlreadyYielded = pdFALSE;
    490e:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4910:	0f b6       	in	r0, 0x3f	; 63
    4912:	f8 94       	cli
    4914:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4916:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    491a:	81 50       	subi	r24, 0x01	; 1
    491c:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4920:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    4924:	88 23       	and	r24, r24
    4926:	09 f0       	breq	.+2      	; 0x492a <xTaskResumeAll+0x2c>
    4928:	77 c0       	rjmp	.+238    	; 0x4a18 <xTaskResumeAll+0x11a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    492a:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxCurrentNumberOfTasks>
    492e:	88 23       	and	r24, r24
    4930:	09 f4       	brne	.+2      	; 0x4934 <xTaskResumeAll+0x36>
    4932:	72 c0       	rjmp	.+228    	; 0x4a18 <xTaskResumeAll+0x11a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4934:	49 c0       	rjmp	.+146    	; 0x49c8 <xTaskResumeAll+0xca>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4936:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <xPendingReadyList+0x5>
    493a:	90 91 e8 06 	lds	r25, 0x06E8	; 0x8006e8 <xPendingReadyList+0x6>
    493e:	fc 01       	movw	r30, r24
    4940:	86 81       	ldd	r24, Z+6	; 0x06
    4942:	97 81       	ldd	r25, Z+7	; 0x07
    4944:	9a 83       	std	Y+2, r25	; 0x02
    4946:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4948:	89 81       	ldd	r24, Y+1	; 0x01
    494a:	9a 81       	ldd	r25, Y+2	; 0x02
    494c:	0c 96       	adiw	r24, 0x0c	; 12
    494e:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4952:	89 81       	ldd	r24, Y+1	; 0x01
    4954:	9a 81       	ldd	r25, Y+2	; 0x02
    4956:	02 96       	adiw	r24, 0x02	; 2
    4958:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    495c:	89 81       	ldd	r24, Y+1	; 0x01
    495e:	9a 81       	ldd	r25, Y+2	; 0x02
    4960:	fc 01       	movw	r30, r24
    4962:	96 89       	ldd	r25, Z+22	; 0x16
    4964:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    4968:	89 17       	cp	r24, r25
    496a:	30 f4       	brcc	.+12     	; 0x4978 <xTaskResumeAll+0x7a>
    496c:	89 81       	ldd	r24, Y+1	; 0x01
    496e:	9a 81       	ldd	r25, Y+2	; 0x02
    4970:	fc 01       	movw	r30, r24
    4972:	86 89       	ldd	r24, Z+22	; 0x16
    4974:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    4978:	89 81       	ldd	r24, Y+1	; 0x01
    497a:	9a 81       	ldd	r25, Y+2	; 0x02
    497c:	ac 01       	movw	r20, r24
    497e:	4e 5f       	subi	r20, 0xFE	; 254
    4980:	5f 4f       	sbci	r21, 0xFF	; 255
    4982:	89 81       	ldd	r24, Y+1	; 0x01
    4984:	9a 81       	ldd	r25, Y+2	; 0x02
    4986:	fc 01       	movw	r30, r24
    4988:	86 89       	ldd	r24, Z+22	; 0x16
    498a:	28 2f       	mov	r18, r24
    498c:	30 e0       	ldi	r19, 0x00	; 0
    498e:	c9 01       	movw	r24, r18
    4990:	88 0f       	add	r24, r24
    4992:	99 1f       	adc	r25, r25
    4994:	88 0f       	add	r24, r24
    4996:	99 1f       	adc	r25, r25
    4998:	88 0f       	add	r24, r24
    499a:	99 1f       	adc	r25, r25
    499c:	82 0f       	add	r24, r18
    499e:	93 1f       	adc	r25, r19
    49a0:	81 56       	subi	r24, 0x61	; 97
    49a2:	99 4f       	sbci	r25, 0xF9	; 249
    49a4:	ba 01       	movw	r22, r20
    49a6:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    49aa:	89 81       	ldd	r24, Y+1	; 0x01
    49ac:	9a 81       	ldd	r25, Y+2	; 0x02
    49ae:	fc 01       	movw	r30, r24
    49b0:	26 89       	ldd	r18, Z+22	; 0x16
    49b2:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    49b6:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    49ba:	fc 01       	movw	r30, r24
    49bc:	86 89       	ldd	r24, Z+22	; 0x16
    49be:	28 17       	cp	r18, r24
    49c0:	18 f0       	brcs	.+6      	; 0x49c8 <xTaskResumeAll+0xca>
					{
						xYieldPending = pdTRUE;
    49c2:	81 e0       	ldi	r24, 0x01	; 1
    49c4:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    49c8:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <xPendingReadyList>
    49cc:	88 23       	and	r24, r24
    49ce:	09 f0       	breq	.+2      	; 0x49d2 <xTaskResumeAll+0xd4>
    49d0:	b2 cf       	rjmp	.-156    	; 0x4936 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    49d2:	89 81       	ldd	r24, Y+1	; 0x01
    49d4:	9a 81       	ldd	r25, Y+2	; 0x02
    49d6:	89 2b       	or	r24, r25
    49d8:	11 f0       	breq	.+4      	; 0x49de <xTaskResumeAll+0xe0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    49da:	0e 94 47 29 	call	0x528e	; 0x528e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    49de:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxPendedTicks>
    49e2:	8c 83       	std	Y+4, r24	; 0x04

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    49e4:	8c 81       	ldd	r24, Y+4	; 0x04
    49e6:	88 23       	and	r24, r24
    49e8:	79 f0       	breq	.+30     	; 0x4a08 <xTaskResumeAll+0x10a>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    49ea:	0e 94 6a 25 	call	0x4ad4	; 0x4ad4 <xTaskIncrementTick>
    49ee:	88 23       	and	r24, r24
    49f0:	19 f0       	breq	.+6      	; 0x49f8 <xTaskResumeAll+0xfa>
							{
								xYieldPending = pdTRUE;
    49f2:	81 e0       	ldi	r24, 0x01	; 1
    49f4:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    49f8:	8c 81       	ldd	r24, Y+4	; 0x04
    49fa:	81 50       	subi	r24, 0x01	; 1
    49fc:	8c 83       	std	Y+4, r24	; 0x04
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    49fe:	8c 81       	ldd	r24, Y+4	; 0x04
    4a00:	88 23       	and	r24, r24
    4a02:	99 f7       	brne	.-26     	; 0x49ea <xTaskResumeAll+0xec>

						uxPendedTicks = 0;
    4a04:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4a08:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xYieldPending>
    4a0c:	88 23       	and	r24, r24
    4a0e:	21 f0       	breq	.+8      	; 0x4a18 <xTaskResumeAll+0x11a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4a10:	81 e0       	ldi	r24, 0x01	; 1
    4a12:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4a14:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4a18:	0f 90       	pop	r0
    4a1a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4a1c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4a1e:	0f 90       	pop	r0
    4a20:	0f 90       	pop	r0
    4a22:	0f 90       	pop	r0
    4a24:	0f 90       	pop	r0
    4a26:	df 91       	pop	r29
    4a28:	cf 91       	pop	r28
    4a2a:	08 95       	ret

00004a2c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4a2c:	cf 93       	push	r28
    4a2e:	df 93       	push	r29
    4a30:	00 d0       	rcall	.+0      	; 0x4a32 <xTaskGetTickCount+0x6>
    4a32:	cd b7       	in	r28, 0x3d	; 61
    4a34:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4a36:	0f b6       	in	r0, 0x3f	; 63
    4a38:	f8 94       	cli
    4a3a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4a3c:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xTickCount>
    4a40:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xTickCount+0x1>
    4a44:	9a 83       	std	Y+2, r25	; 0x02
    4a46:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4a48:	0f 90       	pop	r0
    4a4a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4a4c:	89 81       	ldd	r24, Y+1	; 0x01
    4a4e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4a50:	0f 90       	pop	r0
    4a52:	0f 90       	pop	r0
    4a54:	df 91       	pop	r29
    4a56:	cf 91       	pop	r28
    4a58:	08 95       	ret

00004a5a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4a5a:	cf 93       	push	r28
    4a5c:	df 93       	push	r29
    4a5e:	00 d0       	rcall	.+0      	; 0x4a60 <xTaskGetTickCountFromISR+0x6>
    4a60:	1f 92       	push	r1
    4a62:	cd b7       	in	r28, 0x3d	; 61
    4a64:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4a66:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4a68:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xTickCount>
    4a6c:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xTickCount+0x1>
    4a70:	9b 83       	std	Y+3, r25	; 0x03
    4a72:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4a74:	8a 81       	ldd	r24, Y+2	; 0x02
    4a76:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4a78:	0f 90       	pop	r0
    4a7a:	0f 90       	pop	r0
    4a7c:	0f 90       	pop	r0
    4a7e:	df 91       	pop	r29
    4a80:	cf 91       	pop	r28
    4a82:	08 95       	ret

00004a84 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4a84:	cf 93       	push	r28
    4a86:	df 93       	push	r29
    4a88:	cd b7       	in	r28, 0x3d	; 61
    4a8a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4a8c:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxCurrentNumberOfTasks>
}
    4a90:	df 91       	pop	r29
    4a92:	cf 91       	pop	r28
    4a94:	08 95       	ret

00004a96 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4a96:	cf 93       	push	r28
    4a98:	df 93       	push	r29
    4a9a:	00 d0       	rcall	.+0      	; 0x4a9c <pcTaskGetName+0x6>
    4a9c:	00 d0       	rcall	.+0      	; 0x4a9e <pcTaskGetName+0x8>
    4a9e:	cd b7       	in	r28, 0x3d	; 61
    4aa0:	de b7       	in	r29, 0x3e	; 62
    4aa2:	9c 83       	std	Y+4, r25	; 0x04
    4aa4:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    4aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    4aaa:	89 2b       	or	r24, r25
    4aac:	29 f4       	brne	.+10     	; 0x4ab8 <pcTaskGetName+0x22>
    4aae:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4ab2:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4ab6:	02 c0       	rjmp	.+4      	; 0x4abc <pcTaskGetName+0x26>
    4ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    4aba:	9c 81       	ldd	r25, Y+4	; 0x04
    4abc:	9a 83       	std	Y+2, r25	; 0x02
    4abe:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4ac0:	89 81       	ldd	r24, Y+1	; 0x01
    4ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ac4:	49 96       	adiw	r24, 0x19	; 25
}
    4ac6:	0f 90       	pop	r0
    4ac8:	0f 90       	pop	r0
    4aca:	0f 90       	pop	r0
    4acc:	0f 90       	pop	r0
    4ace:	df 91       	pop	r29
    4ad0:	cf 91       	pop	r28
    4ad2:	08 95       	ret

00004ad4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4ad4:	cf 93       	push	r28
    4ad6:	df 93       	push	r29
    4ad8:	cd b7       	in	r28, 0x3d	; 61
    4ada:	de b7       	in	r29, 0x3e	; 62
    4adc:	29 97       	sbiw	r28, 0x09	; 9
    4ade:	0f b6       	in	r0, 0x3f	; 63
    4ae0:	f8 94       	cli
    4ae2:	de bf       	out	0x3e, r29	; 62
    4ae4:	0f be       	out	0x3f, r0	; 63
    4ae6:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4ae8:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4aea:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    4aee:	88 23       	and	r24, r24
    4af0:	09 f0       	breq	.+2      	; 0x4af4 <xTaskIncrementTick+0x20>
    4af2:	c8 c0       	rjmp	.+400    	; 0x4c84 <xTaskIncrementTick+0x1b0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4af4:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xTickCount>
    4af8:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xTickCount+0x1>
    4afc:	01 96       	adiw	r24, 0x01	; 1
    4afe:	9b 83       	std	Y+3, r25	; 0x03
    4b00:	8a 83       	std	Y+2, r24	; 0x02

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4b02:	8a 81       	ldd	r24, Y+2	; 0x02
    4b04:	9b 81       	ldd	r25, Y+3	; 0x03
    4b06:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <xTickCount+0x1>
    4b0a:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4b0e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b10:	9b 81       	ldd	r25, Y+3	; 0x03
    4b12:	89 2b       	or	r24, r25
    4b14:	d9 f4       	brne	.+54     	; 0x4b4c <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4b16:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <pxDelayedTaskList>
    4b1a:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <pxDelayedTaskList+0x1>
    4b1e:	9d 83       	std	Y+5, r25	; 0x05
    4b20:	8c 83       	std	Y+4, r24	; 0x04
    4b22:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxOverflowDelayedTaskList>
    4b26:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxOverflowDelayedTaskList+0x1>
    4b2a:	90 93 df 06 	sts	0x06DF, r25	; 0x8006df <pxDelayedTaskList+0x1>
    4b2e:	80 93 de 06 	sts	0x06DE, r24	; 0x8006de <pxDelayedTaskList>
    4b32:	8c 81       	ldd	r24, Y+4	; 0x04
    4b34:	9d 81       	ldd	r25, Y+5	; 0x05
    4b36:	90 93 e1 06 	sts	0x06E1, r25	; 0x8006e1 <pxOverflowDelayedTaskList+0x1>
    4b3a:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <pxOverflowDelayedTaskList>
    4b3e:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <xNumOfOverflows>
    4b42:	8f 5f       	subi	r24, 0xFF	; 255
    4b44:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <xNumOfOverflows>
    4b48:	0e 94 47 29 	call	0x528e	; 0x528e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4b4c:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xNextTaskUnblockTime>
    4b50:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <xNextTaskUnblockTime+0x1>
    4b54:	2a 81       	ldd	r18, Y+2	; 0x02
    4b56:	3b 81       	ldd	r19, Y+3	; 0x03
    4b58:	28 17       	cp	r18, r24
    4b5a:	39 07       	cpc	r19, r25
    4b5c:	08 f4       	brcc	.+2      	; 0x4b60 <xTaskIncrementTick+0x8c>
    4b5e:	78 c0       	rjmp	.+240    	; 0x4c50 <xTaskIncrementTick+0x17c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4b60:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <pxDelayedTaskList>
    4b64:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <pxDelayedTaskList+0x1>
    4b68:	fc 01       	movw	r30, r24
    4b6a:	80 81       	ld	r24, Z
    4b6c:	88 23       	and	r24, r24
    4b6e:	39 f4       	brne	.+14     	; 0x4b7e <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4b70:	8f ef       	ldi	r24, 0xFF	; 255
    4b72:	9f ef       	ldi	r25, 0xFF	; 255
    4b74:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <xNextTaskUnblockTime+0x1>
    4b78:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNextTaskUnblockTime>
					break;
    4b7c:	69 c0       	rjmp	.+210    	; 0x4c50 <xTaskIncrementTick+0x17c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b7e:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <pxDelayedTaskList>
    4b82:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <pxDelayedTaskList+0x1>
    4b86:	fc 01       	movw	r30, r24
    4b88:	85 81       	ldd	r24, Z+5	; 0x05
    4b8a:	96 81       	ldd	r25, Z+6	; 0x06
    4b8c:	fc 01       	movw	r30, r24
    4b8e:	86 81       	ldd	r24, Z+6	; 0x06
    4b90:	97 81       	ldd	r25, Z+7	; 0x07
    4b92:	9f 83       	std	Y+7, r25	; 0x07
    4b94:	8e 83       	std	Y+6, r24	; 0x06
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4b96:	8e 81       	ldd	r24, Y+6	; 0x06
    4b98:	9f 81       	ldd	r25, Y+7	; 0x07
    4b9a:	fc 01       	movw	r30, r24
    4b9c:	82 81       	ldd	r24, Z+2	; 0x02
    4b9e:	93 81       	ldd	r25, Z+3	; 0x03
    4ba0:	99 87       	std	Y+9, r25	; 0x09
    4ba2:	88 87       	std	Y+8, r24	; 0x08

					if( xConstTickCount < xItemValue )
    4ba4:	2a 81       	ldd	r18, Y+2	; 0x02
    4ba6:	3b 81       	ldd	r19, Y+3	; 0x03
    4ba8:	88 85       	ldd	r24, Y+8	; 0x08
    4baa:	99 85       	ldd	r25, Y+9	; 0x09
    4bac:	28 17       	cp	r18, r24
    4bae:	39 07       	cpc	r19, r25
    4bb0:	38 f4       	brcc	.+14     	; 0x4bc0 <xTaskIncrementTick+0xec>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4bb2:	88 85       	ldd	r24, Y+8	; 0x08
    4bb4:	99 85       	ldd	r25, Y+9	; 0x09
    4bb6:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <xNextTaskUnblockTime+0x1>
    4bba:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    4bbe:	48 c0       	rjmp	.+144    	; 0x4c50 <xTaskIncrementTick+0x17c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4bc0:	8e 81       	ldd	r24, Y+6	; 0x06
    4bc2:	9f 81       	ldd	r25, Y+7	; 0x07
    4bc4:	02 96       	adiw	r24, 0x02	; 2
    4bc6:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4bca:	8e 81       	ldd	r24, Y+6	; 0x06
    4bcc:	9f 81       	ldd	r25, Y+7	; 0x07
    4bce:	fc 01       	movw	r30, r24
    4bd0:	84 89       	ldd	r24, Z+20	; 0x14
    4bd2:	95 89       	ldd	r25, Z+21	; 0x15
    4bd4:	89 2b       	or	r24, r25
    4bd6:	29 f0       	breq	.+10     	; 0x4be2 <xTaskIncrementTick+0x10e>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4bd8:	8e 81       	ldd	r24, Y+6	; 0x06
    4bda:	9f 81       	ldd	r25, Y+7	; 0x07
    4bdc:	0c 96       	adiw	r24, 0x0c	; 12
    4bde:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4be2:	8e 81       	ldd	r24, Y+6	; 0x06
    4be4:	9f 81       	ldd	r25, Y+7	; 0x07
    4be6:	fc 01       	movw	r30, r24
    4be8:	96 89       	ldd	r25, Z+22	; 0x16
    4bea:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    4bee:	89 17       	cp	r24, r25
    4bf0:	30 f4       	brcc	.+12     	; 0x4bfe <xTaskIncrementTick+0x12a>
    4bf2:	8e 81       	ldd	r24, Y+6	; 0x06
    4bf4:	9f 81       	ldd	r25, Y+7	; 0x07
    4bf6:	fc 01       	movw	r30, r24
    4bf8:	86 89       	ldd	r24, Z+22	; 0x16
    4bfa:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    4bfe:	8e 81       	ldd	r24, Y+6	; 0x06
    4c00:	9f 81       	ldd	r25, Y+7	; 0x07
    4c02:	ac 01       	movw	r20, r24
    4c04:	4e 5f       	subi	r20, 0xFE	; 254
    4c06:	5f 4f       	sbci	r21, 0xFF	; 255
    4c08:	8e 81       	ldd	r24, Y+6	; 0x06
    4c0a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c0c:	fc 01       	movw	r30, r24
    4c0e:	86 89       	ldd	r24, Z+22	; 0x16
    4c10:	28 2f       	mov	r18, r24
    4c12:	30 e0       	ldi	r19, 0x00	; 0
    4c14:	c9 01       	movw	r24, r18
    4c16:	88 0f       	add	r24, r24
    4c18:	99 1f       	adc	r25, r25
    4c1a:	88 0f       	add	r24, r24
    4c1c:	99 1f       	adc	r25, r25
    4c1e:	88 0f       	add	r24, r24
    4c20:	99 1f       	adc	r25, r25
    4c22:	82 0f       	add	r24, r18
    4c24:	93 1f       	adc	r25, r19
    4c26:	81 56       	subi	r24, 0x61	; 97
    4c28:	99 4f       	sbci	r25, 0xF9	; 249
    4c2a:	ba 01       	movw	r22, r20
    4c2c:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4c30:	8e 81       	ldd	r24, Y+6	; 0x06
    4c32:	9f 81       	ldd	r25, Y+7	; 0x07
    4c34:	fc 01       	movw	r30, r24
    4c36:	26 89       	ldd	r18, Z+22	; 0x16
    4c38:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4c3c:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4c40:	fc 01       	movw	r30, r24
    4c42:	86 89       	ldd	r24, Z+22	; 0x16
    4c44:	28 17       	cp	r18, r24
    4c46:	08 f4       	brcc	.+2      	; 0x4c4a <xTaskIncrementTick+0x176>
    4c48:	8b cf       	rjmp	.-234    	; 0x4b60 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4c4a:	81 e0       	ldi	r24, 0x01	; 1
    4c4c:	89 83       	std	Y+1, r24	; 0x01
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    4c4e:	88 cf       	rjmp	.-240    	; 0x4b60 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4c50:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4c54:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4c58:	fc 01       	movw	r30, r24
    4c5a:	86 89       	ldd	r24, Z+22	; 0x16
    4c5c:	28 2f       	mov	r18, r24
    4c5e:	30 e0       	ldi	r19, 0x00	; 0
    4c60:	c9 01       	movw	r24, r18
    4c62:	88 0f       	add	r24, r24
    4c64:	99 1f       	adc	r25, r25
    4c66:	88 0f       	add	r24, r24
    4c68:	99 1f       	adc	r25, r25
    4c6a:	88 0f       	add	r24, r24
    4c6c:	99 1f       	adc	r25, r25
    4c6e:	82 0f       	add	r24, r18
    4c70:	93 1f       	adc	r25, r19
    4c72:	81 56       	subi	r24, 0x61	; 97
    4c74:	99 4f       	sbci	r25, 0xF9	; 249
    4c76:	fc 01       	movw	r30, r24
    4c78:	80 81       	ld	r24, Z
    4c7a:	82 30       	cpi	r24, 0x02	; 2
    4c7c:	40 f0       	brcs	.+16     	; 0x4c8e <xTaskIncrementTick+0x1ba>
			{
				xSwitchRequired = pdTRUE;
    4c7e:	81 e0       	ldi	r24, 0x01	; 1
    4c80:	89 83       	std	Y+1, r24	; 0x01
    4c82:	05 c0       	rjmp	.+10     	; 0x4c8e <xTaskIncrementTick+0x1ba>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4c84:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxPendedTicks>
    4c88:	8f 5f       	subi	r24, 0xFF	; 255
    4c8a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxPendedTicks>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4c8e:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xYieldPending>
    4c92:	88 23       	and	r24, r24
    4c94:	11 f0       	breq	.+4      	; 0x4c9a <xTaskIncrementTick+0x1c6>
		{
			xSwitchRequired = pdTRUE;
    4c96:	81 e0       	ldi	r24, 0x01	; 1
    4c98:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4c9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    4c9c:	29 96       	adiw	r28, 0x09	; 9
    4c9e:	0f b6       	in	r0, 0x3f	; 63
    4ca0:	f8 94       	cli
    4ca2:	de bf       	out	0x3e, r29	; 62
    4ca4:	0f be       	out	0x3f, r0	; 63
    4ca6:	cd bf       	out	0x3d, r28	; 61
    4ca8:	df 91       	pop	r29
    4caa:	cf 91       	pop	r28
    4cac:	08 95       	ret

00004cae <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4cae:	cf 93       	push	r28
    4cb0:	df 93       	push	r29
    4cb2:	00 d0       	rcall	.+0      	; 0x4cb4 <vTaskSwitchContext+0x6>
    4cb4:	1f 92       	push	r1
    4cb6:	cd b7       	in	r28, 0x3d	; 61
    4cb8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4cba:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    4cbe:	88 23       	and	r24, r24
    4cc0:	21 f0       	breq	.+8      	; 0x4cca <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4cc2:	81 e0       	ldi	r24, 0x01	; 1
    4cc4:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4cc8:	5f c0       	rjmp	.+190    	; 0x4d88 <vTaskSwitchContext+0xda>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    4cca:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4cce:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    4cd2:	89 83       	std	Y+1, r24	; 0x01
    4cd4:	03 c0       	rjmp	.+6      	; 0x4cdc <vTaskSwitchContext+0x2e>
    4cd6:	89 81       	ldd	r24, Y+1	; 0x01
    4cd8:	81 50       	subi	r24, 0x01	; 1
    4cda:	89 83       	std	Y+1, r24	; 0x01
    4cdc:	89 81       	ldd	r24, Y+1	; 0x01
    4cde:	28 2f       	mov	r18, r24
    4ce0:	30 e0       	ldi	r19, 0x00	; 0
    4ce2:	c9 01       	movw	r24, r18
    4ce4:	88 0f       	add	r24, r24
    4ce6:	99 1f       	adc	r25, r25
    4ce8:	88 0f       	add	r24, r24
    4cea:	99 1f       	adc	r25, r25
    4cec:	88 0f       	add	r24, r24
    4cee:	99 1f       	adc	r25, r25
    4cf0:	82 0f       	add	r24, r18
    4cf2:	93 1f       	adc	r25, r19
    4cf4:	81 56       	subi	r24, 0x61	; 97
    4cf6:	99 4f       	sbci	r25, 0xF9	; 249
    4cf8:	fc 01       	movw	r30, r24
    4cfa:	80 81       	ld	r24, Z
    4cfc:	88 23       	and	r24, r24
    4cfe:	59 f3       	breq	.-42     	; 0x4cd6 <vTaskSwitchContext+0x28>
    4d00:	89 81       	ldd	r24, Y+1	; 0x01
    4d02:	28 2f       	mov	r18, r24
    4d04:	30 e0       	ldi	r19, 0x00	; 0
    4d06:	c9 01       	movw	r24, r18
    4d08:	88 0f       	add	r24, r24
    4d0a:	99 1f       	adc	r25, r25
    4d0c:	88 0f       	add	r24, r24
    4d0e:	99 1f       	adc	r25, r25
    4d10:	88 0f       	add	r24, r24
    4d12:	99 1f       	adc	r25, r25
    4d14:	82 0f       	add	r24, r18
    4d16:	93 1f       	adc	r25, r19
    4d18:	81 56       	subi	r24, 0x61	; 97
    4d1a:	99 4f       	sbci	r25, 0xF9	; 249
    4d1c:	9b 83       	std	Y+3, r25	; 0x03
    4d1e:	8a 83       	std	Y+2, r24	; 0x02
    4d20:	8a 81       	ldd	r24, Y+2	; 0x02
    4d22:	9b 81       	ldd	r25, Y+3	; 0x03
    4d24:	fc 01       	movw	r30, r24
    4d26:	81 81       	ldd	r24, Z+1	; 0x01
    4d28:	92 81       	ldd	r25, Z+2	; 0x02
    4d2a:	fc 01       	movw	r30, r24
    4d2c:	22 81       	ldd	r18, Z+2	; 0x02
    4d2e:	33 81       	ldd	r19, Z+3	; 0x03
    4d30:	8a 81       	ldd	r24, Y+2	; 0x02
    4d32:	9b 81       	ldd	r25, Y+3	; 0x03
    4d34:	fc 01       	movw	r30, r24
    4d36:	32 83       	std	Z+2, r19	; 0x02
    4d38:	21 83       	std	Z+1, r18	; 0x01
    4d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    4d3c:	9b 81       	ldd	r25, Y+3	; 0x03
    4d3e:	fc 01       	movw	r30, r24
    4d40:	21 81       	ldd	r18, Z+1	; 0x01
    4d42:	32 81       	ldd	r19, Z+2	; 0x02
    4d44:	8a 81       	ldd	r24, Y+2	; 0x02
    4d46:	9b 81       	ldd	r25, Y+3	; 0x03
    4d48:	03 96       	adiw	r24, 0x03	; 3
    4d4a:	28 17       	cp	r18, r24
    4d4c:	39 07       	cpc	r19, r25
    4d4e:	69 f4       	brne	.+26     	; 0x4d6a <vTaskSwitchContext+0xbc>
    4d50:	8a 81       	ldd	r24, Y+2	; 0x02
    4d52:	9b 81       	ldd	r25, Y+3	; 0x03
    4d54:	fc 01       	movw	r30, r24
    4d56:	81 81       	ldd	r24, Z+1	; 0x01
    4d58:	92 81       	ldd	r25, Z+2	; 0x02
    4d5a:	fc 01       	movw	r30, r24
    4d5c:	22 81       	ldd	r18, Z+2	; 0x02
    4d5e:	33 81       	ldd	r19, Z+3	; 0x03
    4d60:	8a 81       	ldd	r24, Y+2	; 0x02
    4d62:	9b 81       	ldd	r25, Y+3	; 0x03
    4d64:	fc 01       	movw	r30, r24
    4d66:	32 83       	std	Z+2, r19	; 0x02
    4d68:	21 83       	std	Z+1, r18	; 0x01
    4d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    4d6c:	9b 81       	ldd	r25, Y+3	; 0x03
    4d6e:	fc 01       	movw	r30, r24
    4d70:	81 81       	ldd	r24, Z+1	; 0x01
    4d72:	92 81       	ldd	r25, Z+2	; 0x02
    4d74:	fc 01       	movw	r30, r24
    4d76:	86 81       	ldd	r24, Z+6	; 0x06
    4d78:	97 81       	ldd	r25, Z+7	; 0x07
    4d7a:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <pxCurrentTCB+0x1>
    4d7e:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <pxCurrentTCB>
    4d82:	89 81       	ldd	r24, Y+1	; 0x01
    4d84:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4d88:	00 00       	nop
    4d8a:	0f 90       	pop	r0
    4d8c:	0f 90       	pop	r0
    4d8e:	0f 90       	pop	r0
    4d90:	df 91       	pop	r29
    4d92:	cf 91       	pop	r28
    4d94:	08 95       	ret

00004d96 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4d96:	cf 93       	push	r28
    4d98:	df 93       	push	r29
    4d9a:	00 d0       	rcall	.+0      	; 0x4d9c <vTaskPlaceOnEventList+0x6>
    4d9c:	00 d0       	rcall	.+0      	; 0x4d9e <vTaskPlaceOnEventList+0x8>
    4d9e:	cd b7       	in	r28, 0x3d	; 61
    4da0:	de b7       	in	r29, 0x3e	; 62
    4da2:	9a 83       	std	Y+2, r25	; 0x02
    4da4:	89 83       	std	Y+1, r24	; 0x01
    4da6:	7c 83       	std	Y+4, r23	; 0x04
    4da8:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4daa:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4dae:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4db2:	9c 01       	movw	r18, r24
    4db4:	24 5f       	subi	r18, 0xF4	; 244
    4db6:	3f 4f       	sbci	r19, 0xFF	; 255
    4db8:	89 81       	ldd	r24, Y+1	; 0x01
    4dba:	9a 81       	ldd	r25, Y+2	; 0x02
    4dbc:	b9 01       	movw	r22, r18
    4dbe:	0e 94 77 13 	call	0x26ee	; 0x26ee <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4dc2:	8b 81       	ldd	r24, Y+3	; 0x03
    4dc4:	9c 81       	ldd	r25, Y+4	; 0x04
    4dc6:	61 e0       	ldi	r22, 0x01	; 1
    4dc8:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <prvAddCurrentTaskToDelayedList>
}
    4dcc:	00 00       	nop
    4dce:	0f 90       	pop	r0
    4dd0:	0f 90       	pop	r0
    4dd2:	0f 90       	pop	r0
    4dd4:	0f 90       	pop	r0
    4dd6:	df 91       	pop	r29
    4dd8:	cf 91       	pop	r28
    4dda:	08 95       	ret

00004ddc <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4ddc:	cf 93       	push	r28
    4dde:	df 93       	push	r29
    4de0:	00 d0       	rcall	.+0      	; 0x4de2 <vTaskPlaceOnUnorderedEventList+0x6>
    4de2:	00 d0       	rcall	.+0      	; 0x4de4 <vTaskPlaceOnUnorderedEventList+0x8>
    4de4:	00 d0       	rcall	.+0      	; 0x4de6 <vTaskPlaceOnUnorderedEventList+0xa>
    4de6:	cd b7       	in	r28, 0x3d	; 61
    4de8:	de b7       	in	r29, 0x3e	; 62
    4dea:	9a 83       	std	Y+2, r25	; 0x02
    4dec:	89 83       	std	Y+1, r24	; 0x01
    4dee:	7c 83       	std	Y+4, r23	; 0x04
    4df0:	6b 83       	std	Y+3, r22	; 0x03
    4df2:	5e 83       	std	Y+6, r21	; 0x06
    4df4:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4df6:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4dfa:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4dfe:	2b 81       	ldd	r18, Y+3	; 0x03
    4e00:	3c 81       	ldd	r19, Y+4	; 0x04
    4e02:	30 68       	ori	r19, 0x80	; 128
    4e04:	fc 01       	movw	r30, r24
    4e06:	35 87       	std	Z+13, r19	; 0x0d
    4e08:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4e0a:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4e0e:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4e12:	9c 01       	movw	r18, r24
    4e14:	24 5f       	subi	r18, 0xF4	; 244
    4e16:	3f 4f       	sbci	r19, 0xFF	; 255
    4e18:	89 81       	ldd	r24, Y+1	; 0x01
    4e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e1c:	b9 01       	movw	r22, r18
    4e1e:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e22:	8d 81       	ldd	r24, Y+5	; 0x05
    4e24:	9e 81       	ldd	r25, Y+6	; 0x06
    4e26:	61 e0       	ldi	r22, 0x01	; 1
    4e28:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <prvAddCurrentTaskToDelayedList>
}
    4e2c:	00 00       	nop
    4e2e:	26 96       	adiw	r28, 0x06	; 6
    4e30:	0f b6       	in	r0, 0x3f	; 63
    4e32:	f8 94       	cli
    4e34:	de bf       	out	0x3e, r29	; 62
    4e36:	0f be       	out	0x3f, r0	; 63
    4e38:	cd bf       	out	0x3d, r28	; 61
    4e3a:	df 91       	pop	r29
    4e3c:	cf 91       	pop	r28
    4e3e:	08 95       	ret

00004e40 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4e40:	cf 93       	push	r28
    4e42:	df 93       	push	r29
    4e44:	00 d0       	rcall	.+0      	; 0x4e46 <xTaskRemoveFromEventList+0x6>
    4e46:	00 d0       	rcall	.+0      	; 0x4e48 <xTaskRemoveFromEventList+0x8>
    4e48:	1f 92       	push	r1
    4e4a:	cd b7       	in	r28, 0x3d	; 61
    4e4c:	de b7       	in	r29, 0x3e	; 62
    4e4e:	9d 83       	std	Y+5, r25	; 0x05
    4e50:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4e52:	8c 81       	ldd	r24, Y+4	; 0x04
    4e54:	9d 81       	ldd	r25, Y+5	; 0x05
    4e56:	fc 01       	movw	r30, r24
    4e58:	85 81       	ldd	r24, Z+5	; 0x05
    4e5a:	96 81       	ldd	r25, Z+6	; 0x06
    4e5c:	fc 01       	movw	r30, r24
    4e5e:	86 81       	ldd	r24, Z+6	; 0x06
    4e60:	97 81       	ldd	r25, Z+7	; 0x07
    4e62:	9b 83       	std	Y+3, r25	; 0x03
    4e64:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4e66:	8a 81       	ldd	r24, Y+2	; 0x02
    4e68:	9b 81       	ldd	r25, Y+3	; 0x03
    4e6a:	0c 96       	adiw	r24, 0x0c	; 12
    4e6c:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4e70:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    4e74:	88 23       	and	r24, r24
    4e76:	69 f5       	brne	.+90     	; 0x4ed2 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4e78:	8a 81       	ldd	r24, Y+2	; 0x02
    4e7a:	9b 81       	ldd	r25, Y+3	; 0x03
    4e7c:	02 96       	adiw	r24, 0x02	; 2
    4e7e:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4e82:	8a 81       	ldd	r24, Y+2	; 0x02
    4e84:	9b 81       	ldd	r25, Y+3	; 0x03
    4e86:	fc 01       	movw	r30, r24
    4e88:	96 89       	ldd	r25, Z+22	; 0x16
    4e8a:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    4e8e:	89 17       	cp	r24, r25
    4e90:	30 f4       	brcc	.+12     	; 0x4e9e <xTaskRemoveFromEventList+0x5e>
    4e92:	8a 81       	ldd	r24, Y+2	; 0x02
    4e94:	9b 81       	ldd	r25, Y+3	; 0x03
    4e96:	fc 01       	movw	r30, r24
    4e98:	86 89       	ldd	r24, Z+22	; 0x16
    4e9a:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    4e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea0:	9b 81       	ldd	r25, Y+3	; 0x03
    4ea2:	ac 01       	movw	r20, r24
    4ea4:	4e 5f       	subi	r20, 0xFE	; 254
    4ea6:	5f 4f       	sbci	r21, 0xFF	; 255
    4ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eaa:	9b 81       	ldd	r25, Y+3	; 0x03
    4eac:	fc 01       	movw	r30, r24
    4eae:	86 89       	ldd	r24, Z+22	; 0x16
    4eb0:	28 2f       	mov	r18, r24
    4eb2:	30 e0       	ldi	r19, 0x00	; 0
    4eb4:	c9 01       	movw	r24, r18
    4eb6:	88 0f       	add	r24, r24
    4eb8:	99 1f       	adc	r25, r25
    4eba:	88 0f       	add	r24, r24
    4ebc:	99 1f       	adc	r25, r25
    4ebe:	88 0f       	add	r24, r24
    4ec0:	99 1f       	adc	r25, r25
    4ec2:	82 0f       	add	r24, r18
    4ec4:	93 1f       	adc	r25, r19
    4ec6:	81 56       	subi	r24, 0x61	; 97
    4ec8:	99 4f       	sbci	r25, 0xF9	; 249
    4eca:	ba 01       	movw	r22, r20
    4ecc:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
    4ed0:	08 c0       	rjmp	.+16     	; 0x4ee2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4ed2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ed4:	9b 81       	ldd	r25, Y+3	; 0x03
    4ed6:	0c 96       	adiw	r24, 0x0c	; 12
    4ed8:	bc 01       	movw	r22, r24
    4eda:	82 ee       	ldi	r24, 0xE2	; 226
    4edc:	96 e0       	ldi	r25, 0x06	; 6
    4ede:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ee4:	9b 81       	ldd	r25, Y+3	; 0x03
    4ee6:	fc 01       	movw	r30, r24
    4ee8:	26 89       	ldd	r18, Z+22	; 0x16
    4eea:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4eee:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4ef2:	fc 01       	movw	r30, r24
    4ef4:	86 89       	ldd	r24, Z+22	; 0x16
    4ef6:	82 17       	cp	r24, r18
    4ef8:	30 f4       	brcc	.+12     	; 0x4f06 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4efa:	81 e0       	ldi	r24, 0x01	; 1
    4efc:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4efe:	81 e0       	ldi	r24, 0x01	; 1
    4f00:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
    4f04:	01 c0       	rjmp	.+2      	; 0x4f08 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    4f06:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4f08:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f0a:	0f 90       	pop	r0
    4f0c:	0f 90       	pop	r0
    4f0e:	0f 90       	pop	r0
    4f10:	0f 90       	pop	r0
    4f12:	0f 90       	pop	r0
    4f14:	df 91       	pop	r29
    4f16:	cf 91       	pop	r28
    4f18:	08 95       	ret

00004f1a <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4f1a:	cf 93       	push	r28
    4f1c:	df 93       	push	r29
    4f1e:	00 d0       	rcall	.+0      	; 0x4f20 <vTaskRemoveFromUnorderedEventList+0x6>
    4f20:	00 d0       	rcall	.+0      	; 0x4f22 <vTaskRemoveFromUnorderedEventList+0x8>
    4f22:	00 d0       	rcall	.+0      	; 0x4f24 <vTaskRemoveFromUnorderedEventList+0xa>
    4f24:	cd b7       	in	r28, 0x3d	; 61
    4f26:	de b7       	in	r29, 0x3e	; 62
    4f28:	9c 83       	std	Y+4, r25	; 0x04
    4f2a:	8b 83       	std	Y+3, r24	; 0x03
    4f2c:	7e 83       	std	Y+6, r23	; 0x06
    4f2e:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4f30:	8d 81       	ldd	r24, Y+5	; 0x05
    4f32:	9e 81       	ldd	r25, Y+6	; 0x06
    4f34:	9c 01       	movw	r18, r24
    4f36:	30 68       	ori	r19, 0x80	; 128
    4f38:	8b 81       	ldd	r24, Y+3	; 0x03
    4f3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f3c:	fc 01       	movw	r30, r24
    4f3e:	31 83       	std	Z+1, r19	; 0x01
    4f40:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4f42:	8b 81       	ldd	r24, Y+3	; 0x03
    4f44:	9c 81       	ldd	r25, Y+4	; 0x04
    4f46:	fc 01       	movw	r30, r24
    4f48:	86 81       	ldd	r24, Z+6	; 0x06
    4f4a:	97 81       	ldd	r25, Z+7	; 0x07
    4f4c:	9a 83       	std	Y+2, r25	; 0x02
    4f4e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4f50:	8b 81       	ldd	r24, Y+3	; 0x03
    4f52:	9c 81       	ldd	r25, Y+4	; 0x04
    4f54:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4f58:	89 81       	ldd	r24, Y+1	; 0x01
    4f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f5c:	02 96       	adiw	r24, 0x02	; 2
    4f5e:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4f62:	89 81       	ldd	r24, Y+1	; 0x01
    4f64:	9a 81       	ldd	r25, Y+2	; 0x02
    4f66:	fc 01       	movw	r30, r24
    4f68:	96 89       	ldd	r25, Z+22	; 0x16
    4f6a:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    4f6e:	89 17       	cp	r24, r25
    4f70:	30 f4       	brcc	.+12     	; 0x4f7e <vTaskRemoveFromUnorderedEventList+0x64>
    4f72:	89 81       	ldd	r24, Y+1	; 0x01
    4f74:	9a 81       	ldd	r25, Y+2	; 0x02
    4f76:	fc 01       	movw	r30, r24
    4f78:	86 89       	ldd	r24, Z+22	; 0x16
    4f7a:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    4f7e:	89 81       	ldd	r24, Y+1	; 0x01
    4f80:	9a 81       	ldd	r25, Y+2	; 0x02
    4f82:	ac 01       	movw	r20, r24
    4f84:	4e 5f       	subi	r20, 0xFE	; 254
    4f86:	5f 4f       	sbci	r21, 0xFF	; 255
    4f88:	89 81       	ldd	r24, Y+1	; 0x01
    4f8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f8c:	fc 01       	movw	r30, r24
    4f8e:	86 89       	ldd	r24, Z+22	; 0x16
    4f90:	28 2f       	mov	r18, r24
    4f92:	30 e0       	ldi	r19, 0x00	; 0
    4f94:	c9 01       	movw	r24, r18
    4f96:	88 0f       	add	r24, r24
    4f98:	99 1f       	adc	r25, r25
    4f9a:	88 0f       	add	r24, r24
    4f9c:	99 1f       	adc	r25, r25
    4f9e:	88 0f       	add	r24, r24
    4fa0:	99 1f       	adc	r25, r25
    4fa2:	82 0f       	add	r24, r18
    4fa4:	93 1f       	adc	r25, r19
    4fa6:	81 56       	subi	r24, 0x61	; 97
    4fa8:	99 4f       	sbci	r25, 0xF9	; 249
    4faa:	ba 01       	movw	r22, r20
    4fac:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fb0:	89 81       	ldd	r24, Y+1	; 0x01
    4fb2:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb4:	fc 01       	movw	r30, r24
    4fb6:	26 89       	ldd	r18, Z+22	; 0x16
    4fb8:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    4fbc:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    4fc0:	fc 01       	movw	r30, r24
    4fc2:	86 89       	ldd	r24, Z+22	; 0x16
    4fc4:	82 17       	cp	r24, r18
    4fc6:	18 f4       	brcc	.+6      	; 0x4fce <vTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4fc8:	81 e0       	ldi	r24, 0x01	; 1
    4fca:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
	}
}
    4fce:	00 00       	nop
    4fd0:	26 96       	adiw	r28, 0x06	; 6
    4fd2:	0f b6       	in	r0, 0x3f	; 63
    4fd4:	f8 94       	cli
    4fd6:	de bf       	out	0x3e, r29	; 62
    4fd8:	0f be       	out	0x3f, r0	; 63
    4fda:	cd bf       	out	0x3d, r28	; 61
    4fdc:	df 91       	pop	r29
    4fde:	cf 91       	pop	r28
    4fe0:	08 95       	ret

00004fe2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4fe2:	cf 93       	push	r28
    4fe4:	df 93       	push	r29
    4fe6:	00 d0       	rcall	.+0      	; 0x4fe8 <vTaskSetTimeOutState+0x6>
    4fe8:	cd b7       	in	r28, 0x3d	; 61
    4fea:	de b7       	in	r29, 0x3e	; 62
    4fec:	9a 83       	std	Y+2, r25	; 0x02
    4fee:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4ff0:	0f b6       	in	r0, 0x3f	; 63
    4ff2:	f8 94       	cli
    4ff4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4ff6:	20 91 05 07 	lds	r18, 0x0705	; 0x800705 <xNumOfOverflows>
    4ffa:	89 81       	ldd	r24, Y+1	; 0x01
    4ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    4ffe:	fc 01       	movw	r30, r24
    5000:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    5002:	20 91 ff 06 	lds	r18, 0x06FF	; 0x8006ff <xTickCount>
    5006:	30 91 00 07 	lds	r19, 0x0700	; 0x800700 <xTickCount+0x1>
    500a:	89 81       	ldd	r24, Y+1	; 0x01
    500c:	9a 81       	ldd	r25, Y+2	; 0x02
    500e:	fc 01       	movw	r30, r24
    5010:	32 83       	std	Z+2, r19	; 0x02
    5012:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    5014:	0f 90       	pop	r0
    5016:	0f be       	out	0x3f, r0	; 63
}
    5018:	00 00       	nop
    501a:	0f 90       	pop	r0
    501c:	0f 90       	pop	r0
    501e:	df 91       	pop	r29
    5020:	cf 91       	pop	r28
    5022:	08 95       	ret

00005024 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5024:	cf 93       	push	r28
    5026:	df 93       	push	r29
    5028:	00 d0       	rcall	.+0      	; 0x502a <vTaskInternalSetTimeOutState+0x6>
    502a:	cd b7       	in	r28, 0x3d	; 61
    502c:	de b7       	in	r29, 0x3e	; 62
    502e:	9a 83       	std	Y+2, r25	; 0x02
    5030:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5032:	20 91 05 07 	lds	r18, 0x0705	; 0x800705 <xNumOfOverflows>
    5036:	89 81       	ldd	r24, Y+1	; 0x01
    5038:	9a 81       	ldd	r25, Y+2	; 0x02
    503a:	fc 01       	movw	r30, r24
    503c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    503e:	20 91 ff 06 	lds	r18, 0x06FF	; 0x8006ff <xTickCount>
    5042:	30 91 00 07 	lds	r19, 0x0700	; 0x800700 <xTickCount+0x1>
    5046:	89 81       	ldd	r24, Y+1	; 0x01
    5048:	9a 81       	ldd	r25, Y+2	; 0x02
    504a:	fc 01       	movw	r30, r24
    504c:	32 83       	std	Z+2, r19	; 0x02
    504e:	21 83       	std	Z+1, r18	; 0x01
}
    5050:	00 00       	nop
    5052:	0f 90       	pop	r0
    5054:	0f 90       	pop	r0
    5056:	df 91       	pop	r29
    5058:	cf 91       	pop	r28
    505a:	08 95       	ret

0000505c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    505c:	cf 93       	push	r28
    505e:	df 93       	push	r29
    5060:	cd b7       	in	r28, 0x3d	; 61
    5062:	de b7       	in	r29, 0x3e	; 62
    5064:	29 97       	sbiw	r28, 0x09	; 9
    5066:	0f b6       	in	r0, 0x3f	; 63
    5068:	f8 94       	cli
    506a:	de bf       	out	0x3e, r29	; 62
    506c:	0f be       	out	0x3f, r0	; 63
    506e:	cd bf       	out	0x3d, r28	; 61
    5070:	9f 83       	std	Y+7, r25	; 0x07
    5072:	8e 83       	std	Y+6, r24	; 0x06
    5074:	79 87       	std	Y+9, r23	; 0x09
    5076:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5078:	0f b6       	in	r0, 0x3f	; 63
    507a:	f8 94       	cli
    507c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    507e:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xTickCount>
    5082:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xTickCount+0x1>
    5086:	9b 83       	std	Y+3, r25	; 0x03
    5088:	8a 83       	std	Y+2, r24	; 0x02
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    508a:	8e 81       	ldd	r24, Y+6	; 0x06
    508c:	9f 81       	ldd	r25, Y+7	; 0x07
    508e:	fc 01       	movw	r30, r24
    5090:	81 81       	ldd	r24, Z+1	; 0x01
    5092:	92 81       	ldd	r25, Z+2	; 0x02
    5094:	2a 81       	ldd	r18, Y+2	; 0x02
    5096:	3b 81       	ldd	r19, Y+3	; 0x03
    5098:	a9 01       	movw	r20, r18
    509a:	48 1b       	sub	r20, r24
    509c:	59 0b       	sbc	r21, r25
    509e:	ca 01       	movw	r24, r20
    50a0:	9d 83       	std	Y+5, r25	; 0x05
    50a2:	8c 83       	std	Y+4, r24	; 0x04
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    50a4:	88 85       	ldd	r24, Y+8	; 0x08
    50a6:	99 85       	ldd	r25, Y+9	; 0x09
    50a8:	fc 01       	movw	r30, r24
    50aa:	80 81       	ld	r24, Z
    50ac:	91 81       	ldd	r25, Z+1	; 0x01
    50ae:	01 96       	adiw	r24, 0x01	; 1
    50b0:	11 f4       	brne	.+4      	; 0x50b6 <xTaskCheckForTimeOut+0x5a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    50b2:	19 82       	std	Y+1, r1	; 0x01
    50b4:	3a c0       	rjmp	.+116    	; 0x512a <xTaskCheckForTimeOut+0xce>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    50b6:	8e 81       	ldd	r24, Y+6	; 0x06
    50b8:	9f 81       	ldd	r25, Y+7	; 0x07
    50ba:	fc 01       	movw	r30, r24
    50bc:	90 81       	ld	r25, Z
    50be:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <xNumOfOverflows>
    50c2:	98 17       	cp	r25, r24
    50c4:	69 f0       	breq	.+26     	; 0x50e0 <xTaskCheckForTimeOut+0x84>
    50c6:	8e 81       	ldd	r24, Y+6	; 0x06
    50c8:	9f 81       	ldd	r25, Y+7	; 0x07
    50ca:	fc 01       	movw	r30, r24
    50cc:	21 81       	ldd	r18, Z+1	; 0x01
    50ce:	32 81       	ldd	r19, Z+2	; 0x02
    50d0:	8a 81       	ldd	r24, Y+2	; 0x02
    50d2:	9b 81       	ldd	r25, Y+3	; 0x03
    50d4:	82 17       	cp	r24, r18
    50d6:	93 07       	cpc	r25, r19
    50d8:	18 f0       	brcs	.+6      	; 0x50e0 <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    50da:	81 e0       	ldi	r24, 0x01	; 1
    50dc:	89 83       	std	Y+1, r24	; 0x01
    50de:	25 c0       	rjmp	.+74     	; 0x512a <xTaskCheckForTimeOut+0xce>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    50e0:	88 85       	ldd	r24, Y+8	; 0x08
    50e2:	99 85       	ldd	r25, Y+9	; 0x09
    50e4:	fc 01       	movw	r30, r24
    50e6:	20 81       	ld	r18, Z
    50e8:	31 81       	ldd	r19, Z+1	; 0x01
    50ea:	8c 81       	ldd	r24, Y+4	; 0x04
    50ec:	9d 81       	ldd	r25, Y+5	; 0x05
    50ee:	82 17       	cp	r24, r18
    50f0:	93 07       	cpc	r25, r19
    50f2:	a0 f4       	brcc	.+40     	; 0x511c <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    50f4:	88 85       	ldd	r24, Y+8	; 0x08
    50f6:	99 85       	ldd	r25, Y+9	; 0x09
    50f8:	fc 01       	movw	r30, r24
    50fa:	20 81       	ld	r18, Z
    50fc:	31 81       	ldd	r19, Z+1	; 0x01
    50fe:	8c 81       	ldd	r24, Y+4	; 0x04
    5100:	9d 81       	ldd	r25, Y+5	; 0x05
    5102:	28 1b       	sub	r18, r24
    5104:	39 0b       	sbc	r19, r25
    5106:	88 85       	ldd	r24, Y+8	; 0x08
    5108:	99 85       	ldd	r25, Y+9	; 0x09
    510a:	fc 01       	movw	r30, r24
    510c:	31 83       	std	Z+1, r19	; 0x01
    510e:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    5110:	8e 81       	ldd	r24, Y+6	; 0x06
    5112:	9f 81       	ldd	r25, Y+7	; 0x07
    5114:	0e 94 12 28 	call	0x5024	; 0x5024 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    5118:	19 82       	std	Y+1, r1	; 0x01
    511a:	07 c0       	rjmp	.+14     	; 0x512a <xTaskCheckForTimeOut+0xce>
		}
		else
		{
			*pxTicksToWait = 0;
    511c:	88 85       	ldd	r24, Y+8	; 0x08
    511e:	99 85       	ldd	r25, Y+9	; 0x09
    5120:	fc 01       	movw	r30, r24
    5122:	11 82       	std	Z+1, r1	; 0x01
    5124:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    5126:	81 e0       	ldi	r24, 0x01	; 1
    5128:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    512a:	0f 90       	pop	r0
    512c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    512e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5130:	29 96       	adiw	r28, 0x09	; 9
    5132:	0f b6       	in	r0, 0x3f	; 63
    5134:	f8 94       	cli
    5136:	de bf       	out	0x3e, r29	; 62
    5138:	0f be       	out	0x3f, r0	; 63
    513a:	cd bf       	out	0x3d, r28	; 61
    513c:	df 91       	pop	r29
    513e:	cf 91       	pop	r28
    5140:	08 95       	ret

00005142 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5142:	cf 93       	push	r28
    5144:	df 93       	push	r29
    5146:	cd b7       	in	r28, 0x3d	; 61
    5148:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    514a:	81 e0       	ldi	r24, 0x01	; 1
    514c:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
}
    5150:	00 00       	nop
    5152:	df 91       	pop	r29
    5154:	cf 91       	pop	r28
    5156:	08 95       	ret

00005158 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5158:	cf 93       	push	r28
    515a:	df 93       	push	r29
    515c:	00 d0       	rcall	.+0      	; 0x515e <prvIdleTask+0x6>
    515e:	cd b7       	in	r28, 0x3d	; 61
    5160:	de b7       	in	r29, 0x3e	; 62
    5162:	9a 83       	std	Y+2, r25	; 0x02
    5164:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5166:	0e 94 fe 28 	call	0x51fc	; 0x51fc <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    516a:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <pxReadyTasksLists>
    516e:	82 30       	cpi	r24, 0x02	; 2
    5170:	d0 f3       	brcs	.-12     	; 0x5166 <prvIdleTask+0xe>
			{
				taskYIELD();
    5172:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    5176:	f7 cf       	rjmp	.-18     	; 0x5166 <prvIdleTask+0xe>

00005178 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5178:	cf 93       	push	r28
    517a:	df 93       	push	r29
    517c:	1f 92       	push	r1
    517e:	cd b7       	in	r28, 0x3d	; 61
    5180:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5182:	19 82       	std	Y+1, r1	; 0x01
    5184:	13 c0       	rjmp	.+38     	; 0x51ac <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5186:	89 81       	ldd	r24, Y+1	; 0x01
    5188:	28 2f       	mov	r18, r24
    518a:	30 e0       	ldi	r19, 0x00	; 0
    518c:	c9 01       	movw	r24, r18
    518e:	88 0f       	add	r24, r24
    5190:	99 1f       	adc	r25, r25
    5192:	88 0f       	add	r24, r24
    5194:	99 1f       	adc	r25, r25
    5196:	88 0f       	add	r24, r24
    5198:	99 1f       	adc	r25, r25
    519a:	82 0f       	add	r24, r18
    519c:	93 1f       	adc	r25, r19
    519e:	81 56       	subi	r24, 0x61	; 97
    51a0:	99 4f       	sbci	r25, 0xF9	; 249
    51a2:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    51a6:	89 81       	ldd	r24, Y+1	; 0x01
    51a8:	8f 5f       	subi	r24, 0xFF	; 255
    51aa:	89 83       	std	Y+1, r24	; 0x01
    51ac:	89 81       	ldd	r24, Y+1	; 0x01
    51ae:	85 30       	cpi	r24, 0x05	; 5
    51b0:	50 f3       	brcs	.-44     	; 0x5186 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    51b2:	8c ec       	ldi	r24, 0xCC	; 204
    51b4:	96 e0       	ldi	r25, 0x06	; 6
    51b6:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    51ba:	85 ed       	ldi	r24, 0xD5	; 213
    51bc:	96 e0       	ldi	r25, 0x06	; 6
    51be:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    51c2:	82 ee       	ldi	r24, 0xE2	; 226
    51c4:	96 e0       	ldi	r25, 0x06	; 6
    51c6:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    51ca:	8b ee       	ldi	r24, 0xEB	; 235
    51cc:	96 e0       	ldi	r25, 0x06	; 6
    51ce:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    51d2:	85 ef       	ldi	r24, 0xF5	; 245
    51d4:	96 e0       	ldi	r25, 0x06	; 6
    51d6:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    51da:	8c ec       	ldi	r24, 0xCC	; 204
    51dc:	96 e0       	ldi	r25, 0x06	; 6
    51de:	90 93 df 06 	sts	0x06DF, r25	; 0x8006df <pxDelayedTaskList+0x1>
    51e2:	80 93 de 06 	sts	0x06DE, r24	; 0x8006de <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    51e6:	85 ed       	ldi	r24, 0xD5	; 213
    51e8:	96 e0       	ldi	r25, 0x06	; 6
    51ea:	90 93 e1 06 	sts	0x06E1, r25	; 0x8006e1 <pxOverflowDelayedTaskList+0x1>
    51ee:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <pxOverflowDelayedTaskList>
}
    51f2:	00 00       	nop
    51f4:	0f 90       	pop	r0
    51f6:	df 91       	pop	r29
    51f8:	cf 91       	pop	r28
    51fa:	08 95       	ret

000051fc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    51fc:	cf 93       	push	r28
    51fe:	df 93       	push	r29
    5200:	00 d0       	rcall	.+0      	; 0x5202 <prvCheckTasksWaitingTermination+0x6>
    5202:	cd b7       	in	r28, 0x3d	; 61
    5204:	de b7       	in	r29, 0x3e	; 62
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5206:	21 c0       	rjmp	.+66     	; 0x524a <prvCheckTasksWaitingTermination+0x4e>
		{
			taskENTER_CRITICAL();
    5208:	0f b6       	in	r0, 0x3f	; 63
    520a:	f8 94       	cli
    520c:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    520e:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <xTasksWaitingTermination+0x5>
    5212:	90 91 f1 06 	lds	r25, 0x06F1	; 0x8006f1 <xTasksWaitingTermination+0x6>
    5216:	fc 01       	movw	r30, r24
    5218:	86 81       	ldd	r24, Z+6	; 0x06
    521a:	97 81       	ldd	r25, Z+7	; 0x07
    521c:	9a 83       	std	Y+2, r25	; 0x02
    521e:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5220:	89 81       	ldd	r24, Y+1	; 0x01
    5222:	9a 81       	ldd	r25, Y+2	; 0x02
    5224:	02 96       	adiw	r24, 0x02	; 2
    5226:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
				--uxCurrentNumberOfTasks;
    522a:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxCurrentNumberOfTasks>
    522e:	81 50       	subi	r24, 0x01	; 1
    5230:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
    5234:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <uxDeletedTasksWaitingCleanUp>
    5238:	81 50       	subi	r24, 0x01	; 1
    523a:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
    523e:	0f 90       	pop	r0
    5240:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    5242:	89 81       	ldd	r24, Y+1	; 0x01
    5244:	9a 81       	ldd	r25, Y+2	; 0x02
    5246:	0e 94 2f 29 	call	0x525e	; 0x525e <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    524a:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <uxDeletedTasksWaitingCleanUp>
    524e:	88 23       	and	r24, r24
    5250:	d9 f6       	brne	.-74     	; 0x5208 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5252:	00 00       	nop
    5254:	0f 90       	pop	r0
    5256:	0f 90       	pop	r0
    5258:	df 91       	pop	r29
    525a:	cf 91       	pop	r28
    525c:	08 95       	ret

0000525e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    525e:	cf 93       	push	r28
    5260:	df 93       	push	r29
    5262:	00 d0       	rcall	.+0      	; 0x5264 <prvDeleteTCB+0x6>
    5264:	cd b7       	in	r28, 0x3d	; 61
    5266:	de b7       	in	r29, 0x3e	; 62
    5268:	9a 83       	std	Y+2, r25	; 0x02
    526a:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    526c:	89 81       	ldd	r24, Y+1	; 0x01
    526e:	9a 81       	ldd	r25, Y+2	; 0x02
    5270:	fc 01       	movw	r30, r24
    5272:	87 89       	ldd	r24, Z+23	; 0x17
    5274:	90 8d       	ldd	r25, Z+24	; 0x18
    5276:	0e 94 b6 12 	call	0x256c	; 0x256c <vPortFree>
			vPortFree( pxTCB );
    527a:	89 81       	ldd	r24, Y+1	; 0x01
    527c:	9a 81       	ldd	r25, Y+2	; 0x02
    527e:	0e 94 b6 12 	call	0x256c	; 0x256c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5282:	00 00       	nop
    5284:	0f 90       	pop	r0
    5286:	0f 90       	pop	r0
    5288:	df 91       	pop	r29
    528a:	cf 91       	pop	r28
    528c:	08 95       	ret

0000528e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    528e:	cf 93       	push	r28
    5290:	df 93       	push	r29
    5292:	00 d0       	rcall	.+0      	; 0x5294 <prvResetNextTaskUnblockTime+0x6>
    5294:	cd b7       	in	r28, 0x3d	; 61
    5296:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5298:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <pxDelayedTaskList>
    529c:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <pxDelayedTaskList+0x1>
    52a0:	fc 01       	movw	r30, r24
    52a2:	80 81       	ld	r24, Z
    52a4:	88 23       	and	r24, r24
    52a6:	39 f4       	brne	.+14     	; 0x52b6 <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    52a8:	8f ef       	ldi	r24, 0xFF	; 255
    52aa:	9f ef       	ldi	r25, 0xFF	; 255
    52ac:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <xNextTaskUnblockTime+0x1>
    52b0:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNextTaskUnblockTime>
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
    52b4:	15 c0       	rjmp	.+42     	; 0x52e0 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    52b6:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <pxDelayedTaskList>
    52ba:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <pxDelayedTaskList+0x1>
    52be:	fc 01       	movw	r30, r24
    52c0:	85 81       	ldd	r24, Z+5	; 0x05
    52c2:	96 81       	ldd	r25, Z+6	; 0x06
    52c4:	fc 01       	movw	r30, r24
    52c6:	86 81       	ldd	r24, Z+6	; 0x06
    52c8:	97 81       	ldd	r25, Z+7	; 0x07
    52ca:	9a 83       	std	Y+2, r25	; 0x02
    52cc:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    52ce:	89 81       	ldd	r24, Y+1	; 0x01
    52d0:	9a 81       	ldd	r25, Y+2	; 0x02
    52d2:	fc 01       	movw	r30, r24
    52d4:	82 81       	ldd	r24, Z+2	; 0x02
    52d6:	93 81       	ldd	r25, Z+3	; 0x03
    52d8:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <xNextTaskUnblockTime+0x1>
    52dc:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNextTaskUnblockTime>
	}
}
    52e0:	00 00       	nop
    52e2:	0f 90       	pop	r0
    52e4:	0f 90       	pop	r0
    52e6:	df 91       	pop	r29
    52e8:	cf 91       	pop	r28
    52ea:	08 95       	ret

000052ec <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    52ec:	cf 93       	push	r28
    52ee:	df 93       	push	r29
    52f0:	00 d0       	rcall	.+0      	; 0x52f2 <xTaskGetCurrentTaskHandle+0x6>
    52f2:	cd b7       	in	r28, 0x3d	; 61
    52f4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    52f6:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    52fa:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    52fe:	9a 83       	std	Y+2, r25	; 0x02
    5300:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5302:	89 81       	ldd	r24, Y+1	; 0x01
    5304:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5306:	0f 90       	pop	r0
    5308:	0f 90       	pop	r0
    530a:	df 91       	pop	r29
    530c:	cf 91       	pop	r28
    530e:	08 95       	ret

00005310 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    5310:	cf 93       	push	r28
    5312:	df 93       	push	r29
    5314:	00 d0       	rcall	.+0      	; 0x5316 <xTaskPriorityInherit+0x6>
    5316:	00 d0       	rcall	.+0      	; 0x5318 <xTaskPriorityInherit+0x8>
    5318:	1f 92       	push	r1
    531a:	cd b7       	in	r28, 0x3d	; 61
    531c:	de b7       	in	r29, 0x3e	; 62
    531e:	9d 83       	std	Y+5, r25	; 0x05
    5320:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    5322:	8c 81       	ldd	r24, Y+4	; 0x04
    5324:	9d 81       	ldd	r25, Y+5	; 0x05
    5326:	9b 83       	std	Y+3, r25	; 0x03
    5328:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    532a:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    532c:	8c 81       	ldd	r24, Y+4	; 0x04
    532e:	9d 81       	ldd	r25, Y+5	; 0x05
    5330:	89 2b       	or	r24, r25
    5332:	09 f4       	brne	.+2      	; 0x5336 <xTaskPriorityInherit+0x26>
    5334:	90 c0       	rjmp	.+288    	; 0x5456 <xTaskPriorityInherit+0x146>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    5336:	8a 81       	ldd	r24, Y+2	; 0x02
    5338:	9b 81       	ldd	r25, Y+3	; 0x03
    533a:	fc 01       	movw	r30, r24
    533c:	26 89       	ldd	r18, Z+22	; 0x16
    533e:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5342:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5346:	fc 01       	movw	r30, r24
    5348:	86 89       	ldd	r24, Z+22	; 0x16
    534a:	28 17       	cp	r18, r24
    534c:	08 f0       	brcs	.+2      	; 0x5350 <xTaskPriorityInherit+0x40>
    534e:	75 c0       	rjmp	.+234    	; 0x543a <xTaskPriorityInherit+0x12a>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    5350:	8a 81       	ldd	r24, Y+2	; 0x02
    5352:	9b 81       	ldd	r25, Y+3	; 0x03
    5354:	fc 01       	movw	r30, r24
    5356:	84 85       	ldd	r24, Z+12	; 0x0c
    5358:	95 85       	ldd	r25, Z+13	; 0x0d
    535a:	99 23       	and	r25, r25
    535c:	8c f0       	brlt	.+34     	; 0x5380 <xTaskPriorityInherit+0x70>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    535e:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5362:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5366:	fc 01       	movw	r30, r24
    5368:	86 89       	ldd	r24, Z+22	; 0x16
    536a:	88 2f       	mov	r24, r24
    536c:	90 e0       	ldi	r25, 0x00	; 0
    536e:	25 e0       	ldi	r18, 0x05	; 5
    5370:	30 e0       	ldi	r19, 0x00	; 0
    5372:	28 1b       	sub	r18, r24
    5374:	39 0b       	sbc	r19, r25
    5376:	8a 81       	ldd	r24, Y+2	; 0x02
    5378:	9b 81       	ldd	r25, Y+3	; 0x03
    537a:	fc 01       	movw	r30, r24
    537c:	35 87       	std	Z+13, r19	; 0x0d
    537e:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    5380:	8a 81       	ldd	r24, Y+2	; 0x02
    5382:	9b 81       	ldd	r25, Y+3	; 0x03
    5384:	fc 01       	movw	r30, r24
    5386:	42 85       	ldd	r20, Z+10	; 0x0a
    5388:	53 85       	ldd	r21, Z+11	; 0x0b
    538a:	8a 81       	ldd	r24, Y+2	; 0x02
    538c:	9b 81       	ldd	r25, Y+3	; 0x03
    538e:	fc 01       	movw	r30, r24
    5390:	86 89       	ldd	r24, Z+22	; 0x16
    5392:	28 2f       	mov	r18, r24
    5394:	30 e0       	ldi	r19, 0x00	; 0
    5396:	c9 01       	movw	r24, r18
    5398:	88 0f       	add	r24, r24
    539a:	99 1f       	adc	r25, r25
    539c:	88 0f       	add	r24, r24
    539e:	99 1f       	adc	r25, r25
    53a0:	88 0f       	add	r24, r24
    53a2:	99 1f       	adc	r25, r25
    53a4:	82 0f       	add	r24, r18
    53a6:	93 1f       	adc	r25, r19
    53a8:	81 56       	subi	r24, 0x61	; 97
    53aa:	99 4f       	sbci	r25, 0xF9	; 249
    53ac:	48 17       	cp	r20, r24
    53ae:	59 07       	cpc	r21, r25
    53b0:	b9 f5       	brne	.+110    	; 0x5420 <xTaskPriorityInherit+0x110>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    53b2:	8a 81       	ldd	r24, Y+2	; 0x02
    53b4:	9b 81       	ldd	r25, Y+3	; 0x03
    53b6:	02 96       	adiw	r24, 0x02	; 2
    53b8:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    53bc:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    53c0:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    53c4:	fc 01       	movw	r30, r24
    53c6:	26 89       	ldd	r18, Z+22	; 0x16
    53c8:	8a 81       	ldd	r24, Y+2	; 0x02
    53ca:	9b 81       	ldd	r25, Y+3	; 0x03
    53cc:	fc 01       	movw	r30, r24
    53ce:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    53d0:	8a 81       	ldd	r24, Y+2	; 0x02
    53d2:	9b 81       	ldd	r25, Y+3	; 0x03
    53d4:	fc 01       	movw	r30, r24
    53d6:	96 89       	ldd	r25, Z+22	; 0x16
    53d8:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    53dc:	89 17       	cp	r24, r25
    53de:	30 f4       	brcc	.+12     	; 0x53ec <xTaskPriorityInherit+0xdc>
    53e0:	8a 81       	ldd	r24, Y+2	; 0x02
    53e2:	9b 81       	ldd	r25, Y+3	; 0x03
    53e4:	fc 01       	movw	r30, r24
    53e6:	86 89       	ldd	r24, Z+22	; 0x16
    53e8:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    53ec:	8a 81       	ldd	r24, Y+2	; 0x02
    53ee:	9b 81       	ldd	r25, Y+3	; 0x03
    53f0:	ac 01       	movw	r20, r24
    53f2:	4e 5f       	subi	r20, 0xFE	; 254
    53f4:	5f 4f       	sbci	r21, 0xFF	; 255
    53f6:	8a 81       	ldd	r24, Y+2	; 0x02
    53f8:	9b 81       	ldd	r25, Y+3	; 0x03
    53fa:	fc 01       	movw	r30, r24
    53fc:	86 89       	ldd	r24, Z+22	; 0x16
    53fe:	28 2f       	mov	r18, r24
    5400:	30 e0       	ldi	r19, 0x00	; 0
    5402:	c9 01       	movw	r24, r18
    5404:	88 0f       	add	r24, r24
    5406:	99 1f       	adc	r25, r25
    5408:	88 0f       	add	r24, r24
    540a:	99 1f       	adc	r25, r25
    540c:	88 0f       	add	r24, r24
    540e:	99 1f       	adc	r25, r25
    5410:	82 0f       	add	r24, r18
    5412:	93 1f       	adc	r25, r19
    5414:	81 56       	subi	r24, 0x61	; 97
    5416:	99 4f       	sbci	r25, 0xF9	; 249
    5418:	ba 01       	movw	r22, r20
    541a:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
    541e:	0a c0       	rjmp	.+20     	; 0x5434 <xTaskPriorityInherit+0x124>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    5420:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5424:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5428:	fc 01       	movw	r30, r24
    542a:	26 89       	ldd	r18, Z+22	; 0x16
    542c:	8a 81       	ldd	r24, Y+2	; 0x02
    542e:	9b 81       	ldd	r25, Y+3	; 0x03
    5430:	fc 01       	movw	r30, r24
    5432:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    5434:	81 e0       	ldi	r24, 0x01	; 1
    5436:	89 83       	std	Y+1, r24	; 0x01
    5438:	0e c0       	rjmp	.+28     	; 0x5456 <xTaskPriorityInherit+0x146>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    543a:	8a 81       	ldd	r24, Y+2	; 0x02
    543c:	9b 81       	ldd	r25, Y+3	; 0x03
    543e:	fc 01       	movw	r30, r24
    5440:	21 a1       	ldd	r18, Z+33	; 0x21
    5442:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5446:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    544a:	fc 01       	movw	r30, r24
    544c:	86 89       	ldd	r24, Z+22	; 0x16
    544e:	28 17       	cp	r18, r24
    5450:	10 f4       	brcc	.+4      	; 0x5456 <xTaskPriorityInherit+0x146>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    5452:	81 e0       	ldi	r24, 0x01	; 1
    5454:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5456:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5458:	0f 90       	pop	r0
    545a:	0f 90       	pop	r0
    545c:	0f 90       	pop	r0
    545e:	0f 90       	pop	r0
    5460:	0f 90       	pop	r0
    5462:	df 91       	pop	r29
    5464:	cf 91       	pop	r28
    5466:	08 95       	ret

00005468 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    5468:	cf 93       	push	r28
    546a:	df 93       	push	r29
    546c:	00 d0       	rcall	.+0      	; 0x546e <xTaskPriorityDisinherit+0x6>
    546e:	00 d0       	rcall	.+0      	; 0x5470 <xTaskPriorityDisinherit+0x8>
    5470:	1f 92       	push	r1
    5472:	cd b7       	in	r28, 0x3d	; 61
    5474:	de b7       	in	r29, 0x3e	; 62
    5476:	9d 83       	std	Y+5, r25	; 0x05
    5478:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    547a:	8c 81       	ldd	r24, Y+4	; 0x04
    547c:	9d 81       	ldd	r25, Y+5	; 0x05
    547e:	9b 83       	std	Y+3, r25	; 0x03
    5480:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    5482:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    5484:	8c 81       	ldd	r24, Y+4	; 0x04
    5486:	9d 81       	ldd	r25, Y+5	; 0x05
    5488:	89 2b       	or	r24, r25
    548a:	09 f4       	brne	.+2      	; 0x548e <xTaskPriorityDisinherit+0x26>
    548c:	61 c0       	rjmp	.+194    	; 0x5550 <xTaskPriorityDisinherit+0xe8>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    548e:	8a 81       	ldd	r24, Y+2	; 0x02
    5490:	9b 81       	ldd	r25, Y+3	; 0x03
    5492:	fc 01       	movw	r30, r24
    5494:	82 a1       	ldd	r24, Z+34	; 0x22
    5496:	2f ef       	ldi	r18, 0xFF	; 255
    5498:	28 0f       	add	r18, r24
    549a:	8a 81       	ldd	r24, Y+2	; 0x02
    549c:	9b 81       	ldd	r25, Y+3	; 0x03
    549e:	fc 01       	movw	r30, r24
    54a0:	22 a3       	std	Z+34, r18	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    54a2:	8a 81       	ldd	r24, Y+2	; 0x02
    54a4:	9b 81       	ldd	r25, Y+3	; 0x03
    54a6:	fc 01       	movw	r30, r24
    54a8:	26 89       	ldd	r18, Z+22	; 0x16
    54aa:	8a 81       	ldd	r24, Y+2	; 0x02
    54ac:	9b 81       	ldd	r25, Y+3	; 0x03
    54ae:	fc 01       	movw	r30, r24
    54b0:	81 a1       	ldd	r24, Z+33	; 0x21
    54b2:	28 17       	cp	r18, r24
    54b4:	09 f4       	brne	.+2      	; 0x54b8 <xTaskPriorityDisinherit+0x50>
    54b6:	4c c0       	rjmp	.+152    	; 0x5550 <xTaskPriorityDisinherit+0xe8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    54b8:	8a 81       	ldd	r24, Y+2	; 0x02
    54ba:	9b 81       	ldd	r25, Y+3	; 0x03
    54bc:	fc 01       	movw	r30, r24
    54be:	82 a1       	ldd	r24, Z+34	; 0x22
    54c0:	88 23       	and	r24, r24
    54c2:	09 f0       	breq	.+2      	; 0x54c6 <xTaskPriorityDisinherit+0x5e>
    54c4:	45 c0       	rjmp	.+138    	; 0x5550 <xTaskPriorityDisinherit+0xe8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    54c6:	8a 81       	ldd	r24, Y+2	; 0x02
    54c8:	9b 81       	ldd	r25, Y+3	; 0x03
    54ca:	02 96       	adiw	r24, 0x02	; 2
    54cc:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    54d0:	8a 81       	ldd	r24, Y+2	; 0x02
    54d2:	9b 81       	ldd	r25, Y+3	; 0x03
    54d4:	fc 01       	movw	r30, r24
    54d6:	21 a1       	ldd	r18, Z+33	; 0x21
    54d8:	8a 81       	ldd	r24, Y+2	; 0x02
    54da:	9b 81       	ldd	r25, Y+3	; 0x03
    54dc:	fc 01       	movw	r30, r24
    54de:	26 8b       	std	Z+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    54e0:	8a 81       	ldd	r24, Y+2	; 0x02
    54e2:	9b 81       	ldd	r25, Y+3	; 0x03
    54e4:	fc 01       	movw	r30, r24
    54e6:	86 89       	ldd	r24, Z+22	; 0x16
    54e8:	88 2f       	mov	r24, r24
    54ea:	90 e0       	ldi	r25, 0x00	; 0
    54ec:	25 e0       	ldi	r18, 0x05	; 5
    54ee:	30 e0       	ldi	r19, 0x00	; 0
    54f0:	28 1b       	sub	r18, r24
    54f2:	39 0b       	sbc	r19, r25
    54f4:	8a 81       	ldd	r24, Y+2	; 0x02
    54f6:	9b 81       	ldd	r25, Y+3	; 0x03
    54f8:	fc 01       	movw	r30, r24
    54fa:	35 87       	std	Z+13, r19	; 0x0d
    54fc:	24 87       	std	Z+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    54fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5500:	9b 81       	ldd	r25, Y+3	; 0x03
    5502:	fc 01       	movw	r30, r24
    5504:	96 89       	ldd	r25, Z+22	; 0x16
    5506:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    550a:	89 17       	cp	r24, r25
    550c:	30 f4       	brcc	.+12     	; 0x551a <xTaskPriorityDisinherit+0xb2>
    550e:	8a 81       	ldd	r24, Y+2	; 0x02
    5510:	9b 81       	ldd	r25, Y+3	; 0x03
    5512:	fc 01       	movw	r30, r24
    5514:	86 89       	ldd	r24, Z+22	; 0x16
    5516:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    551a:	8a 81       	ldd	r24, Y+2	; 0x02
    551c:	9b 81       	ldd	r25, Y+3	; 0x03
    551e:	ac 01       	movw	r20, r24
    5520:	4e 5f       	subi	r20, 0xFE	; 254
    5522:	5f 4f       	sbci	r21, 0xFF	; 255
    5524:	8a 81       	ldd	r24, Y+2	; 0x02
    5526:	9b 81       	ldd	r25, Y+3	; 0x03
    5528:	fc 01       	movw	r30, r24
    552a:	86 89       	ldd	r24, Z+22	; 0x16
    552c:	28 2f       	mov	r18, r24
    552e:	30 e0       	ldi	r19, 0x00	; 0
    5530:	c9 01       	movw	r24, r18
    5532:	88 0f       	add	r24, r24
    5534:	99 1f       	adc	r25, r25
    5536:	88 0f       	add	r24, r24
    5538:	99 1f       	adc	r25, r25
    553a:	88 0f       	add	r24, r24
    553c:	99 1f       	adc	r25, r25
    553e:	82 0f       	add	r24, r18
    5540:	93 1f       	adc	r25, r19
    5542:	81 56       	subi	r24, 0x61	; 97
    5544:	99 4f       	sbci	r25, 0xF9	; 249
    5546:	ba 01       	movw	r22, r20
    5548:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    554c:	81 e0       	ldi	r24, 0x01	; 1
    554e:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5550:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5552:	0f 90       	pop	r0
    5554:	0f 90       	pop	r0
    5556:	0f 90       	pop	r0
    5558:	0f 90       	pop	r0
    555a:	0f 90       	pop	r0
    555c:	df 91       	pop	r29
    555e:	cf 91       	pop	r28
    5560:	08 95       	ret

00005562 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    5562:	cf 93       	push	r28
    5564:	df 93       	push	r29
    5566:	cd b7       	in	r28, 0x3d	; 61
    5568:	de b7       	in	r29, 0x3e	; 62
    556a:	28 97       	sbiw	r28, 0x08	; 8
    556c:	0f b6       	in	r0, 0x3f	; 63
    556e:	f8 94       	cli
    5570:	de bf       	out	0x3e, r29	; 62
    5572:	0f be       	out	0x3f, r0	; 63
    5574:	cd bf       	out	0x3d, r28	; 61
    5576:	9f 83       	std	Y+7, r25	; 0x07
    5578:	8e 83       	std	Y+6, r24	; 0x06
    557a:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    557c:	8e 81       	ldd	r24, Y+6	; 0x06
    557e:	9f 81       	ldd	r25, Y+7	; 0x07
    5580:	9b 83       	std	Y+3, r25	; 0x03
    5582:	8a 83       	std	Y+2, r24	; 0x02
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    5584:	81 e0       	ldi	r24, 0x01	; 1
    5586:	8c 83       	std	Y+4, r24	; 0x04

		if( pxMutexHolder != NULL )
    5588:	8e 81       	ldd	r24, Y+6	; 0x06
    558a:	9f 81       	ldd	r25, Y+7	; 0x07
    558c:	89 2b       	or	r24, r25
    558e:	09 f4       	brne	.+2      	; 0x5592 <vTaskPriorityDisinheritAfterTimeout+0x30>
    5590:	7e c0       	rjmp	.+252    	; 0x568e <vTaskPriorityDisinheritAfterTimeout+0x12c>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    5592:	8a 81       	ldd	r24, Y+2	; 0x02
    5594:	9b 81       	ldd	r25, Y+3	; 0x03
    5596:	fc 01       	movw	r30, r24
    5598:	91 a1       	ldd	r25, Z+33	; 0x21
    559a:	88 85       	ldd	r24, Y+8	; 0x08
    559c:	98 17       	cp	r25, r24
    559e:	18 f4       	brcc	.+6      	; 0x55a6 <vTaskPriorityDisinheritAfterTimeout+0x44>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    55a0:	88 85       	ldd	r24, Y+8	; 0x08
    55a2:	89 83       	std	Y+1, r24	; 0x01
    55a4:	05 c0       	rjmp	.+10     	; 0x55b0 <vTaskPriorityDisinheritAfterTimeout+0x4e>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    55a6:	8a 81       	ldd	r24, Y+2	; 0x02
    55a8:	9b 81       	ldd	r25, Y+3	; 0x03
    55aa:	fc 01       	movw	r30, r24
    55ac:	81 a1       	ldd	r24, Z+33	; 0x21
    55ae:	89 83       	std	Y+1, r24	; 0x01
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    55b0:	8a 81       	ldd	r24, Y+2	; 0x02
    55b2:	9b 81       	ldd	r25, Y+3	; 0x03
    55b4:	fc 01       	movw	r30, r24
    55b6:	96 89       	ldd	r25, Z+22	; 0x16
    55b8:	89 81       	ldd	r24, Y+1	; 0x01
    55ba:	98 17       	cp	r25, r24
    55bc:	09 f4       	brne	.+2      	; 0x55c0 <vTaskPriorityDisinheritAfterTimeout+0x5e>
    55be:	67 c0       	rjmp	.+206    	; 0x568e <vTaskPriorityDisinheritAfterTimeout+0x12c>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    55c0:	8a 81       	ldd	r24, Y+2	; 0x02
    55c2:	9b 81       	ldd	r25, Y+3	; 0x03
    55c4:	fc 01       	movw	r30, r24
    55c6:	92 a1       	ldd	r25, Z+34	; 0x22
    55c8:	8c 81       	ldd	r24, Y+4	; 0x04
    55ca:	98 17       	cp	r25, r24
    55cc:	09 f0       	breq	.+2      	; 0x55d0 <vTaskPriorityDisinheritAfterTimeout+0x6e>
    55ce:	5f c0       	rjmp	.+190    	; 0x568e <vTaskPriorityDisinheritAfterTimeout+0x12c>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    55d0:	8a 81       	ldd	r24, Y+2	; 0x02
    55d2:	9b 81       	ldd	r25, Y+3	; 0x03
    55d4:	fc 01       	movw	r30, r24
    55d6:	86 89       	ldd	r24, Z+22	; 0x16
    55d8:	8d 83       	std	Y+5, r24	; 0x05
					pxTCB->uxPriority = uxPriorityToUse;
    55da:	8a 81       	ldd	r24, Y+2	; 0x02
    55dc:	9b 81       	ldd	r25, Y+3	; 0x03
    55de:	29 81       	ldd	r18, Y+1	; 0x01
    55e0:	fc 01       	movw	r30, r24
    55e2:	26 8b       	std	Z+22, r18	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    55e4:	8a 81       	ldd	r24, Y+2	; 0x02
    55e6:	9b 81       	ldd	r25, Y+3	; 0x03
    55e8:	fc 01       	movw	r30, r24
    55ea:	84 85       	ldd	r24, Z+12	; 0x0c
    55ec:	95 85       	ldd	r25, Z+13	; 0x0d
    55ee:	99 23       	and	r25, r25
    55f0:	64 f0       	brlt	.+24     	; 0x560a <vTaskPriorityDisinheritAfterTimeout+0xa8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    55f2:	89 81       	ldd	r24, Y+1	; 0x01
    55f4:	88 2f       	mov	r24, r24
    55f6:	90 e0       	ldi	r25, 0x00	; 0
    55f8:	25 e0       	ldi	r18, 0x05	; 5
    55fa:	30 e0       	ldi	r19, 0x00	; 0
    55fc:	28 1b       	sub	r18, r24
    55fe:	39 0b       	sbc	r19, r25
    5600:	8a 81       	ldd	r24, Y+2	; 0x02
    5602:	9b 81       	ldd	r25, Y+3	; 0x03
    5604:	fc 01       	movw	r30, r24
    5606:	35 87       	std	Z+13, r19	; 0x0d
    5608:	24 87       	std	Z+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    560a:	8a 81       	ldd	r24, Y+2	; 0x02
    560c:	9b 81       	ldd	r25, Y+3	; 0x03
    560e:	fc 01       	movw	r30, r24
    5610:	42 85       	ldd	r20, Z+10	; 0x0a
    5612:	53 85       	ldd	r21, Z+11	; 0x0b
    5614:	8d 81       	ldd	r24, Y+5	; 0x05
    5616:	28 2f       	mov	r18, r24
    5618:	30 e0       	ldi	r19, 0x00	; 0
    561a:	c9 01       	movw	r24, r18
    561c:	88 0f       	add	r24, r24
    561e:	99 1f       	adc	r25, r25
    5620:	88 0f       	add	r24, r24
    5622:	99 1f       	adc	r25, r25
    5624:	88 0f       	add	r24, r24
    5626:	99 1f       	adc	r25, r25
    5628:	82 0f       	add	r24, r18
    562a:	93 1f       	adc	r25, r19
    562c:	81 56       	subi	r24, 0x61	; 97
    562e:	99 4f       	sbci	r25, 0xF9	; 249
    5630:	48 17       	cp	r20, r24
    5632:	59 07       	cpc	r21, r25
    5634:	61 f5       	brne	.+88     	; 0x568e <vTaskPriorityDisinheritAfterTimeout+0x12c>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5636:	8a 81       	ldd	r24, Y+2	; 0x02
    5638:	9b 81       	ldd	r25, Y+3	; 0x03
    563a:	02 96       	adiw	r24, 0x02	; 2
    563c:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    5640:	8a 81       	ldd	r24, Y+2	; 0x02
    5642:	9b 81       	ldd	r25, Y+3	; 0x03
    5644:	fc 01       	movw	r30, r24
    5646:	96 89       	ldd	r25, Z+22	; 0x16
    5648:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    564c:	89 17       	cp	r24, r25
    564e:	30 f4       	brcc	.+12     	; 0x565c <vTaskPriorityDisinheritAfterTimeout+0xfa>
    5650:	8a 81       	ldd	r24, Y+2	; 0x02
    5652:	9b 81       	ldd	r25, Y+3	; 0x03
    5654:	fc 01       	movw	r30, r24
    5656:	86 89       	ldd	r24, Z+22	; 0x16
    5658:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    565c:	8a 81       	ldd	r24, Y+2	; 0x02
    565e:	9b 81       	ldd	r25, Y+3	; 0x03
    5660:	ac 01       	movw	r20, r24
    5662:	4e 5f       	subi	r20, 0xFE	; 254
    5664:	5f 4f       	sbci	r21, 0xFF	; 255
    5666:	8a 81       	ldd	r24, Y+2	; 0x02
    5668:	9b 81       	ldd	r25, Y+3	; 0x03
    566a:	fc 01       	movw	r30, r24
    566c:	86 89       	ldd	r24, Z+22	; 0x16
    566e:	28 2f       	mov	r18, r24
    5670:	30 e0       	ldi	r19, 0x00	; 0
    5672:	c9 01       	movw	r24, r18
    5674:	88 0f       	add	r24, r24
    5676:	99 1f       	adc	r25, r25
    5678:	88 0f       	add	r24, r24
    567a:	99 1f       	adc	r25, r25
    567c:	88 0f       	add	r24, r24
    567e:	99 1f       	adc	r25, r25
    5680:	82 0f       	add	r24, r18
    5682:	93 1f       	adc	r25, r19
    5684:	81 56       	subi	r24, 0x61	; 97
    5686:	99 4f       	sbci	r25, 0xF9	; 249
    5688:	ba 01       	movw	r22, r20
    568a:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    568e:	00 00       	nop
    5690:	28 96       	adiw	r28, 0x08	; 8
    5692:	0f b6       	in	r0, 0x3f	; 63
    5694:	f8 94       	cli
    5696:	de bf       	out	0x3e, r29	; 62
    5698:	0f be       	out	0x3f, r0	; 63
    569a:	cd bf       	out	0x3d, r28	; 61
    569c:	df 91       	pop	r29
    569e:	cf 91       	pop	r28
    56a0:	08 95       	ret

000056a2 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    56a2:	cf 93       	push	r28
    56a4:	df 93       	push	r29
    56a6:	00 d0       	rcall	.+0      	; 0x56a8 <uxTaskResetEventItemValue+0x6>
    56a8:	cd b7       	in	r28, 0x3d	; 61
    56aa:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    56ac:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    56b0:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    56b4:	fc 01       	movw	r30, r24
    56b6:	84 85       	ldd	r24, Z+12	; 0x0c
    56b8:	95 85       	ldd	r25, Z+13	; 0x0d
    56ba:	9a 83       	std	Y+2, r25	; 0x02
    56bc:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    56be:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    56c2:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    56c6:	20 91 9d 06 	lds	r18, 0x069D	; 0x80069d <pxCurrentTCB>
    56ca:	30 91 9e 06 	lds	r19, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    56ce:	f9 01       	movw	r30, r18
    56d0:	26 89       	ldd	r18, Z+22	; 0x16
    56d2:	22 2f       	mov	r18, r18
    56d4:	30 e0       	ldi	r19, 0x00	; 0
    56d6:	45 e0       	ldi	r20, 0x05	; 5
    56d8:	50 e0       	ldi	r21, 0x00	; 0
    56da:	ba 01       	movw	r22, r20
    56dc:	62 1b       	sub	r22, r18
    56de:	73 0b       	sbc	r23, r19
    56e0:	9b 01       	movw	r18, r22
    56e2:	fc 01       	movw	r30, r24
    56e4:	35 87       	std	Z+13, r19	; 0x0d
    56e6:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    56e8:	89 81       	ldd	r24, Y+1	; 0x01
    56ea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    56ec:	0f 90       	pop	r0
    56ee:	0f 90       	pop	r0
    56f0:	df 91       	pop	r29
    56f2:	cf 91       	pop	r28
    56f4:	08 95       	ret

000056f6 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    56f6:	cf 93       	push	r28
    56f8:	df 93       	push	r29
    56fa:	cd b7       	in	r28, 0x3d	; 61
    56fc:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    56fe:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5702:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5706:	89 2b       	or	r24, r25
    5708:	49 f0       	breq	.+18     	; 0x571c <pvTaskIncrementMutexHeldCount+0x26>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    570a:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    570e:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5712:	fc 01       	movw	r30, r24
    5714:	22 a1       	ldd	r18, Z+34	; 0x22
    5716:	2f 5f       	subi	r18, 0xFF	; 255
    5718:	fc 01       	movw	r30, r24
    571a:	22 a3       	std	Z+34, r18	; 0x22
		}

		return pxCurrentTCB;
    571c:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5720:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
	}
    5724:	df 91       	pop	r29
    5726:	cf 91       	pop	r28
    5728:	08 95       	ret

0000572a <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    572a:	cf 93       	push	r28
    572c:	df 93       	push	r29
    572e:	cd b7       	in	r28, 0x3d	; 61
    5730:	de b7       	in	r29, 0x3e	; 62
    5732:	27 97       	sbiw	r28, 0x07	; 7
    5734:	0f b6       	in	r0, 0x3f	; 63
    5736:	f8 94       	cli
    5738:	de bf       	out	0x3e, r29	; 62
    573a:	0f be       	out	0x3f, r0	; 63
    573c:	cd bf       	out	0x3d, r28	; 61
    573e:	8d 83       	std	Y+5, r24	; 0x05
    5740:	7f 83       	std	Y+7, r23	; 0x07
    5742:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5744:	0f b6       	in	r0, 0x3f	; 63
    5746:	f8 94       	cli
    5748:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    574a:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    574e:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5752:	fc 01       	movw	r30, r24
    5754:	83 a1       	ldd	r24, Z+35	; 0x23
    5756:	94 a1       	ldd	r25, Z+36	; 0x24
    5758:	a5 a1       	ldd	r26, Z+37	; 0x25
    575a:	b6 a1       	ldd	r27, Z+38	; 0x26
    575c:	89 2b       	or	r24, r25
    575e:	8a 2b       	or	r24, r26
    5760:	8b 2b       	or	r24, r27
    5762:	91 f4       	brne	.+36     	; 0x5788 <ulTaskNotifyTake+0x5e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5764:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5768:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    576c:	21 e0       	ldi	r18, 0x01	; 1
    576e:	fc 01       	movw	r30, r24
    5770:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5772:	8e 81       	ldd	r24, Y+6	; 0x06
    5774:	9f 81       	ldd	r25, Y+7	; 0x07
    5776:	89 2b       	or	r24, r25
    5778:	39 f0       	breq	.+14     	; 0x5788 <ulTaskNotifyTake+0x5e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    577a:	8e 81       	ldd	r24, Y+6	; 0x06
    577c:	9f 81       	ldd	r25, Y+7	; 0x07
    577e:	61 e0       	ldi	r22, 0x01	; 1
    5780:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5784:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5788:	0f 90       	pop	r0
    578a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    578c:	0f b6       	in	r0, 0x3f	; 63
    578e:	f8 94       	cli
    5790:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5792:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5796:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    579a:	fc 01       	movw	r30, r24
    579c:	83 a1       	ldd	r24, Z+35	; 0x23
    579e:	94 a1       	ldd	r25, Z+36	; 0x24
    57a0:	a5 a1       	ldd	r26, Z+37	; 0x25
    57a2:	b6 a1       	ldd	r27, Z+38	; 0x26
    57a4:	89 83       	std	Y+1, r24	; 0x01
    57a6:	9a 83       	std	Y+2, r25	; 0x02
    57a8:	ab 83       	std	Y+3, r26	; 0x03
    57aa:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    57ac:	89 81       	ldd	r24, Y+1	; 0x01
    57ae:	9a 81       	ldd	r25, Y+2	; 0x02
    57b0:	ab 81       	ldd	r26, Y+3	; 0x03
    57b2:	bc 81       	ldd	r27, Y+4	; 0x04
    57b4:	89 2b       	or	r24, r25
    57b6:	8a 2b       	or	r24, r26
    57b8:	8b 2b       	or	r24, r27
    57ba:	e9 f0       	breq	.+58     	; 0x57f6 <ulTaskNotifyTake+0xcc>
			{
				if( xClearCountOnExit != pdFALSE )
    57bc:	8d 81       	ldd	r24, Y+5	; 0x05
    57be:	88 23       	and	r24, r24
    57c0:	51 f0       	breq	.+20     	; 0x57d6 <ulTaskNotifyTake+0xac>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    57c2:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    57c6:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    57ca:	fc 01       	movw	r30, r24
    57cc:	13 a2       	std	Z+35, r1	; 0x23
    57ce:	14 a2       	std	Z+36, r1	; 0x24
    57d0:	15 a2       	std	Z+37, r1	; 0x25
    57d2:	16 a2       	std	Z+38, r1	; 0x26
    57d4:	10 c0       	rjmp	.+32     	; 0x57f6 <ulTaskNotifyTake+0xcc>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    57d6:	20 91 9d 06 	lds	r18, 0x069D	; 0x80069d <pxCurrentTCB>
    57da:	30 91 9e 06 	lds	r19, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    57de:	89 81       	ldd	r24, Y+1	; 0x01
    57e0:	9a 81       	ldd	r25, Y+2	; 0x02
    57e2:	ab 81       	ldd	r26, Y+3	; 0x03
    57e4:	bc 81       	ldd	r27, Y+4	; 0x04
    57e6:	01 97       	sbiw	r24, 0x01	; 1
    57e8:	a1 09       	sbc	r26, r1
    57ea:	b1 09       	sbc	r27, r1
    57ec:	f9 01       	movw	r30, r18
    57ee:	83 a3       	std	Z+35, r24	; 0x23
    57f0:	94 a3       	std	Z+36, r25	; 0x24
    57f2:	a5 a3       	std	Z+37, r26	; 0x25
    57f4:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    57f6:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    57fa:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    57fe:	fc 01       	movw	r30, r24
    5800:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5802:	0f 90       	pop	r0
    5804:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    5806:	89 81       	ldd	r24, Y+1	; 0x01
    5808:	9a 81       	ldd	r25, Y+2	; 0x02
    580a:	ab 81       	ldd	r26, Y+3	; 0x03
    580c:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    580e:	bc 01       	movw	r22, r24
    5810:	cd 01       	movw	r24, r26
    5812:	27 96       	adiw	r28, 0x07	; 7
    5814:	0f b6       	in	r0, 0x3f	; 63
    5816:	f8 94       	cli
    5818:	de bf       	out	0x3e, r29	; 62
    581a:	0f be       	out	0x3f, r0	; 63
    581c:	cd bf       	out	0x3d, r28	; 61
    581e:	df 91       	pop	r29
    5820:	cf 91       	pop	r28
    5822:	08 95       	ret

00005824 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5824:	ef 92       	push	r14
    5826:	ff 92       	push	r15
    5828:	0f 93       	push	r16
    582a:	1f 93       	push	r17
    582c:	cf 93       	push	r28
    582e:	df 93       	push	r29
    5830:	cd b7       	in	r28, 0x3d	; 61
    5832:	de b7       	in	r29, 0x3e	; 62
    5834:	2d 97       	sbiw	r28, 0x0d	; 13
    5836:	0f b6       	in	r0, 0x3f	; 63
    5838:	f8 94       	cli
    583a:	de bf       	out	0x3e, r29	; 62
    583c:	0f be       	out	0x3f, r0	; 63
    583e:	cd bf       	out	0x3d, r28	; 61
    5840:	6a 83       	std	Y+2, r22	; 0x02
    5842:	7b 83       	std	Y+3, r23	; 0x03
    5844:	8c 83       	std	Y+4, r24	; 0x04
    5846:	9d 83       	std	Y+5, r25	; 0x05
    5848:	2e 83       	std	Y+6, r18	; 0x06
    584a:	3f 83       	std	Y+7, r19	; 0x07
    584c:	48 87       	std	Y+8, r20	; 0x08
    584e:	59 87       	std	Y+9, r21	; 0x09
    5850:	1b 87       	std	Y+11, r17	; 0x0b
    5852:	0a 87       	std	Y+10, r16	; 0x0a
    5854:	fd 86       	std	Y+13, r15	; 0x0d
    5856:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5858:	0f b6       	in	r0, 0x3f	; 63
    585a:	f8 94       	cli
    585c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    585e:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5862:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5866:	fc 01       	movw	r30, r24
    5868:	87 a1       	ldd	r24, Z+39	; 0x27
    586a:	82 30       	cpi	r24, 0x02	; 2
    586c:	61 f1       	breq	.+88     	; 0x58c6 <xTaskNotifyWait+0xa2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    586e:	60 91 9d 06 	lds	r22, 0x069D	; 0x80069d <pxCurrentTCB>
    5872:	70 91 9e 06 	lds	r23, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5876:	fb 01       	movw	r30, r22
    5878:	23 a1       	ldd	r18, Z+35	; 0x23
    587a:	34 a1       	ldd	r19, Z+36	; 0x24
    587c:	45 a1       	ldd	r20, Z+37	; 0x25
    587e:	56 a1       	ldd	r21, Z+38	; 0x26
    5880:	8a 81       	ldd	r24, Y+2	; 0x02
    5882:	9b 81       	ldd	r25, Y+3	; 0x03
    5884:	ac 81       	ldd	r26, Y+4	; 0x04
    5886:	bd 81       	ldd	r27, Y+5	; 0x05
    5888:	80 95       	com	r24
    588a:	90 95       	com	r25
    588c:	a0 95       	com	r26
    588e:	b0 95       	com	r27
    5890:	82 23       	and	r24, r18
    5892:	93 23       	and	r25, r19
    5894:	a4 23       	and	r26, r20
    5896:	b5 23       	and	r27, r21
    5898:	fb 01       	movw	r30, r22
    589a:	83 a3       	std	Z+35, r24	; 0x23
    589c:	94 a3       	std	Z+36, r25	; 0x24
    589e:	a5 a3       	std	Z+37, r26	; 0x25
    58a0:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    58a2:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    58a6:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    58aa:	21 e0       	ldi	r18, 0x01	; 1
    58ac:	fc 01       	movw	r30, r24
    58ae:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    58b0:	8c 85       	ldd	r24, Y+12	; 0x0c
    58b2:	9d 85       	ldd	r25, Y+13	; 0x0d
    58b4:	89 2b       	or	r24, r25
    58b6:	39 f0       	breq	.+14     	; 0x58c6 <xTaskNotifyWait+0xa2>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    58b8:	8c 85       	ldd	r24, Y+12	; 0x0c
    58ba:	9d 85       	ldd	r25, Y+13	; 0x0d
    58bc:	61 e0       	ldi	r22, 0x01	; 1
    58be:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    58c2:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    58c6:	0f 90       	pop	r0
    58c8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    58ca:	0f b6       	in	r0, 0x3f	; 63
    58cc:	f8 94       	cli
    58ce:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    58d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    58d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    58d4:	89 2b       	or	r24, r25
    58d6:	81 f0       	breq	.+32     	; 0x58f8 <xTaskNotifyWait+0xd4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    58d8:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    58dc:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    58e0:	fc 01       	movw	r30, r24
    58e2:	83 a1       	ldd	r24, Z+35	; 0x23
    58e4:	94 a1       	ldd	r25, Z+36	; 0x24
    58e6:	a5 a1       	ldd	r26, Z+37	; 0x25
    58e8:	b6 a1       	ldd	r27, Z+38	; 0x26
    58ea:	2a 85       	ldd	r18, Y+10	; 0x0a
    58ec:	3b 85       	ldd	r19, Y+11	; 0x0b
    58ee:	f9 01       	movw	r30, r18
    58f0:	80 83       	st	Z, r24
    58f2:	91 83       	std	Z+1, r25	; 0x01
    58f4:	a2 83       	std	Z+2, r26	; 0x02
    58f6:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    58f8:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    58fc:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5900:	fc 01       	movw	r30, r24
    5902:	87 a1       	ldd	r24, Z+39	; 0x27
    5904:	82 30       	cpi	r24, 0x02	; 2
    5906:	11 f0       	breq	.+4      	; 0x590c <xTaskNotifyWait+0xe8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    5908:	19 82       	std	Y+1, r1	; 0x01
    590a:	1c c0       	rjmp	.+56     	; 0x5944 <xTaskNotifyWait+0x120>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    590c:	60 91 9d 06 	lds	r22, 0x069D	; 0x80069d <pxCurrentTCB>
    5910:	70 91 9e 06 	lds	r23, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5914:	fb 01       	movw	r30, r22
    5916:	23 a1       	ldd	r18, Z+35	; 0x23
    5918:	34 a1       	ldd	r19, Z+36	; 0x24
    591a:	45 a1       	ldd	r20, Z+37	; 0x25
    591c:	56 a1       	ldd	r21, Z+38	; 0x26
    591e:	8e 81       	ldd	r24, Y+6	; 0x06
    5920:	9f 81       	ldd	r25, Y+7	; 0x07
    5922:	a8 85       	ldd	r26, Y+8	; 0x08
    5924:	b9 85       	ldd	r27, Y+9	; 0x09
    5926:	80 95       	com	r24
    5928:	90 95       	com	r25
    592a:	a0 95       	com	r26
    592c:	b0 95       	com	r27
    592e:	82 23       	and	r24, r18
    5930:	93 23       	and	r25, r19
    5932:	a4 23       	and	r26, r20
    5934:	b5 23       	and	r27, r21
    5936:	fb 01       	movw	r30, r22
    5938:	83 a3       	std	Z+35, r24	; 0x23
    593a:	94 a3       	std	Z+36, r25	; 0x24
    593c:	a5 a3       	std	Z+37, r26	; 0x25
    593e:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    5940:	81 e0       	ldi	r24, 0x01	; 1
    5942:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5944:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5948:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    594c:	fc 01       	movw	r30, r24
    594e:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5950:	0f 90       	pop	r0
    5952:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5954:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5956:	2d 96       	adiw	r28, 0x0d	; 13
    5958:	0f b6       	in	r0, 0x3f	; 63
    595a:	f8 94       	cli
    595c:	de bf       	out	0x3e, r29	; 62
    595e:	0f be       	out	0x3f, r0	; 63
    5960:	cd bf       	out	0x3d, r28	; 61
    5962:	df 91       	pop	r29
    5964:	cf 91       	pop	r28
    5966:	1f 91       	pop	r17
    5968:	0f 91       	pop	r16
    596a:	ff 90       	pop	r15
    596c:	ef 90       	pop	r14
    596e:	08 95       	ret

00005970 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5970:	0f 93       	push	r16
    5972:	1f 93       	push	r17
    5974:	cf 93       	push	r28
    5976:	df 93       	push	r29
    5978:	cd b7       	in	r28, 0x3d	; 61
    597a:	de b7       	in	r29, 0x3e	; 62
    597c:	2d 97       	sbiw	r28, 0x0d	; 13
    597e:	0f b6       	in	r0, 0x3f	; 63
    5980:	f8 94       	cli
    5982:	de bf       	out	0x3e, r29	; 62
    5984:	0f be       	out	0x3f, r0	; 63
    5986:	cd bf       	out	0x3d, r28	; 61
    5988:	9e 83       	std	Y+6, r25	; 0x06
    598a:	8d 83       	std	Y+5, r24	; 0x05
    598c:	4f 83       	std	Y+7, r20	; 0x07
    598e:	58 87       	std	Y+8, r21	; 0x08
    5990:	69 87       	std	Y+9, r22	; 0x09
    5992:	7a 87       	std	Y+10, r23	; 0x0a
    5994:	2b 87       	std	Y+11, r18	; 0x0b
    5996:	1d 87       	std	Y+13, r17	; 0x0d
    5998:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    599a:	81 e0       	ldi	r24, 0x01	; 1
    599c:	89 83       	std	Y+1, r24	; 0x01
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    599e:	8d 81       	ldd	r24, Y+5	; 0x05
    59a0:	9e 81       	ldd	r25, Y+6	; 0x06
    59a2:	9b 83       	std	Y+3, r25	; 0x03
    59a4:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    59a6:	0f b6       	in	r0, 0x3f	; 63
    59a8:	f8 94       	cli
    59aa:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    59ac:	8c 85       	ldd	r24, Y+12	; 0x0c
    59ae:	9d 85       	ldd	r25, Y+13	; 0x0d
    59b0:	89 2b       	or	r24, r25
    59b2:	71 f0       	breq	.+28     	; 0x59d0 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    59b4:	8a 81       	ldd	r24, Y+2	; 0x02
    59b6:	9b 81       	ldd	r25, Y+3	; 0x03
    59b8:	fc 01       	movw	r30, r24
    59ba:	83 a1       	ldd	r24, Z+35	; 0x23
    59bc:	94 a1       	ldd	r25, Z+36	; 0x24
    59be:	a5 a1       	ldd	r26, Z+37	; 0x25
    59c0:	b6 a1       	ldd	r27, Z+38	; 0x26
    59c2:	2c 85       	ldd	r18, Y+12	; 0x0c
    59c4:	3d 85       	ldd	r19, Y+13	; 0x0d
    59c6:	f9 01       	movw	r30, r18
    59c8:	80 83       	st	Z, r24
    59ca:	91 83       	std	Z+1, r25	; 0x01
    59cc:	a2 83       	std	Z+2, r26	; 0x02
    59ce:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    59d0:	8a 81       	ldd	r24, Y+2	; 0x02
    59d2:	9b 81       	ldd	r25, Y+3	; 0x03
    59d4:	fc 01       	movw	r30, r24
    59d6:	87 a1       	ldd	r24, Z+39	; 0x27
    59d8:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    59da:	8a 81       	ldd	r24, Y+2	; 0x02
    59dc:	9b 81       	ldd	r25, Y+3	; 0x03
    59de:	22 e0       	ldi	r18, 0x02	; 2
    59e0:	fc 01       	movw	r30, r24
    59e2:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    59e4:	8b 85       	ldd	r24, Y+11	; 0x0b
    59e6:	88 2f       	mov	r24, r24
    59e8:	90 e0       	ldi	r25, 0x00	; 0
    59ea:	82 30       	cpi	r24, 0x02	; 2
    59ec:	91 05       	cpc	r25, r1
    59ee:	31 f1       	breq	.+76     	; 0x5a3c <xTaskGenericNotify+0xcc>
    59f0:	83 30       	cpi	r24, 0x03	; 3
    59f2:	91 05       	cpc	r25, r1
    59f4:	34 f4       	brge	.+12     	; 0x5a02 <xTaskGenericNotify+0x92>
    59f6:	00 97       	sbiw	r24, 0x00	; 0
    59f8:	09 f4       	brne	.+2      	; 0x59fc <xTaskGenericNotify+0x8c>
    59fa:	4f c0       	rjmp	.+158    	; 0x5a9a <xTaskGenericNotify+0x12a>
    59fc:	01 97       	sbiw	r24, 0x01	; 1
    59fe:	39 f0       	breq	.+14     	; 0x5a0e <xTaskGenericNotify+0x9e>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a00:	4d c0       	rjmp	.+154    	; 0x5a9c <xTaskGenericNotify+0x12c>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5a02:	83 30       	cpi	r24, 0x03	; 3
    5a04:	91 05       	cpc	r25, r1
    5a06:	61 f1       	breq	.+88     	; 0x5a60 <xTaskGenericNotify+0xf0>
    5a08:	04 97       	sbiw	r24, 0x04	; 4
    5a0a:	b1 f1       	breq	.+108    	; 0x5a78 <xTaskGenericNotify+0x108>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
    5a0c:	47 c0       	rjmp	.+142    	; 0x5a9c <xTaskGenericNotify+0x12c>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    5a10:	9b 81       	ldd	r25, Y+3	; 0x03
    5a12:	fc 01       	movw	r30, r24
    5a14:	23 a1       	ldd	r18, Z+35	; 0x23
    5a16:	34 a1       	ldd	r19, Z+36	; 0x24
    5a18:	45 a1       	ldd	r20, Z+37	; 0x25
    5a1a:	56 a1       	ldd	r21, Z+38	; 0x26
    5a1c:	8f 81       	ldd	r24, Y+7	; 0x07
    5a1e:	98 85       	ldd	r25, Y+8	; 0x08
    5a20:	a9 85       	ldd	r26, Y+9	; 0x09
    5a22:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a24:	82 2b       	or	r24, r18
    5a26:	93 2b       	or	r25, r19
    5a28:	a4 2b       	or	r26, r20
    5a2a:	b5 2b       	or	r27, r21
    5a2c:	2a 81       	ldd	r18, Y+2	; 0x02
    5a2e:	3b 81       	ldd	r19, Y+3	; 0x03
    5a30:	f9 01       	movw	r30, r18
    5a32:	83 a3       	std	Z+35, r24	; 0x23
    5a34:	94 a3       	std	Z+36, r25	; 0x24
    5a36:	a5 a3       	std	Z+37, r26	; 0x25
    5a38:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5a3a:	30 c0       	rjmp	.+96     	; 0x5a9c <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    5a3e:	9b 81       	ldd	r25, Y+3	; 0x03
    5a40:	fc 01       	movw	r30, r24
    5a42:	83 a1       	ldd	r24, Z+35	; 0x23
    5a44:	94 a1       	ldd	r25, Z+36	; 0x24
    5a46:	a5 a1       	ldd	r26, Z+37	; 0x25
    5a48:	b6 a1       	ldd	r27, Z+38	; 0x26
    5a4a:	01 96       	adiw	r24, 0x01	; 1
    5a4c:	a1 1d       	adc	r26, r1
    5a4e:	b1 1d       	adc	r27, r1
    5a50:	2a 81       	ldd	r18, Y+2	; 0x02
    5a52:	3b 81       	ldd	r19, Y+3	; 0x03
    5a54:	f9 01       	movw	r30, r18
    5a56:	83 a3       	std	Z+35, r24	; 0x23
    5a58:	94 a3       	std	Z+36, r25	; 0x24
    5a5a:	a5 a3       	std	Z+37, r26	; 0x25
    5a5c:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5a5e:	1e c0       	rjmp	.+60     	; 0x5a9c <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5a60:	2a 81       	ldd	r18, Y+2	; 0x02
    5a62:	3b 81       	ldd	r19, Y+3	; 0x03
    5a64:	8f 81       	ldd	r24, Y+7	; 0x07
    5a66:	98 85       	ldd	r25, Y+8	; 0x08
    5a68:	a9 85       	ldd	r26, Y+9	; 0x09
    5a6a:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a6c:	f9 01       	movw	r30, r18
    5a6e:	83 a3       	std	Z+35, r24	; 0x23
    5a70:	94 a3       	std	Z+36, r25	; 0x24
    5a72:	a5 a3       	std	Z+37, r26	; 0x25
    5a74:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5a76:	12 c0       	rjmp	.+36     	; 0x5a9c <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5a78:	8c 81       	ldd	r24, Y+4	; 0x04
    5a7a:	82 30       	cpi	r24, 0x02	; 2
    5a7c:	61 f0       	breq	.+24     	; 0x5a96 <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5a7e:	2a 81       	ldd	r18, Y+2	; 0x02
    5a80:	3b 81       	ldd	r19, Y+3	; 0x03
    5a82:	8f 81       	ldd	r24, Y+7	; 0x07
    5a84:	98 85       	ldd	r25, Y+8	; 0x08
    5a86:	a9 85       	ldd	r26, Y+9	; 0x09
    5a88:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a8a:	f9 01       	movw	r30, r18
    5a8c:	83 a3       	std	Z+35, r24	; 0x23
    5a8e:	94 a3       	std	Z+36, r25	; 0x24
    5a90:	a5 a3       	std	Z+37, r26	; 0x25
    5a92:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5a94:	03 c0       	rjmp	.+6      	; 0x5a9c <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5a96:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5a98:	01 c0       	rjmp	.+2      	; 0x5a9c <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    5a9a:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5a9c:	8c 81       	ldd	r24, Y+4	; 0x04
    5a9e:	81 30       	cpi	r24, 0x01	; 1
    5aa0:	d1 f5       	brne	.+116    	; 0x5b16 <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    5aa4:	9b 81       	ldd	r25, Y+3	; 0x03
    5aa6:	02 96       	adiw	r24, 0x02	; 2
    5aa8:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5aac:	8a 81       	ldd	r24, Y+2	; 0x02
    5aae:	9b 81       	ldd	r25, Y+3	; 0x03
    5ab0:	fc 01       	movw	r30, r24
    5ab2:	96 89       	ldd	r25, Z+22	; 0x16
    5ab4:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    5ab8:	89 17       	cp	r24, r25
    5aba:	30 f4       	brcc	.+12     	; 0x5ac8 <xTaskGenericNotify+0x158>
    5abc:	8a 81       	ldd	r24, Y+2	; 0x02
    5abe:	9b 81       	ldd	r25, Y+3	; 0x03
    5ac0:	fc 01       	movw	r30, r24
    5ac2:	86 89       	ldd	r24, Z+22	; 0x16
    5ac4:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    5ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    5aca:	9b 81       	ldd	r25, Y+3	; 0x03
    5acc:	ac 01       	movw	r20, r24
    5ace:	4e 5f       	subi	r20, 0xFE	; 254
    5ad0:	5f 4f       	sbci	r21, 0xFF	; 255
    5ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ad6:	fc 01       	movw	r30, r24
    5ad8:	86 89       	ldd	r24, Z+22	; 0x16
    5ada:	28 2f       	mov	r18, r24
    5adc:	30 e0       	ldi	r19, 0x00	; 0
    5ade:	c9 01       	movw	r24, r18
    5ae0:	88 0f       	add	r24, r24
    5ae2:	99 1f       	adc	r25, r25
    5ae4:	88 0f       	add	r24, r24
    5ae6:	99 1f       	adc	r25, r25
    5ae8:	88 0f       	add	r24, r24
    5aea:	99 1f       	adc	r25, r25
    5aec:	82 0f       	add	r24, r18
    5aee:	93 1f       	adc	r25, r19
    5af0:	81 56       	subi	r24, 0x61	; 97
    5af2:	99 4f       	sbci	r25, 0xF9	; 249
    5af4:	ba 01       	movw	r22, r20
    5af6:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5afa:	8a 81       	ldd	r24, Y+2	; 0x02
    5afc:	9b 81       	ldd	r25, Y+3	; 0x03
    5afe:	fc 01       	movw	r30, r24
    5b00:	26 89       	ldd	r18, Z+22	; 0x16
    5b02:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5b06:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5b0a:	fc 01       	movw	r30, r24
    5b0c:	86 89       	ldd	r24, Z+22	; 0x16
    5b0e:	82 17       	cp	r24, r18
    5b10:	10 f4       	brcc	.+4      	; 0x5b16 <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5b12:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5b16:	0f 90       	pop	r0
    5b18:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5b1a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5b1c:	2d 96       	adiw	r28, 0x0d	; 13
    5b1e:	0f b6       	in	r0, 0x3f	; 63
    5b20:	f8 94       	cli
    5b22:	de bf       	out	0x3e, r29	; 62
    5b24:	0f be       	out	0x3f, r0	; 63
    5b26:	cd bf       	out	0x3d, r28	; 61
    5b28:	df 91       	pop	r29
    5b2a:	cf 91       	pop	r28
    5b2c:	1f 91       	pop	r17
    5b2e:	0f 91       	pop	r16
    5b30:	08 95       	ret

00005b32 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5b32:	ef 92       	push	r14
    5b34:	ff 92       	push	r15
    5b36:	0f 93       	push	r16
    5b38:	1f 93       	push	r17
    5b3a:	cf 93       	push	r28
    5b3c:	df 93       	push	r29
    5b3e:	cd b7       	in	r28, 0x3d	; 61
    5b40:	de b7       	in	r29, 0x3e	; 62
    5b42:	60 97       	sbiw	r28, 0x10	; 16
    5b44:	0f b6       	in	r0, 0x3f	; 63
    5b46:	f8 94       	cli
    5b48:	de bf       	out	0x3e, r29	; 62
    5b4a:	0f be       	out	0x3f, r0	; 63
    5b4c:	cd bf       	out	0x3d, r28	; 61
    5b4e:	9f 83       	std	Y+7, r25	; 0x07
    5b50:	8e 83       	std	Y+6, r24	; 0x06
    5b52:	48 87       	std	Y+8, r20	; 0x08
    5b54:	59 87       	std	Y+9, r21	; 0x09
    5b56:	6a 87       	std	Y+10, r22	; 0x0a
    5b58:	7b 87       	std	Y+11, r23	; 0x0b
    5b5a:	2c 87       	std	Y+12, r18	; 0x0c
    5b5c:	1e 87       	std	Y+14, r17	; 0x0e
    5b5e:	0d 87       	std	Y+13, r16	; 0x0d
    5b60:	f8 8a       	std	Y+16, r15	; 0x10
    5b62:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5b64:	81 e0       	ldi	r24, 0x01	; 1
    5b66:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5b68:	8e 81       	ldd	r24, Y+6	; 0x06
    5b6a:	9f 81       	ldd	r25, Y+7	; 0x07
    5b6c:	9b 83       	std	Y+3, r25	; 0x03
    5b6e:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5b70:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    5b72:	8d 85       	ldd	r24, Y+13	; 0x0d
    5b74:	9e 85       	ldd	r25, Y+14	; 0x0e
    5b76:	89 2b       	or	r24, r25
    5b78:	71 f0       	breq	.+28     	; 0x5b96 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5b7a:	8a 81       	ldd	r24, Y+2	; 0x02
    5b7c:	9b 81       	ldd	r25, Y+3	; 0x03
    5b7e:	fc 01       	movw	r30, r24
    5b80:	83 a1       	ldd	r24, Z+35	; 0x23
    5b82:	94 a1       	ldd	r25, Z+36	; 0x24
    5b84:	a5 a1       	ldd	r26, Z+37	; 0x25
    5b86:	b6 a1       	ldd	r27, Z+38	; 0x26
    5b88:	2d 85       	ldd	r18, Y+13	; 0x0d
    5b8a:	3e 85       	ldd	r19, Y+14	; 0x0e
    5b8c:	f9 01       	movw	r30, r18
    5b8e:	80 83       	st	Z, r24
    5b90:	91 83       	std	Z+1, r25	; 0x01
    5b92:	a2 83       	std	Z+2, r26	; 0x02
    5b94:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5b96:	8a 81       	ldd	r24, Y+2	; 0x02
    5b98:	9b 81       	ldd	r25, Y+3	; 0x03
    5b9a:	fc 01       	movw	r30, r24
    5b9c:	87 a1       	ldd	r24, Z+39	; 0x27
    5b9e:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5ba0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ba2:	9b 81       	ldd	r25, Y+3	; 0x03
    5ba4:	22 e0       	ldi	r18, 0x02	; 2
    5ba6:	fc 01       	movw	r30, r24
    5ba8:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5baa:	8c 85       	ldd	r24, Y+12	; 0x0c
    5bac:	88 2f       	mov	r24, r24
    5bae:	90 e0       	ldi	r25, 0x00	; 0
    5bb0:	82 30       	cpi	r24, 0x02	; 2
    5bb2:	91 05       	cpc	r25, r1
    5bb4:	31 f1       	breq	.+76     	; 0x5c02 <xTaskGenericNotifyFromISR+0xd0>
    5bb6:	83 30       	cpi	r24, 0x03	; 3
    5bb8:	91 05       	cpc	r25, r1
    5bba:	34 f4       	brge	.+12     	; 0x5bc8 <xTaskGenericNotifyFromISR+0x96>
    5bbc:	00 97       	sbiw	r24, 0x00	; 0
    5bbe:	09 f4       	brne	.+2      	; 0x5bc2 <xTaskGenericNotifyFromISR+0x90>
    5bc0:	4f c0       	rjmp	.+158    	; 0x5c60 <xTaskGenericNotifyFromISR+0x12e>
    5bc2:	01 97       	sbiw	r24, 0x01	; 1
    5bc4:	39 f0       	breq	.+14     	; 0x5bd4 <xTaskGenericNotifyFromISR+0xa2>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5bc6:	4d c0       	rjmp	.+154    	; 0x5c62 <xTaskGenericNotifyFromISR+0x130>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    5bc8:	83 30       	cpi	r24, 0x03	; 3
    5bca:	91 05       	cpc	r25, r1
    5bcc:	61 f1       	breq	.+88     	; 0x5c26 <xTaskGenericNotifyFromISR+0xf4>
    5bce:	04 97       	sbiw	r24, 0x04	; 4
    5bd0:	b1 f1       	breq	.+108    	; 0x5c3e <xTaskGenericNotifyFromISR+0x10c>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
    5bd2:	47 c0       	rjmp	.+142    	; 0x5c62 <xTaskGenericNotifyFromISR+0x130>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5bd4:	8a 81       	ldd	r24, Y+2	; 0x02
    5bd6:	9b 81       	ldd	r25, Y+3	; 0x03
    5bd8:	fc 01       	movw	r30, r24
    5bda:	23 a1       	ldd	r18, Z+35	; 0x23
    5bdc:	34 a1       	ldd	r19, Z+36	; 0x24
    5bde:	45 a1       	ldd	r20, Z+37	; 0x25
    5be0:	56 a1       	ldd	r21, Z+38	; 0x26
    5be2:	88 85       	ldd	r24, Y+8	; 0x08
    5be4:	99 85       	ldd	r25, Y+9	; 0x09
    5be6:	aa 85       	ldd	r26, Y+10	; 0x0a
    5be8:	bb 85       	ldd	r27, Y+11	; 0x0b
    5bea:	82 2b       	or	r24, r18
    5bec:	93 2b       	or	r25, r19
    5bee:	a4 2b       	or	r26, r20
    5bf0:	b5 2b       	or	r27, r21
    5bf2:	2a 81       	ldd	r18, Y+2	; 0x02
    5bf4:	3b 81       	ldd	r19, Y+3	; 0x03
    5bf6:	f9 01       	movw	r30, r18
    5bf8:	83 a3       	std	Z+35, r24	; 0x23
    5bfa:	94 a3       	std	Z+36, r25	; 0x24
    5bfc:	a5 a3       	std	Z+37, r26	; 0x25
    5bfe:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c00:	30 c0       	rjmp	.+96     	; 0x5c62 <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5c02:	8a 81       	ldd	r24, Y+2	; 0x02
    5c04:	9b 81       	ldd	r25, Y+3	; 0x03
    5c06:	fc 01       	movw	r30, r24
    5c08:	83 a1       	ldd	r24, Z+35	; 0x23
    5c0a:	94 a1       	ldd	r25, Z+36	; 0x24
    5c0c:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c0e:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c10:	01 96       	adiw	r24, 0x01	; 1
    5c12:	a1 1d       	adc	r26, r1
    5c14:	b1 1d       	adc	r27, r1
    5c16:	2a 81       	ldd	r18, Y+2	; 0x02
    5c18:	3b 81       	ldd	r19, Y+3	; 0x03
    5c1a:	f9 01       	movw	r30, r18
    5c1c:	83 a3       	std	Z+35, r24	; 0x23
    5c1e:	94 a3       	std	Z+36, r25	; 0x24
    5c20:	a5 a3       	std	Z+37, r26	; 0x25
    5c22:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c24:	1e c0       	rjmp	.+60     	; 0x5c62 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5c26:	2a 81       	ldd	r18, Y+2	; 0x02
    5c28:	3b 81       	ldd	r19, Y+3	; 0x03
    5c2a:	88 85       	ldd	r24, Y+8	; 0x08
    5c2c:	99 85       	ldd	r25, Y+9	; 0x09
    5c2e:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c30:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c32:	f9 01       	movw	r30, r18
    5c34:	83 a3       	std	Z+35, r24	; 0x23
    5c36:	94 a3       	std	Z+36, r25	; 0x24
    5c38:	a5 a3       	std	Z+37, r26	; 0x25
    5c3a:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5c3c:	12 c0       	rjmp	.+36     	; 0x5c62 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5c3e:	8d 81       	ldd	r24, Y+5	; 0x05
    5c40:	82 30       	cpi	r24, 0x02	; 2
    5c42:	61 f0       	breq	.+24     	; 0x5c5c <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5c44:	2a 81       	ldd	r18, Y+2	; 0x02
    5c46:	3b 81       	ldd	r19, Y+3	; 0x03
    5c48:	88 85       	ldd	r24, Y+8	; 0x08
    5c4a:	99 85       	ldd	r25, Y+9	; 0x09
    5c4c:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c4e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c50:	f9 01       	movw	r30, r18
    5c52:	83 a3       	std	Z+35, r24	; 0x23
    5c54:	94 a3       	std	Z+36, r25	; 0x24
    5c56:	a5 a3       	std	Z+37, r26	; 0x25
    5c58:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5c5a:	03 c0       	rjmp	.+6      	; 0x5c62 <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5c5c:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5c5e:	01 c0       	rjmp	.+2      	; 0x5c62 <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    5c60:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5c62:	8d 81       	ldd	r24, Y+5	; 0x05
    5c64:	81 30       	cpi	r24, 0x01	; 1
    5c66:	09 f0       	breq	.+2      	; 0x5c6a <xTaskGenericNotifyFromISR+0x138>
    5c68:	51 c0       	rjmp	.+162    	; 0x5d0c <xTaskGenericNotifyFromISR+0x1da>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c6a:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    5c6e:	88 23       	and	r24, r24
    5c70:	69 f5       	brne	.+90     	; 0x5ccc <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5c72:	8a 81       	ldd	r24, Y+2	; 0x02
    5c74:	9b 81       	ldd	r25, Y+3	; 0x03
    5c76:	02 96       	adiw	r24, 0x02	; 2
    5c78:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c7e:	9b 81       	ldd	r25, Y+3	; 0x03
    5c80:	fc 01       	movw	r30, r24
    5c82:	96 89       	ldd	r25, Z+22	; 0x16
    5c84:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    5c88:	89 17       	cp	r24, r25
    5c8a:	30 f4       	brcc	.+12     	; 0x5c98 <xTaskGenericNotifyFromISR+0x166>
    5c8c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c8e:	9b 81       	ldd	r25, Y+3	; 0x03
    5c90:	fc 01       	movw	r30, r24
    5c92:	86 89       	ldd	r24, Z+22	; 0x16
    5c94:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    5c98:	8a 81       	ldd	r24, Y+2	; 0x02
    5c9a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c9c:	ac 01       	movw	r20, r24
    5c9e:	4e 5f       	subi	r20, 0xFE	; 254
    5ca0:	5f 4f       	sbci	r21, 0xFF	; 255
    5ca2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ca4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ca6:	fc 01       	movw	r30, r24
    5ca8:	86 89       	ldd	r24, Z+22	; 0x16
    5caa:	28 2f       	mov	r18, r24
    5cac:	30 e0       	ldi	r19, 0x00	; 0
    5cae:	c9 01       	movw	r24, r18
    5cb0:	88 0f       	add	r24, r24
    5cb2:	99 1f       	adc	r25, r25
    5cb4:	88 0f       	add	r24, r24
    5cb6:	99 1f       	adc	r25, r25
    5cb8:	88 0f       	add	r24, r24
    5cba:	99 1f       	adc	r25, r25
    5cbc:	82 0f       	add	r24, r18
    5cbe:	93 1f       	adc	r25, r19
    5cc0:	81 56       	subi	r24, 0x61	; 97
    5cc2:	99 4f       	sbci	r25, 0xF9	; 249
    5cc4:	ba 01       	movw	r22, r20
    5cc6:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
    5cca:	08 c0       	rjmp	.+16     	; 0x5cdc <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cce:	9b 81       	ldd	r25, Y+3	; 0x03
    5cd0:	0c 96       	adiw	r24, 0x0c	; 12
    5cd2:	bc 01       	movw	r22, r24
    5cd4:	82 ee       	ldi	r24, 0xE2	; 226
    5cd6:	96 e0       	ldi	r25, 0x06	; 6
    5cd8:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cde:	9b 81       	ldd	r25, Y+3	; 0x03
    5ce0:	fc 01       	movw	r30, r24
    5ce2:	26 89       	ldd	r18, Z+22	; 0x16
    5ce4:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5ce8:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5cec:	fc 01       	movw	r30, r24
    5cee:	86 89       	ldd	r24, Z+22	; 0x16
    5cf0:	82 17       	cp	r24, r18
    5cf2:	60 f4       	brcc	.+24     	; 0x5d0c <xTaskGenericNotifyFromISR+0x1da>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5cf4:	8f 85       	ldd	r24, Y+15	; 0x0f
    5cf6:	98 89       	ldd	r25, Y+16	; 0x10
    5cf8:	89 2b       	or	r24, r25
    5cfa:	29 f0       	breq	.+10     	; 0x5d06 <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5cfc:	8f 85       	ldd	r24, Y+15	; 0x0f
    5cfe:	98 89       	ldd	r25, Y+16	; 0x10
    5d00:	21 e0       	ldi	r18, 0x01	; 1
    5d02:	fc 01       	movw	r30, r24
    5d04:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5d06:	81 e0       	ldi	r24, 0x01	; 1
    5d08:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5d0c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5d0e:	60 96       	adiw	r28, 0x10	; 16
    5d10:	0f b6       	in	r0, 0x3f	; 63
    5d12:	f8 94       	cli
    5d14:	de bf       	out	0x3e, r29	; 62
    5d16:	0f be       	out	0x3f, r0	; 63
    5d18:	cd bf       	out	0x3d, r28	; 61
    5d1a:	df 91       	pop	r29
    5d1c:	cf 91       	pop	r28
    5d1e:	1f 91       	pop	r17
    5d20:	0f 91       	pop	r16
    5d22:	ff 90       	pop	r15
    5d24:	ef 90       	pop	r14
    5d26:	08 95       	ret

00005d28 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5d28:	cf 93       	push	r28
    5d2a:	df 93       	push	r29
    5d2c:	cd b7       	in	r28, 0x3d	; 61
    5d2e:	de b7       	in	r29, 0x3e	; 62
    5d30:	28 97       	sbiw	r28, 0x08	; 8
    5d32:	0f b6       	in	r0, 0x3f	; 63
    5d34:	f8 94       	cli
    5d36:	de bf       	out	0x3e, r29	; 62
    5d38:	0f be       	out	0x3f, r0	; 63
    5d3a:	cd bf       	out	0x3d, r28	; 61
    5d3c:	9e 83       	std	Y+6, r25	; 0x06
    5d3e:	8d 83       	std	Y+5, r24	; 0x05
    5d40:	78 87       	std	Y+8, r23	; 0x08
    5d42:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5d44:	8d 81       	ldd	r24, Y+5	; 0x05
    5d46:	9e 81       	ldd	r25, Y+6	; 0x06
    5d48:	9a 83       	std	Y+2, r25	; 0x02
    5d4a:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5d4c:	1b 82       	std	Y+3, r1	; 0x03
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5d4e:	89 81       	ldd	r24, Y+1	; 0x01
    5d50:	9a 81       	ldd	r25, Y+2	; 0x02
    5d52:	fc 01       	movw	r30, r24
    5d54:	87 a1       	ldd	r24, Z+39	; 0x27
    5d56:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5d58:	89 81       	ldd	r24, Y+1	; 0x01
    5d5a:	9a 81       	ldd	r25, Y+2	; 0x02
    5d5c:	22 e0       	ldi	r18, 0x02	; 2
    5d5e:	fc 01       	movw	r30, r24
    5d60:	27 a3       	std	Z+39, r18	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5d62:	89 81       	ldd	r24, Y+1	; 0x01
    5d64:	9a 81       	ldd	r25, Y+2	; 0x02
    5d66:	fc 01       	movw	r30, r24
    5d68:	83 a1       	ldd	r24, Z+35	; 0x23
    5d6a:	94 a1       	ldd	r25, Z+36	; 0x24
    5d6c:	a5 a1       	ldd	r26, Z+37	; 0x25
    5d6e:	b6 a1       	ldd	r27, Z+38	; 0x26
    5d70:	01 96       	adiw	r24, 0x01	; 1
    5d72:	a1 1d       	adc	r26, r1
    5d74:	b1 1d       	adc	r27, r1
    5d76:	29 81       	ldd	r18, Y+1	; 0x01
    5d78:	3a 81       	ldd	r19, Y+2	; 0x02
    5d7a:	f9 01       	movw	r30, r18
    5d7c:	83 a3       	std	Z+35, r24	; 0x23
    5d7e:	94 a3       	std	Z+36, r25	; 0x24
    5d80:	a5 a3       	std	Z+37, r26	; 0x25
    5d82:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5d84:	8c 81       	ldd	r24, Y+4	; 0x04
    5d86:	81 30       	cpi	r24, 0x01	; 1
    5d88:	09 f0       	breq	.+2      	; 0x5d8c <vTaskNotifyGiveFromISR+0x64>
    5d8a:	51 c0       	rjmp	.+162    	; 0x5e2e <vTaskNotifyGiveFromISR+0x106>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5d8c:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxSchedulerSuspended>
    5d90:	88 23       	and	r24, r24
    5d92:	69 f5       	brne	.+90     	; 0x5dee <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5d94:	89 81       	ldd	r24, Y+1	; 0x01
    5d96:	9a 81       	ldd	r25, Y+2	; 0x02
    5d98:	02 96       	adiw	r24, 0x02	; 2
    5d9a:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5d9e:	89 81       	ldd	r24, Y+1	; 0x01
    5da0:	9a 81       	ldd	r25, Y+2	; 0x02
    5da2:	fc 01       	movw	r30, r24
    5da4:	96 89       	ldd	r25, Z+22	; 0x16
    5da6:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
    5daa:	89 17       	cp	r24, r25
    5dac:	30 f4       	brcc	.+12     	; 0x5dba <vTaskNotifyGiveFromISR+0x92>
    5dae:	89 81       	ldd	r24, Y+1	; 0x01
    5db0:	9a 81       	ldd	r25, Y+2	; 0x02
    5db2:	fc 01       	movw	r30, r24
    5db4:	86 89       	ldd	r24, Z+22	; 0x16
    5db6:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
    5dba:	89 81       	ldd	r24, Y+1	; 0x01
    5dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    5dbe:	ac 01       	movw	r20, r24
    5dc0:	4e 5f       	subi	r20, 0xFE	; 254
    5dc2:	5f 4f       	sbci	r21, 0xFF	; 255
    5dc4:	89 81       	ldd	r24, Y+1	; 0x01
    5dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    5dc8:	fc 01       	movw	r30, r24
    5dca:	86 89       	ldd	r24, Z+22	; 0x16
    5dcc:	28 2f       	mov	r18, r24
    5dce:	30 e0       	ldi	r19, 0x00	; 0
    5dd0:	c9 01       	movw	r24, r18
    5dd2:	88 0f       	add	r24, r24
    5dd4:	99 1f       	adc	r25, r25
    5dd6:	88 0f       	add	r24, r24
    5dd8:	99 1f       	adc	r25, r25
    5dda:	88 0f       	add	r24, r24
    5ddc:	99 1f       	adc	r25, r25
    5dde:	82 0f       	add	r24, r18
    5de0:	93 1f       	adc	r25, r19
    5de2:	81 56       	subi	r24, 0x61	; 97
    5de4:	99 4f       	sbci	r25, 0xF9	; 249
    5de6:	ba 01       	movw	r22, r20
    5de8:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
    5dec:	08 c0       	rjmp	.+16     	; 0x5dfe <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5dee:	89 81       	ldd	r24, Y+1	; 0x01
    5df0:	9a 81       	ldd	r25, Y+2	; 0x02
    5df2:	0c 96       	adiw	r24, 0x0c	; 12
    5df4:	bc 01       	movw	r22, r24
    5df6:	82 ee       	ldi	r24, 0xE2	; 226
    5df8:	96 e0       	ldi	r25, 0x06	; 6
    5dfa:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5dfe:	89 81       	ldd	r24, Y+1	; 0x01
    5e00:	9a 81       	ldd	r25, Y+2	; 0x02
    5e02:	fc 01       	movw	r30, r24
    5e04:	26 89       	ldd	r18, Z+22	; 0x16
    5e06:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5e0a:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5e0e:	fc 01       	movw	r30, r24
    5e10:	86 89       	ldd	r24, Z+22	; 0x16
    5e12:	82 17       	cp	r24, r18
    5e14:	60 f4       	brcc	.+24     	; 0x5e2e <vTaskNotifyGiveFromISR+0x106>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5e16:	8f 81       	ldd	r24, Y+7	; 0x07
    5e18:	98 85       	ldd	r25, Y+8	; 0x08
    5e1a:	89 2b       	or	r24, r25
    5e1c:	29 f0       	breq	.+10     	; 0x5e28 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5e1e:	8f 81       	ldd	r24, Y+7	; 0x07
    5e20:	98 85       	ldd	r25, Y+8	; 0x08
    5e22:	21 e0       	ldi	r18, 0x01	; 1
    5e24:	fc 01       	movw	r30, r24
    5e26:	20 83       	st	Z, r18
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5e28:	81 e0       	ldi	r24, 0x01	; 1
    5e2a:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5e2e:	00 00       	nop
    5e30:	28 96       	adiw	r28, 0x08	; 8
    5e32:	0f b6       	in	r0, 0x3f	; 63
    5e34:	f8 94       	cli
    5e36:	de bf       	out	0x3e, r29	; 62
    5e38:	0f be       	out	0x3f, r0	; 63
    5e3a:	cd bf       	out	0x3d, r28	; 61
    5e3c:	df 91       	pop	r29
    5e3e:	cf 91       	pop	r28
    5e40:	08 95       	ret

00005e42 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5e42:	cf 93       	push	r28
    5e44:	df 93       	push	r29
    5e46:	00 d0       	rcall	.+0      	; 0x5e48 <xTaskNotifyStateClear+0x6>
    5e48:	00 d0       	rcall	.+0      	; 0x5e4a <xTaskNotifyStateClear+0x8>
    5e4a:	1f 92       	push	r1
    5e4c:	cd b7       	in	r28, 0x3d	; 61
    5e4e:	de b7       	in	r29, 0x3e	; 62
    5e50:	9d 83       	std	Y+5, r25	; 0x05
    5e52:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5e54:	8c 81       	ldd	r24, Y+4	; 0x04
    5e56:	9d 81       	ldd	r25, Y+5	; 0x05
    5e58:	89 2b       	or	r24, r25
    5e5a:	29 f4       	brne	.+10     	; 0x5e66 <xTaskNotifyStateClear+0x24>
    5e5c:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5e60:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5e64:	02 c0       	rjmp	.+4      	; 0x5e6a <xTaskNotifyStateClear+0x28>
    5e66:	8c 81       	ldd	r24, Y+4	; 0x04
    5e68:	9d 81       	ldd	r25, Y+5	; 0x05
    5e6a:	9b 83       	std	Y+3, r25	; 0x03
    5e6c:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5e6e:	0f b6       	in	r0, 0x3f	; 63
    5e70:	f8 94       	cli
    5e72:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5e74:	8a 81       	ldd	r24, Y+2	; 0x02
    5e76:	9b 81       	ldd	r25, Y+3	; 0x03
    5e78:	fc 01       	movw	r30, r24
    5e7a:	87 a1       	ldd	r24, Z+39	; 0x27
    5e7c:	82 30       	cpi	r24, 0x02	; 2
    5e7e:	39 f4       	brne	.+14     	; 0x5e8e <xTaskNotifyStateClear+0x4c>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5e80:	8a 81       	ldd	r24, Y+2	; 0x02
    5e82:	9b 81       	ldd	r25, Y+3	; 0x03
    5e84:	fc 01       	movw	r30, r24
    5e86:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5e88:	81 e0       	ldi	r24, 0x01	; 1
    5e8a:	89 83       	std	Y+1, r24	; 0x01
    5e8c:	01 c0       	rjmp	.+2      	; 0x5e90 <xTaskNotifyStateClear+0x4e>
			}
			else
			{
				xReturn = pdFAIL;
    5e8e:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5e90:	0f 90       	pop	r0
    5e92:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5e94:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5e96:	0f 90       	pop	r0
    5e98:	0f 90       	pop	r0
    5e9a:	0f 90       	pop	r0
    5e9c:	0f 90       	pop	r0
    5e9e:	0f 90       	pop	r0
    5ea0:	df 91       	pop	r29
    5ea2:	cf 91       	pop	r28
    5ea4:	08 95       	ret

00005ea6 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5ea6:	cf 93       	push	r28
    5ea8:	df 93       	push	r29
    5eaa:	cd b7       	in	r28, 0x3d	; 61
    5eac:	de b7       	in	r29, 0x3e	; 62
    5eae:	27 97       	sbiw	r28, 0x07	; 7
    5eb0:	0f b6       	in	r0, 0x3f	; 63
    5eb2:	f8 94       	cli
    5eb4:	de bf       	out	0x3e, r29	; 62
    5eb6:	0f be       	out	0x3f, r0	; 63
    5eb8:	cd bf       	out	0x3d, r28	; 61
    5eba:	9e 83       	std	Y+6, r25	; 0x06
    5ebc:	8d 83       	std	Y+5, r24	; 0x05
    5ebe:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5ec0:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xTickCount>
    5ec4:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xTickCount+0x1>
    5ec8:	9a 83       	std	Y+2, r25	; 0x02
    5eca:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5ecc:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5ed0:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5ed4:	02 96       	adiw	r24, 0x02	; 2
    5ed6:	0e 94 ef 13 	call	0x27de	; 0x27de <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5eda:	8d 81       	ldd	r24, Y+5	; 0x05
    5edc:	9e 81       	ldd	r25, Y+6	; 0x06
    5ede:	01 96       	adiw	r24, 0x01	; 1
    5ee0:	71 f4       	brne	.+28     	; 0x5efe <prvAddCurrentTaskToDelayedList+0x58>
    5ee2:	8f 81       	ldd	r24, Y+7	; 0x07
    5ee4:	88 23       	and	r24, r24
    5ee6:	59 f0       	breq	.+22     	; 0x5efe <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5ee8:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5eec:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5ef0:	02 96       	adiw	r24, 0x02	; 2
    5ef2:	bc 01       	movw	r22, r24
    5ef4:	85 ef       	ldi	r24, 0xF5	; 245
    5ef6:	96 e0       	ldi	r25, 0x06	; 6
    5ef8:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5efc:	44 c0       	rjmp	.+136    	; 0x5f86 <prvAddCurrentTaskToDelayedList+0xe0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    5efe:	29 81       	ldd	r18, Y+1	; 0x01
    5f00:	3a 81       	ldd	r19, Y+2	; 0x02
    5f02:	8d 81       	ldd	r24, Y+5	; 0x05
    5f04:	9e 81       	ldd	r25, Y+6	; 0x06
    5f06:	82 0f       	add	r24, r18
    5f08:	93 1f       	adc	r25, r19
    5f0a:	9c 83       	std	Y+4, r25	; 0x04
    5f0c:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5f0e:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5f12:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5f16:	2b 81       	ldd	r18, Y+3	; 0x03
    5f18:	3c 81       	ldd	r19, Y+4	; 0x04
    5f1a:	fc 01       	movw	r30, r24
    5f1c:	33 83       	std	Z+3, r19	; 0x03
    5f1e:	22 83       	std	Z+2, r18	; 0x02

			if( xTimeToWake < xConstTickCount )
    5f20:	2b 81       	ldd	r18, Y+3	; 0x03
    5f22:	3c 81       	ldd	r19, Y+4	; 0x04
    5f24:	89 81       	ldd	r24, Y+1	; 0x01
    5f26:	9a 81       	ldd	r25, Y+2	; 0x02
    5f28:	28 17       	cp	r18, r24
    5f2a:	39 07       	cpc	r19, r25
    5f2c:	78 f4       	brcc	.+30     	; 0x5f4c <prvAddCurrentTaskToDelayedList+0xa6>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5f2e:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5f32:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5f36:	9c 01       	movw	r18, r24
    5f38:	2e 5f       	subi	r18, 0xFE	; 254
    5f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f3c:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <pxOverflowDelayedTaskList>
    5f40:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <pxOverflowDelayedTaskList+0x1>
    5f44:	b9 01       	movw	r22, r18
    5f46:	0e 94 77 13 	call	0x26ee	; 0x26ee <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f4a:	1d c0       	rjmp	.+58     	; 0x5f86 <prvAddCurrentTaskToDelayedList+0xe0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5f4c:	80 91 9d 06 	lds	r24, 0x069D	; 0x80069d <pxCurrentTCB>
    5f50:	90 91 9e 06 	lds	r25, 0x069E	; 0x80069e <pxCurrentTCB+0x1>
    5f54:	9c 01       	movw	r18, r24
    5f56:	2e 5f       	subi	r18, 0xFE	; 254
    5f58:	3f 4f       	sbci	r19, 0xFF	; 255
    5f5a:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <pxDelayedTaskList>
    5f5e:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <pxDelayedTaskList+0x1>
    5f62:	b9 01       	movw	r22, r18
    5f64:	0e 94 77 13 	call	0x26ee	; 0x26ee <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5f68:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xNextTaskUnblockTime>
    5f6c:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <xNextTaskUnblockTime+0x1>
    5f70:	2b 81       	ldd	r18, Y+3	; 0x03
    5f72:	3c 81       	ldd	r19, Y+4	; 0x04
    5f74:	28 17       	cp	r18, r24
    5f76:	39 07       	cpc	r19, r25
    5f78:	30 f4       	brcc	.+12     	; 0x5f86 <prvAddCurrentTaskToDelayedList+0xe0>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    5f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    5f7e:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <xNextTaskUnblockTime+0x1>
    5f82:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f86:	00 00       	nop
    5f88:	27 96       	adiw	r28, 0x07	; 7
    5f8a:	0f b6       	in	r0, 0x3f	; 63
    5f8c:	f8 94       	cli
    5f8e:	de bf       	out	0x3e, r29	; 62
    5f90:	0f be       	out	0x3f, r0	; 63
    5f92:	cd bf       	out	0x3d, r28	; 61
    5f94:	df 91       	pop	r29
    5f96:	cf 91       	pop	r28
    5f98:	08 95       	ret

00005f9a <__umulhisi3>:
    5f9a:	a2 9f       	mul	r26, r18
    5f9c:	b0 01       	movw	r22, r0
    5f9e:	b3 9f       	mul	r27, r19
    5fa0:	c0 01       	movw	r24, r0
    5fa2:	a3 9f       	mul	r26, r19
    5fa4:	70 0d       	add	r23, r0
    5fa6:	81 1d       	adc	r24, r1
    5fa8:	11 24       	eor	r1, r1
    5faa:	91 1d       	adc	r25, r1
    5fac:	b2 9f       	mul	r27, r18
    5fae:	70 0d       	add	r23, r0
    5fb0:	81 1d       	adc	r24, r1
    5fb2:	11 24       	eor	r1, r1
    5fb4:	91 1d       	adc	r25, r1
    5fb6:	08 95       	ret

00005fb8 <__subsf3>:
    5fb8:	50 58       	subi	r21, 0x80	; 128

00005fba <__addsf3>:
    5fba:	bb 27       	eor	r27, r27
    5fbc:	aa 27       	eor	r26, r26
    5fbe:	0e 94 f4 2f 	call	0x5fe8	; 0x5fe8 <__addsf3x>
    5fc2:	0c 94 2a 31 	jmp	0x6254	; 0x6254 <__fp_round>
    5fc6:	0e 94 1c 31 	call	0x6238	; 0x6238 <__fp_pscA>
    5fca:	38 f0       	brcs	.+14     	; 0x5fda <__addsf3+0x20>
    5fcc:	0e 94 23 31 	call	0x6246	; 0x6246 <__fp_pscB>
    5fd0:	20 f0       	brcs	.+8      	; 0x5fda <__addsf3+0x20>
    5fd2:	39 f4       	brne	.+14     	; 0x5fe2 <__addsf3+0x28>
    5fd4:	9f 3f       	cpi	r25, 0xFF	; 255
    5fd6:	19 f4       	brne	.+6      	; 0x5fde <__addsf3+0x24>
    5fd8:	26 f4       	brtc	.+8      	; 0x5fe2 <__addsf3+0x28>
    5fda:	0c 94 19 31 	jmp	0x6232	; 0x6232 <__fp_nan>
    5fde:	0e f4       	brtc	.+2      	; 0x5fe2 <__addsf3+0x28>
    5fe0:	e0 95       	com	r30
    5fe2:	e7 fb       	bst	r30, 7
    5fe4:	0c 94 13 31 	jmp	0x6226	; 0x6226 <__fp_inf>

00005fe8 <__addsf3x>:
    5fe8:	e9 2f       	mov	r30, r25
    5fea:	0e 94 3b 31 	call	0x6276	; 0x6276 <__fp_split3>
    5fee:	58 f3       	brcs	.-42     	; 0x5fc6 <__addsf3+0xc>
    5ff0:	ba 17       	cp	r27, r26
    5ff2:	62 07       	cpc	r22, r18
    5ff4:	73 07       	cpc	r23, r19
    5ff6:	84 07       	cpc	r24, r20
    5ff8:	95 07       	cpc	r25, r21
    5ffa:	20 f0       	brcs	.+8      	; 0x6004 <__addsf3x+0x1c>
    5ffc:	79 f4       	brne	.+30     	; 0x601c <__addsf3x+0x34>
    5ffe:	a6 f5       	brtc	.+104    	; 0x6068 <__addsf3x+0x80>
    6000:	0c 94 5d 31 	jmp	0x62ba	; 0x62ba <__fp_zero>
    6004:	0e f4       	brtc	.+2      	; 0x6008 <__addsf3x+0x20>
    6006:	e0 95       	com	r30
    6008:	0b 2e       	mov	r0, r27
    600a:	ba 2f       	mov	r27, r26
    600c:	a0 2d       	mov	r26, r0
    600e:	0b 01       	movw	r0, r22
    6010:	b9 01       	movw	r22, r18
    6012:	90 01       	movw	r18, r0
    6014:	0c 01       	movw	r0, r24
    6016:	ca 01       	movw	r24, r20
    6018:	a0 01       	movw	r20, r0
    601a:	11 24       	eor	r1, r1
    601c:	ff 27       	eor	r31, r31
    601e:	59 1b       	sub	r21, r25
    6020:	99 f0       	breq	.+38     	; 0x6048 <__addsf3x+0x60>
    6022:	59 3f       	cpi	r21, 0xF9	; 249
    6024:	50 f4       	brcc	.+20     	; 0x603a <__addsf3x+0x52>
    6026:	50 3e       	cpi	r21, 0xE0	; 224
    6028:	68 f1       	brcs	.+90     	; 0x6084 <__addsf3x+0x9c>
    602a:	1a 16       	cp	r1, r26
    602c:	f0 40       	sbci	r31, 0x00	; 0
    602e:	a2 2f       	mov	r26, r18
    6030:	23 2f       	mov	r18, r19
    6032:	34 2f       	mov	r19, r20
    6034:	44 27       	eor	r20, r20
    6036:	58 5f       	subi	r21, 0xF8	; 248
    6038:	f3 cf       	rjmp	.-26     	; 0x6020 <__addsf3x+0x38>
    603a:	46 95       	lsr	r20
    603c:	37 95       	ror	r19
    603e:	27 95       	ror	r18
    6040:	a7 95       	ror	r26
    6042:	f0 40       	sbci	r31, 0x00	; 0
    6044:	53 95       	inc	r21
    6046:	c9 f7       	brne	.-14     	; 0x603a <__addsf3x+0x52>
    6048:	7e f4       	brtc	.+30     	; 0x6068 <__addsf3x+0x80>
    604a:	1f 16       	cp	r1, r31
    604c:	ba 0b       	sbc	r27, r26
    604e:	62 0b       	sbc	r22, r18
    6050:	73 0b       	sbc	r23, r19
    6052:	84 0b       	sbc	r24, r20
    6054:	ba f0       	brmi	.+46     	; 0x6084 <__addsf3x+0x9c>
    6056:	91 50       	subi	r25, 0x01	; 1
    6058:	a1 f0       	breq	.+40     	; 0x6082 <__addsf3x+0x9a>
    605a:	ff 0f       	add	r31, r31
    605c:	bb 1f       	adc	r27, r27
    605e:	66 1f       	adc	r22, r22
    6060:	77 1f       	adc	r23, r23
    6062:	88 1f       	adc	r24, r24
    6064:	c2 f7       	brpl	.-16     	; 0x6056 <__addsf3x+0x6e>
    6066:	0e c0       	rjmp	.+28     	; 0x6084 <__addsf3x+0x9c>
    6068:	ba 0f       	add	r27, r26
    606a:	62 1f       	adc	r22, r18
    606c:	73 1f       	adc	r23, r19
    606e:	84 1f       	adc	r24, r20
    6070:	48 f4       	brcc	.+18     	; 0x6084 <__addsf3x+0x9c>
    6072:	87 95       	ror	r24
    6074:	77 95       	ror	r23
    6076:	67 95       	ror	r22
    6078:	b7 95       	ror	r27
    607a:	f7 95       	ror	r31
    607c:	9e 3f       	cpi	r25, 0xFE	; 254
    607e:	08 f0       	brcs	.+2      	; 0x6082 <__addsf3x+0x9a>
    6080:	b0 cf       	rjmp	.-160    	; 0x5fe2 <__addsf3+0x28>
    6082:	93 95       	inc	r25
    6084:	88 0f       	add	r24, r24
    6086:	08 f0       	brcs	.+2      	; 0x608a <__addsf3x+0xa2>
    6088:	99 27       	eor	r25, r25
    608a:	ee 0f       	add	r30, r30
    608c:	97 95       	ror	r25
    608e:	87 95       	ror	r24
    6090:	08 95       	ret

00006092 <__cmpsf2>:
    6092:	0e 94 ef 30 	call	0x61de	; 0x61de <__fp_cmp>
    6096:	08 f4       	brcc	.+2      	; 0x609a <__cmpsf2+0x8>
    6098:	81 e0       	ldi	r24, 0x01	; 1
    609a:	08 95       	ret

0000609c <__divsf3>:
    609c:	0e 94 62 30 	call	0x60c4	; 0x60c4 <__divsf3x>
    60a0:	0c 94 2a 31 	jmp	0x6254	; 0x6254 <__fp_round>
    60a4:	0e 94 23 31 	call	0x6246	; 0x6246 <__fp_pscB>
    60a8:	58 f0       	brcs	.+22     	; 0x60c0 <__divsf3+0x24>
    60aa:	0e 94 1c 31 	call	0x6238	; 0x6238 <__fp_pscA>
    60ae:	40 f0       	brcs	.+16     	; 0x60c0 <__divsf3+0x24>
    60b0:	29 f4       	brne	.+10     	; 0x60bc <__divsf3+0x20>
    60b2:	5f 3f       	cpi	r21, 0xFF	; 255
    60b4:	29 f0       	breq	.+10     	; 0x60c0 <__divsf3+0x24>
    60b6:	0c 94 13 31 	jmp	0x6226	; 0x6226 <__fp_inf>
    60ba:	51 11       	cpse	r21, r1
    60bc:	0c 94 5e 31 	jmp	0x62bc	; 0x62bc <__fp_szero>
    60c0:	0c 94 19 31 	jmp	0x6232	; 0x6232 <__fp_nan>

000060c4 <__divsf3x>:
    60c4:	0e 94 3b 31 	call	0x6276	; 0x6276 <__fp_split3>
    60c8:	68 f3       	brcs	.-38     	; 0x60a4 <__divsf3+0x8>

000060ca <__divsf3_pse>:
    60ca:	99 23       	and	r25, r25
    60cc:	b1 f3       	breq	.-20     	; 0x60ba <__divsf3+0x1e>
    60ce:	55 23       	and	r21, r21
    60d0:	91 f3       	breq	.-28     	; 0x60b6 <__divsf3+0x1a>
    60d2:	95 1b       	sub	r25, r21
    60d4:	55 0b       	sbc	r21, r21
    60d6:	bb 27       	eor	r27, r27
    60d8:	aa 27       	eor	r26, r26
    60da:	62 17       	cp	r22, r18
    60dc:	73 07       	cpc	r23, r19
    60de:	84 07       	cpc	r24, r20
    60e0:	38 f0       	brcs	.+14     	; 0x60f0 <__divsf3_pse+0x26>
    60e2:	9f 5f       	subi	r25, 0xFF	; 255
    60e4:	5f 4f       	sbci	r21, 0xFF	; 255
    60e6:	22 0f       	add	r18, r18
    60e8:	33 1f       	adc	r19, r19
    60ea:	44 1f       	adc	r20, r20
    60ec:	aa 1f       	adc	r26, r26
    60ee:	a9 f3       	breq	.-22     	; 0x60da <__divsf3_pse+0x10>
    60f0:	35 d0       	rcall	.+106    	; 0x615c <__divsf3_pse+0x92>
    60f2:	0e 2e       	mov	r0, r30
    60f4:	3a f0       	brmi	.+14     	; 0x6104 <__divsf3_pse+0x3a>
    60f6:	e0 e8       	ldi	r30, 0x80	; 128
    60f8:	32 d0       	rcall	.+100    	; 0x615e <__divsf3_pse+0x94>
    60fa:	91 50       	subi	r25, 0x01	; 1
    60fc:	50 40       	sbci	r21, 0x00	; 0
    60fe:	e6 95       	lsr	r30
    6100:	00 1c       	adc	r0, r0
    6102:	ca f7       	brpl	.-14     	; 0x60f6 <__divsf3_pse+0x2c>
    6104:	2b d0       	rcall	.+86     	; 0x615c <__divsf3_pse+0x92>
    6106:	fe 2f       	mov	r31, r30
    6108:	29 d0       	rcall	.+82     	; 0x615c <__divsf3_pse+0x92>
    610a:	66 0f       	add	r22, r22
    610c:	77 1f       	adc	r23, r23
    610e:	88 1f       	adc	r24, r24
    6110:	bb 1f       	adc	r27, r27
    6112:	26 17       	cp	r18, r22
    6114:	37 07       	cpc	r19, r23
    6116:	48 07       	cpc	r20, r24
    6118:	ab 07       	cpc	r26, r27
    611a:	b0 e8       	ldi	r27, 0x80	; 128
    611c:	09 f0       	breq	.+2      	; 0x6120 <__divsf3_pse+0x56>
    611e:	bb 0b       	sbc	r27, r27
    6120:	80 2d       	mov	r24, r0
    6122:	bf 01       	movw	r22, r30
    6124:	ff 27       	eor	r31, r31
    6126:	93 58       	subi	r25, 0x83	; 131
    6128:	5f 4f       	sbci	r21, 0xFF	; 255
    612a:	3a f0       	brmi	.+14     	; 0x613a <__divsf3_pse+0x70>
    612c:	9e 3f       	cpi	r25, 0xFE	; 254
    612e:	51 05       	cpc	r21, r1
    6130:	78 f0       	brcs	.+30     	; 0x6150 <__divsf3_pse+0x86>
    6132:	0c 94 13 31 	jmp	0x6226	; 0x6226 <__fp_inf>
    6136:	0c 94 5e 31 	jmp	0x62bc	; 0x62bc <__fp_szero>
    613a:	5f 3f       	cpi	r21, 0xFF	; 255
    613c:	e4 f3       	brlt	.-8      	; 0x6136 <__divsf3_pse+0x6c>
    613e:	98 3e       	cpi	r25, 0xE8	; 232
    6140:	d4 f3       	brlt	.-12     	; 0x6136 <__divsf3_pse+0x6c>
    6142:	86 95       	lsr	r24
    6144:	77 95       	ror	r23
    6146:	67 95       	ror	r22
    6148:	b7 95       	ror	r27
    614a:	f7 95       	ror	r31
    614c:	9f 5f       	subi	r25, 0xFF	; 255
    614e:	c9 f7       	brne	.-14     	; 0x6142 <__divsf3_pse+0x78>
    6150:	88 0f       	add	r24, r24
    6152:	91 1d       	adc	r25, r1
    6154:	96 95       	lsr	r25
    6156:	87 95       	ror	r24
    6158:	97 f9       	bld	r25, 7
    615a:	08 95       	ret
    615c:	e1 e0       	ldi	r30, 0x01	; 1
    615e:	66 0f       	add	r22, r22
    6160:	77 1f       	adc	r23, r23
    6162:	88 1f       	adc	r24, r24
    6164:	bb 1f       	adc	r27, r27
    6166:	62 17       	cp	r22, r18
    6168:	73 07       	cpc	r23, r19
    616a:	84 07       	cpc	r24, r20
    616c:	ba 07       	cpc	r27, r26
    616e:	20 f0       	brcs	.+8      	; 0x6178 <__divsf3_pse+0xae>
    6170:	62 1b       	sub	r22, r18
    6172:	73 0b       	sbc	r23, r19
    6174:	84 0b       	sbc	r24, r20
    6176:	ba 0b       	sbc	r27, r26
    6178:	ee 1f       	adc	r30, r30
    617a:	88 f7       	brcc	.-30     	; 0x615e <__divsf3_pse+0x94>
    617c:	e0 95       	com	r30
    617e:	08 95       	ret

00006180 <__fixunssfsi>:
    6180:	0e 94 43 31 	call	0x6286	; 0x6286 <__fp_splitA>
    6184:	88 f0       	brcs	.+34     	; 0x61a8 <__fixunssfsi+0x28>
    6186:	9f 57       	subi	r25, 0x7F	; 127
    6188:	98 f0       	brcs	.+38     	; 0x61b0 <__fixunssfsi+0x30>
    618a:	b9 2f       	mov	r27, r25
    618c:	99 27       	eor	r25, r25
    618e:	b7 51       	subi	r27, 0x17	; 23
    6190:	b0 f0       	brcs	.+44     	; 0x61be <__fixunssfsi+0x3e>
    6192:	e1 f0       	breq	.+56     	; 0x61cc <__fixunssfsi+0x4c>
    6194:	66 0f       	add	r22, r22
    6196:	77 1f       	adc	r23, r23
    6198:	88 1f       	adc	r24, r24
    619a:	99 1f       	adc	r25, r25
    619c:	1a f0       	brmi	.+6      	; 0x61a4 <__fixunssfsi+0x24>
    619e:	ba 95       	dec	r27
    61a0:	c9 f7       	brne	.-14     	; 0x6194 <__fixunssfsi+0x14>
    61a2:	14 c0       	rjmp	.+40     	; 0x61cc <__fixunssfsi+0x4c>
    61a4:	b1 30       	cpi	r27, 0x01	; 1
    61a6:	91 f0       	breq	.+36     	; 0x61cc <__fixunssfsi+0x4c>
    61a8:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__fp_zero>
    61ac:	b1 e0       	ldi	r27, 0x01	; 1
    61ae:	08 95       	ret
    61b0:	0c 94 5d 31 	jmp	0x62ba	; 0x62ba <__fp_zero>
    61b4:	67 2f       	mov	r22, r23
    61b6:	78 2f       	mov	r23, r24
    61b8:	88 27       	eor	r24, r24
    61ba:	b8 5f       	subi	r27, 0xF8	; 248
    61bc:	39 f0       	breq	.+14     	; 0x61cc <__fixunssfsi+0x4c>
    61be:	b9 3f       	cpi	r27, 0xF9	; 249
    61c0:	cc f3       	brlt	.-14     	; 0x61b4 <__fixunssfsi+0x34>
    61c2:	86 95       	lsr	r24
    61c4:	77 95       	ror	r23
    61c6:	67 95       	ror	r22
    61c8:	b3 95       	inc	r27
    61ca:	d9 f7       	brne	.-10     	; 0x61c2 <__fixunssfsi+0x42>
    61cc:	3e f4       	brtc	.+14     	; 0x61dc <__fixunssfsi+0x5c>
    61ce:	90 95       	com	r25
    61d0:	80 95       	com	r24
    61d2:	70 95       	com	r23
    61d4:	61 95       	neg	r22
    61d6:	7f 4f       	sbci	r23, 0xFF	; 255
    61d8:	8f 4f       	sbci	r24, 0xFF	; 255
    61da:	9f 4f       	sbci	r25, 0xFF	; 255
    61dc:	08 95       	ret

000061de <__fp_cmp>:
    61de:	99 0f       	add	r25, r25
    61e0:	00 08       	sbc	r0, r0
    61e2:	55 0f       	add	r21, r21
    61e4:	aa 0b       	sbc	r26, r26
    61e6:	e0 e8       	ldi	r30, 0x80	; 128
    61e8:	fe ef       	ldi	r31, 0xFE	; 254
    61ea:	16 16       	cp	r1, r22
    61ec:	17 06       	cpc	r1, r23
    61ee:	e8 07       	cpc	r30, r24
    61f0:	f9 07       	cpc	r31, r25
    61f2:	c0 f0       	brcs	.+48     	; 0x6224 <__fp_cmp+0x46>
    61f4:	12 16       	cp	r1, r18
    61f6:	13 06       	cpc	r1, r19
    61f8:	e4 07       	cpc	r30, r20
    61fa:	f5 07       	cpc	r31, r21
    61fc:	98 f0       	brcs	.+38     	; 0x6224 <__fp_cmp+0x46>
    61fe:	62 1b       	sub	r22, r18
    6200:	73 0b       	sbc	r23, r19
    6202:	84 0b       	sbc	r24, r20
    6204:	95 0b       	sbc	r25, r21
    6206:	39 f4       	brne	.+14     	; 0x6216 <__fp_cmp+0x38>
    6208:	0a 26       	eor	r0, r26
    620a:	61 f0       	breq	.+24     	; 0x6224 <__fp_cmp+0x46>
    620c:	23 2b       	or	r18, r19
    620e:	24 2b       	or	r18, r20
    6210:	25 2b       	or	r18, r21
    6212:	21 f4       	brne	.+8      	; 0x621c <__fp_cmp+0x3e>
    6214:	08 95       	ret
    6216:	0a 26       	eor	r0, r26
    6218:	09 f4       	brne	.+2      	; 0x621c <__fp_cmp+0x3e>
    621a:	a1 40       	sbci	r26, 0x01	; 1
    621c:	a6 95       	lsr	r26
    621e:	8f ef       	ldi	r24, 0xFF	; 255
    6220:	81 1d       	adc	r24, r1
    6222:	81 1d       	adc	r24, r1
    6224:	08 95       	ret

00006226 <__fp_inf>:
    6226:	97 f9       	bld	r25, 7
    6228:	9f 67       	ori	r25, 0x7F	; 127
    622a:	80 e8       	ldi	r24, 0x80	; 128
    622c:	70 e0       	ldi	r23, 0x00	; 0
    622e:	60 e0       	ldi	r22, 0x00	; 0
    6230:	08 95       	ret

00006232 <__fp_nan>:
    6232:	9f ef       	ldi	r25, 0xFF	; 255
    6234:	80 ec       	ldi	r24, 0xC0	; 192
    6236:	08 95       	ret

00006238 <__fp_pscA>:
    6238:	00 24       	eor	r0, r0
    623a:	0a 94       	dec	r0
    623c:	16 16       	cp	r1, r22
    623e:	17 06       	cpc	r1, r23
    6240:	18 06       	cpc	r1, r24
    6242:	09 06       	cpc	r0, r25
    6244:	08 95       	ret

00006246 <__fp_pscB>:
    6246:	00 24       	eor	r0, r0
    6248:	0a 94       	dec	r0
    624a:	12 16       	cp	r1, r18
    624c:	13 06       	cpc	r1, r19
    624e:	14 06       	cpc	r1, r20
    6250:	05 06       	cpc	r0, r21
    6252:	08 95       	ret

00006254 <__fp_round>:
    6254:	09 2e       	mov	r0, r25
    6256:	03 94       	inc	r0
    6258:	00 0c       	add	r0, r0
    625a:	11 f4       	brne	.+4      	; 0x6260 <__fp_round+0xc>
    625c:	88 23       	and	r24, r24
    625e:	52 f0       	brmi	.+20     	; 0x6274 <__fp_round+0x20>
    6260:	bb 0f       	add	r27, r27
    6262:	40 f4       	brcc	.+16     	; 0x6274 <__fp_round+0x20>
    6264:	bf 2b       	or	r27, r31
    6266:	11 f4       	brne	.+4      	; 0x626c <__fp_round+0x18>
    6268:	60 ff       	sbrs	r22, 0
    626a:	04 c0       	rjmp	.+8      	; 0x6274 <__fp_round+0x20>
    626c:	6f 5f       	subi	r22, 0xFF	; 255
    626e:	7f 4f       	sbci	r23, 0xFF	; 255
    6270:	8f 4f       	sbci	r24, 0xFF	; 255
    6272:	9f 4f       	sbci	r25, 0xFF	; 255
    6274:	08 95       	ret

00006276 <__fp_split3>:
    6276:	57 fd       	sbrc	r21, 7
    6278:	90 58       	subi	r25, 0x80	; 128
    627a:	44 0f       	add	r20, r20
    627c:	55 1f       	adc	r21, r21
    627e:	59 f0       	breq	.+22     	; 0x6296 <__fp_splitA+0x10>
    6280:	5f 3f       	cpi	r21, 0xFF	; 255
    6282:	71 f0       	breq	.+28     	; 0x62a0 <__fp_splitA+0x1a>
    6284:	47 95       	ror	r20

00006286 <__fp_splitA>:
    6286:	88 0f       	add	r24, r24
    6288:	97 fb       	bst	r25, 7
    628a:	99 1f       	adc	r25, r25
    628c:	61 f0       	breq	.+24     	; 0x62a6 <__fp_splitA+0x20>
    628e:	9f 3f       	cpi	r25, 0xFF	; 255
    6290:	79 f0       	breq	.+30     	; 0x62b0 <__fp_splitA+0x2a>
    6292:	87 95       	ror	r24
    6294:	08 95       	ret
    6296:	12 16       	cp	r1, r18
    6298:	13 06       	cpc	r1, r19
    629a:	14 06       	cpc	r1, r20
    629c:	55 1f       	adc	r21, r21
    629e:	f2 cf       	rjmp	.-28     	; 0x6284 <__fp_split3+0xe>
    62a0:	46 95       	lsr	r20
    62a2:	f1 df       	rcall	.-30     	; 0x6286 <__fp_splitA>
    62a4:	08 c0       	rjmp	.+16     	; 0x62b6 <__fp_splitA+0x30>
    62a6:	16 16       	cp	r1, r22
    62a8:	17 06       	cpc	r1, r23
    62aa:	18 06       	cpc	r1, r24
    62ac:	99 1f       	adc	r25, r25
    62ae:	f1 cf       	rjmp	.-30     	; 0x6292 <__fp_splitA+0xc>
    62b0:	86 95       	lsr	r24
    62b2:	71 05       	cpc	r23, r1
    62b4:	61 05       	cpc	r22, r1
    62b6:	08 94       	sec
    62b8:	08 95       	ret

000062ba <__fp_zero>:
    62ba:	e8 94       	clt

000062bc <__fp_szero>:
    62bc:	bb 27       	eor	r27, r27
    62be:	66 27       	eor	r22, r22
    62c0:	77 27       	eor	r23, r23
    62c2:	cb 01       	movw	r24, r22
    62c4:	97 f9       	bld	r25, 7
    62c6:	08 95       	ret

000062c8 <__gesf2>:
    62c8:	0e 94 ef 30 	call	0x61de	; 0x61de <__fp_cmp>
    62cc:	08 f4       	brcc	.+2      	; 0x62d0 <__gesf2+0x8>
    62ce:	8f ef       	ldi	r24, 0xFF	; 255
    62d0:	08 95       	ret

000062d2 <__mulsf3>:
    62d2:	0e 94 7c 31 	call	0x62f8	; 0x62f8 <__mulsf3x>
    62d6:	0c 94 2a 31 	jmp	0x6254	; 0x6254 <__fp_round>
    62da:	0e 94 1c 31 	call	0x6238	; 0x6238 <__fp_pscA>
    62de:	38 f0       	brcs	.+14     	; 0x62ee <__mulsf3+0x1c>
    62e0:	0e 94 23 31 	call	0x6246	; 0x6246 <__fp_pscB>
    62e4:	20 f0       	brcs	.+8      	; 0x62ee <__mulsf3+0x1c>
    62e6:	95 23       	and	r25, r21
    62e8:	11 f0       	breq	.+4      	; 0x62ee <__mulsf3+0x1c>
    62ea:	0c 94 13 31 	jmp	0x6226	; 0x6226 <__fp_inf>
    62ee:	0c 94 19 31 	jmp	0x6232	; 0x6232 <__fp_nan>
    62f2:	11 24       	eor	r1, r1
    62f4:	0c 94 5e 31 	jmp	0x62bc	; 0x62bc <__fp_szero>

000062f8 <__mulsf3x>:
    62f8:	0e 94 3b 31 	call	0x6276	; 0x6276 <__fp_split3>
    62fc:	70 f3       	brcs	.-36     	; 0x62da <__mulsf3+0x8>

000062fe <__mulsf3_pse>:
    62fe:	95 9f       	mul	r25, r21
    6300:	c1 f3       	breq	.-16     	; 0x62f2 <__mulsf3+0x20>
    6302:	95 0f       	add	r25, r21
    6304:	50 e0       	ldi	r21, 0x00	; 0
    6306:	55 1f       	adc	r21, r21
    6308:	62 9f       	mul	r22, r18
    630a:	f0 01       	movw	r30, r0
    630c:	72 9f       	mul	r23, r18
    630e:	bb 27       	eor	r27, r27
    6310:	f0 0d       	add	r31, r0
    6312:	b1 1d       	adc	r27, r1
    6314:	63 9f       	mul	r22, r19
    6316:	aa 27       	eor	r26, r26
    6318:	f0 0d       	add	r31, r0
    631a:	b1 1d       	adc	r27, r1
    631c:	aa 1f       	adc	r26, r26
    631e:	64 9f       	mul	r22, r20
    6320:	66 27       	eor	r22, r22
    6322:	b0 0d       	add	r27, r0
    6324:	a1 1d       	adc	r26, r1
    6326:	66 1f       	adc	r22, r22
    6328:	82 9f       	mul	r24, r18
    632a:	22 27       	eor	r18, r18
    632c:	b0 0d       	add	r27, r0
    632e:	a1 1d       	adc	r26, r1
    6330:	62 1f       	adc	r22, r18
    6332:	73 9f       	mul	r23, r19
    6334:	b0 0d       	add	r27, r0
    6336:	a1 1d       	adc	r26, r1
    6338:	62 1f       	adc	r22, r18
    633a:	83 9f       	mul	r24, r19
    633c:	a0 0d       	add	r26, r0
    633e:	61 1d       	adc	r22, r1
    6340:	22 1f       	adc	r18, r18
    6342:	74 9f       	mul	r23, r20
    6344:	33 27       	eor	r19, r19
    6346:	a0 0d       	add	r26, r0
    6348:	61 1d       	adc	r22, r1
    634a:	23 1f       	adc	r18, r19
    634c:	84 9f       	mul	r24, r20
    634e:	60 0d       	add	r22, r0
    6350:	21 1d       	adc	r18, r1
    6352:	82 2f       	mov	r24, r18
    6354:	76 2f       	mov	r23, r22
    6356:	6a 2f       	mov	r22, r26
    6358:	11 24       	eor	r1, r1
    635a:	9f 57       	subi	r25, 0x7F	; 127
    635c:	50 40       	sbci	r21, 0x00	; 0
    635e:	9a f0       	brmi	.+38     	; 0x6386 <__mulsf3_pse+0x88>
    6360:	f1 f0       	breq	.+60     	; 0x639e <__mulsf3_pse+0xa0>
    6362:	88 23       	and	r24, r24
    6364:	4a f0       	brmi	.+18     	; 0x6378 <__mulsf3_pse+0x7a>
    6366:	ee 0f       	add	r30, r30
    6368:	ff 1f       	adc	r31, r31
    636a:	bb 1f       	adc	r27, r27
    636c:	66 1f       	adc	r22, r22
    636e:	77 1f       	adc	r23, r23
    6370:	88 1f       	adc	r24, r24
    6372:	91 50       	subi	r25, 0x01	; 1
    6374:	50 40       	sbci	r21, 0x00	; 0
    6376:	a9 f7       	brne	.-22     	; 0x6362 <__mulsf3_pse+0x64>
    6378:	9e 3f       	cpi	r25, 0xFE	; 254
    637a:	51 05       	cpc	r21, r1
    637c:	80 f0       	brcs	.+32     	; 0x639e <__mulsf3_pse+0xa0>
    637e:	0c 94 13 31 	jmp	0x6226	; 0x6226 <__fp_inf>
    6382:	0c 94 5e 31 	jmp	0x62bc	; 0x62bc <__fp_szero>
    6386:	5f 3f       	cpi	r21, 0xFF	; 255
    6388:	e4 f3       	brlt	.-8      	; 0x6382 <__mulsf3_pse+0x84>
    638a:	98 3e       	cpi	r25, 0xE8	; 232
    638c:	d4 f3       	brlt	.-12     	; 0x6382 <__mulsf3_pse+0x84>
    638e:	86 95       	lsr	r24
    6390:	77 95       	ror	r23
    6392:	67 95       	ror	r22
    6394:	b7 95       	ror	r27
    6396:	f7 95       	ror	r31
    6398:	e7 95       	ror	r30
    639a:	9f 5f       	subi	r25, 0xFF	; 255
    639c:	c1 f7       	brne	.-16     	; 0x638e <__mulsf3_pse+0x90>
    639e:	fe 2b       	or	r31, r30
    63a0:	88 0f       	add	r24, r24
    63a2:	91 1d       	adc	r25, r1
    63a4:	96 95       	lsr	r25
    63a6:	87 95       	ror	r24
    63a8:	97 f9       	bld	r25, 7
    63aa:	08 95       	ret

000063ac <memcpy>:
    63ac:	fb 01       	movw	r30, r22
    63ae:	dc 01       	movw	r26, r24
    63b0:	02 c0       	rjmp	.+4      	; 0x63b6 <memcpy+0xa>
    63b2:	01 90       	ld	r0, Z+
    63b4:	0d 92       	st	X+, r0
    63b6:	41 50       	subi	r20, 0x01	; 1
    63b8:	50 40       	sbci	r21, 0x00	; 0
    63ba:	d8 f7       	brcc	.-10     	; 0x63b2 <memcpy+0x6>
    63bc:	08 95       	ret

000063be <_exit>:
    63be:	f8 94       	cli

000063c0 <__stop_program>:
    63c0:	ff cf       	rjmp	.-2      	; 0x63c0 <__stop_program>
